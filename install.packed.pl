#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;
  use strict;
  use warnings;
  package Capture::Tiny;
  # ABSTRACT: Capture STDOUT and STDERR from Perl, XS or external programs
  our $VERSION = '0.48';
  use Carp ();
  use Exporter ();
  use IO::Handle ();
  use File::Spec ();
  use File::Temp qw/tempfile tmpnam/;
  use Scalar::Util qw/reftype blessed/;
  # Get PerlIO or fake it
  BEGIN {
    local $@;
    eval { require PerlIO; PerlIO->can('get_layers') }
      or *PerlIO::get_layers = sub { return () };
  }
  
  #--------------------------------------------------------------------------#
  # create API subroutines and export them
  # [do STDOUT flag, do STDERR flag, do merge flag, do tee flag]
  #--------------------------------------------------------------------------#
  
  my %api = (
    capture         => [1,1,0,0],
    capture_stdout  => [1,0,0,0],
    capture_stderr  => [0,1,0,0],
    capture_merged  => [1,1,1,0],
    tee             => [1,1,0,1],
    tee_stdout      => [1,0,0,1],
    tee_stderr      => [0,1,0,1],
    tee_merged      => [1,1,1,1],
  );
  
  for my $sub ( keys %api ) {
    my $args = join q{, }, @{$api{$sub}};
    eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; ## no critic
  }
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = keys %api;
  our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  #--------------------------------------------------------------------------#
  # constants and fixtures
  #--------------------------------------------------------------------------#
  
  my $IS_WIN32 = $^O eq 'MSWin32';
  
  ##our $DEBUG = $ENV{PERL_CAPTURE_TINY_DEBUG};
  ##
  ##my $DEBUGFH;
  ##open $DEBUGFH, "> DEBUG" if $DEBUG;
  ##
  ##*_debug = $DEBUG ? sub(@) { print {$DEBUGFH} @_ } : sub(){0};
  
  our $TIMEOUT = 30;
  
  #--------------------------------------------------------------------------#
  # command to tee output -- the argument is a filename that must
  # be opened to signal that the process is ready to receive input.
  # This is annoying, but seems to be the best that can be done
  # as a simple, portable IPC technique
  #--------------------------------------------------------------------------#
  my @cmd = ($^X, '-C0', '-e', <<'HERE');
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
  
  #--------------------------------------------------------------------------#
  # filehandle manipulation
  #--------------------------------------------------------------------------#
  
  sub _relayer {
    my ($fh, $apply_layers) = @_;
    # _debug("# requested layers (@{$layers}) for @{[fileno $fh]}\n");
  
    # eliminate pseudo-layers
    binmode( $fh, ":raw" );
    # strip off real layers until only :unix is left
    while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
        binmode( $fh, ":pop" );
    }
    # apply other layers
    my @to_apply = @$apply_layers;
    shift @to_apply; # eliminate initial :unix
    # _debug("# applying layers  (unix @to_apply) to @{[fileno $fh]}\n");
    binmode($fh, ":" . join(":",@to_apply));
  }
  
  sub _name {
    my $glob = shift;
    no strict 'refs'; ## no critic
    return *{$glob}{NAME};
  }
  
  sub _open {
    open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
    # _debug( "# open " . join( ", " , map { defined $_ ? _name($_) : 'undef' } @_ ) . " as " . fileno( $_[0] ) . "\n" );
  }
  
  sub _close {
    # _debug( "# closing " . ( defined $_[0] ? _name($_[0]) : 'undef' )  . " on " . fileno( $_[0] ) . "\n" );
    close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
  }
  
  my %dup; # cache this so STDIN stays fd0
  my %proxy_count;
  sub _proxy_std {
    my %proxies;
    if ( ! defined fileno STDIN ) {
      $proxy_count{stdin}++;
      if (defined $dup{stdin}) {
        _open \*STDIN, "<&=" . fileno($dup{stdin});
        # _debug( "# restored proxy STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
      }
      else {
        _open \*STDIN, "<" . File::Spec->devnull;
        # _debug( "# proxied STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
        _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
      }
      $proxies{stdin} = \*STDIN;
      binmode(STDIN, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDOUT ) {
      $proxy_count{stdout}++;
      if (defined $dup{stdout}) {
        _open \*STDOUT, ">&=" . fileno($dup{stdout});
        # _debug( "# restored proxy STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
      }
      else {
        _open \*STDOUT, ">" . File::Spec->devnull;
         # _debug( "# proxied STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
        _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
      }
      $proxies{stdout} = \*STDOUT;
      binmode(STDOUT, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDERR ) {
      $proxy_count{stderr}++;
      if (defined $dup{stderr}) {
        _open \*STDERR, ">&=" . fileno($dup{stderr});
         # _debug( "# restored proxy STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
      }
      else {
        _open \*STDERR, ">" . File::Spec->devnull;
         # _debug( "# proxied STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
        _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
      }
      $proxies{stderr} = \*STDERR;
      binmode(STDERR, ':utf8') if $] >= 5.008; ## no critic
    }
    return %proxies;
  }
  
  sub _unproxy {
    my (%proxies) = @_;
    # _debug( "# unproxying: " . join(" ", keys %proxies) . "\n" );
    for my $p ( keys %proxies ) {
      $proxy_count{$p}--;
      # _debug( "# unproxied " . uc($p) . " ($proxy_count{$p} left)\n" );
      if ( ! $proxy_count{$p} ) {
        _close $proxies{$p};
        _close $dup{$p} unless $] < 5.008; # 5.6 will have already closed this as dup
        delete $dup{$p};
      }
    }
  }
  
  sub _copy_std {
    my %handles;
    for my $h ( qw/stdout stderr stdin/ ) {
      next if $h eq 'stdin' && ! $IS_WIN32; # WIN32 hangs on tee without STDIN copied
      my $redir = $h eq 'stdin' ? "<&" : ">&";
      _open $handles{$h} = IO::Handle->new(), $redir . uc($h); # ">&STDOUT" or "<&STDIN"
    }
    return \%handles;
  }
  
  # In some cases we open all (prior to forking) and in others we only open
  # the output handles (setting up redirection)
  sub _open_std {
    my ($handles) = @_;
    _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
    _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
    _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
  }
  
  #--------------------------------------------------------------------------#
  # private subs
  #--------------------------------------------------------------------------#
  
  sub _start_tee {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    # setup pipes
    $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
    pipe $stash->{reader}{$which}, $stash->{tee}{$which};
    # _debug( "# pipe for $which\: " .  _name($stash->{tee}{$which}) . " " . fileno( $stash->{tee}{$which} ) . " => " . _name($stash->{reader}{$which}) . " " . fileno( $stash->{reader}{$which}) . "\n" );
    select((select($stash->{tee}{$which}), $|=1)[0]); # autoflush
    # setup desired redirection for parent and child
    $stash->{new}{$which} = $stash->{tee}{$which};
    $stash->{child}{$which} = {
      stdin   => $stash->{reader}{$which},
      stdout  => $stash->{old}{$which},
      stderr  => $stash->{capture}{$which},
    };
    # flag file is used to signal the child is ready
    $stash->{flag_files}{$which} = scalar( tmpnam() ) . $$;
    # execute @cmd as a separate process
    if ( $IS_WIN32 ) {
      my $old_eval_err=$@;
      undef $@;
  
      eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
      # _debug( "# Win32API::File loaded\n") unless $@;
      my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
      # _debug( "# Couldn't get OS handle: " . fileLastError() . "\n") if ! defined $os_fhandle || $os_fhandle == INVALID_HANDLE_VALUE();
      my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
      # _debug( $result ? "# set no-inherit flag on $which tee\n" : ("# can't disable tee handle flag inherit: " . fileLastError() . "\n"));
      _open_std( $stash->{child}{$which} );
      $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
      # not restoring std here as it all gets redirected again shortly anyway
      $@=$old_eval_err;
    }
    else { # use fork
      _fork_exec( $which, $stash );
    }
  }
  
  sub _fork_exec {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    my $pid = fork;
    if ( not defined $pid ) {
      Carp::confess "Couldn't fork(): $!";
    }
    elsif ($pid == 0) { # child
      # _debug( "# in child process ...\n" );
      untie *STDIN; untie *STDOUT; untie *STDERR;
      _close $stash->{tee}{$which};
      # _debug( "# redirecting handles in child ...\n" );
      _open_std( $stash->{child}{$which} );
      # _debug( "# calling exec on command ...\n" );
      exec @cmd, $stash->{flag_files}{$which};
    }
    $stash->{pid}{$which} = $pid
  }
  
  my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
  sub _files_exist {
    return 1 if @_ == grep { -f } @_;
    Time::HiRes::usleep(1000) if $have_usleep;
    return 0;
  }
  
  sub _wait_for_tees {
    my ($stash) = @_;
    my $start = time;
    my @files = values %{$stash->{flag_files}};
    my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
                ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
    1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
    Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
    unlink $_ for @files;
  }
  
  sub _kill_tees {
    my ($stash) = @_;
    if ( $IS_WIN32 ) {
      # _debug( "# closing handles\n");
      close($_) for values %{ $stash->{tee} };
      # _debug( "# waiting for subprocesses to finish\n");
      my $start = time;
      1 until wait == -1 || (time - $start > 30);
    }
    else {
      _close $_ for values %{ $stash->{tee} };
      waitpid $_, 0 for values %{ $stash->{pid} };
    }
  }
  
  sub _slurp {
    my ($name, $stash) = @_;
    my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
    # _debug( "# slurping captured $name from " . fileno($fh) . " at pos $pos with layers: @{[PerlIO::get_layers($fh)]}\n");
    seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
    my $text = do { local $/; scalar readline $fh };
    return defined($text) ? $text : "";
  }
  
  #--------------------------------------------------------------------------#
  # _capture_tee() -- generic main sub for capturing or teeing
  #--------------------------------------------------------------------------#
  
  sub _capture_tee {
    # _debug( "# starting _capture_tee with (@_)...\n" );
    my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
    my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
    Carp::confess("Custom capture options must be given as key/value pairs\n")
      unless @opts % 2 == 0;
    my $stash = { capture => { @opts } };
    for ( keys %{$stash->{capture}} ) {
      my $fh = $stash->{capture}{$_};
      Carp::confess "Custom handle for $_ must be seekable\n"
        unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
    }
    # save existing filehandles and setup captures
    local *CT_ORIG_STDIN  = *STDIN ;
    local *CT_ORIG_STDOUT = *STDOUT;
    local *CT_ORIG_STDERR = *STDERR;
    # find initial layers
    my %layers = (
      stdin   => [PerlIO::get_layers(\*STDIN) ],
      stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
      stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
    );
    # _debug( "# existing layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # get layers from underlying glob of tied filehandles if we can
    # (this only works for things that work like Tie::StdHandle)
    $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
      if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
    $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
      if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
    # _debug( "# tied object corrected layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # bypass scalar filehandles and tied handles
    # localize scalar STDIN to get a proxy to pick up FD0, then restore later to CT_ORIG_STDIN
    my %localize;
    $localize{stdin}++,  local(*STDIN)
      if grep { $_ eq 'scalar' } @{$layers{stdin}};
    $localize{stdout}++, local(*STDOUT)
      if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
    $localize{stderr}++, local(*STDERR)
      if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
    $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
      if tied *STDIN && $] >= 5.008;
    $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
      if $do_stdout && tied *STDOUT && $] >= 5.008;
    $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
      if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
    # _debug( "# localized $_\n" ) for keys %localize;
    # proxy any closed/localized handles so we don't use fds 0, 1 or 2
    my %proxy_std = _proxy_std();
    # _debug( "# proxy std: @{ [%proxy_std] }\n" );
    # update layers after any proxying
    $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
    $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
    # _debug( "# post-proxy layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # store old handles and setup handles for capture
    $stash->{old} = _copy_std();
    $stash->{new} = { %{$stash->{old}} }; # default to originals
    for ( keys %do ) {
      $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
      seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
      $stash->{pos}{$_} = tell $stash->{capture}{$_};
      # _debug("# will capture $_ on " . fileno($stash->{capture}{$_})."\n" );
      _start_tee( $_ => $stash ) if $do_tee; # tees may change $stash->{new}
    }
    _wait_for_tees( $stash ) if $do_tee;
    # finalize redirection
    $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
    # _debug( "# redirecting in parent ...\n" );
    _open_std( $stash->{new} );
    # execute user provided code
    my ($exit_code, $inner_error, $outer_error, $orig_pid, @result);
    {
      $orig_pid = $$;
      local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; # get original, not proxy STDIN
      # _debug( "# finalizing layers ...\n" );
      _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
      _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
      # _debug( "# running code $code ...\n" );
      my $old_eval_err=$@;
      undef $@;
      eval { @result = $code->(); $inner_error = $@ };
      $exit_code = $?; # save this for later
      $outer_error = $@; # save this for later
      STDOUT->flush if $do_stdout;
      STDERR->flush if $do_stderr;
      $@ = $old_eval_err;
    }
    # restore prior filehandles and shut down tees
    # _debug( "# restoring filehandles ...\n" );
    _open_std( $stash->{old} );
    _close( $_ ) for values %{$stash->{old}}; # don't leak fds
    # shouldn't need relayering originals, but see rt.perl.org #114404
    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
    _unproxy( %proxy_std );
    # _debug( "# killing tee subprocesses ...\n" ) if $do_tee;
    _kill_tees( $stash ) if $do_tee;
    # return captured output, but shortcut in void context
    # unless we have to echo output to tied/scalar handles;
    my %got;
    if ( $orig_pid == $$ and ( defined wantarray or ($do_tee && keys %localize) ) ) {
      for ( keys %do ) {
        _relayer($stash->{capture}{$_}, $layers{$_});
        $got{$_} = _slurp($_, $stash);
        # _debug("# slurped " . length($got{$_}) . " bytes from $_\n");
      }
      print CT_ORIG_STDOUT $got{stdout}
        if $do_stdout && $do_tee && $localize{stdout};
      print CT_ORIG_STDERR $got{stderr}
        if $do_stderr && $do_tee && $localize{stderr};
    }
    $? = $exit_code;
    $@ = $inner_error if $inner_error;
    die $outer_error if $outer_error;
    # _debug( "# ending _capture_tee with (@_)...\n" );
    return unless defined wantarray;
    my @return;
    push @return, $got{stdout} if $do_stdout;
    push @return, $got{stderr} if $do_stderr && ! $do_merge;
    push @return, @result;
    return wantarray ? @return : $return[0];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
  
  =head1 VERSION
  
  version 0.48
  
  =head1 SYNOPSIS
  
    use Capture::Tiny ':all';
  
    # capture from external command
  
    ($stdout, $stderr, $exit) = capture {
      system( $cmd, @args );
    };
  
    # capture from arbitrary code (Perl or external)
  
    ($stdout, $stderr, @result) = capture {
      # your code here
    };
  
    # capture partial or merged output
  
    $stdout = capture_stdout { ... };
    $stderr = capture_stderr { ... };
    $merged = capture_merged { ... };
  
    # tee output
  
    ($stdout, $stderr) = tee {
      # your code here
    };
  
    $stdout = tee_stdout { ... };
    $stderr = tee_stderr { ... };
    $merged = tee_merged { ... };
  
  =head1 DESCRIPTION
  
  Capture::Tiny provides a simple, portable way to capture almost anything sent
  to STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program.  Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles.  Yes, it even
  works on Windows (usually).  Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
  
  =head1 USAGE
  
  The following functions are available.  None are exported by default.
  
  =head2 capture
  
    ($stdout, $stderr, @result) = capture \&code;
    $stdout = capture \&code;
  
  The C<capture> function takes a code reference and returns what is sent to
  STDOUT and STDERR as well as any return values from the code reference.  In
  scalar context, it returns only STDOUT.  If no output was received for a
  filehandle, it returns an empty string for that filehandle.  Regardless of calling
  context, all output is captured -- nothing is passed to the existing filehandles.
  
  It is prototyped to take a subroutine reference as an argument. Thus, it
  can be called in block form:
  
    ($stdout, $stderr) = capture {
      # your code here ...
    };
  
  Note that the coderef is evaluated in list context.  If you wish to force
  scalar context on the return value, you must use the C<scalar> keyword.
  
    ($stdout, $stderr, $count) = capture {
      my @list = qw/one two three/;
      return scalar @list; # $count will be 3
    };
  
  Also note that within the coderef, the C<@_> variable will be empty.  So don't
  use arguments from a surrounding subroutine without copying them to an array
  first:
  
    sub wont_work {
      my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
      ...
    }
  
    sub will_work {
      my @args = @_;
      my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
      ...
    }
  
  Captures are normally done to an anonymous temporary filehandle.  To
  capture via a named file (e.g. to externally monitor a long-running capture),
  provide custom filehandles as a trailing list of option pairs:
  
    my $out_fh = IO::File->new("out.txt", "w+");
    my $err_fh = IO::File->new("out.txt", "w+");
    capture { ... } stdout => $out_fh, stderr => $err_fh;
  
  The filehandles must be read/write and seekable.  Modifying the files or
  filehandles during a capture operation will give unpredictable results.
  Existing IO layers on them may be changed by the capture.
  
  When called in void context, C<capture> saves memory and time by
  not reading back from the capture handles.
  
  =head2 capture_stdout
  
    ($stdout, @result) = capture_stdout \&code;
    $stdout = capture_stdout \&code;
  
  The C<capture_stdout> function works just like C<capture> except only
  STDOUT is captured.  STDERR is not captured.
  
  =head2 capture_stderr
  
    ($stderr, @result) = capture_stderr \&code;
    $stderr = capture_stderr \&code;
  
  The C<capture_stderr> function works just like C<capture> except only
  STDERR is captured.  STDOUT is not captured.
  
  =head2 capture_merged
  
    ($merged, @result) = capture_merged \&code;
    $merged = capture_merged \&code;
  
  The C<capture_merged> function works just like C<capture> except STDOUT and
  STDERR are merged. (Technically, STDERR is redirected to the same capturing
  handle as STDOUT before executing the function.)
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head2 tee
  
    ($stdout, $stderr, @result) = tee \&code;
    $stdout = tee \&code;
  
  The C<tee> function works just like C<capture>, except that output is captured
  as well as passed on to the original STDOUT and STDERR.
  
  When called in void context, C<tee> saves memory and time by
  not reading back from the capture handles, except when the
  original STDOUT OR STDERR were tied or opened to a scalar
  handle.
  
  =head2 tee_stdout
  
    ($stdout, @result) = tee_stdout \&code;
    $stdout = tee_stdout \&code;
  
  The C<tee_stdout> function works just like C<tee> except only
  STDOUT is teed.  STDERR is not teed (output goes to STDERR as usual).
  
  =head2 tee_stderr
  
    ($stderr, @result) = tee_stderr \&code;
    $stderr = tee_stderr \&code;
  
  The C<tee_stderr> function works just like C<tee> except only
  STDERR is teed.  STDOUT is not teed (output goes to STDOUT as usual).
  
  =head2 tee_merged
  
    ($merged, @result) = tee_merged \&code;
    $merged = tee_merged \&code;
  
  The C<tee_merged> function works just like C<capture_merged> except that output
  is captured as well as passed on to STDOUT.
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head1 LIMITATIONS
  
  =head2 Portability
  
  Portability is a goal, not a guarantee.  C<tee> requires fork, except on
  Windows where C<system(1, @cmd)> is used instead.  Not tested on any
  particularly esoteric platforms yet.  See the
  L<CPAN Testers Matrix|http://matrix.cpantesters.org/?dist=Capture-Tiny>
  for test result by platform.
  
  =head2 PerlIO layers
  
  Capture::Tiny does its best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
  STDOUT or STDERR I<before> the call to C<capture> or C<tee>.  This may not work
  for tied filehandles (see below).
  
  =head2 Modifying filehandles before capturing
  
  Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety of
  unexpected, undesirable and/or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
  
  =head3 Closed filehandles
  
  Capture::Tiny will work even if STDIN, STDOUT or STDERR have been previously
  closed.  However, since they will be reopened to capture or tee output, any
  code within the captured block that depends on finding them closed will, of
  course, not find them to be closed.  If they started closed, Capture::Tiny will
  close them again when the capture block finishes.
  
  Note that this reopening will happen even for STDIN or a filehandle not being
  captured to ensure that the filehandle used for capture is not opened to file
  descriptor 0, as this causes problems on various platforms.
  
  Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D leaks filehandles
  and also breaks tee() for undiagnosed reasons.  So don't do that.
  
  =head3 Localized filehandles
  
  If code localizes any of Perl's standard filehandles before capturing, the capture
  will affect the localized filehandles and not the original ones.  External system
  calls are not affected by localizing a filehandle in Perl and will continue
  to send output to the original filehandles (which will thus not be captured).
  
  =head3 Scalar filehandles
  
  If STDOUT or STDERR are reopened to scalar filehandles prior to the call to
  C<capture> or C<tee>, then Capture::Tiny will override the output filehandle for
  the duration of the C<capture> or C<tee> call and then, for C<tee>, send captured
  output to the output filehandle after the capture is complete.  (Requires Perl
  5.8)
  
  Capture::Tiny attempts to preserve the semantics of STDIN opened to a scalar
  reference, but note that external processes will not be able to read from such
  a handle.  Capture::Tiny tries to ensure that external processes will read from
  the null device instead, but this is not guaranteed.
  
  =head3 Tied output filehandles
  
  If STDOUT or STDERR are tied prior to the call to C<capture> or C<tee>, then
  Capture::Tiny will attempt to override the tie for the duration of the
  C<capture> or C<tee> call and then send captured output to the tied filehandle after
  the capture is complete.  (Requires Perl 5.8)
  
  Capture::Tiny may not succeed resending UTF-8 encoded data to a tied
  STDOUT or STDERR filehandle.  Characters may appear as bytes.  If the tied filehandle
  is based on L<Tie::StdHandle>, then Capture::Tiny will attempt to determine
  appropriate layers like C<:utf8> from the underlying filehandle and do the right
  thing.
  
  =head3 Tied input filehandle
  
  Capture::Tiny attempts to preserve the semantics of tied STDIN, but this
  requires Perl 5.8 and is not entirely predictable.  External processes
  will not be able to read from such a handle.
  
  Unless having STDIN tied is crucial, it may be safest to localize STDIN when
  capturing:
  
    my ($out, $err) = do { local *STDIN; capture { ... } };
  
  =head2 Modifying filehandles during a capture
  
  Attempting to modify STDIN, STDOUT or STDERR I<during> C<capture> or C<tee> is
  almost certainly going to cause problems.  Don't do that.
  
  =head3 Forking inside a capture
  
  Forks aren't portable.  The behavior of filehandles during a fork is even
  less so.  If Capture::Tiny detects that a fork has occurred within a
  capture, it will shortcut in the child process and return empty strings for
  captures.  Other problems may occur in the child or parent, as well.
  Forking in a capture block is not recommended.
  
  =head3 Using threads
  
  Filehandles are global.  Mixing up I/O and captures in different threads
  without coordination is going to cause problems.  Besides, threads are
  officially discouraged.
  
  =head3 Dropping privileges during a capture
  
  If you drop privileges during a capture, temporary files created to
  facilitate the capture may not be cleaned up afterwards.
  
  =head2 No support for Perl 5.8.0
  
  It's just too buggy when it comes to layers and UTF-8.  Perl 5.8.1 or later
  is recommended.
  
  =head2 Limited support for Perl 5.6
  
  Perl 5.6 predates PerlIO.  UTF-8 data may not be captured correctly.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_CAPTURE_TINY_TIMEOUT
  
  Capture::Tiny uses subprocesses internally for C<tee>.  By default,
  Capture::Tiny will timeout with an error if such subprocesses are not ready to
  receive data within 30 seconds (or whatever is the value of
  C<$Capture::Tiny::TIMEOUT>).  An alternate timeout may be specified by setting
  the C<PERL_CAPTURE_TINY_TIMEOUT> environment variable.  Setting it to zero will
  disable timeouts.  B<NOTE>, this does not timeout the code reference being
  captured -- this only prevents Capture::Tiny itself from hanging your process
  waiting for its child processes to be ready to proceed.
  
  =head1 SEE ALSO
  
  This module was inspired by L<IO::CaptureOutput>, which provides
  similar functionality without the ability to tee output and with more
  complicated code and API.  L<IO::CaptureOutput> does not handle layers
  or most of the unusual cases described in the L</Limitations> section and
  I no longer recommend it.
  
  There are many other CPAN modules that provide some sort of output capture,
  albeit with various limitations that make them appropriate only in particular
  circumstances.  I'm probably missing some.  The long list is provided to show
  why I felt Capture::Tiny was necessary.
  
  =over 4
  
  =item *
  
  L<IO::Capture>
  
  =item *
  
  L<IO::Capture::Extended>
  
  =item *
  
  L<IO::CaptureOutput>
  
  =item *
  
  L<IPC::Capture>
  
  =item *
  
  L<IPC::Cmd>
  
  =item *
  
  L<IPC::Open2>
  
  =item *
  
  L<IPC::Open3>
  
  =item *
  
  L<IPC::Open3::Simple>
  
  =item *
  
  L<IPC::Open3::Utils>
  
  =item *
  
  L<IPC::Run>
  
  =item *
  
  L<IPC::Run::SafeHandles>
  
  =item *
  
  L<IPC::Run::Simple>
  
  =item *
  
  L<IPC::Run3>
  
  =item *
  
  L<IPC::System::Simple>
  
  =item *
  
  L<Tee>
  
  =item *
  
  L<IO::Tee>
  
  =item *
  
  L<File::Tee>
  
  =item *
  
  L<Filter::Handle>
  
  =item *
  
  L<Tie::STDERR>
  
  =item *
  
  L<Tie::STDOUT>
  
  =item *
  
  L<Test::Output>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Capture-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Capture-Tiny>
  
    git clone https://github.com/dagolden/Capture-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David E. Wheeler fecundf Graham Knop Peter Rabbitson
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =item *
  
  fecundf <not.com+github@gmail.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2009 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CAPTURE_TINY

$fatpacked{"Carp/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_ASSERT';
  package Carp::Assert;
  
  require 5.006;
  use strict qw(subs vars);
  use warnings;
  use Exporter;
  
  use vars qw(@ISA $VERSION %EXPORT_TAGS);
  
  BEGIN {
      $VERSION = '0.22';
  
      @ISA = qw(Exporter);
  
      %EXPORT_TAGS = (
                      NDEBUG => [qw(assert affirm should shouldnt DEBUG)],
                     );
      $EXPORT_TAGS{DEBUG} = $EXPORT_TAGS{NDEBUG};
      Exporter::export_tags(qw(NDEBUG DEBUG));
  }
  
  # constant.pm, alas, adds too much load time (yes, I benchmarked it)
  sub REAL_DEBUG  ()  { 1 }       # CONSTANT
  sub NDEBUG      ()  { 0 }       # CONSTANT
  
  # Export the proper DEBUG flag according to if :NDEBUG is set.
  # Also export noop versions of our routines if NDEBUG
  sub noop { undef }
  sub noop_affirm (&;$) { undef };
  
  sub import {
      my $env_ndebug = exists $ENV{PERL_NDEBUG} ? $ENV{PERL_NDEBUG}
                                                : $ENV{'NDEBUG'};
      if( grep(/^:NDEBUG$/, @_) or $env_ndebug ) {
          my $caller = caller;
          foreach my $func (grep !/^DEBUG$/, @{$EXPORT_TAGS{'NDEBUG'}}) {
              if( $func eq 'affirm' ) {
                  *{$caller.'::'.$func} = \&noop_affirm;
              } else {
                  *{$caller.'::'.$func} = \&noop;
              }
          }
          *{$caller.'::DEBUG'} = \&NDEBUG;
      }
      else {
          *DEBUG = *REAL_DEBUG;
          Carp::Assert->_export_to_level(1, @_);
      }
  }
  
  
  # 5.004's Exporter doesn't have export_to_level.
  sub _export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;                  # XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  
  sub unimport {
      *DEBUG = *NDEBUG;
      push @_, ':NDEBUG';
      goto &import;
  }
  
  
  # Can't call confess() here or the stack trace will be wrong.
  sub _fail_msg {
      my($name) = shift;
      my $msg = 'Assertion';
      $msg   .= " ($name)" if defined $name;
      $msg   .= " failed!\n";
      return $msg;
  }
  
  
  =head1 NAME
  
  Carp::Assert - executable comments
  
  =head1 SYNOPSIS
  
      # Assertions are on.
      use Carp::Assert;
  
      $next_sunrise_time = sunrise();
  
      # Assert that the sun must rise in the next 24 hours.
      assert(($next_sunrise_time - time) < 24*60*60) if DEBUG;
  
      # Assert that your customer's primary credit card is active
      affirm {
          my @cards = @{$customer->credit_cards};
          $cards[0]->is_active;
      };
  
  
      # Assertions are off.
      no Carp::Assert;
  
      $next_pres = divine_next_president();
  
      # Assert that if you predict Dan Quayle will be the next president
      # your crystal ball might need some polishing.  However, since
      # assertions are off, IT COULD HAPPEN!
      shouldnt($next_pres, 'Dan Quayle') if DEBUG;
  
  
  =head1 DESCRIPTION
  
  =begin testing
  
  BEGIN {
      local %ENV = %ENV;
      delete @ENV{qw(PERL_NDEBUG NDEBUG)};
      require Carp::Assert;
      Carp::Assert->import;
  }
  
  local %ENV = %ENV;
  delete @ENV{qw(PERL_NDEBUG NDEBUG)};
  
  =end testing
  
      "We are ready for any unforseen event that may or may not 
      occur."
          - Dan Quayle
  
  Carp::Assert is intended for a purpose like the ANSI C library
  L<assert.h|http://en.wikipedia.org/wiki/Assert.h>.
  If you're already familiar with assert.h, then you can
  probably skip this and go straight to the FUNCTIONS section.
  
  Assertions are the explicit expressions of your assumptions about the
  reality your program is expected to deal with, and a declaration of
  those which it is not.  They are used to prevent your program from
  blissfully processing garbage inputs (garbage in, garbage out becomes
  garbage in, error out) and to tell you when you've produced garbage
  output.  (If I was going to be a cynic about Perl and the user nature,
  I'd say there are no user inputs but garbage, and Perl produces
  nothing but...)
  
  An assertion is used to prevent the impossible from being asked of
  your code, or at least tell you when it does.  For example:
  
  =for example begin
  
      # Take the square root of a number.
      sub my_sqrt {
          my($num) = shift;
  
          # the square root of a negative number is imaginary.
          assert($num >= 0);
  
          return sqrt $num;
      }
  
  =for example end
  
  =for example_testing
  is( my_sqrt(4),  2,            'my_sqrt example with good input' );
  ok( !eval{ my_sqrt(-1); 1 },   '  and pukes on bad' );
  
  The assertion will warn you if a negative number was handed to your
  subroutine, a reality the routine has no intention of dealing with.
  
  An assertion should also be used as something of a reality check, to
  make sure what your code just did really did happen:
  
      open(FILE, $filename) || die $!;
      @stuff = <FILE>;
      @stuff = do_something(@stuff);
  
      # I should have some stuff.
      assert(@stuff > 0);
  
  The assertion makes sure you have some @stuff at the end.  Maybe the
  file was empty, maybe do_something() returned an empty list... either
  way, the assert() will give you a clue as to where the problem lies,
  rather than 50 lines down at when you wonder why your program isn't
  printing anything.
  
  Since assertions are designed for debugging and will remove themelves
  from production code, your assertions should be carefully crafted so
  as to not have any side-effects, change any variables, or otherwise
  have any effect on your program.  Here is an example of a bad
  assertation:
  
      assert($error = 1 if $king ne 'Henry');  # Bad!
  
  It sets an error flag which may then be used somewhere else in your
  program. When you shut off your assertions with the $DEBUG flag,
  $error will no longer be set.
  
  Here's another example of B<bad> use:
  
      assert($next_pres ne 'Dan Quayle' or goto Canada);  # Bad!
  
  This assertion has the side effect of moving to Canada should it fail.
  This is a very bad assertion since error handling should not be
  placed in an assertion, nor should it have side-effects.
  
  In short, an assertion is an executable comment.  For instance, instead
  of writing this
  
      # $life ends with a '!'
      $life = begin_life();
  
  you'd replace the comment with an assertion which B<enforces> the comment.
  
      $life = begin_life();
      assert( $life =~ /!$/ );
  
  =for testing
  my $life = 'Whimper!';
  ok( eval { assert( $life =~ /!$/ ); 1 },   'life ends with a bang' );
  
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item B<assert>
  
      assert(EXPR) if DEBUG;
      assert(EXPR, $name) if DEBUG;
  
  assert's functionality is effected by compile time value of the DEBUG
  constant, controlled by saying C<use Carp::Assert> or C<no
  Carp::Assert>.  In the former case, assert will function as below.
  Otherwise, the assert function will compile itself out of the program.
  See L<Debugging vs Production> for details.
  
  =for testing
  {
    package Some::Other;
    no Carp::Assert;
    ::ok( eval { assert(0) if DEBUG; 1 } );
  }
  
  Give assert an expression, assert will Carp::confess() if that
  expression is false, otherwise it does nothing.  (DO NOT use the
  return value of assert for anything, I mean it... really!).
  
  =for testing
  ok( eval { assert(1); 1 } );
  ok( !eval { assert(0); 1 } );
  
  The error from assert will look something like this:
  
      Assertion failed!
              Carp::Assert::assert(0) called at prog line 23
              main::foo called at prog line 50
  
  =for testing
  eval { assert(0) };
  like( $@, '/^Assertion failed!/',       'error format' );
  like( $@, '/Carp::Assert::assert\(0\) called at/',      '  with stack trace' );
  
  Indicating that in the file "prog" an assert failed inside the
  function main::foo() on line 23 and that foo() was in turn called from
  line 50 in the same file.
  
  If given a $name, assert() will incorporate this into your error message,
  giving users something of a better idea what's going on.
  
      assert( Dogs->isa('People'), 'Dogs are people, too!' ) if DEBUG;
      # Result - "Assertion (Dogs are people, too!) failed!"
  
  =for testing
  eval { assert( Dogs->isa('People'), 'Dogs are people, too!' ); };
  like( $@, '/^Assertion \(Dogs are people, too!\) failed!/', 'names' );
  
  =cut
  
  sub assert ($;$) {
      unless($_[0]) {
          require Carp;
          Carp::confess( _fail_msg($_[1]) );
      }
      return undef;
  }
  
  
  =item B<affirm>
  
      affirm BLOCK if DEBUG;
      affirm BLOCK $name if DEBUG;
  
  Very similar to assert(), but instead of taking just a simple
  expression it takes an entire block of code and evaluates it to make
  sure its true.  This can allow more complicated assertions than
  assert() can without letting the debugging code leak out into
  production and without having to smash together several
  statements into one.
  
  =for example begin
  
      affirm {
          my $customer = Customer->new($customerid);
          my @cards = $customer->credit_cards;
          grep { $_->is_active } @cards;
      } "Our customer has an active credit card";
  
  =for example end
  
  =for testing
  my $foo = 1;  my $bar = 2;
  eval { affirm { $foo == $bar } };
  like( $@, '/\$foo == \$bar/' );
  
  
  affirm() also has the nice side effect that if you forgot the C<if DEBUG>
  suffix its arguments will not be evaluated at all.  This can be nice
  if you stick affirm()s with expensive checks into hot loops and other
  time-sensitive parts of your program.
  
  If the $name is left off and your Perl version is 5.6 or higher the
  affirm() diagnostics will include the code begin affirmed.
  
  =cut
  
  sub affirm (&;$) {
      unless( eval { &{$_[0]}; } ) {
          my $name = $_[1];
  
          if( !defined $name ) {
              eval {
                  require B::Deparse;
                  $name = B::Deparse->new->coderef2text($_[0]);
              };
              $name = 
                'code display non-functional on this version of Perl, sorry'
                  if $@;
          }
  
          require Carp;
          Carp::confess( _fail_msg($name) );
      }
      return undef;
  }
  
  =item B<should>
  
  =item B<shouldnt>
  
      should  ($this, $shouldbe)   if DEBUG;
      shouldnt($this, $shouldntbe) if DEBUG;
  
  Similar to assert(), it is specially for simple "this should be that"
  or "this should be anything but that" style of assertions.
  
  Due to Perl's lack of a good macro system, assert() can only report
  where something failed, but it can't report I<what> failed or I<how>.
  should() and shouldnt() can produce more informative error messages:
  
      Assertion ('this' should be 'that'!) failed!
              Carp::Assert::should('this', 'that') called at moof line 29
              main::foo() called at moof line 58
  
  So this:
  
      should($this, $that) if DEBUG;
  
  is similar to this:
  
      assert($this eq $that) if DEBUG;
  
  except for the better error message.
  
  Currently, should() and shouldnt() can only do simple eq and ne tests
  (respectively).  Future versions may allow regexes.
  
  =cut
  
  sub should ($$) {
      unless($_[0] eq $_[1]) {
          require Carp;
          &Carp::confess( _fail_msg("'$_[0]' should be '$_[1]'!") );
      }
      return undef;
  }
  
  sub shouldnt ($$) {
      unless($_[0] ne $_[1]) {
          require Carp;
          &Carp::confess( _fail_msg("'$_[0]' shouldn't be that!") );
      }
      return undef;
  }
  
  =back
  
  =head1 Debugging vs Production
  
  Because assertions are extra code and because it is sometimes necessary to
  place them in 'hot' portions of your code where speed is paramount,
  Carp::Assert provides the option to remove its assert() calls from your
  program.
  
  So, we provide a way to force Perl to inline the switched off assert()
  routine, thereby removing almost all performance impact on your production
  code.
  
      no Carp::Assert;  # assertions are off.
      assert(1==1) if DEBUG;
  
  DEBUG is a constant set to 0.  Adding the 'if DEBUG' condition on your
  assert() call gives perl the cue to go ahead and remove assert() call from
  your program entirely, since the if conditional will always be false.
  
      # With C<no Carp::Assert> the assert() has no impact.
      for (1..100) {
          assert( do_some_really_time_consuming_check ) if DEBUG;
      }
  
  If C<if DEBUG> gets too annoying, you can always use affirm().
  
      # Once again, affirm() has (almost) no impact with C<no Carp::Assert>
      for (1..100) {
          affirm { do_some_really_time_consuming_check };
      }
  
  Another way to switch off all asserts, system wide, is to define the
  NDEBUG or the PERL_NDEBUG environment variable.
  
  You can safely leave out the "if DEBUG" part, but then your assert()
  function will always execute (and its arguments evaluated and time
  spent).  To get around this, use affirm().  You still have the
  overhead of calling a function but at least its arguments will not be
  evaluated.
  
  
  =head1 Differences from ANSI C
  
  assert() is intended to act like the function from ANSI C fame. 
  Unfortunately, due to Perl's lack of macros or strong inlining, it's not
  nearly as unobtrusive.
  
  Well, the obvious one is the "if DEBUG" part.  This is cleanest way I could
  think of to cause each assert() call and its arguments to be removed from
  the program at compile-time, like the ANSI C macro does.
  
  Also, this version of assert does not report the statement which
  failed, just the line number and call frame via Carp::confess.  You
  can't do C<assert('$a == $b')> because $a and $b will probably be
  lexical, and thus unavailable to assert().  But with Perl, unlike C,
  you always have the source to look through, so the need isn't as
  great.
  
  
  =head1 EFFICIENCY
  
  With C<no Carp::Assert> (or NDEBUG) and using the C<if DEBUG> suffixes
  on all your assertions, Carp::Assert has almost no impact on your
  production code.  I say almost because it does still add some load-time
  to your code (I've tried to reduce this as much as possible).
  
  If you forget the C<if DEBUG> on an C<assert()>, C<should()> or
  C<shouldnt()>, its arguments are still evaluated and thus will impact
  your code.  You'll also have the extra overhead of calling a
  subroutine (even if that subroutine does nothing).
  
  Forgetting the C<if DEBUG> on an C<affirm()> is not so bad.  While you
  still have the overhead of calling a subroutine (one that does
  nothing) it will B<not> evaluate its code block and that can save
  a lot.
  
  Try to remember the B<if DEBUG>.
  
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item NDEBUG
  
  Defining NDEBUG switches off all assertions.  It has the same effect
  as changing "use Carp::Assert" to "no Carp::Assert" but it effects all
  code.
  
  =item PERL_NDEBUG
  
  Same as NDEBUG and will override it.  Its provided to give you
  something which won't conflict with any C programs you might be
  working on at the same time.
  
  =back
  
  
  =head1 BUGS, CAVETS and other MUSINGS
  
  =head2 Conflicts with C<POSIX.pm>
  
  The C<POSIX> module exports an C<assert> routine which will conflict with C<Carp::Assert> if both are used in the same namespace.  If you are using both together, prevent C<POSIX> from exporting like so:
  
      use POSIX ();
      use Carp::Assert;
  
  Since C<POSIX> exports way too much, you should be using it like that anyway.
  
  =head2 C<affirm> and C<$^S>
  
  affirm() mucks with the expression's caller and it is run in an eval
  so anything that checks $^S will be wrong.
  
  =head2 missing C<if DEBUG>
  
  It would be nice if we could warn about missing C<if DEBUG>.
  
  
  =head1 SEE ALSO
  
  L<assert.h|http://en.wikipedia.org/wiki/Assert.h> - the wikipedia
  page about C<assert.h>.
  
  L<Carp::Assert::More> provides a set of convenience functions
  that are wrappers around C<Carp::Assert>.
  
  L<Sub::Assert> provides support for subroutine pre- and post-conditions.
  The documentation says it's slow.
  
  L<PerlX::Assert> provides compile-time assertions, which are usually
  optimised away at compile time. Currently part of the L<Moops>
  distribution, but may get its own distribution sometime in 2014.
  
  L<Devel::Assert> also provides an C<assert> function, for Perl >= 5.8.1.
  
  L<assertions> provides an assertion mechanism for Perl >= 5.9.0.
  
  =head1 REPOSITORY
  
  L<https://github.com/schwern/Carp-Assert>
  
  =head1 COPYRIGHT
  
  Copyright 2001-2007 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =cut
  
  return q|You don't just EAT the largest turnip in the world!|;
CARP_ASSERT

$fatpacked{"Contextual/Return.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN';
  package Contextual::Return;
  use warnings;
  use strict;
  our $VERSION = '0.004014';
  
  my %attrs_of;
  
  # This is localized as caller to hide the interim blocks...
  my $smart_caller;
  
  # Fake out Carp::*, and Scalar::Util::blessed() very early...
  BEGIN {
      no warnings 'redefine';
  
      my $fallback_caller = *CORE::GLOBAL::caller{CODE};
      if (!defined $fallback_caller) {
          *CORE::GLOBAL::caller = sub (;$) {
              my ($height) = @_;
              $height++;
              my @caller = CORE::caller($height);
              if ( CORE::caller() eq 'DB' ) {
                  # Oops, redo picking up @DB::args
                  package DB;
                  @caller = CORE::caller($height);
              }
  
              return if ! @caller;                  # empty
              return $caller[0] if ! wantarray;     # scalar context
              return @_ ? @caller : @caller[0..2];  # extra info or regular
          };
      }
      $smart_caller = sub (;$) {
          my ($uplevels) = $_[0] || 0;
          my @caller;
          if (CORE::caller eq 'DB') {
              package DB;
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          else {
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          return if ! @caller;                  # empty
          return $caller[0] if ! wantarray;     # scalar context
          return @_ ? @caller : @caller[0..2];  # extra info or regular
      };
  
      use Carp;
      my $real_carp  = *Carp::carp{CODE};
      my $real_croak = *Carp::croak{CODE};
  
      *Carp::carp = sub {
          goto &{$real_carp} if !$Contextual::Return::uplevel;
          warn _in_context(@_);
      };
  
      *Carp::croak = sub {
          goto &{$real_croak} if !$Contextual::Return::uplevel;
          die _in_context(@_);
      };
  
      # Scalar::Util::blessed()...
      use Scalar::Util 'refaddr';
  
      # Remember the current blessed()...
      my $original_blessing = *Scalar::Util::blessed{CODE};
  
      # ...and replace it...
      *Scalar::Util::blessed = sub($) {
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Are we operating on a CRV???
          my $attrs = $attrs_of{refaddr $_[0] or q{}};
  
          # If not, use the original code...
          goto &{$original_blessing} if !$attrs;
  
          # Does this object have a BLESSED handler???
          if (exists $attrs->{BLESSED}) {
              return $attrs->{BLESSED}->(@{$attrs->{args}});
          }
  
          # Otherwise, find the appropriate scalar handler...
          handler:
          for my $context (qw( OBJREF LAZY REF SCALAR VALUE NONVOID DEFAULT )) {
              my $handler = $attrs->{$context}
                  or next handler;
  
              my $obj_ref = eval { $handler->(@{$attrs->{args}}) };
  
              my $was_blessed = $original_blessing->($obj_ref);
              return $was_blessed if $was_blessed;
          }
  
          # Otherwise, simulate unblessed status...
          return undef;
      };
  }
  
  
  
  sub _in_context {
      my $msg = join q{}, @_;
  
      # Start looking in caller...
      my $stack_frame = 1;
      my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
      my ($orig_package, $prev_package) = ($package) x 2;
      my $LOC = qq{at $file line $line};
  
      # Walk up stack...
      STACK_FRAME:
      while (1) {
          my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
          # Fall off the top of the stack...
          last STACK_FRAME if !defined $package;
  
          # Ignore this module (and any helpers)...
          next STACK_FRAME if $package =~ m{^Contextual::Return}xms;
  
          # Track the call up the stack...
          $LOC = qq{at $file line $line};
  
          # Ignore any @CARP_NOT'ed packages
          next STACK_FRAME
              if do { no strict 'refs'; *{$package.'::CARP_NOT'}{ARRAY}; };
  
          # Ignore transitions within original caller...
          next STACK_FRAME
              if $package eq $orig_package && $prev_package eq $orig_package;
  
          # If we get a transition out of the original package, we're there...
          last STACK_FRAME;
      }
  
      # Insert location details...
      $msg =~ s/<LOC>/$LOC/g or $msg =~ s/[^\S\n]*$/ $LOC/;
      $msg =~ s/$/\n/;
      return $msg;
  }
  
  # Indentation corresponds to inherited fall-back relationships...
  my @CONTEXTS = qw(
      DEFAULT
          VOID
          NONVOID
              LIST
              SCALAR
                  VALUE
                      STR
                      NUM
                      BOOL
                          PUREBOOL
                  REF
                      SCALARREF
                      ARRAYREF
                      CODEREF
                      HASHREF
                      GLOBREF
                      OBJREF
                          METHOD
                          BLESSED
  );
  
  my @ALL_EXPORTS = (
      @CONTEXTS,
      qw(
          LAZY       RESULT      RVALUE      METHOD     FAIL
          FIXED      RECOVER     LVALUE      RETOBJ     FAIL_WITH
          ACTIVE     CLEANUP     NVALUE      STRICT     BLESSED
      )
  );
  
  my %STD_NAME_FOR = map { $_ => $_ } @ALL_EXPORTS;
  
  sub import {
      # Load utility module for failure handlers...
      if (require Contextual::Return::Failure) {
          *FAIL      = \&Contextual::Return::Failure::_FAIL;
          *FAIL_WITH = \&Contextual::Return::Failure::_FAIL_WITH;
      }
  
      # Don't need the package name...
      shift @_;
  
      # If args, export nothing by default; otherwise export all...
      my %exports = @_ ? () : %STD_NAME_FOR;
  
      # All args are export either selectors and/or renamers...
      while (my $selector = shift @_) {
          my $next_arg = $_[0];
          my $renamer = (defined $next_arg
                      && !ref $next_arg
                      && !exists $STD_NAME_FOR{$next_arg})
                          ? shift(@_)
                          : undef;
          %exports = (%exports, _add_exports_for($selector, $renamer));
      }
  
      # Loop through possible exports, exporting anything requested...
      my $caller = CORE::caller;
      EXPORT:
      for my $subname (keys %exports) {
          no strict qw( refs );
          *{$caller.'::'.$exports{$subname}} = \&{$subname};
      }
  };
  
  sub _add_exports_for {
      my ($selector, $renamer) = @_;
  
      # If no renamer, use original name...
      $renamer ||= '%s';
  
      # Handle different types of selector...
      my $selector_type = ref($selector) || 'literal';
  
      # Array selector recursively export each element...
      if ($selector_type eq 'ARRAY') {
          return map { _add_exports_for($_,$renamer) } @{$selector};
      }
      elsif ($selector_type eq 'Regexp') {
          my @selected = grep {/$selector/} @ALL_EXPORTS;
          if (!@selected) {
              Carp::carp("use Contextual::Return $selector didn't export anything");
          }
          no if $] >= 5.022, warnings => 'redundant';
          return map { $_ => sprintf($renamer, $_) } @selected;
      }
      elsif ($selector_type eq 'literal') {
          Carp::croak "Can't export $selector: no such handler"
              if !exists $STD_NAME_FOR{$selector};
          no if $] >= 5.022, warnings => 'redundant';
          return ( $selector => sprintf($renamer, $selector) );
      }
      else {
          Carp::croak "Can't use $selector_type as export specifier";
      }
  }
  
  
  # Let handlers access the result object they're inside...
  
  sub RETOBJ() {
      our $__RETOBJ__;
      return $__RETOBJ__;
  }
  
  
  use Scalar::Util qw( refaddr );
  
  # Override return value in a C::R handler...
  sub RESULT(;&) {
      my ($block) = @_;
  
      # Determine call context and arg list...
      my $context;
      my $args = do { package DB; $context=(CORE::caller 1)[5]; my $args = \@DB::args; ()=CORE::caller(1); $args };
  
      # No args -> return appropriate value...
      if (!@_) {
          return $context ? @{ $Contextual::Return::__RESULT__ || [] }
                          :    $Contextual::Return::__RESULT__->[0]
                          ;
      }
  
      # Hide from caller() and the enclosing eval{}...
  
      # Evaluate block in context and cache result...
      local $Contextual::Return::uplevel = $Contextual::Return::uplevel+1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      $Contextual::Return::__RESULT__
          =         $context  ? [        $block->(@{$args})      ]
          : defined $context  ? [ scalar $block->(@{$args}) ]
          :                     do {     $block->(@{$args}); [] }
          ;
  
      return;
  }
  
  sub RVALUE(&;@) :lvalue;
  sub LVALUE(&;@) :lvalue;
  sub NVALUE(&;@) :lvalue;
  
  my %opposite_of = (
      'RVALUE' => 'LVALUE or NVALUE',
      'LVALUE' => 'RVALUE or NVALUE',
      'NVALUE' => 'LVALUE or RVALUE',
  );
  
  
  BEGIN {
      for my $subname (qw( RVALUE LVALUE NVALUE) ) {
          no strict 'refs';
          *{$subname} = sub(&;@) :lvalue {    # (handler, return_lvalue);
              my $handler = shift;
              my $impl;
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              if (@_==0) {
                  $impl = tie $_[0], 'Contextual::Return::Lvalue',
                      $subname => $handler, args=>$args;
              }
              elsif (@_==1 and $impl = tied $_[0]) {
                  die _in_context "Can't install two $subname handlers"
                      if exists $impl->{$subname};
                  $impl->{$subname} = $handler;
              }
              else {
                  my $vals = join q{, }, map { tied $_    ? keys %{tied $_}
                                             : defined $_ ? $_
                                             :              'undef'
                                             } @_;
                  die _in_context "Expected a $opposite_of{$subname} block ",
                                  "after the $subname block <LOC> ",
                                  "but found instead: $vals\n";
              }
  
              # Handle void context calls...
              if (!defined wantarray && $impl->{NVALUE}) {
                  # Fake out caller() and Carp...
                  local $Contextual::Return::uplevel = 1;
                  no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
                  # Call and clear handler...
                  local $Contextual::Return::__RETOBJ__ = $impl;
                  $impl->{NVALUE}( @{$impl->{args}} );
                  delete $impl->{NVALUE};
              }
              $_[0];
          }
      }
  }
  
  for my $modifier_name (qw< STRICT FIXED ACTIVE >) {
      no strict 'refs';
      *{$modifier_name} = sub ($) {
          my ($crv) = @_;
          my $attrs = $attrs_of{refaddr $crv or q{}};
  
          # Track context...
          my $wantarray = wantarray;
          use Want;
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Remember the modification...
          $attrs->{$modifier_name} = 1;
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last handler if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, let someone else handle it...
          return $crv;
      }
  }
  
  sub LIST (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !!(CORE::caller 1)[5] if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare LIST {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two LIST handlers"
          if exists $attrs->{LIST};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
  
          my @rv = eval { $block->(@{$attrs->{args}}) };
          if ($recover) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [@rv];
              }
              () = $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return @rv if !$Contextual::Return::__RESULT__;
          return @{$Contextual::Return::__RESULT__};
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          handler:
          for my $context (qw< VOID DEFAULT >) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              eval { $attrs->{$context}->(@{$attrs->{args}}) };
              if ($recover) {
                  $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
              last handler;
          }
          if ($attrs->{STRICT}) {
              $@ = _in_context "Can't call $attrs->{sub} in a void context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{LIST} = $block;
      return $crv;
  }
  
  
  sub VOID (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !defined( (CORE::caller 1)[5] ) if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare VOID {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two VOID handlers"
          if exists $attrs->{VOID};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly, if possible...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
          # List or ancestral handlers...
          handler:
          for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              my @rv = eval { $handler->(@{$attrs->{args}}) };
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [@rv];
                  }
                  () = $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              return @rv if !$Contextual::Return::__RESULT__;
              return @{$Contextual::Return::__RESULT__};
          }
          # Convert to list from arrayref handler...
          if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
              my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [$array_ref];
                  }
                  scalar $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              # Array ref may be returned directly, or via RESULT{}...
              $array_ref = $Contextual::Return::__RESULT__->[0]
                  if $Contextual::Return::__RESULT__;
  
              return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
          }
          # Return scalar object as one-elem list, if possible...
          handler:
          for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
              last handler if $attrs->{STRICT};
              return $crv if exists $attrs->{$context};
          }
          $@ = _in_context "Can't call $attrs->{sub} in a list context";
          if ($recover) {
              () = $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          eval { $block->(@{$attrs->{args}}) };
  
          if ($recover) {
              $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{VOID} = $block;
      return $crv;
  }
  
  for my $context (qw( SCALAR NONVOID )) {
      no strict qw( refs );
      *{$context} = sub (;&$) {
          my ($block, $crv) = @_;
  
          # Handle simple context tests...
          if (!@_) {
              my $callers_context = (CORE::caller 1)[5];
              return defined $callers_context
                  && ($context eq 'NONVOID' || !$callers_context);
          }
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                      = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          die _in_context "Can't install two $context handlers"
              if exists $attrs->{$context};
          $attrs->{$context} = $block;
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
  
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              die _in_context "Can't call $attrs->{sub} in a list context";
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  handler:
  for my $context_name (@CONTEXTS, qw< RECOVER _internal_LIST CLEANUP >) {
      next handler if $context_name eq 'LIST'       # These
                   || $context_name eq 'VOID'       #  four
                   || $context_name eq 'SCALAR'     #   handled
                   || $context_name eq 'NONVOID';   #    separately
  
      no strict qw( refs );
      *{$context_name} = sub (&;$) {
          my ($block, $crv) = @_;
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context_name {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                       = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          if ($context_name ne '_internal_LIST') {
              die _in_context "Can't install two $context_name handlers"
                  if exists $attrs->{$context_name};
              $attrs->{$context_name} = $block;
          }
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__
                  = $context_name eq 'RECOVER' ? $Contextual::Return::__RESULT__
                  :                              undef
                  ;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  local $Contextual::Return::uplevel = 2;
  
                  # Array ref may be returned directly, or via RESULT{}...
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw(VOID DEFAULT)) {
                  if (!$attrs->{$context}) {
                      last handler if $attrs->{STRICT};
                      next handler;
                  }
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  # Alias LAZY to SCALAR...
  *LAZY = *SCALAR;
  
  
  # Set $Data::Dumper::Freezer to 'Contextual::Return::FREEZE' to be able to
  # dump contextual return values...
  
  my %operator_impl;
  
  my $no_handler_message = qr{
      ^ Can't [ ] call [ ] .*? [ ] in [ ] [\w]+ [ ] context
    | ^ [\w:]+ [ ] can't [ ] return [ ] a [ ] \w+ [ ] reference
  }xms;
  
  sub _flag_self_ref_in {
      my ($data_ref, $obj_ref) = @_;
      my $type = ref $data_ref;
      return if !$type;
      for my $ref ( $type eq 'SCALAR' ? ${$data_ref} : $type eq 'ARRAY' ? @{$data_ref} : ()) {
          no warnings 'numeric', 'uninitialized';
          if (refaddr($ref) == refaddr($obj_ref)) {
              $ref = '<<<self-reference>>>';
          }
      }
  }
  
  sub FREEZE {
      my ($self) = @_;
      my $attrs_ref = $attrs_of{refaddr $self};
      my $args_ref  = $attrs_ref->{args};
  
      my @no_handler;
  
      # Call appropriate operator handler, defusing and recording exceptions...
      my $overloaded = sub {
          my ($context, $op) = @_;
  
          # Try the operator...
          my $retval = eval { $operator_impl{$op}->($self,@{$args_ref}) };
  
          # Detect and report internal exceptions...
          if (my $exception = $@) {
              if ($exception =~ $no_handler_message) {
                  push @no_handler, $context;
                  return ();
              }
              chomp $exception;
              return { $context => "<<<Throws exception: $exception>>>" };
          }
  
          # Detect self-referential overloadings (to avoid infinite recursion)...
          {
              no warnings 'numeric', 'uninitialized';
              if (ref $retval eq 'REF' && eval{ ${$retval} == ${$self} }) {
                  return { $context => "<<<self-reference>>>" };
              }
          }
  
          # Normal return of contextual value labelled by context...
          return { $context => $retval };
      };
  
      my @values;
  
      # Where did this value originate?
      push @values, { ISA  => 'Contextual::Return::Value' };
      push @values, { FROM => $attrs_ref->{sub} };
  
      # Does it return a value in void context?
      if (exists $attrs_ref->{VOID} || exists $attrs_ref->{DEFAULT}) {
          push @values, { VOID => undef };
      }
      else {
          push @no_handler, 'VOID';
      }
  
      # Generate list context value by "pretend" LIST handler...
      push @values, { LIST => eval{ [ _internal_LIST(sub{}, $self) ] } // do{ chomp $@; "<<<Throws exception: $@>>>"} };
          _flag_self_ref_in($values[-1]{LIST}, $self);
  
      # Generate scalar context values by calling appropriate handler...
      push @values, $overloaded->( STR       => q{""}  );
      push @values, $overloaded->( NUM       => '0+'   );
      push @values, $overloaded->( BOOL      => 'bool' );
      push @values, $overloaded->( SCALARREF => '${}'  );
          _flag_self_ref_in($values[-1]{SCALARREF}, $self);
      push @values, $overloaded->( ARRAYREF  => '@{}'  );
          _flag_self_ref_in($values[-1]{ARRAYREF}, $self);
      push @values, $overloaded->( CODEREF   => '&{}'  );
      push @values, $overloaded->( HASHREF   => '%{}'  );
      push @values, $overloaded->( GLOBREF   => '*{}'  );
  
      # Are there handlers for various "generic" super-contexts...
      my @fallbacks = grep { $attrs_ref->{$_} }
                         qw< DEFAULT NONVOID SCALAR VALUE REF RECOVER >;
  
      push @values, { NO_HANDLER => \@no_handler };
      push @values, { FALLBACKS  => \@fallbacks  };
  
      # Temporarily replace object being dumped, by values found...
      $_[0] = \@values;
  }
  
  # Call this method on a contextual return value object to debug it...
  
  sub DUMP {
      if (eval{ require Data::Dumper; 1; }) {
          my ($crv) = @_;
          if (eval{ ref($crv)->isa('Contextual::Return::Value')}) {
              Contextual::Return::FREEZE($crv);
          }
          local $Data::Dumper::Terse = 1;
          local $Data::Dumper::Indent = 1;
          my $dump = Data::Dumper::Dumper($crv);
          $dump =~ s<,\n  \{><,ZZZZ{>msg;
          $dump =~ s<\n\s+>< >msg;
          $dump =~ s<,ZZZZ\{><\n  {>msg;
          return $dump;
      }
      else {
          Carp::carp("Can't DUMP contextual return value (no Data::Dumper!)");
          return;
      }
  }
  
  
  package Contextual::Return::Value;
  BEGIN { *_in_context = *Contextual::Return::_in_context; }
  use Scalar::Util qw( refaddr );
  
  BEGIN {
      %operator_impl = (
          q{""} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(STR SCALAR LAZY VALUE NONVOID DEFAULT NUM)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a string";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{0+} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(NUM SCALAR LAZY VALUE NONVOID DEFAULT STR)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a number";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{bool} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
  
              # Handle Calls in Pure Boolean context...
              my @PUREBOOL = $attrs->{want_pure_bool} ? ('PUREBOOL') : ();
              $attrs->{want_pure_bool} = 0;
  
              handler:
              for my $context (@PUREBOOL, qw(BOOL STR NUM SCALAR LAZY VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $context eq 'BOOL' and $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $outer_sig_warn = $SIG{__WARN__};
                  local $SIG{__WARN__}
                      = sub{ return if $_[0] =~ /^Exiting \S+ via next/;
                             goto &{$outer_sig_warn} if $outer_sig_warn;
                             warn @_;
                        };
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a boolean";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '${}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(SCALARREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the scalar dereference"
                          if ref($rv) ne 'SCALAR' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return a scalar reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              if ( $attrs->{FIXED} ) {
                  $_[0] = \$self;
              }
              return \$self;
          },
          '@{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              local $Contextual::Return::__RESULT__;
              handler:
              for my $context (qw(ARRAYREF REF)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the array dereference"
                          if ref($rv) ne 'ARRAY' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  last handler if $attrs->{STRICT};
                  my $handler = $attrs->{$context}
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      @rv = @{$Contextual::Return::__RESULT__->[0]};
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = \@rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { @rv };
                  }
                  return \@rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return an array reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              return [ $self ];
          },
          '%{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(HASHREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the hash dereference"
                          if ref($rv) ne 'HASH' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a hash reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '&{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(CODEREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the subroutine dereference"
                          if ref($rv) ne 'CODE' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a subroutine reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '*{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(GLOBREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the typeglob dereference"
                          if ref($rv) ne 'GLOB' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a typeglob reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
      );
  }
  
  use overload %operator_impl, fallback => 1;
  
  sub DESTROY {
      my ($id) = refaddr shift;
      my $attrs = $attrs_of{$id};
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      if (my $handler = $attrs->{CLEANUP}) {
          $handler->(@{ $attrs->{args} });
      }
      delete $attrs_of{$id};
      return;
  }
  
  my $NO_SUCH_METHOD = qr/\ACan't (?:locate|call)(?: class| object)? method/ms;
  
  # Forward metainformation requests to actual class...
  sub can {
      my ($invocant) = @_;
      # Only forward requests on actual C::R::V objects...
      if (ref $invocant) {
          our $AUTOLOAD = 'can';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::can(@_[1..$#_]);
  }
  
  sub isa {
      # Only forward requests on actual C::R::V objects...
      my ($invocant) = @_;
      if (ref $invocant) {
          our $AUTOLOAD = 'isa';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::isa(@_[1..$#_]);
  }
  
  
  sub AUTOLOAD {
      my ($self) = @_;
      our $AUTOLOAD;
  
      my ($requested_method) = $AUTOLOAD =~ m{ .* :: (.*) }xms ? $1 : $AUTOLOAD;
  
      my $attrs = $attrs_of{refaddr $self} || {};
      local $Contextual::Return::__RETOBJ__ = $self;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # First, see if there is a method call handler...
      if (my $context_handler = $attrs->{METHOD}) {
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my @method_handlers = eval { $context_handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [\@method_handlers];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              @method_handlers = @{$Contextual::Return::__RESULT__};
          }
  
          # Locate the correct method handler (if any)...
          MATCHER:
          while (my ($matcher, $method_handler) = splice @method_handlers, 0, 2) {
  
              if (ref($matcher) eq 'ARRAY') {
                  next MATCHER
                      if !grep { $requested_method =~ $_ } @{$matcher};
              }
              elsif ($requested_method !~ $matcher) {
                  next MATCHER;
              }
  
              shift;
              if (wantarray) {
                  my @result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return @result;
              }
              else {
                  my $result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return $result;
              }
          }
      }
  
      # Next, try to create an object on which to call the method...
      handler:
      for my $context (qw(OBJREF STR SCALAR LAZY VALUE NONVOID DEFAULT)) {
          my $handler = $attrs->{$context}
              or $attrs->{STRICT} and last handler
              or next handler;
  
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my $object = eval { $handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [$object];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              $object = $Contextual::Return::__RESULT__->[0];
          }
  
          if ( $attrs->{FIXED} ) {
              $_[0] = $object;
          }
          elsif ( !$attrs->{ACTIVE} ) {
              $attrs->{$context} = sub { $object };
          }
          shift;
  
          if (wantarray) {
              my @result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return @result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          else {
              my $result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return $result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          $@ = _in_context "Can't call method '$requested_method' on $context value returned by $attrs->{sub}";
          if (my $recover = $attrs->{RECOVER}) {
              scalar $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Otherwise, the method cannot be called, so react accordingly...
      $@ = _in_context "Can't call method '$requested_method' on value returned by $attrs->{sub}";
      if (my $recover = $attrs->{RECOVER}) {
          return scalar $recover->(@{$attrs->{args}});
      }
      else {
          die $@;
      }
  }
  
  package Contextual::Return::Lvalue;
  
  sub TIESCALAR {
      my ($package, @handler) = @_;
      return bless {@handler}, $package;
  }
  
  # Handle calls that are lvalues...
  sub STORE {
      local *CALLER::_ = \$_;
      local *_         = \$_[1];
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{LVALUE}( @{$_[0]{args}} );
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  # Handle calls that are rvalues...
  sub FETCH {
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{RVALUE} ? $_[0]{RVALUE}( @{$_[0]{args}} ) : undef;
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  sub DESTROY {};
  
  1; # Magic true value required at end of module
  
  __END__
  
  =head1 NAME
  
  Contextual::Return - Create context-sensitive return values
  
  
  =head1 VERSION
  
  This document describes Contextual::Return version 0.004014
  
  
  =head1 SYNOPSIS
  
      use Contextual::Return;
      use Carp;
  
      sub foo {
          return
              SCALAR { 'thirty-twelve' }
              LIST   { 1,2,3 }
  
              BOOL { 1 }
              NUM  { 7*6 }
              STR  { 'forty-two' }
  
              HASHREF  { {name => 'foo', value => 99} }
              ARRAYREF { [3,2,1] }
  
              GLOBREF  { \*STDOUT }
              CODEREF  { croak "Don't use this result as code!"; }
          ;
      }
  
      # and later...
  
      if (my $foo = foo()) {
          for my $count (1..$foo) {
              print "$count: $foo is:\n"
                  . "  array: @{$foo}\n"
                  . "  hash:  $foo->{name} => $foo->{value}\n"
                  ;
          }
          print {$foo} $foo->();
      }
  
  =head1 DESCRIPTION
  
  Usually, when you need to create a subroutine that returns different values in
  different contexts (list, scalar, or void), you write something like:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data,
          # depending on call context...
          if (wantarray()) {
              return @server_data{ qw(name uptime load users) };
          }
          if (defined wantarray()) {
              return $server_data{load};
          }
          if (!defined wantarray()) {
              carp 'Useless use of get_server_status() in void context';
              return;
          }
          else {
              croak q{Bad context! No biscuit!};
          }
      }
  
  That works okay, but the code could certainly be more readable. In
  its simplest usage, this module makes that code more readable by
  providing three subroutines--C<LIST()>, C<SCALAR()>, C<VOID()>--that
  are true only when the current subroutine is called in the
  corresponding context:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          if (LIST)   { return @server_data{ qw(name uptime load users) } }
          if (SCALAR) { return $server_data{load}                         }
          if (VOID)   { print "$server_data{load}\n"                      }
          else        { croak q{Bad context! No biscuit!}                 }
      }
  
  =head2 Contextual returns
  
  Those three subroutines can also be used in another way: as labels on a
  series of I<contextual return blocks> (collectively known as a I<contextual
  return sequence>). When a context sequence is returned, it automatically
  selects the appropriate contextual return block for the calling context.
  So the previous example could be written even more cleanly as:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
              LIST    { return @server_data{ qw(name uptime load users) } }
              SCALAR  { return $server_data{load}                         }
              VOID    { print "$server_data{load}\n"                      }
              DEFAULT { croak q{Bad context! No biscuit!}                 }
          );
      }
  
  The context sequence automatically selects the appropriate block for each call
  context.
  
  
  =head2 Lazy contextual return values
  
  C<LIST> and C<VOID> blocks are always executed during the C<return>
  statement. However, scalar return blocks (C<SCALAR>, C<STR>, C<NUM>,
  C<BOOL>, etc.) blocks are not. Instead, returning any of scalar block
  types causes the subroutine to return an object that lazily
  evaluates that block only when the return value is used.
  
  This means that returning a C<SCALAR> block is a convenient way to
  implement a subroutine with a lazy return value. For example:
  
      sub digest {
          return SCALAR {
              my ($text) = @_;
              md5($text);
          }
      }
  
      my $digest = digest($text);
  
      print $digest;   # md5() called only when $digest used as string
  
  To better document this usage, the C<SCALAR> block has a synonym: C<LAZY>.
  
      sub digest {
          return LAZY {
              my ($text) = @_;
              md5($text);
          }
      }
  
  
  =head2 Active contextual return values
  
  Once a return value has been lazily evaluated in a given context,
  the resulting value is cached, and thereafter reused in that same context.
  
  However, you can specify that, rather than being cached, the value
  should be re-evaluated I<every> time the value is used:
  
       sub make_counter {
          my $counter = 0;
          return ACTIVE
              SCALAR   { ++$counter }
              ARRAYREF { [1..$counter] }
      }
  
      my $idx = make_counter();
  
      print "$idx\n";      # 1
      print "$idx\n";      # 2
      print "[@$idx]\n";   # [1 2]
      print "$idx\n";      # 3
      print "[@$idx]\n";   # [1 2 3]
  
  
  =head2 Semi-lazy contextual return values
  
  Sometimes, single or repeated lazy evaluation of a scalar return value
  in different contexts isn't what you really want. Sometimes what you
  really want is for the return value to be lazily evaluated once only (the
  first time it's used in any context), and then for that first value to
  be reused whenever the return value is subsequently reevaluated in any
  other context.
  
  To get that behaviour, you can use the C<FIXED> modifier, which causes
  the return value to morph itself into the actual value the first time it
  is used. For example:
  
      sub lazy {
          return
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $lazy = lazy();
      print $lazy + 1;            # 43
      print "@{$lazy}";           # 1 2 3
  
  
      sub semilazy {
          return FIXED
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $semi = semilazy();
      print $semi + 1;            # 43
      print "@{$semi}";           # die q{Can't use string ("42") as an ARRAY ref}
  
  
  
  =head2 Finer distinctions of scalar context
  
  Because the scalar values returned from a context sequence are lazily
  evaluated, it becomes possible to be more specific about I<what kind> of
  scalar value should be returned: a boolean, a number, or a string. To support
  those distinctions, Contextual::Return provides four extra context blocks:
  C<NUM>, C<STR>, C<BOOL>, and C<PUREBOOL>:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }          }
             PUREBOOL { $_ = $server_data{uptime}; $server_data{uptime} > 0 }
                 BOOL { $server_data{uptime} > 0                            }
                 NUM  { $server_data{load}                                  }
                 STR  { "$server_data{name}: $server_data{uptime}"          }
                 VOID { print "$server_data{load}\n"                        }
              DEFAULT { croak q{Bad context! No biscuit!}                   }
          );
      }
  
  With these in place, the object returned from a scalar-context call to
  C<get_server_status()> now behaves differently, depending on how
  it's used. For example:
  
      if ( my $status = get_server_status() ) {  # BOOL: True if uptime > 0
          $load_distribution[$status]++;         # INT:  Evaluates to load value
          print "$status\n";                     # STR:  Prints "name: uptime"
      }
  
      if (get_server_status()) {                 # PUREBOOL: also sets $_;
          print;                                 # ...which is then used here
      }
  
  =head3 Boolean vs Pure Boolean contexts
  
  There is a special subset of boolean contexts where the return value is being
  used and immediately thrown away. For example, in the loop:
  
      while (get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is tested for truth and then discarded.
  This is known as "pure boolean context". In contrast, in the loop:
  
      while (my $data = get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is first assigned to C<$data>, then
  tested for truth. Because of the assignment, the return value is I<not>
  discarded after the boolean test. This is ordinary "boolean context".
  
  In Perl, pure boolean context is often associated with a special side-effect,
  that does not occur in regular boolean contexts. For example:
  
      while (<>) {...}         # $_ set as side-effect of pure boolean context
  
      while ($v = <>) {...}    # $_ NOT set in ordinary boolean context
  
  Contextual::Return supports this with a special subcase of C<BOOL> named
  <PUREBOOL>. In pure boolean contexts, Contextual::Return will call a
  C<PUREBOOL> handler if one has been defined, or fall back to a C<BOOL>
  or C<SCALAR> handler if no C<PUREBOOL> handler exists. In ordinary
  boolean contexts only the C<BOOL> or C<SCALAR> handlers are tried, even
  if a C<PUREBOOL> handler is also defined.
  
  Typically C<PUREBOOL> handlers are set up to have some side-effect (most
  commonly: setting C<$_> or <$@>), like so:
  
      sub get_data {
          my ($succeeded, @data) = _go_and_get_data();
  
          return
              PUREBOOL { $_ = $data[0]; $succeeded; }
                  BOOL {                $succeeded; }
                SCALAR {                $data[0];   }
                  LIST {                @data;      }
      }
  
  However, there is no requirement that they have side-effects. For example,
  they can also be used to implement "look-but-don't-retrieve-yet" checking:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  
  =head2 Self-reference within handlers
  
  Any handler can refer to the contextual return object it is part of, by
  calling the C<RETOBJ()> function. This is particularly useful for C<PUREBOOL>
  and C<LIST> handlers. For example:
  
      return
          PUREBOOL { $_ = RETOBJ; next handler; }
              BOOL { !$failed;                  }
           DEFAULT { $data;                     };
  
  
  =head2 Referential contexts
  
  The other major kind of scalar return value is a reference.
  Contextual::Return provides contextual return blocks that allow you to
  specify what to (lazily) return when the return value of a subroutine is
  used as a reference to a scalar (C<SCALARREF {...}>), to an array
  (C<ARRAYREF {...}>), to a hash (C<HASHREF {...}>), to a subroutine
  (C<CODEREF {...}>), or to a typeglob (C<GLOBREF {...}>).
  
  For example, the server status subroutine shown earlier could be extended to
  allow it to return a hash reference, thereby supporting "named return values":
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }  }
                 BOOL { $server_data{uptime} > 0                    }
                  NUM { $server_data{load}                          }
                  STR { "$server_data{name}: $server_data{uptime}"  }
                 VOID { print "$server_data{load}\n"                }
              HASHREF { return \%server_data                        }
              DEFAULT { croak q{Bad context! No biscuit!}           }
          );
      }
  
      # and later...
  
      my $users = get_server_status->{users};
  
  
      # or, lazily...
  
      my $server = get_server_status();
  
      print "$server->{name} load = $server->{load}\n";
  
  
  =head2 Interpolative referential contexts
  
  The C<SCALARREF {...}> and C<ARRAYREF {...}> context blocks are
  especially useful when you need to interpolate a subroutine into
  strings. For example, if you have a subroutine like:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and later...
  
      print "There are ", scalar(get_todo_tasks()), " tasks:\n",
              get_todo_tasks();
  
  then you could make it much easier to interpolate calls to that
  subroutine by adding:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              SCALARREF { \scalar @todo_list }  # Ref to how many
              ARRAYREF  { \@todo_list        }  # Ref to them
          );
      }
  
      # and then...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  In fact, this behaviour is so useful that it's the default. If you
  don't provide an explicit C<SCALARREF {...}> block,
  Contextual::Return automatically provides an implicit one that simply
  returns a reference to whatever would have been returned in scalar context.
  Likewise, if no C<ARRAYREF {...}> block is specified, the module supplies one
  that returns the list-context return value wrapped up in an array reference.
  
  So you could just write:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and still do this...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  
  =head2 Fallback contexts
  
  As the previous sections imply, the C<BOOL {...}>, C<NUM {...}>, C<STR
  {...}>, and various C<*REF {...}> blocks, are special cases of the
  general C<SCALAR {...}> context block. If a subroutine is called in one
  of these specialized contexts but does not use the corresponding context
  block, then the more general C<SCALAR {...}> block is used instead (if
  it has been specified).
  
  So, for example:
  
      sub read_value_from {
          my ($fh) = @_;
  
          my $value = <$fh>;
          chomp $value;
  
          return (
              BOOL   { defined $value }
              SCALAR { $value         }
          );
      }
  
  ensures that the C<read_value_from()> subroutine returns true in boolean
  contexts if the read was successful. But, because no specific C<NUM {...}>
  or C<STR {...}> return behaviours were specified, the subroutine falls back on
  using its generic C<SCALAR {...}> block in all other scalar contexts.
  
  Another way to think about this behaviour is that the various kinds of
  scalar context blocks form a hierarchy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |
           `--< STR
  
  Contextual::Return uses this hierarchical relationship to choose the most
  specific context block available to handle any particular return context,
  working its way up the tree from the specific type it needs, to the more
  general type, if that's all that is available.
  
  There are two slight complications to this picture. The first is that Perl
  treats strings and numbers as interconvertable so the diagram (and the
  Contextual::Return module) also has to allow these interconversions as a
  fallback strategy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |    : ^
           |    v :
           `--< STR
  
  The dotted lines are meant to indicate that this intraconversion is secondary
  to the main hierarchical fallback. That is, in a numeric context, a C<STR
  {...}> block will only be used if there is no C<NUM {...}> block I<and> no
  C<SCALAR {...}> block. In other words, the generic context type is always
  used in preference to string<->number conversion.
  
  The second slight complication is that the above diagram only shows a
  small part of the complete hierarchy of contexts supported by
  Contextual::Return. The full fallback hierarchy (including dotted
  interconversions) is:
  
        DEFAULT
           ^
           |
           |--< VOID
           |
           `--< NONVOID
                   ^
                   |
                   |--< VALUE <...............
                   |      ^                   :
                   |      |                   :
                   |      |--< SCALAR <.......:...
                   |      |           ^           :
                   |      |           |           :
                   |      |           |--< BOOL   :
                   |      |           |     ^     :
                   |      |           |     |     :
                   |      |           |  PUREBOOL :
                   |      |           |           :
                   |      |           |--< NUM <..:.
                   |      |           |    : ^      :
                   |      |           |    v :      :
                   |      |           `--< STR <....:..
                   |      |                           :
                   |      |                          ::
                   |      `--< LIST ................: :
                   |            : ^                   :
                   |            : :                   :
                   `--- REF     : :                   :
                         ^      : :                   :
                         |      v :                   :
                         |--< ARRAYREF                :
                         |                            :
                         |--< SCALARREF .............:
                         |
                         |--< HASHREF
                         |
                         |--< CODEREF
                         |
                         |--< GLOBREF
                         |
                         `--< OBJREF <....... METHOD
                                 ^
                                 :........... BLESSED
  
  As before, each dashed arrow represents a fallback relationship. That
  is, if the required context specifier isn't available, the arrows are
  followed until a more generic one is found. The dotted arrows again
  represent the interconversion of return values, which is
  attempted only after the normal hierarchical fallback fails.
  
  For example, if a subroutine is called in a context that expects a
  scalar reference, but no C<SCALARREF {...}> block is provided, then
  Contextual::Return tries the following blocks in order:
  
          REF {...}
      NONVOID {...}
      DEFAULT {...}
          STR {...} (automatically taking a reference to the result)
          NUM {...} (automatically taking a reference to the result)
       SCALAR {...} (automatically taking a reference to the result)
        VALUE {...} (automatically taking a reference to the result)
  
  Likewise, in a list context, if there is no C<LIST {...}> context block, the
  module tries:
  
         VALUE {...}
       NONVOID {...}
       DEFAULT {...}
      ARRAYREF {...} (automatically dereferencing the result)
           STR {...} (treating it as a list of one element)
           NUM {...} (treating it as a list of one element)
        SCALAR {...} (treating it as a list of one element)
  
  The more generic context blocks are especially useful for intercepting
  unexpected and undesirable call contexts. For example, to turn I<off>
  the automatic scalar-ref and array-ref interpolative behaviour described
  in L<Interpolative referential contexts>, you could intercept I<all>
  referential contexts using a generic C<REF {...}> context block:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              REF { croak q{get_todo_task() can't be used as a reference} }
          );
      }
  
      print 'There are ', get_todo_tasks(), '...';    # Still okay
      print "There are ${get_todo_tasks()}...";       # Throws an exception
  
  
  =head2 Treating return values as objects
  
  Normally, when a return value is treated as an object (i.e. has a method
  called on it), Contextual::Return invokes any C<OBJREF> handler that was
  specified in the contextual return list, and delegates the method call to
  the object returned by that handler.
  
  However, you can also be more specific, by specifying a C<METHOD> context
  handler in the contextual return list. The block of this handler is expected
  to return one or more method-name/method-handler pairs, like so:
  
      return
          METHOD {
              get_count => sub { my $n = shift; $data[$n]{count} },
              get_items => sub { my $n = shift; $data[$n]{items} },
              clear     => sub { @data = (); },
              reset     => sub { @data = (); },
          }
  
  Then, whenever one of the specified methods is called on the return value,
  the corresponding subroutine will be called to implement it.
  
  The method handlers must always be subroutine references, but the method-name
  specifiers may be strings (as in the previous example) or they may be
  specified generically, as either regexes or array references. Generic method
  names are used to call the same handler for two or more distinct method names.
  For example, the previous example could be simplified to:
  
      return
          METHOD {
              qr/get_(\w+)/     => sub { my $n = shift; $data[$n]{$1} },
              ['clear','reset'] => sub { @data = (); },
          }
  
  A method name specified by regex will invoke the corresponding handler for any
  method call request that the regex matches. A method name specified by array
  ref will invoke the corresponding handler if the method requested matches any
  of the elements of the array (which may themselves be strings or regexes).
  
  When the method handler is invoked, the name of the method requested is
  passed to the handler in C<$_>, and the method's argument list is passed
  (as usual) via C<@_>.
  
  Note that any methods not explicitly handled by the C<METHOD> handlers
  will still be delegated to the object returned by the C<OBJREF> handler
  (if it is also specified).
  
  
  =head2 Not treating return values as objects
  
  The use of C<OBJREF> and C<METHOD> are slightly complicated by the fact
  that contextual return values are themselves objects.
  
  For example, prior to version 0.4.4 of the module, if you passed a
  contextual return value to C<Scalar::Util::blessed()>, it always
  returned a true value (namely, the string: 'Contextual::Return::Value'),
  even if the return value had not specified handlers for C<OBJREF> or
  C<METHOD>.
  
  In other words, the I<implementation> of contextual return values (as
  objects) was getting in the way of the I<use> of contextual return
  values (as non-objects).
  
  So the module now also provides a C<BLESSED> handler, which allows you
  to explicitly control how contextual return values interact with
  C<Scalar::Util::blessed()>.
  
  If C<$crv> is a contextual return value, by default
  C<Scalar::Util::blessed($crv)> will now only return true if that return
  value has a C<OBJREF>, C<LAZY>, C<REF>, C<SCALAR>, C<VALUE>, C<NONVOID>,
  or C<DEFAULT> handler that in turn returns a blessed object.
  
  However if C<$crv> also provides a C<BLESSED> handler, C<blessed()>
  will return whatever that handler returns.
  
  This means:
  
      sub simulate_non_object {
          return BOOL { 1 }
                  NUM { 42 }
      }
  
      sub simulate_real_object {
          return OBJREF { bless {}, 'My::Class' }
                   BOOL { 1 }
                    NUM { 42 }
      }
  
      sub simulate_faked_object {
          return BLESSED { 'Foo' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
      sub simulate_previous_behaviour {
          return BLESSED { 'Contextual::Return::Value' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
  
      say blessed( simulate_non_object()         );   # undef
      say blessed( simulate_real_object()        );   # My::Class
      say blessed( simulate_faked_object()       );   # Foo
      say blessed( simulate_previous_behaviour() );   # Contextual::Return::Value
  
  Typically, you either want no C<BLESSED> handler (in which case
  contextual return values pretend not to be blessed objects), or you want
  C<BLESSED { 'Contextual::Return::Value' }> for backwards compatibility
  with pre-v0.4.7 behaviour.
  
  
  =head3 Preventing fallbacks
  
  Sometimes fallbacks can be too helpful. Or sometimes you want to impose
  strict type checking on a return value.
  
  Contextual::Returns allows that via the C<STRICT> specifier. If you include
  C<STRICT> anywhere in your return statement, the module disables all
  fallbacks and will therefore through an exception if the return value is
  used in any way not explicitly specified in the contextual return sequence.
  
  For example, to create a subroutine that returns only a string:
  
      sub get_name {
          return STRICT STR { 'Bruce' }
      }
  
  If the return value of the subroutine is used in any other way than as
  a string, an exception will be thrown.
  
  You can still specify handlers for more than a single kind of context
  when using C<STRICT>:
  
      sub get_name {
          return STRICT
              STR  { 'Bruce' }
              BOOL { 0 }
      }
  
  ...but these will still be the only contexts in which the return value
  can be used:
  
      my $n = get_name() ? 1 : 2;  # Okay because BOOL handler specified
  
      my $n = 'Dr' . get_name();   # Okay because STR handler specified
  
      my $n = 1 + get_name();      # Exception thrown because no NUM handler
  
  In other words, C<STRICT> allows you to impose strict type checking on
  your contextual return value.
  
  
  =head2 Deferring handlers
  
  Because the various handlers form a hierarchy, it's possible to
  implement more specific handlers by falling back on ("deferring to")
  more general ones. For example, L<a C<PUREBOOL> handler|"Boolean vs Pure
  Boolean contexts"> is almost always identical in its basic behaviour to
  the corresponding C<BOOL> handler, except that it adds some side-effect.
  For example:
  
      return
          PUREBOOL { $_ = $return_val; defined $return_val && $return_val > 0 }
              BOOL {                   defined $return_val && $return_val > 0 }
            SCALAR {                   $return_val;                           }
  
  So Contextual::Return allows you to have a handler perform some action
  and then defer to a more general handler to supply the actual return
  value. To fall back to a more general case in this way, you simply write:
  
      next handler;
  
  at the end of the handler in question, after which Contextual::Return
  will find the next-most-specific handler and execute it as well. So the
  previous example, could be re-written:
  
      return
          PUREBOOL { $_ = $return_val; next handler;        }
              BOOL { defined $return_val && $return_val > 0 }
            SCALAR { $return_val;                           }
  
  Note that I<any> specific handler can defer to a more general one in
  this same way. For example, you could provide consistent and
  maintainable type-checking for a subroutine that returns references by
  providing C<ARRAYREF>, C<HASHREF>, and C<SCALARREF> handlers that all
  defer to a generic C<REF> handler, like so:
  
      my $retval = _get_ref();
  
      return
         SCALARREF { croak 'Type mismatch' if ref($retval) ne 'SCALAR';
                     next handler;
                   }
          ARRAYREF { croak 'Type mismatch' if ref($retval) ne 'ARRAY';
                     next handler;
                   }
           HASHREF { croak 'Type mismatch' if ref($retval) ne 'HASH';
                     next handler;
                   }
               REF { $retval }
  
  If, at a later time, the process of returning a reference became more complex,
  only the C<REF> handler would have to be updated.
  
  
  =head2 Nested handlers
  
  Another way of factoring out return behaviour is to nest more specific
  handlers inside more general ones. For instance, in the final example given in
  L<"Boolean vs Pure Boolean contexts">:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  you could factor out the repeated calls to C<_go_and_get_data()> like so:
  
      sub get_data {
          return
              PUREBOOL { _check_for_but_dont_get_data(); }
               DEFAULT {
                  my $data = _go_and_get_data();
  
                  BOOL { defined $data; }
                   REF {         $data; }
               }
      }
  
  Here, the C<DEFAULT> handler deals with every return context except pure
  boolean. Within that C<DEFAULT> handler, the data is first retrieved,
  and then two "sub-handlers" deal with the ordinary boolean and
  referential contexts.
  
  Typically nested handlers are used in precisely this way: to optimize
  for inexpensive special cases (such as pure boolean or integer or void
  return contexts) and only do extra work for those other cases that
  require it.
  
  
  =head2 Failure contexts
  
  Two of the most common ways to specify that a subroutine has failed
  are to return a false value, or to throw an exception. The
  Contextual::Return module provides a mechanism that allows the
  subroutine writer to support I<both> of these mechanisms at the
  same time, by using the C<FAIL> specifier.
  
  A return statement of the form:
  
      return FAIL;
  
  causes the surrounding subroutine to return C<undef> (i.e. false) in
  boolean contexts, and to throw an exception in any other context. For example:
  
      use Contextual::Return;
  
      sub get_next_val {
          my $next_val = <>;
          return FAIL if !defined $next_val;
          chomp $next_val;
          return $next_val;
      }
  
  If the C<return FAIL> statement is executed, it will either return false in a
  boolean context:
  
      if (my $val = get_next_val()) {      # returns undef if no next val
          print "[$val]\n";
      }
  
  or else throw an exception if the return value is used in any
  other context:
  
      print get_next_val();       # throws exception if no next val
  
      my $next_val = get_next_val();
      print "[$next_val]\n";      # throws exception if no next val
  
  
  The exception that is thrown is of the form:
  
      Call to main::get_next_val() failed at demo.pl line 42
  
  but you can change that message by providing a block to the C<FAIL>, like so:
  
      return FAIL { "No more data" } if !defined $next_val;
  
  in which case, the final value of the block becomes the exception message:
  
      No more data at demo.pl line 42
  
  A failure value can be interrogated for its error message, by calling its
  C<error()> method, like so:
  
      my $val = get_next_val();
      if ($val) {
          print "[$val]\n";
      }
      else {
          print $val->error, "\n";
      }
  
  
  =head2 Configurable failure contexts
  
  The default C<FAIL> behaviour--false in boolean context, fatal in all
  others--works well in most situations, but violates the Platinum Rule ("Do
  unto others as I<they> would have done unto them").
  
  So it may be user-friendlier if the user of a module is allowed decide how
  the module's subroutines should behave on failure. For example, one user
  might prefer that failing subs always return undef; another might prefer
  that they always throw an exception; a third might prefer that they
  always log the problem and return a special Failure object; whilst a
  fourth user might want to get back C<0> in scalar contexts, an empty list
  in list contexts, and an exception everywhere else.
  
  You could create a module that allows the user to specify all these
  alternatives, like so:
  
      package MyModule;
      use Contextual::Return;
      use Log::StdLog;
  
      sub import {
          my ($package, @args) = @_;
  
          Contextual::Return::FAIL_WITH {
              ':false' => sub { return undef },
              ':fatal' => sub { croak @_       },
              ':filed' => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              ':fussy' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @args;
      }
  
  This configures Contextual::Return so that, instead of the usual
  false-or-fatal semantics, every C<return FAIL> within MyModule's namespace is
  implemented by one of the four subroutines specified in the hash that was
  passed to C<FAIL_WITH>.
  
  Which of those four subs implements the C<FAIL> is determined by the
  arguments passed after the hash (i.e. by the contents of C<@args>).
  C<FAIL_WITH> walks through that list of arguments and compares
  them against the keys of the hash. If a key matches an argument, the
  corresponding value is used as the implementation of C<FAIL>. Note that,
  if subsequent arguments also match a key, their subroutine overrides the
  previously installed implementation, so only the final override has any
  effect. Contextual::Return generates warnings when multiple overrides are
  specified.
  
  All of which mean that, if a user loaded the MyModule module like this:
  
      use MyModule qw( :fatal other args here );
  
  then every C<FAIL> within MyModule would be reconfigured to throw an exception
  in all circumstances, since the presence of the C<':fatal'> in the argument
  list will cause C<FAIL_WITH> to select the hash entry whose key is C<':fatal'>.
  
  On the other hand, if they loaded the module:
  
      use MyModule qw( :fussy other args here );
  
  then each C<FAIL> within MyModule would return undef or empty list or throw an
  exception, depending on context, since that's what the subroutine whose key is
  C<':fussy'> does.
  
  Many people prefer module interfaces with a C<< I<flag> => I<value> >>
  format, and C<FAIL_WITH> supports this too. For example, if you
  wanted your module to take a C<-fail> flag, whose associated value could
  be any of C<"undefined">, C<"exception">, C<"logged">, or C<"context">,
  then you could implement that simply by specifying the flag as the first
  argument (i.e. I<before> the hash) like so:
  
      sub import {
          my $package = shift;
  
          Contextual::Return::FAIL_WITH -fail => {
              'undefined' => sub { return undef },
              'exception' => sub { croak @_ },
              'logged'    => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              'context' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @_;
  
  and then load the module:
  
      use MyModule qw( other args here ), -fail=>'undefined';
  
  or:
  
      use MyModule qw( other args here ), -fail=>'exception';
  
  In this case, C<FAIL_WITH> scans the argument list for a pair of values: its
  flag string, followed by some other selector value. Then it looks up the
  selector value in the hash, and installs the corresponding subroutine as its
  local C<FAIL> handler.
  
  If this "flagged" interface is used, the user of the module can also
  specify their own handler directly, by passing a subroutine reference as
  the selector value instead of a string:
  
      use MyModule qw( other args here ), -fail=>sub{ die 'horribly'};
  
  If this last example were used, any call to C<FAIL> within MyModule
  would invoke the specified anonymous subroutine (and hence throw a
  'horribly' exception).
  
  Note that, any overriding of a C<FAIL> handler is specific to the
  namespace and file from which the subroutine that calls C<FAIL_WITH> is
  itself called. Since C<FAIL_WITH> is designed to be called from within a
  module's C<import()> subroutine, that generally means that the C<FAIL>s
  within a given module X are only overridden for the current namespace
  within the particular file from module X is loaded. This means that two
  separate pieces of code (in separate files or separate namespaces) can
  each independently override a module's C<FAIL> behaviour, without
  interfering with each other.
  
  =head2 Lvalue contexts
  
  Recent versions of Perl offer (limited) support for lvalue subroutines:
  subroutines that return a modifiable variable, rather than a simple constant
  value.
  
  Contextual::Return can make it easier to create such subroutines, within the
  limitations imposed by Perl itself. The limitations that Perl places on lvalue
  subs are:
  
  =over
  
  =item 1.
  
  The subroutine must be declared with an C<:lvalue> attribute:
  
      sub foo :lvalue {...}
  
  =item 2.
  
  The subroutine must not return via an explicit C<return>. Instead, the
  last statement must evaluate to a variable, or must be a call to another
  lvalue subroutine call.
  
      my ($foo, $baz);
  
      sub foo :lvalue {
          $foo;               # last statement evals to a var
      }
  
      sub bar :lvalue {
          foo();              # last statement is lvalue sub call
      }
  
      sub baz :lvalue {
          my ($arg) = @_;
  
          $arg > 0            # last statement evals...
              ? $baz          # ...to a var
              : bar();        # ...or to an lvalue sub call
      }
  
  =back
  
  Thereafter, any call to the lvalue subroutine produces a result that can be
  assigned to:
  
      baz(0) = 42;            # same as: $baz = 42
  
      baz(1) = 84;            # same as:                  bar() = 84
                              #  which is the same as:    foo() = 84
                              #   which is the same as:   $foo  = 84
  
  Ultimately, every lvalue subroutine must return a scalar variable, which
  is then used as the lvalue of the assignment (or whatever other lvalue
  operation is applied to the subroutine call). Unfortunately, because the
  subroutine has to return this variable I<before> the assignment
  can take place, there is no way that a normal lvalue subroutine can
  get access to the value that will eventually be assigned to its
  return value.
  
  This is occasionally annoying, so the Contextual::Return module offers
  a solution: in addition to all the context blocks described above, it
  provides three special contextual return blocks specifically for use in
  lvalue subroutines: C<LVALUE>, C<RVALUE>, and C<NVALUE>.
  
  Using these blocks you can specify what happens when an lvalue
  subroutine is used in lvalue and non-lvalue (rvalue) context. For
  example:
  
      my $verbosity_level = 1;
  
      # Verbosity values must be between 0 and 5...
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = max(0, min($_, 5)) }
          RVALUE { $verbosity_level                      }
      }
  
  The C<LVALUE> block is executed whenever C<verbosity> is called as an lvalue:
  
      verbosity() = 7;
  
  The block has access to the value being assigned, which is passed to it
  as C<$_>. So, in the above example, the assigned value of 7 would be
  aliased to C<$_> within the C<LVALUE> block, would be reduced to 5 by the
  "min-of-max" expression, and then assigned to C<$verbosity_level>.
  
  (If you need to access the caller's C<$_>, it's also still available:
  as C<$CALLER::_>.)
  
  When the subroutine isn't used as an lvalue:
  
      print verbosity();
  
  the C<RVALUE> block is executed instead and its final value returned.
  Within an C<RVALUE> block you can use any of the other features of
  Contextual::Return. For example:
  
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  but the context sequence must be nested inside an C<RVALUE> block.
  
  You can also specify what an lvalue subroutine should do when it is used
  neither as an lvalue nor as an rvalue (i.e. in void context), by using an
  C<NVALUE> block:
  
      sub verbosity :lvalue {
          my ($level) = @_;
  
          NVALUE { $verbosity_level = int max(0, min($level, 5)) }
          LVALUE { $verbosity_level = int max(0, min($_,     5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  In this example, a call to C<verbosity()> in void context sets the verbosity
  level to whatever argument is passed to the subroutine:
  
      verbosity(1);
  
  Note that you I<cannot> get the same effect by nesting a C<VOID> block
  within an C<RVALUE> block:
  
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
              VOID { $verbosity_level = $level      }  # Wrong!
          }
  
  That's because, in a void context the return value is never evaluated,
  so it is never treated as an rvalue, which means the C<RVALUE> block
  never executes.
  
  
  =head2 Result blocks
  
  Occasionally, it's convenient to calculate a return value I<before> the
  end of a contextual return block. For example, you may need to clean up
  external resources involved in the calculation after it's complete.
  Typically, this requirement produces a slightly awkward code sequence
  like this:
  
      return
          VALUE {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  Such code sequences become considerably more awkward when you want
  the return value to be context sensitive, in which case you have to
  write either:
  
      return
          LIST {
              $db->start_work();
              my @result = $db->retrieve_query($query);
              $db->commit();
              @result;
          }
          SCALAR {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  or, worse:
  
      return
          VALUE {
              $db->start_work();
              my $result = LIST ? [$db->retrieve_query($query)]
                                :  $db->retrieve_query($query);
              $db->commit();
              LIST ? @{$result} : $result;
          }
  
  To avoid these infelicities, Contextual::Return provides a second way of
  setting the result of a context block; a way that doesn't require that the
  result be the last statement in the block:
  
      return
          LIST {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
          SCALAR {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  The presence of a C<RESULT> block inside a contextual return block causes
  that block to return the value of the final statement of the C<RESULT>
  block as the handler's return value, rather than returning the value of
  the handler's own final statement. In other words, the presence of a C<RESULT>
  block overrides the normal return value of a context handler.
  
  Better still, the C<RESULT> block always evaluates its final statement
  in the same context as the surrounding C<return>, so you can just write:
  
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  and the C<retrieve_query()> method will be called in the appropriate context
  in all cases.
  
  A C<RESULT> block can appear anywhere inside any contextual return
  block, but may not be used outside a context block. That is, this
  is an error:
  
      if ($db->closed) {
          RESULT { undef }; # Error: not in a context block
      }
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  
  =head2 Post-handler clean-up
  
  If a subroutine uses an external resource, it's often necessary to close
  or clean-up that resource after the subroutine ends...regardless of
  whether the subroutine exits normally or via an exception.
  
  Typically, this is done by encapsulating the resource in a lexically
  scoped object whose destructor does the clean-up. However, if the clean-up
  doesn't involve deallocation of an object (as in the C<< $db->commit() >>
  example in the previous section), it can be annoying to have to create a
  class and allocate a container object, merely to mediate the clean-up.
  
  To make it easier to manage such resources, Contextual::Return supplies
  a special labelled block: the C<RECOVER> block. If a C<RECOVER> block is
  specified as part of a contextual return sequence, that block is
  executed after any context handler, even if the context handler exits
  via an exception.
  
  So, for example, you could implement a simple commit-or-revert
  policy like so:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          RECOVER {
              if ($@) {
                  $db->revert();
              }
              else {
                  $db->commit();
              }
          }
  
  The presence of a C<RECOVER> block also intercepts all exceptions thrown
  in any other context block in the same contextual return sequence. Any
  such exception is passed into the C<RECOVER> block in the usual manner:
  via the C<$@> variable. The exception may be rethrown out of the
  C<RECOVER> block by calling C<die>:
  
      return
          LIST    { $db->retrieve_all($query) }
          DEFAULT { croak "Invalid call (not in list context)" }
          RECOVER {
              die $@ if $@;    # Propagate any exception
              $db->commit();   # Otherwise commit the changes
          }
  
  A C<RECOVER> block can also access or replace the returned value, by
  invoking a C<RESULT> block. For example:
  
      return
          LIST    { attempt_to_generate_list_for(@_)  }
          SCALAR  { attempt_to_generate_count_for(@_) }
          RECOVER {
              if ($@) {                # On any exception...
                  warn "Replacing return value. Previously: ", RESULT;
                  RESULT { undef }     # ...return undef
              }
          }
  
  
  =head2 Post-return clean-up
  
  Occasionally it's necessary to defer the clean-up of resources until
  after the return value has been used. Once again, this is usually
  done by returning an object with a suitable destructor.
  
  Using Contextual::Return you can get the same effect, by providing a
  C<CLEANUP> block in the contextual return sequence:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          CLEANUP { $db->commit()              }
  
  In this example, the C<commit> method call is only performed after the
  return value has been used by the caller. Note that this is quite
  different from using a C<RECOVER> block, which is called as the
  subroutine returns its value; a C<CLEANUP> is called when the returned
  value is garbage collected.
  
  A C<CLEANUP> block is useful for controlling resources allocated to support an
  C<ACTIVE> return value. For example:
  
      my %file;
  
      # Return an active value that is always the next line from a file...
      sub readline_from {
          my ($file_name) = @_;
  
          # Open the file, if not already open...
          if (!$file{$file_name}) {
              open $file{$file_name}{handle}, '<', $file_name;
          }
  
          # Track how many active return values are using this file...
          $file{$file_name}{count}++;
  
          return ACTIVE
              # Evaluating the return value returns the next line...
              VALUE   { readline $file{$file_name}{handle} }
  
              # Once the active value is finished with, clean up the filehandle...
              CLEANUP {
                  delete $file{$file_name}
                      if --$file{$file_name}{count} == 0;
              }
      }
  
  
  =head2 Debugging contextual return values
  
  Contextual return values are implemented as opaque objects (using the
  "inside-out" technique). This means that passing such values to
  Data::Dumper produces an uninformative output like:
  
      $VAR1 = bless( do{\(my $o = undef)}, 'Contextual::Return::Value' );
  
  So the module provides two methods that allow contextual return values
  to be correctly reported: either directly, or when dumped by
  Data::Dumper.
  
  To dump a contextual return value directly, call the module's C<DUMP()>
  method explicitly and print the result:
  
      print $crv->Contextual::Return::DUMP();
  
  This produces an output something like:
  
      [
       { FROM       => 'main::foo'                                       },
       { NO_HANDLER => [ 'VOID', 'CODEREF', 'HASHREF', 'GLOBREF' ]       },
       { FALLBACKS  => [ 'VALUE' ]                                       },
       { LIST       => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
       { STR        => '<<<Throws exception: Died at demo.pl line 7.>>>' },
       { NUM        => 42                                                },
       { BOOL       => -1                                                },
       { SCALARREF  => '<<<self-reference>>>'                            },
       { ARRAYREF   => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
      ];
  
  The C<FROM> hash entry names the subroutine that produced the return
  value. The C<NO_HANDLER> hash entry lists those contexts for which no
  handler was defined (and which would therefore normally produce "can't
  call" exceptions such as: C<"Can't call main::foo in VOID context">).
  The C<FALLBACKS> hash entry lists any "generic" contexts such as
  C<VALUE>, C<NONVOID>, C<REF>, C<DEFAULT>, etc. that the contextual
  return value can also handle. After these, all the remaining hash
  entries are actual contexts in which the return value could successfully
  be evaluated, and the value it would produce in each of those contexts.
  
  The Data::Dumper module also has a mechanism by which you can tell it
  how to produce a similar listing automatically whenever a contextual
  return value is passed to its C<Dumper> method. Data::Dumper allows you
  to register a "freezer" method, that is called prior to dumping, and
  which can be used to adapt an opaque object to make it dumpable.
  Contextual::Return provides just such a method
  (C<Contextual::Return::FREEZE()>) for you to register, like so:
  
      use Data::Dumper 'Dumper';
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
      print Dumper $foo;
  
  The output is then precisely the same as C<Contextual::Return::DUMP()>
  would produce.
  
  Note that, with both of the above dumping mechanisms, it is essential to use
  the full name of the method. That is:
  
      print $crv->Contextual::Return::DUMP();
  
  rather than:
  
      print $crv->DUMP();
  
  This is because the shorter version is interpreted as calling the
  C<DUMP()> method on the object returned by the return value's C<OBJREF>
  context block (see L<"Scalar reference contexts">)
  
  For the same reason, you must write:
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
  not:
  
      local $Data::Dumper::Freezer = 'FREEZE';
  
  
  =head2 Namespace controls
  
  By default the module exports a large number of return context markers:
  
      DEFAULT    REF          LAZY
      VOID       SCALARREF    FIXED
      NONVOID    ARRAYREF     ACTIVE
      LIST       CODEREF      RESULT
      SCALAR     HASHREF      RECOVER
      VALUE      GLOBREF      CLEANUP
      STR        OBJREF       RVALUE
      NUM        METHOD       LVALUE
      BOOL                    NVALUE
      PUREBOOL
  
  These are exported as subroutines, and so can conflict with existing
  subroutines in your namespace, or with subroutines imported from other
  modules.
  
  Contextual::Return allows you to control which contextual return blocks are
  exported into any namespace that uses the module. It also allows you to rename
  blocks to avoid namespace conflicts with existing subroutines.
  
  Both these features are controlled by passing arguments to the C<use>
  statement that loads the module as follows:
  
  =over
  
  =item *
  
  Any string passed as an argument to C<use Contextual::Return>,
  exports only the block name it specifies;
  
  =item *
  
  Any regex passed as an argument to C<use Contextual::Return>
  exports every block name it matches;
  
  =item *
  
  Any array ref (recursively) exports each of its elements
  
  =item *
  
  Any string that appears immediately after one of the above three specifiers,
  and which is not itself a block name, renames the handlers exported by that
  preceding specifier by filtering each handler name through C<sprintf()>
  
  =back
  
  That is, you can specify handlers to be exported by exact name (as a string),
  by general pattern (as a regex), or collectively (in an array). And after any
  of these export specifications, you can append a template in which any C<'%s'>
  will be replaced by the original name of the handler. For example:
  
      # Selectively export specific sets of handlers...
      use Contextual::Return  qr/[NLR]VALUE/;
      use Contextual::Return  qr/.*REF/;
  
      # Selective export specific sets and add a suffix to each...
      use Contextual::Return  qr/[NLR]VALUE/ => '%s_CONTEXT';
  
      # Selective export specific sets and add a prefix to each...
      use Contextual::Return  qr/.*REF/ => 'CR_%s';
  
      # Export a list of handlers...
      use Contextual::Return    'NUM', 'STR', 'BOOL' ;
      use Contextual::Return qw< NUM    STR    BOOL >;
      use Contextual::Return   ['NUM', 'STR', 'BOOL'];
  
      # Export a list of handlers, renaming them individually...
      use Contextual::Return  NUM => 'NUMERIC', STR => 'TEXT', BOOL => 'CR_%s';
  
      # Export a list of handlers, renaming them collectively...
      use Contextual::Return  ['NUM', 'STR', 'BOOL'] => '%s_CONTEXT';
  
      # Mixed exports and renames...
      use Contextual::Return (
          STR => 'TEXT',
          ['NUM', 'BOOL'] => 'CR_%s',
          ['LIST', 'SCALAR', 'VOID', qr/^[NLR]VALUE/] => '%s_CONTEXT',
      );
  
  
  
  =head1 INTERFACE
  
  =head2 Context tests
  
  =over
  
  =item C<< LIST() >>
  
  Returns true if the current subroutine was called in list context.
  A cleaner way of writing: C<< wantarray() >>
  
  =item C<< SCALAR() >>
  
  Returns true if the current subroutine was called in scalar context.
  A cleaner way of writing: C<< defined wantarray() && ! wantarray() >>
  
  
  =item C<< VOID() >>
  
  Returns true if the current subroutine was called in void context.
  A cleaner way of writing: C<< !defined wantarray() >>
  
  =item C<< NONVOID() >>
  
  Returns true if the current subroutine was called in list or scalar context.
  A cleaner way of writing: C<< defined wantarray() >>
  
  =back
  
  =head2 Standard contexts
  
  =over
  
  =item C<< LIST {...} >>
  
  The block specifies what the context sequence should evaluate to when
  called in list context.
  
  =item C<< SCALAR {...} >>
  
  The block specifies what the context sequence should evaluate to in
  scalar contexts, unless some more-specific specifier scalar context specifier
  (see below) also occurs in the same context sequence.
  
  =item C<< VOID {...} >>
  
  The block specifies what the context sequence should do when
  called in void context.
  
  =back
  
  =head2 Scalar value contexts
  
  =over
  
  =item C<< BOOL {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a boolean value.
  
  =item C<< NUM {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a numeric value.
  
  =item C<< STR {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a string value.
  
  =item C<< LAZY {...} >>
  
  Another name for C<SCALAR {...}>. Usefully self-documenting when the primary
  purpose of the contextual return is to defer evaluation of the return value
  until it's actually required.
  
  =back
  
  =head2 Scalar reference contexts
  
  =over
  
  =item C<< SCALARREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a scalar.
  
  =item C<< ARRAYREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an array.
  
  =item C<< HASHREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a hash.
  
  Note that a common error here is to write:
  
  HASHREF { a=>1, b=>2, c=>3 }
  
  The curly braces there are a block, not a hash constructor, so the block
  doesn't return a hash reference and the interpreter throws an exception.
  What's needed is:
  
  HASHREF { {a=>1, b=>2, c=>3} }
  
  in which the inner braces I<are> a hash constructor.
  
  =item C<< CODEREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a subroutine.
  
  =item C<< GLOBREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a typeglob.
  
  =item C<< OBJREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an object.
  
  =item C<< METHOD {...} >>
  
  The block can be used to specify particular handlers for specific method calls
  when the return value is treated as an object reference.
  It should return a list of methodname/methodbody pairs. Each method name can
  be specified as a string, a regex, or an array of strings or regexes. The
  method bodies must be specified as subroutine references (usually anonymous
  subs). The first method name that matches the actual method call selects the
  corresponding handler, which is then called.
  
  =back
  
  =head2 Generic contexts
  
  =over
  
  =item C<< VALUE {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a non-referential value (as a boolean, numeric, string,
  scalar, or list). Only used if there is no more-specific value context
  specifier in the context sequence.
  
  =item C<< REF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference of any kind. Only used if there is no
  more-specific referential context specifier in the context sequence.
  
  =item C<< NONVOID {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =item C<< DEFAULT {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a void or non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =back
  
  =head2 Failure context
  
  =over
  
  =item C<< FAIL >>
  
  This block is executed unconditionally and is used to indicate failure. In a
  Boolean context it return false. In all other contexts it throws an exception
  consisting of the final evaluated value of the block.
  
  That is, using C<FAIL>:
  
  return
  FAIL { "Could not defenestrate the widget" }
  
  is exactly equivalent to writing:
  
  return
  BOOL { 0 }
  DEFAULT { croak "Could not defenestrate the widget" }
  
  except that the reporting of errors is a little smarter under C<FAIL>.
  
  If C<FAIL> is called without specifying a block:
  
  return FAIL;
  
  it is equivalent to:
  
  return FAIL { croak "Call to <subname> failed" }
  
  (where C<< <subname> >> is replaced with the name of the surrounding
  subroutine).
  
  Note that, because C<FAIL> implicitly covers every possible return
  context, it cannot be chained with other context specifiers.
  
  =item C<< Contextual::Return::FAIL_WITH >>
  
  This subroutine is not exported, but may be called directly to reconfigure
  C<FAIL> behaviour in the caller's namespace.
  
  The subroutine is called with an optional string (the I<flag>), followed
  by a mandatory hash reference (the I<configurations hash>), followed by a
  list of zero-or-more strings (the I<selector list>). The values of the
  configurations hash must all be subroutine references.
  
  If the optional flag is specified, C<FAIL_WITH> searches the selector
  list looking for that string, then uses the I<following> item in the
  selector list as its I<selector value>. If that selector value is a
  string, C<FAIL_WITH> looks up that key in the hash, and installs the
  corresponding subroutine as the namespace's C<FAIL> handler (an
  exception is thrown if the selector string is not a valid key of the
  configurations hash). If the selector value is a subroutine reference,
  C<FAIL_WITH> installs that subroutine as the C<FAIL> handler.
  
  If the optional flag is I<not> specified, C<FAIL_WITH> searches the
  entire selector list looking for the last element that matches any
  key in the configurations hash. It then looks up that key in the
  hash, and installs the corresponding subroutine as the namespace's
  C<FAIL> handler.
  
  See L<Configurable failure contexts> for examples of using this feature.
  
  =back
  
  =head2 Lvalue contexts
  
  =over
  
  =item C<< LVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is assigned
  to. The assigned value is passed to the block as C<$_>. To access the caller's
  C<$_> value, use C<$CALLER::_>.
  
  =item C<< RVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is used
  as an rvalue. The final value that is evaluated in the block becomes the
  rvalue.
  
  =item C<< NVALUE >>
  
  This block is executed when an C<:lvalue> subroutine is evaluated in void
  context.
  
  =back
  
  =head2 Explicit result blocks
  
  =over
  
  =item C<< RESULT >>
  
  This block may only appear inside a context handler block. It causes the
  surrounding handler to return the final value of the C<RESULT>'s block,
  rather than the final value of the handler's own block. This override occurs
  regardless of the location to the C<RESULT> block within the handler.
  
  If called without a trailing C<{...}>, it simply returns the current result
  value in scalar contexts, or the list of result values in list context.
  
  =back
  
  =head2 Recovery blocks
  
  =over
  
  =item C<< RECOVER >>
  
  If present in a context return sequence, this block grabs control after
  any context handler returns or exits via an exception. If an exception
  was thrown it is passed to the C<RECOVER> block via the C<$@> variable.
  
  =back
  
  =head2 Clean-up blocks
  
  =over
  
  =item C<< CLEANUP >>
  
  If present in a context return sequence, this block grabs control when
  a return value is garbage collected.
  
  =back
  
  
  =head2 Modifiers
  
  =over
  
  =item C<< FIXED >>
  
  This specifies that the scalar value will only be evaluated once, the
  first time it is used, and that the value will then morph into that
  evaluated value.
  
  =item C<< ACTIVE >>
  
  This specifies that the scalar value's originating block will be re-
  evaluated every time the return value is used.
  
  =back
  
  =head2 Debugging support
  
  =over
  
  =item C<< $crv->Contextual::Return::DUMP() >>
  
  Return a dumpable representation of the return value in all viable contexts.
  
  =item C<< local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE'; >>
  
  =item C<< local $Data::Dumper::Freezer = \&Contextual::Return::FREEZE; >>
  
  Configure Data::Dumper to correctly dump a representation of the
  contextual return value.
  
  =back
  
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item C<Can't use %s as export specifier>
  
  In your C<use Contextual::Return> statement you specified something (such as a
  hash or coderef) that can't be used to select what the module exports. Make
  sure the list of selectors includes only strings, regexes, or references to
  arrays of strings or regexes.
  
  
  =item C<use Contextual::Return qr{%s} didn't export anything>
  
  In your C<use Contextual::Return> statement you specified a regex to select
  which handlers to support, but the regex didn't select any handlers. Check
  that the regex you're using actually does match at least one of the names of
  the modules many handlers.
  
  
  =item C<Can't export %s: no such handler>
  
  In your C<use Contextual::Return> statement you specified a string as the
  name of a context handler to be exported, but the module doesn't export a
  handler of that name. Check the spelling for the requested export.
  
  
  =item C<Can't call %s in a %s context>
  
  =item C<Can't use return value of %s in a %s context>
  
  The subroutine you called uses a contextual return, but doesn't specify what
  to return in the particular context in which you called it. You either need to
  change the context in which you're calling the subroutine, or else add a
  context block corresponding to the offending context (or perhaps a
  C<DEFAULT {...}> block).
  
  
  =item C<Can't call bare %s {...} in %s context>
  
  You specified a handler (such as C<VOID {...}> or C<LIST {...}>)
  outside any subroutine, and in a context that it
  can't handle. Did you mean to place the handler outside of a subroutine?
  If so, then you need to put it in a context it can actually handle.
  Otherwise, perhaps you need to replace the trailing block with parens
  (that is: C<VOID()> or C<LIST()>).
  
  
  =item C<Call to %s at %s didn't return a %s reference">
  
  You called the subroutine in a context that expected to get back a
  reference of some kind but the subroutine didn't specify the
  corresponding C<SCALARREF>, C<ARRAYREF>, C<HASHREF>, C<CODEREF>,
  C<GLOBREF>, or generic C<REF>, C<NONVOID>, or C<DEFAULT> handlers.
  You need to specify the appropriate one of these handlers in the subroutine.
  
  
  =item C<Can't call method '%s' on %s value returned by %s">
  
  You called the subroutine and then tried to call a method on the return
  value, but the subroutine returned a classname or object that doesn't
  have that method. This probably means that the subroutine didn't return
  the classname or object you expected. Or perhaps you need to specify
  an C<OBJREF {...}> context block.
  
  
  =item C<Can't install two %s handlers>
  
  You attempted to specify two context blocks of the same name in the same
  return context, which is ambiguous. For example:
  
      sub foo: lvalue {
          LVALUE { $foo = $_ }
          RVALUE { $foo }
          LVALUE { $foo = substr($_,1,10) }
      }
  
  or:
  
      sub bar {
          return
              BOOL { 0 }
              NUM  { 1 }
              STR  { "two" }
              BOOL { 1 };
      }
  
  Did you cut-and-paste wrongly, or mislabel one of the blocks?
  
  
  =item C<Expected a %s block after the %s block but found instead: %s>
  
  If you specify any of C<LVALUE>, C<RVALUE>, or C<NVALUE>, then you can only
  specify C<LVALUE>, C<RVALUE>, or C<NVALUE> blocks in the same return context.
  If you need to specify other contexts (like C<BOOL>, or C<STR>, or C<REF>,
  etc.), put them inside an C<RVALUE> block. See L<Lvalue contexts> for an
  example.
  
  
  =item C<Call to %s failed at %s>
  
  This is the default exception that a C<FAIL> throws in a non-scalar
  context. Which means that the subroutine you called has signalled
  failure by throwing an exception, and you didn't catch that exception.
  You should either put the call in an C<eval {...}> block or else call the
  subroutine in boolean context instead.
  
  
  =item C<Call to %s failed at %s. Attempted to use failure value at %s>
  
  This is the default exception that a C<FAIL> throws when a failure value
  is captured in a scalar variable and later used in a non-boolean
  context. That means that the subroutine you called must have failed, and
  you didn't check the return value for that failure, so when you tried to
  use that invalid value it killed your program. You should either put the
  original call in an C<eval {...}> or else test the return value in a
  boolean context and avoid using it if it's false.
  
  
  =item C<Usage: FAIL_WITH $flag_opt, \%selector, @args>
  
  The C<FAIL_WITH> subroutine expects an optional flag, followed by a reference
  to a configuration hash, followed by a list or selector arguments. You gave it
  something else. See L<Configurable Failure Contexts>.
  
  
  =item C<Selector values must be sub refs>
  
  You passed a configuration hash to C<FAIL_WITH> that specified non-
  subroutines as possible C<FAIL> handlers. Since non-subroutines can't
  possibly be handlers, maybe you forgot the C<sub> keyword somewhere?
  
  
  =item C<Invalid option: %s => %s>
  
  The C<FAIL_WITH> subroutine was passed a flag/selector pair, but the selector
  was not one of those allowed by the configuration hash.
  
  
  =item C<FAIL handler for package %s redefined>
  
  A warning that the C<FAIL> handler for a particular package was
  reconfigured more than once. Typically that's because the module was
  loaded in two places with difference configurations specified. You can't
  reasonably expect two different sets of behaviours from the one module within
  the one namespace.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Contextual::Return requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  Requires version.pm and Want.pm.
  
  
  =head1 INCOMPATIBILITIES
  
  C<LVALUE>, C<RVALUE>, and C<NVALUE> do not work correctly under the Perl
  debugger. This seems to be because the debugger injects code to capture
  the return values from subroutines, which interferes destructively with
  the optional final arguments that allow C<LVALUE>, C<RVALUE>, and C<NVALUE>
  to cascade within a single return.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005-2011, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
CONTEXTUAL_RETURN

$fatpacked{"Contextual/Return/Failure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN_FAILURE';
  package Contextual::Return::Failure;
  our $VERSION = 0.000_003;
  
  use Contextual::Return;
  BEGIN { *_in_context = *Contextual::Return::_in_context }
  
  use warnings;
  use strict;
  
  my %handler_for;
  
  sub _FAIL_WITH {
      # Unpack and vet args...
      my $flag = shift;
      my $selector_ref;
      if (ref $flag eq 'HASH') {
          $selector_ref = $flag;
          $flag = undef;
      }
      else {
          $selector_ref = shift;
          die _in_context 'Usage: FAIL_WITH $flag_opt, \%selector, @args'
              if ref $selector_ref ne 'HASH';
      }
      die _in_context "Selector values must be sub refs"
          if grep {ref ne 'CODE'} values %{$selector_ref};
  
      # Search for handler sub;
      my $handler;
      if (defined $flag) {
          ARG:
          while (@_) {
              last ARG if shift(@_) eq $flag;
          }
          my $selector = shift @_;
          if (ref $selector eq 'CODE') {
              $handler = $selector;
              @_ = ();
          }
          else {
              @_ = $selector;
          }
      }
  
      SELECTION:
      for my $selection (reverse @_) {
          if (exists $selector_ref->{$selection}) {
              $handler = $selector_ref->{$selection};
              last SELECTION;
          }
          elsif ($flag) {
              die _in_context "Invalid option: $flag => $selection";
          }
      }
  
      # (Re)set handler...
      if ($handler) {
          my $caller_loc = join '|', (CORE::caller 1)[0,1];
          if (exists $handler_for{$caller_loc}) {
              warn _in_context "FAIL handler for package ", scalar CORE::caller, " redefined";
          }
          $handler_for{$caller_loc} = $handler;
      }
  };
  
  sub _FAIL (;&) {
      # Generate args...
      my $arg_generator_ref = shift;
      my @args;
      if ($arg_generator_ref) {
          package DB;
          ()=CORE::caller(1);
          @args = $arg_generator_ref->(@DB::args);
      }
  
      # Handle user-defined failure semantics...
      my $caller_loc = join '|', (CORE::caller 1)[0,1];
      if (exists $handler_for{$caller_loc} ) {
          # Fake out caller() and Carp...
          local $Contextual::Return::uplevel = 1;
  
          return $handler_for{$caller_loc}->(@args);
      }
  
      my $exception = @args == 1 ? $args[0]
                    : @args > 0  ? join(q{}, @args)
                    :              "Call to " . (CORE::caller 1)[3] . "() failed"
                    ;
  
      # Join message with croak() semantics, if string...
      if (!ref $exception) {
          $exception .= _in_context @_;
      }
  
  #    # Check for immediate failure...
  #    use Want qw( want );
  #    return 0 if want 'BOOL';
  #    die $exception if !want 'SCALAR';
  
      # Return a delayed failure object...
      return
          BOOL    { 0 }
          DEFAULT {
              if (ref $exception) {
                  my $message = "$exception";
                  $message =~ s/$/\n/;
                  die _in_context $message, "Attempted to use failure value";
              }
              else {
                  die _in_context $exception, "Attempted to use failure value";
              }
          }
          METHOD {
              error => sub { _in_context $exception }
          }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Contextual::Return::Failure - Utility module for Contextual::Return
  
  =head1 NOTE
  
  Contains no user serviceable parts. See L<Contextual::Return> instead.
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2006, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
CONTEXTUAL_RETURN_FAILURE

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.006002';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-exporter-tiny/issues>.
  
  =head1 SEE ALSO
  
  L<https://exportertiny.github.io/>.
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017, 2022-2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.006002';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  BEGIN {
  	*_HAS_NATIVE_LEXICAL_SUB = ( $] ge '5.037002' )
  		? sub () { !!1 }
  		: sub () { !!0 };
  	*_HAS_MODULE_LEXICAL_SUB = ( $] ge '5.011002' and eval('require Lexical::Sub') )
  		? sub () { !!1 }
  		: sub () { !!0 };
  };
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]*)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp("$1", $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\![:-](.+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_tag("$1", $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag("$1", $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]*\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	
  	if ( defined $global_opts->{into} and $global_opts->{into} eq '-lexical' ) {
  		$global_opts->{lexical} = 1;
  		delete $global_opts->{into};
  	}
  	if ( not defined $global_opts->{into} ) {
  		$global_opts->{into} = caller;
  	}
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	$global_opts->{installer} ||= $class->_exporter_lexical_installer( $global_opts )
  		if $global_opts->{lexical};
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want) {
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{is_unimport} = 1;
  	
  	if ( defined $global_opts->{into} and $global_opts->{into} eq '-lexical' ) {
  		$global_opts->{lexical} = 1;
  		delete $global_opts->{into};
  	}
  	if ( not defined $global_opts->{into} ) {
  		$global_opts->{into} = caller;
  	}
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Returns a coderef suitable to be used as a sub installer for lexical imports.
  #
  sub _exporter_lexical_installer {
  	_HAS_NATIVE_LEXICAL_SUB and return sub {
  		my ( $sigilname, $sym ) = @{ $_[1] };
  		no warnings ( $] ge '5.037002' ? 'experimental::builtin' : () );
  		builtin::export_lexically( $sigilname, $sym );
  	};
  	_HAS_MODULE_LEXICAL_SUB and return sub {
  		my ( $sigilname, $sym ) = @{ $_[1] };
  		( $sigilname =~ /^\w/ )
  			? 'Lexical::Sub'->import( $sigilname, $sym )
  			: 'Lexical::Var'->import( $sigilname, $sym );
  	};
  	_croak( 'Lexical export requires Perl 5.37.2+ for native support, or Perl 5.11.2+ with the Lexical::Sub module' );
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	my $sigil = "&";
  	if ($name =~ /\A([&\$\%\@\*])(.+)\z/) {
  		$sigil = $1;
  		$name  = $2;
  		if ($sigil eq '*') {
  			_croak("Cannot export symbols with a * sigil");
  		}
  	}
  	my $sigilname = $sigil eq '&' ? $name : "$sigil$name";
  	
  	if ($sigilname =~ $permitted)
  	{
  		my $generatorprefix = {
  			'&' => "_generate_",
  			'$' => "_generateScalar_",
  			'@' => "_generateArray_",
  			'%' => "_generateHash_",
  		}->{$sigil};
  		
  		my $generator = $class->can("$generatorprefix$name");
  		return $sigilname => $class->$generator($sigilname, $value, $globals) if $generator;
  		
  		if ($sigil eq '&') {
  			my $sub = $class->can($name);
  			return $sigilname => $sub if $sub;
  		}
  		else {
  			# Could do this more cleverly, but this works.
  			my $evalled = eval "\\${sigil}${class}::${name}";
  			return $sigilname => $evalled if $evalled;
  		}
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $value_hash = ( ref($value) eq 'HASH' ) ? $value : {};
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as}      ? $globals->{as}->($name) :
  		ref    $value_hash->{-as}  ? $value_hash->{-as}->($name) :
  		exists $value_hash->{-as}  ? $value_hash->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	my $sigil = "&";
  	unless (ref($name)) {
  		if ($name =~ /\A([&\$\%\@\*])(.+)\z/) {
  			$sigil = $1;
  			$name  = $2;
  			if ($sigil eq '*') {
  				_croak("Cannot export symbols with a * sigil");
  			}
  		}
  		my ($prefix) = grep defined, $value_hash->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value_hash->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	my $sigilname = $sigil eq '&' ? $name : ( $sigil . $name );
  	
  #	if ({qw/$ SCALAR @ ARRAY % HASH & CODE/}->{$sigil} ne ref($sym)) {
  #		warn $sym;
  #		warn $sigilname;
  #		_croak("Reference type %s does not match sigil %s", ref($sym), $sigil);
  #	}
  	
  	return ($$name = $sym)              if ref($name) eq q(SCALAR);
  	return ($into->{$sigilname} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	our %TRACKED;
  	
  	if ( ref($sym) eq 'CODE'
  	and ref($into) ? exists($into->{$name}) : exists(&{"$into\::$name"})
  	and $sym != ( ref($into) ? $into->{$name} : \&{"$into\::$name"} ) )
  	{
  		my ($level) = grep defined, $value_hash->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		# Don't complain about double-installing the same sub. This isn't ideal
  		# because the same named sub might be generated in two different ways.
  		$action = sub {} if $TRACKED{$class}{$into}{$sigilname};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s' with sub '%s' exported by %s",
  			ref($into) ? $name : "$into\::$name",
  			$_[0],
  			$class,
  		);
  	}
  	
  	$TRACKED{$class}{$into}{$sigilname} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$sigilname, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  
  	my $sigil = "&";
  	if ($name =~ /\A([&\$\%\@\*])(.+)\z/) {
  		$sigil = $1;
  		$name  = $2;
  		if ($sigil eq '*') {
  			_croak("Cannot export symbols with a * sigil");
  		}
  	}
  	my $sigilname = $sigil eq '&' ? $name : "$sigil$name";
  	
  	if ($sigil ne '&') {
  		_croak("Unimporting non-code symbols not supported yet");
  	}
  
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-exporter-tiny/issues>.
  
  =head1 SEE ALSO
  
  L<https://exportertiny.github.io/>.
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Less tiny version, with more features: L<Exporter::Almighty>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017, 2022-2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Thu Nov 17 17:45:27 2022
  # Update Count    : 1777
  # Status          : Released
  
  ################ Module Preamble ################
  
  # There are no CPAN testers for very old versions of Perl.
  # Getopt::Long is reported to run under 5.8.
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.54;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.54";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=\\.?[0-9])".		# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\\.[0-9_]*)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION_STRING ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  	my $starter;		# the actual starter character(s)
  
  	($found, $opt, $ctl, $starter, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		my $given = $opt;
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name     => $opt,
  				    given    => $given,
  				    ctl      => $ctl,
  				    opctl    => \%opctl,
  				    linkage  => \%linkage,
  				    prefix   => $prefix,
  				    starter  => $starter,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && ( $order == $PERMUTE || $passthrough ) ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Aliases
  		     (?: \| (?: . [^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: 0[0-7]+ | 0[xX][0-9a-fA-F]+ | 0[bB][01]+ | -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(0[0-7]+|0x[0-9a-f]+|0b[01]+|-?\d+|\+)([@%])?$/i ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = 'i';		# assume integer
  	if ( $def eq '+' ) {
  	    # Increment.
  	    $type = 'I';
  	}
  	elsif ( $def =~ /^(0[0-7]+|0[xX][0-9a-fA-F]+|0[bB][01]+)$/ ) {
  	    # Octal, binary or hex.
  	    $type = 'o';
  	    $def = oct($def);
  	}
  	elsif ( $def =~ /^-?\d+$/ ) {
  	    # Integer.
  	    $def = 0 + $def;
  	}
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $starter, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $starter, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    if ( $type eq 'I' ) {
  		# Fake incremental type.
  		my @c = @$ctl;
  		$c[CTL_TYPE] = '+';
  		return (1, $opt, \@c, $starter, 1);
  	    }
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $starter, $val);
  	}
  	return (1, $opt, $ctl, $starter, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand || $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, $starter, 1);
  	}
  	return (1, $opt, $ctl, $starter,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $starter, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $starter, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $starter, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $starter, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, $starter, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $starter, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	if (!defined $pa->{-message}) {
  	    $pa->{-message} = delete($pa->{-msg});
  	}
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1] if @_ > 1;
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  sub given {
      my $self = shift;
      $self->{given};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  (If both C<--verbose> and C<--noverbose> are given, whichever is given
  last takes precedence.)
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  (If the same option appears more than once on the command line, the
  last given value is used.  If you want to take all the values, see
  below.)
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  If the I<number> is octal, hexadecimal or binary, behaves like C<:o>.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Callback object
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  The callback object has the following methods:
  
  =over
  
  =item name
  
  The name of the option, unabbreviated. For an option with multiple
  names it return the first (canonical) name.
  
  =item given
  
  The name of the option as actually used, unabbreveated.
  
  =back
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument. See the next section.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options (and any of their auto-abbreviated shortened forms) B<must>
  always start with a double dash C<--> to avoid ambiguity. For example,
  when C<vax>, C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>. To disable, prefix with C<no> or C<no_>, e.g.
  C<no_ignore_case>. Case does not matter. Multiple calls to Configure()
  are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  (and any of their auto-abbreviated shortened forms) I<must> be
  introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also
  supported in aliases with Getopt::Long of at version 2.39. Note that
  the characters C<!>, C<|>, C<+>, C<=>, and C<:> can only appear as the
  first (or only) character of an alias.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Gradescope/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_COLOR';
  package Gradescope::Color v2023.02.14 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use IPC::Cmd qw(can_run);
      use IPC::Run qw(run);
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          color_print
      );
  
      our $has_colorizer = defined(can_run('batcat')) || defined(can_run('bat'));
      carp '[suggestion] get `bat` for colorized output' if !$has_colorizer;
  
      sub color_print {
          my ($str, $language) = @_;
          if($has_colorizer && !defined($ENV{GU_NO_PAGER})){
              my $bat = 'bat';
              if(can_run('batcat')){ # bat is sometimes named batcat
                  $bat = 'batcat';
              }
              run [$bat, '-l', $language], '<', \$str;
          }
          else{
              print $str;
          }
      }
  
      true;
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  =cut
GRADESCOPE_COLOR

$fatpacked{"Gradescope/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_CURL';
  package Gradescope::Curl v2022.11.13 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use IO::Prompter;
      use JSON;
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          login
      );
  
      our $baseurl;
  
      sub import {
          # in the style of Getopt::Long
          # (I figured people would be familiar w/ this import style since
          # Getopt::Long well known)
          shift; # package
          my @syms;
          my @config;
          my $dest = \@syms;
          for (@_){
              if($_ eq ':config'){
                  $dest = \@config;
              } else{
                  @$dest = (@$dest, $_);
              }
          }
          Gradescope::Curl->export_to_level(1, @syms);
          my %config = @config;
          assert(!defined($baseurl));
          $baseurl = $config{baseurl};
          assert(defined($baseurl));
      }
  
      sub login {
          # hacked together from the python script and a lot of netcat (thanks 489)
          # aka the curl snippets took a lot of trial and error
          open my $tty, '<', '/dev/tty' or confess 'This needs to be run in an interactive shell!';
          my $email = IO::Prompter::prompt('Enter your email: ', -in => $tty);
          my $password = IO::Prompter::prompt('Enter your password: ', -in => $tty, -echo => '');
          my %response = %{JSON::from_json(`curl -s --data 'email=$email&password=$password' $baseurl/api/v1/user_session`)};
          carp '[warning] curl returned error code on gradescope auth' if $? >> 8;
          $response{token} // confess "[error] Your gradescope login credentials are probably wrong";
          carp "[debug] token_expiration_time: $response{token_expiration_time}";
          return $response{token};
      }
  
      true;
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  =cut
GRADESCOPE_CURL

$fatpacked{"Gradescope/Translate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_TRANSLATE';
  package Gradescope::Translate v2022.12.30 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use Text::CSV;
      use JSON;
      use File::Slurp;
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          print_csv
          read_csv
      );
  
      sub print_csv {
          my ($in, $out) = @_;
          Text::CSV::csv({
              # attributes (OO interface)
              binary => 0,
              decode_utf8 => 0,
              strict => 1,
              # `csv` arguments
              in => $in,
              out => $out,
              encoding => ':utf8',
          }) or confess Text::CSV->error_diag;
      }
  
      sub read_csv {
          my ($csv_path, $key_header, $value_header, $filter) = @_;
          $filter //= sub {true};
          my %kv = %{Text::CSV::csv ({
              # attributes (OO interface)
              binary => 0,
              decode_utf8 => 0,
              strict => 1,
              # `csv` arguments
              in => $csv_path,
              filter => $filter,
              encoding => 'UTF-8',
              key => $key_header,
              value => $value_header,
          }) or confess Text::CSV->error_diag};
          return %kv;
      }
  
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  C<Text::CSV> wrappers
  
  =cut
GRADESCOPE_TRANSLATE

$fatpacked{"IO/Prompter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PROMPTER';
  use 5.010;
  package IO::Prompter;
  use utf8;
  
  use warnings;
  no if $] >= 5.018000, warnings => 'experimental';
  use strict;
  use Carp;
  use Contextual::Return qw< PUREBOOL BOOL SCALAR METHOD VOID LIST RETOBJ >;
  use Scalar::Util qw< openhandle looks_like_number >;
  use Symbol       qw< qualify_to_ref >;
  use match::smart qw< match >;
  
  our $VERSION = '0.005001';
  
  my $fake_input;     # Flag that we're faking input from the source
  
  my $DEFAULT_TERM_WIDTH   = 80;
  my $DEFAULT_VERBATIM_KEY = "\cV";
  
  # Completion control...
  my $COMPLETE_DISPLAY_FIELDS = 4;  #...per line
  my $COMPLETE_DISPLAY_GAP    = 3;  #...spaces
  
  my $COMPLETE_KEY  = $ENV{IO_PROMPTER_COMPLETE_KEY} // qq{\t};
  my $COMPLETE_HIST = $ENV{IO_PROMPTER_HISTORY_KEY}  // qq{\cR};
  my $COMPLETE_NEXT = qq{\cN};
  my $COMPLETE_PREV = qq{\cP};
  
  my $COMPLETE_INIT  = qr{ [\Q$COMPLETE_KEY$COMPLETE_HIST\E] }xms;
  my $COMPLETE_CYCLE = qr{ [$COMPLETE_NEXT$COMPLETE_PREV] }xms;
  
  my %COMPLETE_MODE = (
      $COMPLETE_KEY
          => [split /\s+/, $ENV{IO_PROMPTER_COMPLETE_MODES}//q{list+longest  full}],
      $COMPLETE_HIST
          => [split /\s+/, $ENV{IO_PROMPTER_HISTORY_MODES} // q{full}],
  );
  
  my $FAKE_ESC    = "\e";
  my $FAKE_INSERT = "\cF";
  my $MENU_ESC    = "\e";
  my $MENU_MK     = '__M_E_N_U__';
  
  my %EDIT = (
      BACK    => qq{\cB},
      FORWARD => qq{\cF},
      START   => qq{\cA},
      END     => qq{\cE},
  );
  my $EDIT_KEY = '['.join(q{},values %EDIT).']';
  
  # Extracting key letters...
  my $KL_EXTRACT = qr{ (?| \[  ( [[:alnum:]]++ )  \]
                         | \(  ( [[:alnum:]]++ )  \)
                         | \<  ( [[:alnum:]]++ )  \>
                         | \{  ( [[:alnum:]]++ )  \}
                       )
                     }xms;
  my $KL_DEF_EXTRACT = qr{ \[  ( [[:alnum:]]++ )  \] }xms;
  
  
  # Auxiliary prompts for -Yes => N construct...
  my @YESNO_PROMPTS = (
      q{Really?},
      q{You're quite certain?},
      q{Definitely?},
      q{You mean it?},
      q{You truly mean it?},
      q{You're sure?},
      q{Have you thought this through?},
      q{You understand the consequences?},
  );
  
  
  # Remember returned values for history completion...
  my %history_cache;
  
  # Track lexically-scoped default options and wrapper subs...
  my @lexical_options  = [];
  my @lexical_wrappers = [];
  
  # Export the prompt() sub...
  sub import {
      my (undef, $config_data, @other_args) = @_;
  
      # Handle -argv requests...
      if (defined $config_data && $config_data eq '-argv') {
          scalar prompt(-argv, @other_args);
      }
  
      # Handle lexical options...
      elsif (ref $config_data eq 'ARRAY') {
          push @lexical_options, $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
      }
  
      # Handle lexical wrappers...
      elsif (ref $config_data eq 'HASH') {
          push @lexical_options, [];
          $lexical_wrappers[ $#lexical_options ] = $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
          for my $subname (keys %{$config_data}) {
              my @args = @{$config_data->{$subname}};
              no strict 'refs';
              no warnings 'redefine';
              *{caller().'::'.$subname} = sub {
                  my $scope_number = (caller 0)[10]{'IO::Prompter::scope_number'};
                  return prompt(@{$lexical_wrappers[$scope_number]{$subname}//[]}, @_);
              };
          }
      }
  
      # Handler faked input specifications...
      elsif (defined $config_data) {
          $fake_input = $config_data;
      }
  
      no strict 'refs';
      *{caller().'::prompt'} = \&prompt;
  }
  
  # Prompt for, read, vet, and return input...
  sub prompt {
      # Reclaim full control of print statements while prompting...
      local $\ = '';
  
      # Locate any lexical default options...
      my $hints_hash = (caller 0)[10] // {};
      my $scope_num = $hints_hash->{'IO::Prompter::scope_number'} // 0;
  
      # Extract and sanitize configuration arguments...
      my $opt_ref = _decode_args(@{$lexical_options[$scope_num]}, @_);
  
      _warn( void => 'Useless use of prompt() in void context' )
          if VOID && !$opt_ref->{-void};
  
      # Set up yesno prompts if required...
      my @yesno_prompts
          = ($opt_ref->{-yesno}{count}//0) > 1 ? @YESNO_PROMPTS : ();
  
      # Work out where the prompts go, and where the input comes from...
      my $in_filehandle  = $opt_ref->{-in}  // _open_ARGV();
      my $out_filehandle = $opt_ref->{-out} // qualify_to_ref(select);
      if (!openhandle $in_filehandle) {
          open my $fh, '<', $in_filehandle
              or _opt_err('Unacceptable', '-in', 'valid filehandle or filename');
          $in_filehandle = $fh;
      }
      if (!openhandle $out_filehandle) {
          open my $fh, '>', $out_filehandle
              or _opt_err('Unacceptable', '-out', 'valid filehandle or filename');
          $out_filehandle = $fh;
      }
  
      # Track timeouts...
      my $in_pos = do { no warnings;  tell $in_filehandle } // 0;
  
      # Short-circuit if not valid handles...
      return if !openhandle($in_filehandle) || !openhandle($out_filehandle);
  
      # Work out how they're arriving and departing...
      my $outputter_ref = -t $in_filehandle && -t $out_filehandle
                              ? _std_printer_to($out_filehandle, $opt_ref)
                              : _null_printer()
                              ;
      my $inputter_ref = _generate_unbuffered_reader_from(
                              $in_filehandle, $outputter_ref, $opt_ref
                         );
  
      # Clear the screen if requested to...
      if ($opt_ref->{-wipe}) {
          $outputter_ref->(-nostyle => "\n" x 1000);
      }
  
      # Handle menu structures...
      my $input;
      eval {
          REPROMPT_YESNO:
          if ($opt_ref->{-menu}) {
              # Remember top of (possibly nested) menu...
              my @menu = ( $opt_ref->{-menu} );
              my $top_prompt = $opt_ref->{-prompt};
              $top_prompt =~ s{$MENU_MK}{$opt_ref->{-menu}{prompt}}xms;
              $menu[-1]{prompt} = $top_prompt;
  
              MENU:
              while (1) {
                  # Track the current level...
                  $opt_ref->{-menu_curr_level} = $menu[-1]{value_for};
  
                  # Show menu and retreive choice...
                  $outputter_ref->(-style => $menu[-1]{prompt});
                  my $tag = $inputter_ref->($menu[-1]{constraint});
  
                  # Handle a failure by exiting the loop...
                  last MENU if !defined $tag;
                  $tag =~ s{\A\s*(\S*).*}{$1}xms;
  
                  # Handle <ESC> by moving up menu stack...
                  if ($tag eq $MENU_ESC) {
                      $input = undef;
                      last MENU if @menu <= 1;
                      pop @menu;
                      next MENU;
                  }
  
                  # Handle defaults by selecting and ejecting...
                  if ($tag =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
                      $input = $tag;
                      last MENU;
                  }
  
                  # Otherwise, retrieve value for selected tag and exit if not a nested menu...
                  $input = $menu[-1]{value_for}{$tag};
                  last MENU if !ref $input;
  
                  # Otherwise, go down the menu one level...
                  push @menu,
                      _build_menu($input,
                                  "Select from $menu[-1]{key_for}{$tag}: ",
                                  $opt_ref->{-number} || $opt_ref->{-integer}
                      );
                  $menu[-1]{prompt} .= '> ';
              }
          }
  
          # Otherwise, simply ask and ye shall receive...
          else {
                  $outputter_ref->(-style => $opt_ref->{-prompt});
                  $input = $inputter_ref->();
          }
          1;
      }
      // do {
          # Supply the missing newline if requested...
          $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}))
              if exists $opt_ref->{-return};
  
          # Rethrow any other exception...
          my $error = $@;
          die $@ unless ref($error) eq 'IO::Prompter::Cancellation';
  
          # Return failure on cancellation...
          return if $opt_ref->{-verbatim};
          return PUREBOOL { 0 }
                     BOOL { 0 }
                   SCALAR { ${$error}  }
                   METHOD { defaulted => sub { 0 }, timedout  => sub { 0 } };
      };
  
      # Provide default value if available and necessary...
      my $defaulted = 0;
      if (defined $input && $input =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # The input line is usually chomped before being returned...
      if (defined $input && !$opt_ref->{-line}) {
          chomp $input;
      }
  
      # Check for a value indicating failure...
      if (exists $opt_ref->{-fail}   && match($input, $opt_ref->{-fail})) {
          $input = undef;
      }
  
      # Setting @ARGV is a special case; process it like a command-line...
      if ($opt_ref->{-argv}) {
          @ARGV = map { _shell_expand($_) }
                      grep {defined}
                              $input =~ m{
                                      ( '  [^'\\]* (?: \\. [^'\\]* )* ' )
                                  |   ( "  [^"\\]* (?: \\. [^"\\]* )* " )
                                  |   (?: ^ | \s)  ( [^\s"'] \S*        )
                              }gxms;
          return 1;
      }
  
      # "Those who remember history are enabled to repeat it"...
      if (defined $input and $opt_ref->{-history} ne 'NONE') {
          my $history_set = $history_cache{ $opt_ref->{-history} } //= [] ;
          @{ $history_set } = ($input, grep { $_ ne $input } @{ $history_set });
      }
  
      # If input timed out insert the default, if any...
      my $timedout = $in_pos == do{ no warnings; tell $in_filehandle } // 0;
      if ($timedout && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # A defined input is a successful input...
      my $succeeded = defined $input;
  
      # The -yesno variants also need a 'y' to be successful...
      if ($opt_ref->{-yesno}{count}) {
          $succeeded &&= $input =~ m{\A \s* y}ixms;
          if ($succeeded && $opt_ref->{-yesno}{count} > 1) {
              my $count = --$opt_ref->{-yesno}{count};
              $opt_ref->{-prompt}
                  = @yesno_prompts ? shift(@yesno_prompts) . q{ }
                  : $count > 1     ? qq{Please confirm $count more times }
                  :                   q{Please confirm one last time }
                  ;
              goto REPROMPT_YESNO;    # Gasp, yes goto is the cleanest way!
          }
      }
  
      # Verbatim return doesn't do fancy tricks...
      if ($opt_ref->{-verbatim}) {
          return $input // ();
      }
  
      # Failure in a list context returns nothing...
      return if LIST && !$succeeded;
  
      # Otherwise, be context sensitive...
      return
          PUREBOOL { $_ = RETOBJ; next handler;      }
              BOOL { $succeeded;                     }
            SCALAR { $input;                         }
            METHOD {
                      defaulted => sub { $defaulted  },
                      timedout  => sub {
                          return q{} if !$timedout;
                          return "timed out after $opt_ref->{-timeout} second"
                               . ($opt_ref->{-timeout} == 1 ? q{} : q{s});
                      },
                   };
  }
  
  
  # Simulate a command line expansion for the -argv option...
  sub _shell_expand {
      my ($text) = @_;
  
      # Single-quoted text is literal...
      if ($text =~ m{\A ' (.*) ' \z}xms) {
          return $1;
      }
  
      # Everything else has shell variables expanded...
      my $ENV_PAT = join '|', reverse sort keys %ENV;
      $text =~ s{\$ ($ENV_PAT)}{$ENV{$1}}gxms;
  
      # Double-quoted text isn't globbed...
      if ($text =~ m{\A " (.*) " \z}xms) {
          return $1;
      }
  
      # Everything else is...
      return glob($text);
  }
  
  # No completion is the default...
  my $DEFAULT_COMPLETER = sub { q{} };
  
  # Translate std constraints...
  my %STD_CONSTRAINT = (
      positive  => sub { $_ > 0      },
      negative  => sub { $_ < 0      },
      zero      => sub { $_ == 0     },
      even      => sub { $_ % 2 == 0 },
      odd       => sub { $_ % 2 != 0 },
  );
  
  # Create abbreviations...
  $STD_CONSTRAINT{pos} = $STD_CONSTRAINT{positive};
  $STD_CONSTRAINT{neg} = $STD_CONSTRAINT{negative};
  
  # Create antitheses...
  for my $constraint (keys %STD_CONSTRAINT) {
      my $implementation = $STD_CONSTRAINT{$constraint};
      $STD_CONSTRAINT{"non$constraint"}
          = sub { ! $implementation->(@_) };
  }
  
  # Special style specifications require decoding...
  
  sub _decode_echo {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no echoes...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_echostyle {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no styles...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_style {
      # No special prompt styles (yet)...
      return shift;
  }
  
  # Generate safe closure around active sub...
  sub _gen_wrapper_for {
      my ($arg) = @_;
      return ref $arg ne 'CODE'
             ? sub { $arg }
             : sub { eval { for (shift) { no warnings; return $arg->($_) // $_ } } };
  }
  
  # Create recognizer...
  my $STD_CONSTRAINT
      = '^(?:' . join('|', reverse sort keys %STD_CONSTRAINT) . ')';
  
  # Translate name constraints to implementations...
  sub _standardize_constraint {
      my ($option_type, $constraint_spec) = @_;
  
      return ("be an acceptable $option_type", $constraint_spec)
          if ref $constraint_spec;
  
      my @constraint_names = split /\s+/, $constraint_spec;
      my @constraints =
          map { $STD_CONSTRAINT{$_}
                // _opt_err('invalid',-$option_type,'"pos", "neg", "even", etc.', qq{"$_"})
              } @constraint_names;
  
      return (
          'be ' . join(' and ', @constraint_names),
          sub {
              my ($compare_val) = @_;
              for my $constraint (@constraints) {
                  return 0 if !$constraint->($compare_val);
              }
              return 1;
          }
      );
  }
  
  
  # Convert args to prompt + options hash...
  sub _decode_args {
      my %option = (
          -prompt    => undef,
          -complete  => $DEFAULT_COMPLETER,
          -must      => {},
          -history   => 'DEFAULT',
          -style     => sub{ q{} },
          -nostyle   => sub{ q{} },
          -echostyle => sub{ q{} },
          -echo      => sub { my $char = shift; $char eq "\t" ? q{ } : $char },
          -return    => sub { "\n" },
      );
  
      DECODING:
      while (defined(my $arg = shift @_)) {
          if (my $type = ref $arg) {
              _warn( reserved =>
                  'prompt(): Unexpected argument (' . lc($type) . ' ref) ignored'
              );
          }
          else {
              state $already_wiped;
              my $redo;
              # The sound of one hand clapping...
              if ($arg =~ /^-_/) {
                  $redo = 1;
              }
  
              # Non-chomping option...
              elsif ($arg =~ /^-line$/) {
                  $option{-line}++;
              }
              elsif ($arg =~ /^-l/) {
                  $option{-line}++;
                  $redo = 1;
              }
  
              # The -yesno variants...
              elsif ($arg =~ /^-YesNo$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = {
                      must => { '[YN]' => qr{\A \s* [YN] }xms },
                      count  => $count,
                  };
              }
              elsif ($arg =~ /^-YN/) {
                  $option{-yesno} = {
                      must => { '[YN]' => qr{\A \s* [YN] }xms },
                      count  => 1,
                  };
                  $redo = 2;
              }
              elsif ($arg =~ /^-yesno$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = {
                      must => { '[yn]' => qr{\A \s* [YN] }ixms },
                      count  => $count,
                  };
              }
              elsif ($arg =~ /^-yn/) {
                  $option{-yesno} = {
                      must => { '[yn]' => qr{\A \s* [YN] }ixms },
                      count  => 1,
                  };
                  $redo = 2;
              }
              elsif ($arg =~ /^-Yes$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = {
                      must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                      count  => $count,
                  };
              }
              elsif ($arg =~ /^-Y/) {
                  $option{-yesno} = {
                      must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                      count  => 1,
                  };
                  $redo = 1;
              }
              elsif ($arg =~ /^-yes$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = { count  => $count };
              }
              elsif ($arg =~ /^-y/) {
                  $option{-yesno} = { count  => 1 };
                  $redo = 1;
              }
  
              # Load @ARGV...
              elsif ($arg =~ /^-argv$/) {
                  $option{-argv} = 1;
              }
  
              elsif ($arg =~ /^-a/) {
                  $option{-argv} = 1;
                  $redo = 1;
              }
  
              # Clear screen before prompt...
              elsif ($arg =~ /^-wipe(first)?$/) {
                  $option{-wipe} = $1 ? !$already_wiped : 1;
                  $already_wiped = 1;
              }
              elsif ($arg =~ /^-w/) {
                  $option{-wipe} = 1;
                  $already_wiped = 1;
                  $redo = 1;
              }
  
              # Specify a failure condition...
              elsif ($arg =~ /^-fail$/) {
                  _opt_err('Missing', -fail, 'failure condition') if !@_;
                  $option{-fail} = shift @_;
              }
  
              # Specify an immediate failure condition...
              elsif ($arg =~ /^-cancel/) {
                  _opt_err('Missing', -cancel, 'cancellation condition') if !@_;
                  $option{-cancel} = shift @_;
              }
  
              # Specify a file request...
              elsif ($arg =~ /^-f(?:ilenames?)?$/) {
                  $option{-must}{'0: be an existing file'} = sub { -e $_[0] };
                  $option{-must}{'1: be readable'}         = sub { -r $_[0] };
                  $option{-complete}                       = 'filenames';
              }
  
              # Specify prompt echoing colour/style...
              elsif ($arg =~ /^-style/) {
                  _opt_err('Missing -style specification') if !@_;
                  my $style = _decode_style(shift @_);
                  $option{-style} = _gen_wrapper_for($style);
              }
  
              # Specify input colour/style...
              elsif ($arg =~ /^-echostyle/) {
                  _opt_err('Missing -echostyle specification') if !@_;
                  my $style = _decode_echostyle(shift @_);
                  $option{-echostyle} = _gen_wrapper_for($style);
              }
  
  
              # Specify input and output filehandles...
              elsif ($arg =~ /^-stdio$/) { $option{-in}  = *STDIN;
                                  $option{-out} = *STDOUT;
                                  }
              elsif ($arg =~ /^-in$/)    { $option{-in}  = shift @_; }
              elsif ($arg =~ /^-out$/)   { $option{-out} = shift @_; }
  
  
              # Specify integer and number return value...
              elsif ($arg =~ /^-integer$/)       {
                  $option{-integer} = 1;
                  if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                      my ($errmsg, $constraint)
                          = _standardize_constraint('integer',shift);
                      $option{-must}{$errmsg} = $constraint;
                  }
              }
              elsif ($arg =~ /^-num(?:ber)?$/)   {
                  $option{-number}  = 1;
                  if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                      my ($errmsg, $constraint)
                          = _standardize_constraint('number',shift);
                      $option{-must}{$errmsg} = $constraint;
                  }
              }
              elsif ($arg =~ /^-i/)              { $option{-integer} = 1; $redo = 1; }
              elsif ($arg =~ /^-n/)              { $option{-number}  = 1; $redo = 1; }
  
              # Specify void context is okay...
              elsif ($arg =~ /^-void$/)          { $option{-void} = 1;               }
  
              # Specify verbatim return value...
              elsif ($arg =~ /^-verb(?:atim)?$/) { $option{-verbatim} = 1;           }
              elsif ($arg =~ /^-v/)              { $option{-verbatim} = 1; $redo = 1;}
  
              # Specify single character return...
              elsif ($arg =~ /^-sing(?:le)?$/)   { $option{-single} = 1;             }
              elsif ($arg =~ /^-[s1]/)           { $option{-single} = 1; $redo = 1;  }
  
              # Specify a default...
              elsif ($arg =~ /^-DEF(?:AULT)?/) {
                  _opt_err('Missing', '-DEFAULT', 'string') if !@_;
                  $option{-def} = shift @_;
                  $option{-def_nocheck} = 1;
                  _opt_err('Invalid', '-DEFAULT', 'string', 'reference')
                      if ref($option{-def});
              }
              elsif ($arg =~ /^-def(?:ault)?/) {
                  _opt_err('Missing', '-default', 'string') if !@_;
                  $option{-def} = shift @_;
                  _opt_err('Invalid', '-default', 'string', 'reference')
                      if ref($option{-def});
              }
              elsif ($arg =~ /^-d(.+)$/)   { $option{-def} = $1; }
  
              # Specify a timeout...
              elsif ($arg =~ /^-t(\d+)/)   {
                  $option{-timeout} = $1;
                  $arg =~ s{\d+}{}xms;
                  $redo = 1;
              }
              elsif ($arg =~ /^-timeout$/) {
                  _opt_err('Missing', -timeout, 'number of seconds') if !@_;
                  $option{-timeout} = shift @_;
                  _opt_err('Invalid', -timeout,'number of seconds', qq{'$option{-timeout}'})
                      if !looks_like_number($option{-timeout});
              }
  
              # Specify a set of input constraints...
              elsif ($arg =~ /^-g.*/) {
                  _opt_err('Missing', -guarantee, 'input restriction') if !@_;
                  my $restriction = shift @_;
                  my $restriction_type = ref $restriction;
  
                  $option{-must}{'be a valid input'} = $restriction;
  
                  # Hashes restrict input to their keys...
                  if ($restriction_type eq 'HASH') {
                      $restriction_type = 'ARRAY';
                      $restriction = [ keys %{$restriction} ];
                  }
                  # Arrays of strings matched (and completed) char-by-char...
                  if ($restriction_type eq 'ARRAY') {
                      my @restrictions = @{$restriction};
                      $option{-guarantee}
                          = '\A(?:'
                          . join('|', map {
                                  join(q{}, map { "(?:\Q$_\E" } split(q{}, $_))
                              . ')?' x length($_)
                              } @restrictions)
                          . ')\z'
                          ;
                      if ($option{-complete} == $DEFAULT_COMPLETER) {
                          $option{-complete} = \@restrictions;
                      }
                  }
                  # Regexes matched as-is...
                  elsif ($restriction_type eq 'Regexp') {
                      $option{-guarantee} = $restriction;
                  }
                  else {
                      _opt_err( 'Invalid', -guarantee,
                                  'array or hash reference, or regex'
                      );
                  }
              }
  
              # Specify a set of key letters...
              elsif ($arg =~ '-keyletters_implement') {
                  # Extract all keys and default keys...
                  my @keys  = ($option{-prompt} =~ m{$KL_EXTRACT}gxms);
  
                  # Convert default to a -default...
                  my @defaults = ($option{-prompt} =~ m{$KL_DEF_EXTRACT}gxms);
                  if (@defaults > 1) {
                      _warn( ambiguous =>
                          "prompt(): -keyletters found too many defaults"
                      )
                  }
                  elsif (@defaults) {
                      push @_, -default => $defaults[0];
                  }
  
                  # Convert key letters to a -guarantee...
                  @keys = ( map({uc} @keys), map({lc} @keys) );
                  if (@defaults == 1) {
                      push @keys, q{};
                  }
                  push @_, -guarantee => \@keys;
  
              }
              elsif ($arg =~ /^-key(?:let(?:ter)?)(?:s)?/) {
                  push @_, '-keyletters_implement';
              }
              elsif ($arg =~ /^-k/) {
                  push @_, '-keyletters_implement';
                  $redo = 1;
              }
  
              # Specify a set of return constraints...
              elsif ($arg =~ /^-must$/) {
                  _opt_err('Missing', -must, 'constraint hash') if !@_;
                  my $must = shift @_;
                  _opt_err('Invalid', -must, 'hash reference')
                      if ref($must) ne 'HASH';
                  for my $errmsg (keys %{$must}) {
                      $option{-must}{$errmsg} = $must->{$errmsg};
                  }
              }
  
              # Specify a history set...
              elsif ($arg =~ /^-history/) {
                  $option{-history}
                      = @_ && $_[0] !~ /^-/ ? shift @_
                      :                       undef;
                  _opt_err('Invalid', -history, 'history set name', qq{'$option{-history}'})
                      if ref($option{-history});
              }
              elsif ($arg =~ /^-h(.*)/)   { $option{-history} = length($1) ? $1 : undef; }
  
              # Specify completions...
              elsif ($arg =~ /^-comp(?:lete)?/) {
                  _opt_err('Missing', -complete, 'completions') if !@_;
                  my $comp_spec = shift @_;
                  my $comp_type = ref($comp_spec) || $comp_spec || '???';
                  if ($comp_type =~ m{\A(?: file\w* | dir\w* | ARRAY | HASH | CODE )\Z}xms) {
                      $option{-complete} = $comp_spec;
                  }
                  else {
                      _opt_err( 'Invalid', -complete,
                                  '"filenames", "dirnames", or reference to array, hash, or subroutine');
                  }
              }
  
              # Specify what to echo when a character is keyed...
              elsif ($arg =~ /^-(echo|ret(?:urn)?)$/) {
                  my $flag = $1 eq 'echo' ? '-echo' : '-return';
                  if ($flag eq '-echo' && !eval { no warnings 'deprecated'; require Term::ReadKey }) {
                      _warn( bareword => "Warning: next input will be in plaintext\n");
                  }
                  my $arg = @_ && $_[0] !~ /^-/ ? shift(@_)
                          : $flag eq '-echo'    ? q{}
                          :                       qq{\n};
                  $option{$flag} = _gen_wrapper_for(_decode_echo($arg));
              }
              elsif ($arg =~ /^-e(.*)/) {
                  if (!eval { no warnings 'deprecated'; require Term::ReadKey }) {
                      _warn( bareword => "Warning: next input will be in plaintext\n");
                  }
                  my $arg = $1;
                  $option{-echo} = _gen_wrapper_for(_decode_echo($arg));
              }
              elsif ($arg =~ /^-r(.+)/) {
                  my $arg = $1;
                  $option{-return} = _gen_wrapper_for(_decode_echo($arg));
              }
              elsif ($arg =~ /^-r/) {
                  $option{-return} = sub{ "\n" };
              }
  
              # Specify an initial input...
              elsif ($arg =~ /^-prefill/) {
                  _opt_err('Missing', '-prefill', 'string') if !@_;
                  $option{-prefill} = shift @_;
                  _opt_err('Invalid', '-prefill', 'string', 'reference')
                      if ref($option{-prefill});
              }
  
              # Explicit prompt replaces implicit prompts...
              elsif ($arg =~ /^-prompt$/) {
                  _opt_err('Missing', '-prompt', 'prompt string') if !@_;
                  $option{-prompt} = shift @_;
                  _opt_err('Invalid', '-prompt', 'string', 'reference')
                      if ref($option{-prompt});
              }
              elsif ($arg =~ /^-p(\S*)$/) {
                  $option{-prompt} = $1;
              }
  
              # Menus inject a placeholder in the prompt string...
              elsif ($arg =~ /^-menu$/) {
                  _opt_err('Missing', '-menu', 'menu specification') if !@_;
                  $option{-menu}         = ref $_[0] ? shift(@_) : \shift(@_);
                  $option{-prompt}      .= $MENU_MK;
                  $option{-def_nocheck}  = 1;
              }
  
              # A monitoring sub is called on every input character...
              elsif ($arg =~ /^-monitor/) {
                  _opt_err('Missing', '-monitor', 'a monitor subref')
                      if !@_ || ref $_[0] ne 'CODE';
                  $option{-monitor} = shift(@_);
              }
  
              # Anything else of the form '-...' is a misspelt option...
              elsif ($arg =~ /^-\w+$/) { _warn(misc => "prompt(): Unknown option $arg ignored"); }
  
              # Anything else is part fo the prompt...
              else { $option{-prompt} .= $arg; }
  
              # Handle option bundling...
              redo DECODING if $redo && $arg =~ s{\A -.{$redo} (?=.)}{-}xms;
          }
      }
  
      # Precompute top-level menu, if menuing...
      if (exists $option{-menu}) {
          $option{-menu} = _build_menu($option{-menu},
                                       undef,
                                       $option{-number}||$option{-integer}
                           );
      }
  
      # Handle return magic on -single...
      if (defined $option{-single} && length($option{-echo}('X')//'echoself')) {
          $option{-return} //= sub{ "\n" };
      }
  
      # Adjust prompt as necessary...
      if ($option{-argv}) {
          my $progname = $option{-prompt} // $0;
          $progname =~ s{^.*/}{}xms;
  
          my $HINT = '[enter command line args here]';
          $option{-prompt} = "> $progname  $HINT\r> $progname ";
  
          $option{-complete} = 'filenames';
  
          my $not_first;
          $option{-echo}   = sub{
              my $char = shift;
              $option{-prompt} = "> $progname ";  # Sneaky resetting to handle completions
              return $char if $not_first++;
              return "\r> $progname  " . (q{ } x length $HINT) . "\r> $progname $char";
          }
      }
      elsif (!defined $option{-prompt}) {
          $option{-prompt} = '> ';
      }
      elsif ($option{-prompt} =~ m{ \S \z}xms) {
          # If prompt doesn't end in whitespace, make it so...
          $option{-prompt} .= ' ';
      }
      elsif ($option{-prompt} =~ m{ (.*) \n \z}xms) {
          # If prompt ends in a newline, remove it...
          $option{-prompt} = $1;
      }
  
      # Steal history set name if -h given without a specification...
      $option{-history} //= $option{-prompt};
  
      # Verify any default satisfies any constraints...
      if (exists $option{-def} && !$option{-def_nocheck}) {
          if (!_verify_input_constraints(\q{},undef,undef,\%option)) {
              _warn( misc =>
                  'prompt(): -default value does not satisfy -must constraints'
              );
          }
      }
  
      return \%option;
  }
  
  #====[ Error Handlers ]=========================================
  
  sub _opt_err {
      my ($problem, $option, $expectation, $found) = @_;
      if (@_ > 3) {
          Carp::croak "prompt(): $problem value for $option (expected $expectation, but found $found)";
      }
      else {
          Carp::croak "prompt(): $problem value for $option (expected $expectation)";
      }
  }
  
  sub _warn {
      my ($category, @message) = @_;
  
      return if !warnings::enabled($category);
  
      my $message = join(q{},@message);
      warn $message =~ /\n$/ ? $message : Carp::shortmess($message);
  }
  
  
  #====[ Utility subroutines ]====================================
  
  # Return the *ARGV filehandle, "magic-opening" it if necessary...
  sub _open_ARGV {
      if (!openhandle \*ARGV) {
          $ARGV = shift @ARGV // '-';
          open *ARGV or Carp::croak(qq{prompt(): Can't open *ARGV: $!});
      }
      return \*ARGV;
  }
  
  my $INTEGER_PAT = qr{ \A \s*+ [+-]?+ \d++ (?: [Ee] \+? \d+ )? \s*+ \Z }xms;
  
  my $NUMBER_PAT  = qr{
      \A \s*+ [+-]?+
      (?:
          \d++ (?: [.,] \d*+ )?
      |   [.,] \d++
      )
      (?: [eE] [+-]?+ \d++ )?
      \s*+ \Z
  }xms;
  
  # Verify interactive constraints...
  sub _verify_input_constraints {
      my ($input_ref, $local_fake_input_ref, $outputter_ref, $opt_ref, $extras)
          = @_;
  
      # Use default if appropriate (but short-circuit checks if -DEFAULT set)...
      my $input = ${$input_ref};
      if (${$input_ref} =~ m{^\R?$}xms && exists $opt_ref->{-def}) {
          return 1 if $opt_ref->{-def_nocheck};
          $input = $opt_ref->{-def}
      }
      chomp $input;
  
      my $failed;
      # Integer constraint is hard-coded...
      if ($opt_ref->{-integer} && $input !~ $INTEGER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be an integer) ";
      }
  
      # Numeric constraint is hard-coded...
      if (!$failed && $opt_ref->{-number} && $input !~ $NUMBER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be a number) ";
      }
  
      # Sort and clean up -must list...
      my $must_ref = $opt_ref->{-must} // {};
      my @must_keys     = sort keys %{$must_ref};
      my %clean_key_for = map { $_ => (/^\d+[.:]?\s*(.*)/s ? $1 : $_) } @must_keys;
      my @must_kv_list  = map { $clean_key_for{$_} => $must_ref->{$_} } @must_keys;
  
      # Combine -yesno and -must constraints...
      my %constraint_for = (
          %{ $extras // {} },
          %{ $opt_ref->{-yesno}{must} // {} },
          @must_kv_list,
      );
      my @constraints = (
          keys %{ $extras // {} },
          keys %{ $opt_ref->{-yesno}{must} // {} },
          @clean_key_for{@must_keys},
      );
  
      # User-specified constraints...
      if (!$failed && keys %constraint_for) {
          CONSTRAINT:
          for my $msg (@constraints) {
              my $constraint = $constraint_for{$msg};
              next CONSTRAINT if eval { no warnings; local $_ = $input; match($input, $constraint); };
              $failed = $msg =~ m{\A [[:upper:]] }xms ? "$msg "
                      : $msg =~ m{\A \W }xms          ? $opt_ref->{-prompt}
                                                      . "$msg "
                      :                                 $opt_ref->{-prompt}
                                                      . "(must $msg) "
                      ;
              last CONSTRAINT;
          }
      }
  
      # If any constraint not satisfied...
      if ($failed) {
          # Return failure if not actually prompting at the moment...
          return 0 if !$outputter_ref;
  
          # Redraw post-menu prompt with failure message appended...
          $failed =~ s{.*$MENU_MK}{}xms;
          $outputter_ref->(-style => _wipe_line(), $failed);
  
          # Reset input collector...
          ${$input_ref}  = q{};
  
          # Reset faked input, if any...
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              ${$local_fake_input_ref} = $1;
          }
  
          no warnings 'exiting';
          next INPUT;
      }
  
      # Otherwise succeed...
      return 1;
  }
  
  # Build a sub to read from specified filehandle, with or without timeout...
  sub _generate_buffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      # Set-up for timeouts...
      my $fileno      = fileno($in_fh) // -1;
      my $has_timeout = exists $opt_ref->{-timeout} && $fileno >= 0;
      my $timeout     = $opt_ref->{-timeout};
      my $readbits    = q{};
      if ($has_timeout && $fileno >= 0) {
          vec($readbits,$fileno,1) = 1;
      }
  
      # Set up local faked input, if any...
      my $local_fake_input;
      my $orig_fake_input;
      if (defined $fake_input && length($fake_input) > 0) {
          $fake_input =~ s{ \A (.*) \R? }{}xm;
          $orig_fake_input = $local_fake_input = $1;
      }
  
      return sub {
          my ($extra_constraints) = @_;
  
          INPUT:
          while (1) {
              if (!$has_timeout || select $readbits, undef, undef, $timeout) {
                  my $input;
  
                  # Real input comes from real filehandles...
                  if (!defined $local_fake_input) {
                      $input = readline $in_fh;
                  }
                  # Fake input has to be typed...
                  else {
                      $input = $local_fake_input;
                      sleep 1;
                      for ($local_fake_input =~ m/\X/g) {
                          _simulate_typing();
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                      }
                      readline $in_fh;
  
                      # Check for simulated EOF...
                      if ($input =~ m{^ \s* (?: \cD | \cZ ) }xms) {
                          $input = undef;
                      }
                  }
  
                  if (exists $opt_ref->{-cancel}) {
                      for my $nextchar (split q{}, $input) {
                          die bless \$input, 'IO::Prompter::Cancellation'
                              if match($nextchar, $opt_ref->{-cancel});
                      }
                  }
  
                  if (defined $input) {
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref, $opt_ref, $extra_constraints
                      );
                  }
  
                  return defined $input && $opt_ref->{-single}
                              ? substr($input, 0, 1)
                              : $input;
              }
              else {
                  return;
              }
          }
      }
  }
  
  sub _autoflush {
      my ($fh) = @_;
      my $prev_selected = select $fh;
      $| = 1;
      select $prev_selected;
      return;
  }
  
  sub _simulate_typing {
      state $TYPING_SPEED = 0.07; # seconds per character
      select undef, undef, undef, rand $TYPING_SPEED;
  }
  
  sub _term_width {
      my ($term_width) = eval { no warnings 'deprecated'; Term::ReadKey::GetTerminalSize(\*STDERR) };
      return $term_width // $DEFAULT_TERM_WIDTH;
  }
  
  sub _wipe_line {
      return qq{\r} . q{ } x (_term_width()-1) . qq{\r};
  }
  
  # Convert a specification into a list of possible completions...
  sub _current_completions_for {
      my ($input_text, $opt_ref) = @_;
      my $completer = $opt_ref->{-complete};
  
      # Isolate the final whitespace-separated word...
      my ($prefix, $lastword)
          = $input_text =~ m{
              (?| ^ (.*\s+) (.*)
                | ^ ()      (.*)
              )
            }xms;
  
      # Find candidates...
      my @candidates;
      for my $completer_type (ref($completer) || $completer // q{}) {
          # If completer is sub, recursively call it with input words...
          if ($completer_type eq 'CODE') {
              ($prefix, @candidates)
                  = _current_completions_for(
                      $input_text,
                      { %{$opt_ref},
                        -complete => $completer->(split /\s+/, $input_text, -1)
                      }
                    );
          }
  
          # If completer is array, grep the appropriate elements...
          elsif ($completer_type eq 'ARRAY') {
              @candidates = grep { /\A\Q$lastword\E/ } @{$completer};
          }
  
          # If completer is hash, grep the appropriate keys...
          elsif ($completer_type eq 'HASH') {
              @candidates = grep { /\A\Q$lastword\E/ } keys %{$completer};
          }
  
          # If completer is 'file...', glob up the appropriate filenames...
          elsif ($completer_type eq /^file\w*$/) {
              @candidates = glob($lastword.'*');
          }
  
          # If completer is 'dir...', glob up the appropriate directories...
          elsif ($completer_type eq /^dir\w*$/) {
              @candidates = grep {-d} glob($lastword.'*');
          }
      }
  
      chomp @candidates;
      return ($prefix, @candidates);
  }
  
  
  sub _current_history_for {
      my ($prefix, $opt_ref) = @_;
  
      my $prefix_len = length($prefix);
      return q{}, map { /\A (.*?) \R \Z/x ? $1 : $_ }
                 grep { substr($_,0,$prefix_len) eq $prefix }
                      @{ $history_cache{$opt_ref->{-history}} };
  }
  
  sub _longest_common_prefix_for {
      my $prefix = shift @_;
      for my $comparison (@_) {
          ($comparison ^ $prefix) =~ m{ \A (\0*) }xms;
          my $common_length = length($1);
          return q{} if !$common_length;
          $prefix = substr($prefix, 0, $common_length);
      }
      return $prefix;
  }
  
  sub _display_completions {
      my ($input, @candidates) = @_;
  
      return q{} if @candidates <= 1;
  
      # How big is each field in the table?
      my $field_width
          = _term_width() / $COMPLETE_DISPLAY_FIELDS - $COMPLETE_DISPLAY_GAP;
  
      # Crop the possibilities intelligently to that width...
      for my $candidate (@candidates) {
          substr($candidate, 0, length($input)) =~ s{ \A .* [/\\] }{}xms;
          $candidate
              = sprintf "%-*s", $field_width, substr($candidate,0,$field_width);
      }
  
      # Collect them into rows...
      my $display = "\n";
      my $gap     = q{ } x $COMPLETE_DISPLAY_GAP;
      while (@candidates) {
          $display .= $gap
                    . join($gap, splice(@candidates, 0, $COMPLETE_DISPLAY_FIELDS))
                    . "\n";
      }
  
      return $display;
  }
  
  sub _generate_unbuffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      my $has_readkey = eval { no warnings 'deprecated'; require Term::ReadKey };
  
      # If no per-character reads, fall back on buffered input...
      if (!-t $in_fh || !$has_readkey) {
          return _generate_buffered_reader_from($in_fh, $outputter_ref, $opt_ref);
      }
  
      # Adapt to local control characters...
      my %ctrl = eval { Term::ReadKey::GetControlChars($in_fh) };
      delete $ctrl{$_} for grep { $ctrl{$_} eq "\cA" } keys %ctrl;
  
      $ctrl{EOF}       //= "\4";
      $ctrl{INTERRUPT} //= "\3";
      $ctrl{ERASE}     //= $^O eq 'MSWin32' ? "\10" : "0177";
  
      my $ctrl           = join '|', values %ctrl;
  
      my $VERBATIM_KEY = $ctrl{QUOTENEXT} // $DEFAULT_VERBATIM_KEY;
  
      # Translate timeout for ReadKey (with 32-bit MAXINT workaround for Windows)...
      my $timeout = !defined $opt_ref->{-timeout} ? 0x7FFFFFFF    # 68 years
                  : $opt_ref->{-timeout} == 0     ? -1
                  :                                 $opt_ref->{-timeout}
                  ;
  
      return sub {
          my ($extra_constraints) = @_;
  
          # Short-circuit on unreadable filehandle...
          return if !openhandle($in_fh);
  
          # Set up direct reading, and prepare to clean up on abnormal exit...
          Term::ReadKey::ReadMode('raw', $in_fh);
          my $prev_SIGINT = $SIG{INT};
          local $SIG{INT} = sub { return if $prev_SIGINT eq 'IGNORE';
                                  Term::ReadKey::ReadMode('restore', $in_fh);
                                  exit(1) if !defined $prev_SIGINT
                                          || $prev_SIGINT eq 'DEFAULT';
                                  {
                                      package main;
                                      no strict 'refs';
                                      $prev_SIGINT->()
                                  }
                            };
  
          # Set up local faked input, if any...
          my $local_fake_input;
          my $orig_fake_input;
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              $orig_fake_input = $local_fake_input = $1;
          }
  
          my $input = exists $opt_ref->{-prefill} ? $opt_ref->{-prefill} : q{};
          if (exists $opt_ref->{-prefill}) {
              if (exists $opt_ref->{-monitor}) {
                  my %opts = ( -cursor_pos => length($input),
                               -prompt     => $opt_ref->{-prompt},
                               -style      => $opt_ref->{-style}->(),
                               -echostyle  => $opt_ref->{-echostyle}->(),
                          );
                  my $input_copy = $input;
                  eval { $opt_ref->{-monitor}->($input_copy, \%opts) };
              }
              $outputter_ref->( -style => $opt_ref->{-style}, _wipe_line(), $opt_ref->{-prompt});
              $outputter_ref->( -echostyle => join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g) );
          }
  
          my $insert_offset = 0;
          INPUT:
          while (1) {
              state $prev_was_verbatim = 0;
              state $completion_level  = 0;
              state $completion_type   = q{};
  
              # Get next character entered...
              my $next = Term::ReadKey::ReadKey($timeout, $in_fh);
  
              # Check for cancellation...
              if (exists $opt_ref->{-cancel} && match($next, $opt_ref->{-cancel})) {
                  Term::ReadKey::ReadMode('restore', $in_fh);
                  die bless \$input, 'IO::Prompter::Cancellation';
              }
  
              # Finished with completion mode?
              if (($next//q{}) !~ m{ $COMPLETE_INIT | $COMPLETE_CYCLE }xms) {
                  $completion_level = 0;
                  $completion_type = q{};
              }
  
              # Are we faking input?
              my $faking = defined $local_fake_input;
  
              # If not EOF...
              if (defined $next) {
                  # Remember where we were parked...
                  my $prev_insert_offset = $insert_offset;
  
                  # Handle interrupts...
                  if ($next eq $ctrl{INTERRUPT}) {
                      $SIG{INT}();
                      next INPUT;
                  }
  
                  # Handle verbatim quoter...
                  elsif (!$prev_was_verbatim && $next eq $VERBATIM_KEY) {
                      $prev_was_verbatim = 1;
                      next INPUT;
                  }
  
                  # Handle completions...
                  elsif (!$prev_was_verbatim
                         && ( $next =~ $COMPLETE_INIT
                           || $completion_level > 0 && $next =~ $COMPLETE_CYCLE
                         )
                  ) {
                      state @completion_list;  # ...all candidates for completion
                      state @completion_ring;  # ..."next" candidate cycle
                      state $completion_ring_first;  # ...special case first time
                      state $completion_prefix;      # ...skipped before completing
  
                      # Track completion type and level (switch if necessary)...
                      if ($next =~ $COMPLETE_INIT && index($completion_type, $next) < 0) {
                          $completion_type = index($COMPLETE_KEY, $next) >= 0 ? $COMPLETE_KEY : $COMPLETE_HIST;
                          $completion_level = 1;
                      }
                      else {
                          $completion_level++;
                      }
  
                      # If starting completion, cache completions...
                      if ($completion_level == 1) {
                          ($completion_prefix, @completion_list)
                             = index($COMPLETE_KEY, $next) >= 0
                                  ? _current_completions_for($input, $opt_ref)
                                  : _current_history_for($input, $opt_ref);
                          @completion_ring = (@completion_list, q{});
                          $completion_ring_first = 1;
                      }
  
                      # Can only complete if there are completions to be had...
                      if (@completion_list) {
                          # Select the appropriate mode...
                          my $mode = $COMPLETE_MODE{$completion_type}[$completion_level-1]
                                  // $COMPLETE_MODE{$completion_type}[-1];
  
                          # 'longest mode' finds longest consistent prefix...
                          if ($mode =~ /longest/) {
                              $input
                                  = $completion_prefix
                                  . _longest_common_prefix_for(@completion_list);
                          }
                          # 'full mode' suggests next full match...
                          elsif ($mode =~ /full/) {
                              if (!$completion_ring_first) {
                                  if ($next eq $COMPLETE_PREV) {
                                      unshift @completion_ring,
                                              pop @completion_ring;
                                  }
                                  else {
                                      push @completion_ring,
                                           shift @completion_ring;
                                  }
                              }
                              $input = $completion_prefix . $completion_ring[0];
                              $completion_ring_first = 0;
                          }
                          # 'list mode' lists all possibilities...
                          my $list_display = $mode =~ /list/
                              ? _display_completions($input, @completion_list)
                              : q{};
  
                          # Update prompt with selected completion...
                          $outputter_ref->( -style =>
                              $list_display,
                              _wipe_line(),
                              $opt_ref->{-prompt}, $input
                          );
  
                          # If last completion was unique choice, completed...
                          if (@completion_list <= 1) {
                              $completion_level = 0;
                          }
                      }
                      next INPUT;
                  }
  
                  # Handle erasures (including pushbacks if faking)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{ERASE}) {
                      if (!length $input) {
                          # Do nothing...
                      }
                      elsif ($insert_offset) {
                          # Can't erase past start of input...
                          next INPUT if $insert_offset >= length($input);
  
                          # Erase character just before cursor...
                          substr($input, -$insert_offset-1, 1, q{});
  
                          # Redraw...
                          my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                          my $input_post = substr($input.' ',length($input)-$insert_offset);
                          my $display_pre
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                          my $display_post
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                              . q{ } x length($opt_ref->{-echo}(q{ }))
                              . "\b" x length($display_post)
                          );
                      }
                      else {
                          my $erased = substr($input, -1, 1, q{});
                          if ($faking) {
                              substr($local_fake_input,0,0,$erased);
                          }
                          $outputter_ref->( -nostyle =>
                              map { $_ x (length($opt_ref->{-echo}($_)//'X')) }
                                  "\b", ' ', "\b"
                          );
                      }
                      next INPUT;
                  }
  
                  # Handle EOF (including cancelling any remaining fake input)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{EOF}) {
                      Term::ReadKey::ReadMode('restore', $in_fh);
                      close $in_fh;
                      undef $fake_input;
                      return length($input) ? $input : undef;
                  }
  
                  # Handle escape from faking...
                  elsif (!$prev_was_verbatim && $faking && $next eq $FAKE_ESC) {
                      my $lookahead = Term::ReadKey::ReadKey(0, $in_fh);
  
                      # Two <ESC> implies the current faked line is deferred...
                      if ($lookahead eq $FAKE_ESC) {
                          $fake_input =~ s{ \A }{$orig_fake_input\n}xm;
                      }
                      # Only one <ESC> implies the current faked line is replaced...
                      else {
                          $in_fh->ungetc(ord($lookahead));
                      }
                      undef $local_fake_input;
                      $faking = 0;
                      next INPUT;
                  }
  
                  # Handle returns...
                  elsif (!$prev_was_verbatim && $next =~ /\A\R\z/) {
                      # Complete faked line, if faked input incomplete...
                      if ($faking && length($local_fake_input)) {
                          for ($local_fake_input =~ m/\X/g) {
                              _simulate_typing();
                              $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                          }
                          $input .= $local_fake_input;
                      }
  
                      # Add newline to the accumulated input string...
                      $input .= $next;
  
                      # Check that input satisfied any constraints...
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref,
                          $opt_ref, $extra_constraints,
                      );
  
                      # Echo a default value if appropriate...
                      if ($input =~ m{\A\R?\Z}xms && defined $opt_ref->{-def}) {
                          my $def_val = $opt_ref->{-def};
  
                          # Try to find the key, for a menu...
                          if (exists $opt_ref->{-menu_curr_level}) {
                              for my $key ( keys %{$opt_ref->{-menu_curr_level}}) {
                                  if (match($def_val, $opt_ref->{-menu_curr_level}{$key})) {
                                      $def_val = $key;
                                      last;
                                  }
                              }
                          }
  
                          # Echo it as if it had been typed...
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($def_val));
                      }
  
                      # Echo the return (or otherwise, as specified)...
                      $outputter_ref->(-echostyle => $opt_ref->{-return}($next));
  
                      # Clean up, and return the input...
                      Term::ReadKey::ReadMode('restore', $in_fh);
  
                      # Handle fake EOF...
                      if ($faking && $input =~ m{^ (?: \cD | \cZ) }xms) {
                          return undef;
                      }
  
                      return $input;
                  }
  
                  # Handle anything else...
                  elsif ($prev_was_verbatim || $next !~ /$ctrl/) {
                      # If so, get the next fake character...
                      if ($faking) {
                          $next = length($local_fake_input)
                                      ? substr($local_fake_input,0,1,q{})
                                      : q{};
                      }
  
                      # Handle editing...
                      if ($next eq $EDIT{BACK}) {
                          $insert_offset += ($insert_offset < length $input) ? 1 : 0;
                      }
                      elsif ($next eq $EDIT{FORWARD}) {
                          $insert_offset += ($insert_offset > 0) ? -1 : 0;
                      }
                      elsif ($next eq $EDIT{START}) {
                          $insert_offset = length($input);
                      }
                      elsif ($next eq $EDIT{END}) {
                          $insert_offset = 0;
                      }
  
                      # Handle non-editing...
                      else {
                          # Check for input restrictions...
                          if (exists $opt_ref->{-guarantee}) {
                              next INPUT if ($input.$next) !~ $opt_ref->{-guarantee};
                          }
  
                          # Add the new input char to the accumulated input string...
                          if ($insert_offset) {
                              substr($input, -$insert_offset, 0) = $next;
                              $prev_insert_offset++;
                          }
                          else {
                              $input .= $next;
                          }
                      }
  
                      # Display the character (or whatever was specified)...
  
                      if ($insert_offset || $prev_insert_offset) {
                          my $input_pre  = substr($input,0,length($input)-$prev_insert_offset);
                          my $input_post = substr($input,length($input)-$insert_offset);
                          my $display_pre
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                          my $display_post
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                              . "\b" x length($display_post)
                          );
                      }
                      elsif ($next !~ $EDIT_KEY) {
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($next));
                      }
  
                      # Not verbatim after this...
                      $prev_was_verbatim = 0;
                  }
                  else {
                      # Not verbatim after mysterious ctrl input...
                      $prev_was_verbatim = 0;
  
                      next INPUT;
                  }
              }
  
              if ($opt_ref->{-single} || !defined $next || $input =~ m{\Q$/\E$}) {
                  # Did we get an acceptable value?
                  if (defined $next) {
                      _verify_input_constraints(
                         \$input, \$local_fake_input, $outputter_ref,
                         $opt_ref, $extra_constraints,
                      );
                  }
  
                  # Reset terminal...
                  Term::ReadKey::ReadMode('restore', $in_fh);
  
                  # Return failure if failed before input or cancelled...
                  if (!defined $next && length($input) == 0
                  ||  exists $opt_ref->{-cancel} && match($next, $opt_ref->{-cancel})) {
                      return if $opt_ref->{-verbatim};
                      return PUREBOOL { 0 }
                                 BOOL { 0 }
                                 SCALAR { undef  }
                                 METHOD { defaulted => sub { 0 }, timedout  => sub { 0 } };
                  }
  
                  # Otherwise supply a final newline if necessary...
                  if ( $opt_ref->{-single}
                  &&   exists $opt_ref->{-return}
                  &&   $input !~ /\A\R\z/ ) {
                      $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}));
                  }
  
                  return $input;
              }
          }
          continue {
              # Perform monitor (if any) and redraw prompt (if required)...
              if ($opt_ref->{-monitor}) {
                  my %opts = ( -cursor_pos => length($input) - $insert_offset,
                               -prompt     => $opt_ref->{-prompt},
                               -style      => $opt_ref->{-style}->(),
                               -echostyle  => $opt_ref->{-echostyle}->(),
                          );
                  my $input_copy = $input;
                  my $output_pos = $outputter_ref->(-tell);
                  if (!defined eval { $opt_ref->{-monitor}->($input_copy, \%opts) }
                  ||  $output_pos != $outputter_ref->(-tell)) {
                      my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                      my $input_post = substr($input.' ',length($input)-$insert_offset);
                      my $display_pre
                          = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                      my $display_post
                          = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                      $outputter_ref->( -style => $opt_ref->{-style}, _wipe_line(), $opt_ref->{-prompt});
                      $outputter_ref->( -echostyle =>
                                      join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                                      . "\b" x (length($display_post)-1)
                      );
                  }
              }
          }
      }
  }
  
  # Build a menu...
  sub _build_menu {
      my ($source_ref, $initial_prompt, $is_numeric) = @_;
      my $prompt = ($initial_prompt//q{}) . qq{\n};
      my $final = q{};
      my %value_for;
      my %key_for;
      my @selectors;
  
      my $source_type = ref $source_ref;
      if ($source_type eq 'HASH') {
          my @sorted_keys = sort(keys(%{$source_ref}));
          @selectors = $is_numeric ? (1..@sorted_keys) : ('a'..'z','A'..'Z');
          @key_for{@selectors}   = @sorted_keys;
          @value_for{@selectors} = @{$source_ref}{@sorted_keys};
          $source_ref = \@sorted_keys;
      }
      elsif ($source_type eq 'SCALAR') {
          $source_ref = [ split "\n", ${$source_ref} ];
      }
  
      my @source = @{$source_ref};
      @selectors = $is_numeric ? (1..@source) : ('a'..'z','A'..'Z');
      if (!keys %value_for) {
          @value_for{@selectors} = @source;
      }
  
      ITEM:
      for my $tag (@selectors) {
          my $item = shift(@source) // last ITEM;
          chomp $item;
          $prompt .= sprintf("%4s. $item\n", $tag);
          $final = $tag;
      }
  
      if (@source) {
          _warn( misc =>
              "prompt(): Too many menu items. Ignoring the final " . @source
          );
      }
  
      my $constraint = $is_numeric       ? '(?:' . join('|',@selectors) .')'
                     : $final =~ /[A-Z]/ ? "[a-zA-$final]"
                     :                     "[a-$final]";
      my $constraint_desc = $is_numeric  ? "[1-$selectors[-1]]" : $constraint;
      $constraint = '\A\s*' . $constraint . '\s*\Z';
  
      return {
          data       => $source_ref,
          key_for    => \%key_for,
          value_for  => \%value_for,
          prompt     => "$prompt\n",
          is_numeric => $is_numeric,
          constraint => { "Enter $constraint_desc: " => qr/$constraint|$MENU_ESC/ },
      };
  }
  
  # Vocabulary that _stylize understands...
  my %synonyms = (
      bold      => [qw<boldly strong heavy emphasis emphatic highlight highlighted fort forte>],
      dark      => [qw<darkly dim deep>],
      faint     => [qw<faintly light soft>],
      underline => [qw<underlined underscore underscored>],
      italic    => [qw<italics>],
      blink     => [qw<blinking flicker flickering flash flashing>],
      reverse   => [qw<reversed inverse inverted>],
      concealed => [qw<hidden blank invisible>],
      reset     => [qw<normal default standard usual ordinary regular>],
      bright_   => [qw< bright\s+ vivid\s+ >],
      red       => [qw< scarlet vermilion crimson ruby cherry cerise cardinal carmine
                        burgundy claret chestnut copper garnet geranium russet
                        salmon titian coral cochineal rose cinnamon ginger gules >],
      yellow    => [qw< gold golden lemon cadmium daffodil mustard primrose tawny
                        amber aureate canary champagne citrine citron cream goldenrod honey straw >],
      green     => [qw< olive jade pea emerald lime chartreuse forest sage vert >],
      cyan      => [qw< aqua aquamarine teal turquoise ultramarine >],
      blue      => [qw< azure cerulean cobalt indigo navy sapphire >],
      magenta   => [qw< amaranthine amethyst lavender lilac mauve mulberry orchid periwinkle
                        plum pomegranate violet purple aubergine cyclamen fuchsia modena puce
                        purpure >],
      black     => [qw< charcoal ebon ebony jet obsidian onyx raven sable slate >],
      white     => [qw< alabaster ash chalk ivory milk pearl silver argent >],
  );
  
  # Back-mapping to standard terms...
  my %normalize
      = map { join('|', map { "$_\\b" } reverse sort @{$synonyms{$_}}) => $_ }
            keys %synonyms;
  
  my $BACKGROUND = qr{
       (\S+) \s+ (?: behind | beneath | below | under(?:neath)? )\b
     | \b (?:upon|over|on) \s+ (?:an?)? \s+ (.*?) \s+ (?:background|bg|field) \b
     | \b (?:upon\s+ | over\s+ | (?:(on|upon|over)\s+a\s+)?  (?:background|bg|field) \s+ (?:of\s+|in\s+)? | on\s+) (\S+)
  }ixms;
  
  # Convert a description to ANSI colour codes...
  sub _stylize {
      my $spec = shift // q{};
  
      # Handle arrays and hashes as args...
      if (ref($spec) eq 'ARRAY') {
          $spec = join q{ }, @{$spec};
      }
      elsif (ref($spec) eq 'HASH') {
          $spec = join q{ }, keys %{$spec};
      }
  
      # Ignore punctuation...
      $spec =~ s/[^\w\s]//g;
  
      # Handle backgrounds...
      $spec =~ s/$BACKGROUND/on_$+/g;
  
      # Apply standard translations...
      for my $pattern (keys %normalize) {
          $spec =~ s{\b(on_|\b) $pattern}{($1//q{}).$normalize{$pattern}}geixms;
      }
  
      # Ignore anything unknown...
      $spec =~ s{((?:on_)?(?:(ansi\d+|rgb\d+)|(\S+)))}{ $2 || exists $synonyms{$3} ? $1 : q{} }gxmse;
  
      # Build ANSI terminal codes around text...
      my $raw_text = join q{}, @_;
      my ($prews, $text, $postws) = $raw_text =~ m{\A (\s*) (.*?) (\s*) \Z}xms;
      my @style = split /\s+/, $spec;
      return $prews
           . ( @style ? Term::ANSIColor::colored(\@style, $text) : $text )
           . $postws;
  }
  
  # Build a subroutine that prints printable chars to the specified filehandle...
  sub _std_printer_to {
      my ($out_filehandle, $opt_ref) = @_;
      no strict 'refs';
      _autoflush($out_filehandle);
      if (eval { require Term::ANSIColor}) {
          return sub {
              my $style = shift;
              return tell($out_filehandle) if $style eq -tell;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} _stylize($opt_ref->{$style}(@loc), @loc);
          };
      }
      else {
          return sub {
              my $style = shift;
              return tell($out_filehandle) if $style eq -tell;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} @loc;
          };
      }
  }
  
  # Build a subroutine that prints to nowhere...
  sub _null_printer {
      return sub {};
  }
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Prompter - Prompt for input, read it, clean it, return it.
  
  
  =head1 VERSION
  
  This document describes IO::Prompter version 0.005001
  
  
  =head1 SYNOPSIS
  
      use IO::Prompter;
  
      while (prompt -num, 'Enter a number') {
          say "You entered: $_";
      }
  
      my $passwd
          = prompt 'Enter your password', -echo=>'*';
  
      my $selection
          = prompt 'Choose wisely...', -menu => {
                  wealth => [ 'moderate', 'vast', 'incalculable' ],
                  health => [ 'hale', 'hearty', 'rude' ],
                  wisdom => [ 'cosmic', 'folk' ],
            }, '>';
  
  
  =head1 CAVEATS
  
  =over
  
  =item 1.
  
  Several features of this module are known to have problems under
  Windows. If using that platform, you may have more success
  (and less distress) by trying IO::Prompt::Tiny, IO::Prompt::Simple,
  or IO::Prompt::Hooked first.
  
  =item 2.
  
  By default the C<prompt()> subroutine does not return a string; it
  returns an object with overloaded string and boolean conversions.
  This object B<I<always>> evaluates true in boolean contexts, unless the
  read operation actually failed. This means that the object evaluates
  true I<even when the input value is zero or
  an empty string.> See L<"Returning raw data"> to turn off this
  (occasionally counter-intuitive) behaviour.
  
  =back
  
  =head1 DESCRIPTION
  
  IO::Prompter exports a single subroutine, C<prompt>, that prints a
  prompt (but only if the program's selected input and output streams are
  connected to a terminal), then reads some input, then chomps it, and
  finally returns an object representing that text.
  
  The C<prompt()> subroutine expects zero-or-more arguments.
  
  Any argument that starts with a hyphen (C<->) is treated as a named
  option (many of which require an associated value, that may be passed as
  the next argument). See L<"Summary of options"> and L<"Options
  reference"> for details of the available options.
  
  Any other argument that is a string is treated as (part of) the prompt
  to be displayed. All such arguments are concatenated together before the
  prompt is issued. If no prompt string is provided, the string
  C<< '> ' >> is used instead.
  
  Normally, when C<prompt()> is called in either list or scalar context,
  it returns an opaque object that autoconverts to a string. In scalar
  boolean contexts this return object evaluates true if the input
  operation succeeded. In list contexts, if the input operation fails
  C<prompt()> returns an empty list instead of a return object. This
  allows failures in list context to behave correctly (i.e. be false).
  
  If you particularly need a list-context call to C<prompt()> to always
  return a value (i.e. even on failure), prefix the call with C<scalar>:
  
      # Only produces as many elements
      # as there were successful inputs...
      my @data = (
          prompt(' Name:'),
          prompt('  Age:'),
          prompt('Score:'),
      );
  
      # Always produces exactly three elements
      # (some of which may be failure objects)...
      my @data = (
          scalar prompt(' Name:'),
          scalar prompt('  Age:'),
          scalar prompt('Score:'),
      );
  
  In void contexts, C<prompt()> still requests input, but also issues a
  warning about the general uselessness of performing an I/O operation
  whose results are then immediately thrown away.
  See L<"Useful useless uses of C<prompt()>"> for an exception to this.
  
  The C<prompt()> function also sets C<$_> if it is called in a boolean
  context but its return value is not assigned to a variable. Hence, it is
  designed to be a drop-in replacement for C<readline> or C<< <> >>.
  
  =head1 INTERFACE
  
  All the options for C<prompt()> start with a hyphen (C<->).
  Most have both a short and long form. The short form is always
  the first letter of the long form.
  
  Most options have some associated value. For short-form options, this
  value is specified as a string appended to the option itself. The
  associated value for long-form options is always specified as a
  separated argument, immediately following the option (typically
  separated from it by a C<< => >>).
  
  Note that this implies that short-form options may not be able to
  specify every possible associated value (for example, the short-form
  C<-d> option cannot specify defaults with values C<'efault'> or
  C<'$%^!'>).  In such cases, just use the long form of the option
  (for example: S<< C<< -def => 'efault' >> >> or C<< -default=>'$%^!' >>).
  
  
  =head2 Summary of options
  
  Note: For options preceded by an asterisk, the short form is actually
  a Perl file operator, and hence cannot be used by itself.
  Either use the long form of these options,
  or L<bundle them with another option|"Bundling short-form options">,
  or add a L<"no-op"|"Escaping otherwise magic options"> to them.
  
  
      Short   Long
      form    form               Effect
      =====   =============      ======================================
  
      -a      -argv              Prompt for @ARGV data if !@ARGV
  
              -cancel=>SPEC      Immediately fail if input char smartmatches value
  
              -comp[lete]=>SPEC  Complete input on <TAB>, as specified
  
      -dSTR   -def[ault]=>STR    What to return if only <ENTER> typed
              -DEF[AULT]=>STR    (as above, but skip any -must checking)
  
    * -e[STR] -echo=>STR         Echo string for each character typed
  
              -echostyle=>SPEC   What colour/style to echo input in
  
    * -f      -filenames         Input should be name of a readable file
  
              -fail=>VALUE       Return failure if completed input smartmatches value
  
              -guar[antee]=>SPEC Only allow the specified words to be entered
  
      -h[STR] -hist[ory][=>SPEC] Specify the history set this call belongs to
  
              -in=>HANDLE        Read from specified handle
  
      -i      -integer[=>SPEC]   Accept only valid integers (that smartmatch SPEC)
  
      -k      -keyletters        Accept only keyletters (as specified in prompt)
  
    * -l      -line              Don't autochomp
  
              -menu=>SPEC        Specify a menu of responses to be displayed
  
              -must=>HASHREF     Specify requirements/constraints on input
  
              -monitor=>SUBREF   Specify a sub to be called on every character input
  
      -n      -num[ber][=>SPEC]  Accept only valid numbers (that smartmatch SPEC)
  
              -out=>HANDLE       Prompt to specified handle
  
              -prefill=>STR      Start with the specified string pre-entered
  
              -prompt=>STR       Specify prompt explicitly
  
    * -rSTR   -ret[urn]=>STR     After input, echo this string instead of <CR>
  
    * -s -1   -sing[le]          Return immediately after first key pressed
  
              -stdio             Use STDIN and STDOUT for prompting
  
              -style=>SPEC       What colour/style to display the prompt text in
  
      -tNUM   -time[out]=>NUM    Specify a timeout on the input operation
  
      -v      -verb[atim]        Return the input string (no context sensitivity)
  
              -void              Don't complain in void context
  
    * -w      -wipe              Clear screen
              -wipefirst         Clear screen on first prompt() call only
  
    * -y      -yes    [=> NUM]   Return true if [yY] entered, false otherwise
      -yn     -yesno  [=> NUM]   Return true if [yY] entered, false if [nN]
      -Y      -Yes    [=> NUM]   Return true if Y entered, false otherwise
      -YN     -YesNo  [=> NUM]   Return true if Y entered, false if N
  
    * -_                         No-op (handy for bundling ambiguous short forms)
  
  
  =head2 Automatic options
  
  Any of the options listed above (and described in detail below) can be
  automatically applied to every call to C<prompt()> in the current
  lexical scope, by passing them (via an array reference) as the arguments
  to a C<use IO::Prompter> statement.
  
  For example:
  
      use IO::Prompter;
  
      # This call has no automatically added options...
      my $assent = prompt "Do you wish to take the test?", -yn;
  
      {
          use IO::Prompter [-yesno, -single, -style=>'bold'];
  
          # These three calls all have: -yesno, -single, -style=>'bold' options
          my $ready = prompt 'Are you ready to begin?';
          my $prev  = prompt 'Have you taken this test before?';
          my $hints = prompt 'Do you want hints as we go?';
      }
  
      # This call has no automatically added options...
      scalar prompt 'Type any key to start...', -single;
  
  The current scope's lexical options are always I<prepended> to the
  argument list of any call to C<prompt()> in that scope.
  
  To turn off any existing automatic options for the rest of the current
  scope, use:
  
      use IO::Prompter [];
  
  
  =head2 Prebound options
  
  You can also ask IO::Prompter to export modified versions of C<prompt()>
  with zero or more options prebound. For example, you can request an
  C<ask()> subroutine that acts exactly like C<prompt()> but has the C<-
  yn> option pre-specified, or a C<pause()> subroutine that is C<prompt()>
  with a "canned" prompt and the C<-echo>, C<-single>, and C<-void> options.
  
  To specify such subroutines, pass a single hash reference when
  loading the module:
  
      use IO::Prompter {
          ask     => [-yn],
          pause   => [-prompt=>'(Press any key to continue)', -echo, -single, -void],
      }
  
  Each key will be used as the name of a separate subroutine to be
  exported, and each value must be an array reference, containing the
  arguments that are to be automatically supplied.
  
  The resulting subroutines are simply lexically scoped wrappers around
  C<prompt()>, with the specified arguments prepended to the normal
  argument list, equivalent to something like:
  
      my sub ask {
          return prompt(-yn, @_);
      }
  
      my sub pause {
          return prompt(-prompt=>'(Press any key to continue)', -echo, -single, -void, @_);
      }
  
  Note that these subroutines are lexically scoped, so if you want to use
  them throughtout a source file, they should be declared in the outermost
  scope of your program.
  
  
  =head2 Options reference
  
  =head3 Specifying what to prompt
  
  =over 4
  
  C<< -prompt => I<STRING> >>
  
  C<< -pI<STRING> >>
  
  =back
  
  By default, any argument passed to C<prompt()> that does not begin with
  a hyphen is taken to be part of the prompt string to be displayed before
  the input operation. Moreover, if no such string is specified in the
  argument list, the function supplies a default prompt (C<< '> ' >>)
  automatically.
  
  The C<-prompt> option allows you to specify a prompt explicitly, thereby
  enabling you to use a prompt that starts with a hyphen:
  
      my $input
          = prompt -prompt=>'-echo';
  
  or to disable prompting entirely:
  
      my $input
          = prompt -prompt => "";
  
  Note that the use of the C<-prompt> option doesn't override other string
  arguments, it merely adds its argument to the collective prompt.
  
  =head4 Prompt prettification
  
  If the specified prompt ends in a non-whitespace character, C<prompt()>
  adds a single space after it, to better format the output. On the other
  hand, if the prompt ends in a newline, C<prompt()> removes that
  character, to keep the input position on the same line as the prompt.
  
  You can use that second feature to override the first, if necessary. For
  example, if you wanted your prompt to look like:
  
      Load /usr/share/dict/_
  
  (where the _ represents the input cursor), then a call like:
  
      $filename = prompt 'Load /usr/share/dict/';
  
  would not work because it would automatically add a space, producing:
  
      Load /usr/share/dict/ _
  
  But since a terminal newline is removed, you could achieve the desired effect
  with:
  
      $filename = prompt "Load /usr/share/dict/\n";
  
  If for some reason you I<do> want a newline at the end of the prompt (i.e.
  with the input starting on the next line) just put two newlines at the end
  of the prompt. Only the very last one will be removed.
  
  
  =head3 Specifying how the prompt looks
  
  =over 4
  
  C<< -style  => I<SPECIFICATION> >>
  
  =back
  
  If the C<Term::ANSIColor> module is available, this option can be used
  to specify the colour and styling (e.g. bold, inverse, underlined, etc.)
  in which the prompt is displayed.
  
  You can can specify that styling as a single string:
  
      prompt 'next:' -style=>'bold red on yellow';
  
  or an array of styles:
  
      prompt 'next:' -style=>['bold', 'red', 'on_yellow'];
  
  The range of styles and colour names that the option understands is
  quite extensive. All of the following work as expected:
  
      prompt 'next:' -style=>'bold red on yellow';
  
      prompt 'next:' -style=>'strong crimson on gold';
  
      prompt 'next:' -style=>'highlighted vermilion, background of cadmium';
  
      prompt 'next:' -style=>'vivid russet over amber';
  
      prompt 'next:' -style=>'gules fort on a field or';
  
  However, because C<Term::ANSIColor> sometmes maps everything back to the
  standard eight ANSI text colours and seven ANSI text styles, all of the
  above may also be rendered identically. See that module's
  documentation for details.
  
  If C<Term::ANSIColor> is not available, this option is silently ignored.
  
  Please bear in mind that up to 10% of people using your interface will
  have some form of colour vision impairment, so its always a good idea
  to differentiate information by style I<and> colour, rather than by colour
  alone. For example:
  
      if ($dangerous_action) {
          prompt 'Really proceed?', -style=>'bold red underlined';
      }
      else {
          prompt 'Proceed?', -style=>'green';
      }
  
  Also bear in mind that (even though C<-style> does support the C<'blink'>
  style) up to 99% of people using your interface will have Flashing Text
  Tolerance Deficiency. Just say "no".
  
  
  =head3 Specifying where to prompt
  
  =over 4
  
  C<< -out => FILEHANDLE >>
  
  C<< -in => FILEHANDLE >>
  
  C<< -stdio >>
  
  =back
  
  The C<-out> option (which has no short form) is used to specify
  where the prompt should be written to. If this option is not specified,
  prompts are written to the currently C<select>-ed filehandle. The most
  common usage is:
  
      prompt(out => *STDERR)
  
  The C<-in> option (which also has no short form) specifies where the input
  should be read from. If this option is not specified, input is read from
  the C<*ARGV> filehandle. The most common usage is:
  
      prompt(in => *STDIN)
  
  in those cases where C<*ARGV> has been opened to a file, but you still
  wish to interact with the terminal (assuming C<*STDIN> is opened to that
  terminal).
  
  The C<-stdio> option (which again has no short form) is simply a shorthand
  for: C<< -in => *STDIN, -out => *STDOUT >>. This is particularly useful when
  there are arguments on the commandline, but you don't want prompt to treat
  those arguments as filenames for magic C<*ARGV> reads.
  
  
  =head3 Specifying how long to wait for input
  
  =over 4
  
  C<< -timeout => I<N> >>
  
  C<< -tI<N> >>
  
  =back
  
  Normally, the C<prompt()> function simply waits for input. However,
  you can use this option to specify a timeout on the read operation.
  If no input is received within the specified I<N> seconds, the call
  to C<prompt()> either returns the value specified by
  L<the C<-default> option|"Specifying what to return by default">
  (if any), or else an object indicating the read failed.
  
  Note that, if the short form is used, I<N> must be an integer. If the long
  form is used, I<N> may be an integer or floating point value.
  
  You can determine whether an input operation timed out, even if a
  default value was returned, by calling the C<timedout()> method on the
  object returned by C<prompt()>:
  
      if (prompt('Continue?', -y1, -timeout=>60) && !$_->timedout) {
          ...
      }
  
  If a time-out occurred, the return value of C<timedout()> is a string
  describing the timeout, such as:
  
      "timed out after 60 seconds"
  
  
  =head3 Prefilling the input
  
  =over
  
  =item C<< -prefill => I<STRING> >>
  
  =back
  
  Normally, the cursor is placed immediately after the prompt
  in preparation for input. Initially, of course, there is no input.
  
  However, using the C<-prefill> option it is possible to initialize
  the input buffer with an arbitrary string of text (rather than the
  usual empty string)...as if that text had already been entered.
  
  This is useful when a prompt is re-issued so as to allow the user
  to extend, truncate, or otherwise edit a previous input.
  
  
  =head3 Providing a menu of responses
  
  =over
  
  =item C<< -menu => I<SPECIFICATION> >>
  
  =back
  
  You can limit the allowable responses to a prompt, by providing a menu.
  
  A menu is specified using the C<-menu> option, and the menu choices
  are specified as an argument to the option, either as a reference to
  an array, hash, or string, or else as a literal string.
  
  If the menu is specified in a hash, C<prompt()> displays the keys of the
  hash, sorted alphabetically, and with each alternative marked with a
  single alphabetic character (its "selector key").
  
  For example, given:
  
      prompt 'Choose...',
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will display:
  
      Choose...
          a. die
          b. live free
          c. transcend
      > _
  
  It will then only permit the user to enter a valid selector key (in the
  previous example: 'a', 'b', or 'c'). Once one of the alternatives is
  selected, C<prompt()> will return the corresponding value from the hash
  (0, 1, or -1, respectively, in this case).
  
  Note that the use of alphabetics as selector keys inherently limits the
  number of usable menu items to 52. See L<"Numeric menus"> for a way to
  overcome this limitation.
  
  A menu is treated like a special kind of prompt, so that any
  other prompt strings in the C<prompt()> call will appear either before or
  after the menu of choices, depending on whether they appear before or
  after the menu specification in the call to C<prompt()>.
  
  If an array is used to specify the choices:
  
      prompt 'Choose...',
             -menu=>[ 'live free', 'die', 'transcend' ],
             '>';
  
  then each array element is displayed (in the original array order) with
  a selector key:
  
      Choose...
          a. live free
          b. die
          c. transcend
      > _
  
  and C<prompt()> returns the element corresponding to the selection (i.e.
  it returns 'live free' if 'a' is entered, 'die' if 'b' is entered, or
  'transcend' if 'c' is entered).
  
  Hence, the difference between using an array and a hash is that the
  array allows you to control the order of items in the menu, whereas a
  hash allows you to show one thing (i.e. keys) but have something related
  (i.e. values) returned instead.
  
  If the argument after C<-menu> is a string or a reference to a string, the
  option splits the string on newlines, and treats the resulting list as if it
  were an array of choices. This is useful, for example, to request the user
  select a filename:
  
      my $files = `ls`;
      prompt 'Select a file...', -menu=>$files, '>';
  
  
  =head4 Numbered menus
  
  As the previous examples indicate, each menu item is given a unique
  alphabetic selector key. However, if the C<-number> or C<-integer>
  option is specified as well:
  
      prompt 'Choose...',
             -number,
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will number each menu item instead, using consecutive integers
  as the selector keys:
  
      Choose...
          1. die
          2. live free
          3. transcend
      > _
  
  This allows for an unlimited number of alternatives in a single menu,
  but prevents the use of C<-single> for one-key selection from menus if
  the menu has more than nine items.
  
  
  =head4 Hierarchical menus
  
  If you use a hash to specify a menu, the values of the hash do not have
  to be strings. Instead, they can be references to nested hashes or
  arrays.
  
  This allows you to create hierarchical menus, where a selection at the
  top level may lead to a secondary menu, etc. until an actual choice is
  possible. For example, the following call to prompt:
  
      my $choices = {
          animates => {
              animals => {
                  felines => [qw<cat lion lynx>],
                  canines => [qw<dog fox wolf>],
                  bovines => [qw<cow ox buffalo>],
              },
              fish => [qw<shark carp trout bream>],
          },
          inanimates => {
              rocks     => [qw<igneous metamorphic sedimentary>],
              languages => [qw<Perl Python Ruby Tcl>],
          },
      };
  
      my $result = prompt -1, 'Select a species...', -menu=>$choices, '> ';
  
  might result in an interaction like this:
  
      Select a species...
      a.  animates
      b.  inanimates
      > a
  
      Select from animates:
      a.  animals
      b.  fish
      > b
  
      Select from fish:
      a.  shark
      b.  carp
      c.  trout
      d.  bream
      > c
  
  At which point, C<prompt()> would return the string C<'trout'>.
  
  Note that you can nest an arbitrary number of hashes, but that each
  "bottom" level choice has to be either a single string, or an array
  of strings.
  
  
  =head4 Navigating hierarchical menus
  
  Within a hierarchical menu, the user must either select a valid option
  (by entering the corresponding letter), or else may request that they be
  taken back up a level in the hierarchy, by entering C<< <ESC> >>.
  Pressing C<< <ESC> >> at the top level of a menu causes the call to
  C<prompt()> to immediately return with failure.
  
  
  =head3 Simulating a command-line
  
  =over 4
  
  C<< -argv >>
  
  C<< -a  >>
  
  =back
  
  The C<prompt()> subroutine can be used to request that the user provide
  command-line arguments interactively. When requested, the input
  operation is only carried out if C<@ARGV> is empty.
  
  Whatever the user enters is broken into a list and assigned to C<@ARGV>.
  
  The input is first C<glob>bed for file expansions, and has any
  environment variables (of the form C<$VARNAME> interpolated). The
  resulting string is then broken into individual words, except where
  parts of it contain single or double quotes, the contents of which are
  always treated as a single string.
  
  This feature is most useful during development, to allow a program to be
  run from within an editor, and yet pass it a variety of command-lines. The
  typical usage is (at the start of a program):
  
      use IO::Prompter;
      BEGIN { prompt -argv }
  
  However, because this pattern is so typical, there is a shortcut:
  
      use IO::Prompter -argv;
  
  You can also specify the name with which the program args, are to
  be prompted, in the usual way (i.e. by providing a prompt):
  
      use IO::Prompter -argv, 'demo.pl';
  
  Note, however, the critical difference between that shortcut
  (which calls C<prompt -argv> when the module is loaded) and:
  
      use IO::Prompter [-argv];
  
  (which sets C<-argv> as an automatic option for every subsequent call to
  C<prompt()> in the current lexical scope).
  
  Note too that the C<-argv> option also implies C<-complete=>'filenames'>.
  
  
  =head3 Input autocompletion
  
  =over 4
  
  C<< -comp[lete] => I<SPECIFICATION> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will complete
  input using the specified collection of strings. By default, when
  completion is active, word completion is requested using the C<< <TAB> >>
  key, but this can be changed by setting the C<$IO_PROMPTER_COMPLETE_KEY>
  environment variable. Once completion has been initiated, you can use
  the completion key or else C<< <CTRL-N> >> to advance to the next completion
  candidate. You can also use C<< <CTRL-P> >> to back up to the previous
  candidate.
  
  The specific completion mechanism can be defined either using a
  subroutine, an array reference, a hash reference, or a special string:
  
      Specification       Possible completions supplied by...
  
        sub {...}         ...whatever non-subroutine specification
                          (as listed below) is returned when the
                          subroutine is called. The subroutine is passed
                          the words of the current input text, split on
                          whitespace, as its argument list.
  
          [...]           ...the elements of the array
  
          {...}           ...the keys of the hash
  
       'filenames'        ...the list of files supplied by globbing the
                          last whitespace-separated word of the input text
  
       'dirnames'         ...the list of directories supplied by globbing the
                          last whitespace-separated word of the input text
  
  If an array or hash is used, only those elements or keys that begin with
  the last whitespace-separated word of the current input are offered as
  completions.
  
  For example:
  
      # Complete with the possible commands...
      my $next_cmd
          = prompt -complete => \%cmds;
  
      # Complete with valid usernames...
      my $user
          = prompt -complete => \@usernames;
  
      # Complete with valid directory names...
      my $file
          = prompt -complete => 'dirnames';
  
      # Complete with cmds on the first word, and filenames on the rest...
      my $cmdline
          = prompt -complete => sub { @_ <= 1 ? \%cmds : 'filenames' };
  
  
  =head4 Completing from your own input history
  
  The C<prompt()> subroutine also tracks previous input and allows you to
  complete with that instead. No special option is required, as the
  feature is enabled by default.
  
  At the start of a prompted input, the user can cycle backwards through
  previous inputs by pressing C<< <CTRL-R> >> (this can be changed
  externally by setting the C<$IO_PROMPTER_HISTORY_KEY> environment
  variable, or internally by assigning a new keyname to
  C<$ENV{IO_PROMPTER_HISTORY_KEY}>). After the first C<< <CTRL-R> >>,
  subsequent C<< <CTRL-R> >>'s will recall earlier inputs. You can also
  use C<< <CTRL-N> >> and C<< <CTRL-P> >>
  (as in L<user-specified completions|"Input autocompletion">) to move
  back and forth through your input history.
  
  If the user has already typed some input, the completion mechanism
  will only show previous inputs that begin with that partial input.
  
  
  =head4 History sets
  
  =over 4
  
  =item C<< -h[NAME] >>
  
  =item C<< -hist[ory] [=> NAME] >>
  
  =back
  
  By default, IO::Prompter tracks every call to C<prompt()> within a
  program, and accumulates a single set of history completions for all of
  them. That means that, at any prompt, C<< <CTRL-R> >> will take the user
  back through I<every> previous input, regardless of which call to
  C<prompt()> originally retrieved it.
  
  Sometimes that's useful, but sometimes you might prefer that different
  calls to C<prompt()> retained distinct memories. For example, consider
  the following input loop:
  
      while (my $name = prompt 'Name:') {
          my $grade   = prompt 'Grade:', -integer;
          my $comment = prompt 'Comment:';
          ...
      }
  
  If you're entering a name, there's no point in C<prompt()> offering
  to complete it with previous grades or comments. In fact, that's
  just annoying.
  
  IO::Prompter allows you to specify that a particular call to
  C<prompt()> belongs to a particular "history set". Then it completes
  input history using only the history of those calls belonging to the
  same history set.
  
  So the previous example could be improved like so:
  
      while (my $name = prompt 'Name:', -hNAME) {
          my $grade   = prompt 'Grade:', -hGRADE, -integer;
          my $comment = prompt 'Comment:', -hOTHER;
          ...
      }
  
  Now, when prompting for a name, only those inputs in the C<'NAME'>
  history set will be offered as history completions. Likewise only
  previous grades will be recalled when prompting for grades and earlier
  only comments when requesting comments.
  
  If you specify the C<-h> or C<-history> option without providing the
  name of the required history set, C<prompt()> uses the prompt text
  itself as the name of the call's history set. So the previous example
  would work equally well if written:
  
      while (my $name = prompt 'Name:', -h) {
          my $grade   = prompt 'Grade:', -h, -integer;
          my $comment = prompt 'Comment:', -h;
          ...
      }
  
  though now the names of the respective history sets would now be
  C<'Name: '>, C<'Grade: '>, and C<'Comment: '>. This is by far the more
  common method of specifying history sets, with explicitly named sets
  generally only being used when two or more separate calls to
  C<prompt()> have to share a common history despite using distinct
  prompts. For example:
  
      for my $n (1..3) {
          $address .= prompt "Address (line $n):", -hADDR;
      }
  
  If you specify C<'NONE'> as the history set, the input is not
  recorded in the history. This is useful when inputting passwords.
  
  
  =head4 Configuring the autocompletion interaction
  
  By default, when user-defined autocompletion is requested, the
  C<prompt()> subroutine determines the list of possible completions,
  displays it above the prompt, and completes to the longest common
  prefix. If the completion key is pressed again immediately, the
  subroutine then proceeds to complete with each possible completion in a
  cyclic sequence. This is known as "list+longest full" mode.
  
  On the other hand, when historical completion is requested, C<prompt()>
  just immediately cycles through previous full inputs. This is known as "full"
  mode.
  
  You can change these behaviours by setting the
  C<$IO_PROMPTER_COMPLETE_MODES> and C<$IO_PROMPTER_HISTORY_MODES>
  environment variables I<before the module is loaded> (either in your shell,
  or in a C<BEGIN> block before the module is imported).
  
  Specifically, you can set the individual string values of either of
  these variables to a whitespace-separated sequence containing any of the
  following:
  
      list         List all options above the input line
  
      longest      Complete to the longest common prefix
  
      full         Complete with each full match in turn
  
  For example:
  
      # Just list options without actually completing...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'list'; }
  
      # Just cycle full alternatives on each <TAB>...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'full'; }
  
      # For history completion, always start with the
      # longest common prefix on the first <CTRL-R>,
      # then just list the alternatives on a subsequent press...
      BEGIN{ $ENV{IO_PROMPTER_HISTORY_MODES} = 'longest list'; }
  
  
  =head3 Specifying what to return by default
  
  =over
  
  C<< -DEF[AULT] => I<STRING> >>
  
  C<< -def[ault] => I<STRING> >>
  
  C<< -dI<STRING> >>
  
  =back
  
  If a default value is specified, that value will be returned if the user
  enters an empty string at the prompt (i.e. if they just hit
  C<< <ENTER>/<RETURN> >> immediately) or if the input operation times out under
  L<the C<timeout> option|"Specifying how long to wait for input">.
  
  Note that the default value is not added to the prompt, unless you
  do so yourself. A typical usage might therefore be:
  
      my $frequency
          = prompt "Enter polling frequency [default: $DEF_FREQ]",
                   -num, -def=>$DEF_FREQ;
  
  You can determine if the default value was autoselected (as opposed to
  the same value being typed in explicitly) by calling the C<defaulted()>
  method on the object returned by C<prompt()>, like so:
  
      if ($frequency->defaulted) {
          say "Using default frequency";
      }
  
  If you use the L<< C<-must> option|"Constraining what can be returned" >>
  any default value must also satisfy all the constraints you specify,
  unless you use the C<-DEFAULT> form, which skips constraint checking
  when the default value is selected.
  
  If you use the L<< C<-menu> option|"Providing a menu of responses" >>,
  the specified default value will be returned immediately C<< <ENTER>/<RETURN> >> is
  pressed, regardless of the depth you are within the menu. Note that the
  default value specifies the value to be returned, not the selector key
  to be entered. The default value does not even have to be one of the
  menu choices.
  
  
  =head3 Specifying what to echo on input
  
  =over
  
  C<< -echo => I<STR> >>
  
  C<< -eI<STR> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will echo the
  specified string once for each character that is entered. Typically this
  would be used to shroud a password entry, like so:
  
      # Enter password silently:
      my $passwd
          = prompt 'Password:', -echo=>"";
  
      # Echo password showing only asterisks:
      my $passwd
          = prompt 'Password:', -echo=>"*";
  
  As a special case, if the C<-echo> value contains a slash (C</>) and the
  any of the <-yesno> options is also specified, the substring before the
  slash is taken as the string to echo for a 'yes' input, and the
  substring after the slash is echoed for a 'no' input.
  
  Note that this option is only available when the Term::ReadKey module
  is installed. If it is used when that module is not available, a warning
  will be issued.
  
  
  =head4 Specifying how to echo on input
  
  C<< -echostyle => I<SPECIFICATION> >>
  
  The C<-echostyle> option works for the text the user types in
  the same way that the C<-style> option works for the prompt.
  That is, you can specify the style and colour in which the user's
  input will be rendered like so:
  
      # Echo password showing only black asterisks on a red background:
      my $passwd
          = prompt 'Password:', -echo=>"*", -echostyle=>'black on red';
  
  Note that C<-echostyle> is completely independent of C<-echo>:
  
      # Echo user's name input in bold white:
      my $passwd
          = prompt 'Name:', -echostyle=>'bold white';
  
  The C<-echostyle> option requires C<Term::ANSIColor>, and will
  be silently ignored if that module is not available.
  
  
  =head4 Input editing
  
  When the Term::ReadKey module is available, C<prompt()> also honours a
  subset of the usual input cursor motion commands:
  
  =over
  
  =item C<CTRL-B>
  
  Move the cursor back one character
  
  =item C<CTRL-F>
  
  Move the cursor forward one character
  
  =item C<CTRL-A>
  
  Move the cursor to the start of the input
  
  =item C<CTRL-E>
  
  Move the cursor to the end of the input
  
  =back
  
  
  =head3 Specifying when input should fail
  
  =over 4
  
  C<< -fail => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, the final input value is compared with the
  associated string or value, by smartmatching just before the call to
  C<prompt()> returns. If the two match, C<prompt()> returns a failure
  value. This means that instead of writing:
  
      while (my $cmd = prompt '>') {
          last if $cmd eq 'quit';
          ...
      }
  
  you can just write:
  
      while (my $cmd = prompt '>', -fail=>'quit') {
          ...
      }
  
  
  =head3 Specifying when input should fail immediately
  
  =over 4
  
  C<< -cancel => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, then each individual input character is compared
  with the associated string or value, by smartmatching during the input process.
  If any individual input character matches the string/value, C<prompt()>
  immediately returns a failure value.
  
  Note that this is not the same as the behaviour C<-fail> option. A C<-fail>
  waits for the entire input to be completed (typically for a RETURN to be entered)
  and I<then> tests for failure. A C<-cancel> tests each input character as it is
  entered and fails immediately if any input matches the cancellation condition.
  
  Do, for example, to cancel a prompt whenever an ESCAPE character is entered:
  
      my $input = prompt '>', -cancel => "\e";
  
  Note that (as long as Term::ReadKey is available) the cancellation test
  is performed before any other internal processing, so you can set the
  cancellation criterion to be any character, including characters like CNTL-A or
  TAB, which otherwise have special meanings to C<prompt()>.
  
  Note too that the cancellation criterion is tested against each individual
  character as it is entered, B<not> against the cumulative input so far.
  If you need to cancel a call to C<prompt()> based on accumulated input,
  you need to track that yourself. For example, if your cancellation test
  is the presence of three consecutive exclamation marks:
  
      my $input = prompt '>', -cancel => sub ($nextchar) {
                                  state $input;
                                  $input .= $nextchar;
                                  return $input =~ /!!!/;
                              };
  
  
  =head3 Constraining what can be typed
  
  =over 4
  
  =item C<< -guar[antee] => SPEC >>
  
  =back
  
  This option allows you to control what input users can provide.
  The specification can be a regex or a reference to an array or a hash.
  
  If the specification is a regex, that regex is matched against the input
  so far, every time an extra character is input. If the regex ever fails
  to match, the guarantee fails.
  
  If the specification is an array, the input so far is matched against
  the same number of characters from the start of each of the (string)
  elements of the array. If none of these substrings match the input, the
  guarantee fails.
  
  If the specification is a hash, the input so far is matched against the
  same number of characters from the start of each key of the hash. If
  none of these substrings match the input, the guarantee fails.
  
  If the guarantee fails, the input is rejected
  (just as L<< the C<-must> option|"Constraining what can be returned" >>
  does). However, unlike C<-must>, C<-guarantee> rejects the input
  character-by-character as it typed, and I<before> it is even echoed. For
  example, if your call to C<prompt()> is:
  
      my $animal = prompt -guarantee=>['cat','dog','cow'];
  
  then at the prompt:
  
      > _
  
  you will only be able to type in 'c' or 'd'. If you typed 'c', then you would
  only be able to type 'a' or 'o'. If you then typed 'o', you would only be able
  to type 'w'.
  
  In other words, C<-guarantee> ensures that you can only type in a valid input,
  and simply ignores any typing that would not lead to such an input.
  
  To help users get the input right, specifying C<-guarantee> as an array
  or hash reference also automatically specifies a
  L<< C<-complete> option|"Input autocompletion" >> with the array or hash
  as its completion list as well. So, whenever a C<-guarantee> is in
  effect, the user can usually autocomplete the acceptable inputs.
  
  Note, however, that C<-guarantee> can only reject (or autocomplete)
  input as it is typed if the Term::ReadKey module is available. If that
  module cannot be loaded, C<-guarantee> only applies its test after the
  C<< <ENTER>/<RETURN> >> key is pressed, and there will be no autocompletion
  available.
  
  =head4 Constraining input to numbers
  
  =over 4
  
  =item C<< -i >>
  
  =item C<< -integer [=> SPEC] >>
  
  =item C<< -n  >>
  
  =item C<< -num[ber] [=> SPEC] >>
  
  =back
  
  If any of these options are specified, C<prompt()> will only accept a valid
  integer or number as input, and will reprompt until one is entered.
  
  If you need to restrict the kind of number further (say, to positive
  integers), you can supply an extra constraint as an argument to the
  long-form option. Any number entered must satisfy this constraint by
  successfully smart-matching it. For example:
  
      $rep_count = prompt 'How many reps?', -integer => sub{ $_ > 0 };
  
      $die_roll = prompt 'What did you roll?', -integer => [1..6];
  
      $factor = prompt 'Prime factor:', -integer => \&is_prime;
  
      $score = prompt 'Enter score:', -number => sub{ 0 <= $_ && $_ <= 100 };
  
  If the constraint is specified as a subroutine, the entered number will be
  passed to it both as its single argument and in C<$_>.
  
  You cannot pass a scalar value directly as a constraint, except those strings
  listed below. If you want a scalar value as a constraint, use a regex or
  array reference instead:
  
      # Wrong...
      $answer = prompt "What's the ultimate answer?",
                        -integer => 42;
  
      # Use this instead...
      $answer = prompt "What's the ultimate answer?",
                       -integer => qr/^42$/;
  
      # Or this...
      $answer = prompt "What's the ultimate answer?",
                       -integer => [42];
  
  
  Only the following strings may be passed directly as scalar value
  constraints. They do mot match exactly, but instead act as specifiers
  for one or more built-in constraints. You can also pass a string that
  contains two or more of them, separated by whitespace, in which case
  they must all be satisfied. The specifiers are:
  
  =over 4
  
  =item C<'pos'> or C<'positive'>
  
  The number must be greater than zero
  
  =item C<'neg'> or C<'negative'>
  
  The number must be less than zero
  
  =item C<'zero'>
  
  The number must be equal to zero
  
  =item C<'even'> or C<'odd'>
  
  The number must have the correct parity
  
  =back
  
  You can also prepend C<"non"> to any of the above to reverse their meaning.
  
  For example:
  
      $rep_count = prompt 'How much do you bid?', -number => 'positive';
  
      $step_value = prompt 'Next step:', -integer => 'even nonzero';
  
  
  =head4 Constraining input to filenames
  
  =over 4
  
  =item C<< -f >>
  
  =item C<< -filenames >>
  
  =back
  
  You can tell C<prompt()> to accept only valid filenames, using the
  C<-filenames> option (or its shortcut: C<-f>).
  
  This option is equivalent to the options:
  
      -must => {
          'File must exist'       => sub { -e },
          'File must be readable' => sub { -r },
      },
      -complete => 'filenames',
  
  In other words C<-filenames> requires C<prompt()> to accept only the name
  of an existing, readable file, and it also activates filename completion.
  
  
  =head4 Constraining input to "keyletters"
  
  =over
  
  =item C<< -k >>
  
  =item C<< -key[let[ter]][s] >>
  
  =back
  
  A common interaction is to offer the user a range of actions, each of
  which is specified by keying a unique letter, like so:
  
      INPUT:
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          when (/S/i) { save_file()    }
          default     { goto INPUT;    }
      }
  
  This can be cleaned up (very slightly) by using a guarantee:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S',
                    -guarantee=>qr/[SRD]/i
      ) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  However, it's still annoying to have to specify the three key letters
  twice (and the default choice three times) within the call to
  C<prompt()>. So IO::Prompter provides an option that extracts this
  information directly from the prompt itself:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -keyletters) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  This option scans the prompt string and extracts any purely alphanumeric
  character sequences that are enclosed in balanced brackets of any kind
  (square, angle, round, or curly). It then makes each of these character
  sequences a valid input (by implicitly setting the C<-guarantee>
  option), and adds the first option in square brackets (if any) as the
  C<-default> value of the prompt.
  
  Note that the key letters don't have to be at the start of a word, don't
  have to be a single character, and can be either upper or lower case.
  For example:
  
      my $action = prompt -k, '(S)ave, Save(a)ll, (Ex)it without saving';
  
  Multi-character key letters are often a good choice for options with
  serious or irreversible consequences.
  
  A common idiom with key letters is to use the C<-single> option as well,
  so that pressing any key letter immediately completes the input, without
  the user having to also press C<< <ENTER>/<RETURN> >>:
  
      given (prompt -k1, '[S]ave, (R)evert, or (D)iscard:') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  
  
  =head3 Monitoring input
  
  =over 4
  
  =item C<< -monitor => SUBREF  >>
  
  =back
  
  This option allows you to specify a subroutine that will be called
  after each character is input. This subroutine will be passed
  two arguments: a string containing the input so far, and a hash
  reference containing various options passed into the call to
  C<prompt()> (specifically: C<-prompt>, C<-style>, and C<-echostyle>).
  
  The hashref contains an extra key (C<-cursor_pos>) whose value is the
  current location of the input cursor within the string. This is
  typically one character past the end of the string, but see L<"Input editing">.
  
  The subroutine can perform any actions you choose: set variables, validate input,
  print out a response to each input character.
  
  If the subroutine prints anything out that will, of course, mess up the prompt
  and input echoing, so in that case the prompt will automatically be redrawn.
  The prompt is also redrawn if the monitor subroutine throws an exception.
  
  Monitor subroutines are useful for prvoding extra information during an
  input process. For example, when prompting for a filepath, as the path is
  being typed in you could echo all (partially) matching files
  with something like:
  
      my $path = prompt 'File path:',
                        -monitor => sub ($path, $opts) {
                                       clear_screen();
                                       say for glob("$path*");
                                    };
  
  
  =head3 Preserving terminal newlines
  
  =over 4
  
  =item C<< -l  >>
  
  =item C<< -line >>
  
  =back
  
  The (encapsulated) string returned by C<prompt()> is automatically chomped by
  default. To prevent that chomping, specify this option.
  
  
  =head3 Constraining what can be returned
  
  =over 4
  
  =item C<< -must => HASHREF >>
  
  =back
  
  This option allows you to specify requirements and constraints on the input
  string that is returned by C<prompt()>. These limitations are specified as the
  values of a hash.
  
  If the C<-must> option is specified, once input is complete every value in the
  specified hash is smartmatched against the input text. If any of them fail to
  match, the input is discarded, the corresponding hash key is printed as an
  error message, and the prompt is repeated.
  
  Note that the values of the constraint hash cannot be single strings or
  numbers, except for certain strings (such as C<'pos'>, C<'nonzero'>, or
  C<'even'>, as described in L<"Constraining input to numbers">).
  
  If you want to constrain the input to a single string or number (a very
  unusual requirement), just place the value in an array, or match it
  with a regex:
  
      # This doesn't work...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => 'please' };
  
      # Use this instead...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => ['please'] };
  
      # Or, better still...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => qr/please/i };
  
  
  The C<-must> option allows you to test inputs against multiple
  conditions and have the appropriate error messages for each displayed.
  It also ensures that, when C<prompt()> eventually returns, you are
  guaranteed that the input meets all the specified conditions.
  
  For example, suppose the user is required to enter a positive odd prime
  number less than 100. You could enforce that with:
  
      my $opnlt100 = prompt 'Enter your guess:',
                            -integer,
                            -must => { 'be odd'                 => 'odd',
                                       'be in range'            => [1..100],
                                       'It must also be prime:' => \&isprime,
                                     };
  
  Note that, if the error message begins with anything except an uppercase
  character, the prompt is reissued followed by the error message in
  parentheses with the word "must" prepended (where appropriate).
  Otherwise, if the error message does start with an uppercase character,
  the prompt is not reissued and the error message is printed verbatim. So
  a typical input sequence for the previous example might look like:
  
      Enter your guess: 101
      Enter your guess: (must be in range) 42
      It must also be prime: 2
      Enter your guess: (must be odd) 7
  
  at which point, the call to C<prompt()> would accept the input and return.
  
  See also L<the C<-guarantee> option|"Constraining what can be typed">,
  which allows you to constrain inputs as they are typed, rather than
  after they are entered.
  
  
  =head3 Changing how returns are echoed
  
  =over 4
  
  =item C<< -r[STR] >>
  
  =item C<< -ret[urn] [=> STR] >>
  
  =back
  
  When C<< <ENTER>/<RETURN> >> is pressed, C<prompt()> usually echoes a carriage return.
  However, if this option is given, C<prompt()> echoes the specified string
  instead. If the string is omitted, it defaults to C<"\n">.
  
  For example:
  
      while (1) {
          my $expr = prompt 'Calculate:', -ret=>' = ';
          say evaluate($expr);
      }
  
  would prompt for something like this:
  
      Calculate: 2*3+4^5_
  
  and when the C<< <ENTER>/<RETURN> >> key is pressed, respond with:
  
      Calculate: 2*3+4^5 = 1030
      Calculate: _
  
  The string specified with C<-return> is also automatically echoed if the
  L<< C<-single> option|"Single-character input" >> is used, or if an
  input is cancelled via the
  L<< C<-cancel> option|"Specifying when input should fail immediately" >>.
  So if you don't want the automatic carriage return that C<-single> mode
  or C<-cancel> supplies, specify C<< -return=>"" >>.
  
  
  =head3 Single-character input
  
  =over 4
  
  =item C<< -s >>
  
  =item C<< -1 >>
  
  =item C<< -sing[le] >>
  
  =back
  
  This option causes C<prompt()> to return immediately once any single
  character is input. The user does not have to push the C<< <ENTER>/<RETURN> >>
  key to complete the input operation. C<-single> mode input is only
  available if the Term::ReadKey module can be loaded.
  
  By default, C<prompt()> echoes the single character that is entered. Use
  the L<C<-echo> option|"Specifying what to echo on input"> to change or
  prevent that.
  
      # Let user navigate through maze by single, silent keypresses...
      while ($nextdir = prompt "\n", -single, -echo, -guarantee=>qr/[nsew]/) {
          move_player($nextdir);
      }
  
  Unless echoing has been disabled, by default C<prompt()> also supplies a
  carriage return after the input character. Use
  L<the C<-return> option|"Changing how returns are echoed"> to change
  that behaviour. For example, this:
  
      my $question = <<END_QUESTION;
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer:
      END_QUESTION
  
      my $response = prompt $question, -1, -return=>' is ', -g=>['a'..'d'];
      say $response eq $answer ? 'CORRECT' : 'incorrect';
  
  prompts like this:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: _
  
  accepts a single character, like so:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b_
  
  and completes the line thus:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b is CORRECT
      _
  
  
  =head3 Returning raw data
  
  =over 4
  
  =item C<< -v >>
  
  =item C<< -verb[atim] >>
  
  =back
  
  Normally, C<prompt()> returns a special object that contains the text
  input, the success value, and other information such as whether the
  default was selected and whether the input operation timed out.
  
  However, if you prefer to have C<prompt()> just return the input text string
  directly, you can specify this option.
  
  Note however that, under C<-verbatim>, the input is still
  autochomped (unless you also specify
  L<the C<-line> option|"Preserving terminal newlines">.
  
  
  =head3 Prompting on a clear screen
  
  =over 4
  
  =item C<< -w >>
  
  =item C<< -wipe[first] >>
  
  =back
  
  If this option is present, C<prompt()> prints 1000 newlines before
  printing its prompt, effectively wiping the screen clear of other text.
  
  If the C<-wipefirst> variant is used, the wipe will only occur if the
  particular call to C<prompt()> is the first such call anywhere in your
  program. This is useful if you'd like the screen cleared at the start of
  input only, but you're not sure which call to C<prompt()> will happen
  first: just use C<-wipefirst> on all possible initial calls and only the
  actual first call will wipe the screen.
  
  
  =head3 Requesting confirmations
  
  =over 4
  
  =item C<< -y[n] >> or C<< -Y[N] >>
  
  =item C<< -yes[no] >> or C<< -Yes[No] >>
  
  =item C<< -yes[no] => COUNT >> or C<< -Yes[No] => COUNT >>
  
  =back
  
  This option invokes a special mode that can be used to confirm (or deny)
  something. If one of these options is specified, C<prompt> still
  returns the user's input, but the success or failure of the object returned
  now depends on what the user types in.
  
  A true result is returned if C<'y'> is the first character entered. If
  the flag includes an C<n> or C<N>, a false result is returned if C<'n'>
  is the first character entered (and any other input causes the prompt to
  be reissued). If the option doesn't contain an C<n> or C<N>, any input
  except C<'y'> is treated as a "no" and a false value is returned.
  
  If the option is capitalized (C<-Y> or C<-YN>), the first letter of the
  input must be likewise a capital (this is a handy means of slowing down
  automatic unthinking C<y>..."Oh no!" responses to potentially serious
  decisions).
  
  This option is most often used in conjunction with the C<-single> option, like
  so:
  
      $continue = prompt("Continue? ", -yn1);
  
  so that the user can just hit C<y> or C<n> to continue, without having to hit
  C<< <ENTER>/<RETURN> >> as well.
  
  If the optional I<COUNT> argument is supplied, the prompting is repeated
  that many times, with increasingly insistent requests for confirmation.
  The answer must be "yes" in each case for the final result to be true.
  For example:
  
      $rm_star = prompt("Do you want to delete all files? ", -Yes=>3 );
  
  might prompt:
  
      Do you want to delete all files?  Y
      Really?  Y
      Are you sure?  Y
  
  
  
  =head3 Bundling short-form options
  
  You can bundle together any number of short-form options, including those that
  take string arguments. For example, instead of writing:
  
      if (prompt "Continue? ", -yes, -1, -t10, -dn) {
  
  you could just write:
  
      if (prompt "Continue? ", -y1t10dn) {...}
  
  This often does I<not> improve readability (as the preceding example
  demonstrates), but is handy for common usages such as C<-y1> ("ask for
  confirmation, don't require an C<< <ENTER>/<RETURN> >>) or C<-vl>
  ("Return a verbatim and unchomped string").
  
  
  =head3 Escaping otherwise-magic options
  
  =over 4
  
  C<< -_ >>
  
  =back
  
  The C<-_> option exists only to be an explicit no-op. It allows you to
  specify short-form options that would otherwise be interpreted as Perl
  file operators or other special constructs, simply by prepending or
  appending a C<_> to them. For example:
  
      my $input
          = prompt -l_;  # option -l, not the -l file operator.
  
  The following single-letter options require an underscore to chaperone them
  when they're on their own: C<-e>, C<-l>, C<-r>, C<-s>, C<-w>, and C<-y>.
  However, an underscore is not required if two or more are bundled together.
  
  
  =head2 Useful useless uses of C<prompt()>
  
  Normally, in a void context, a call to C<prompt()> issues a warning that
  you are doing an input operation whose input is immediately thrown away.
  
  There is, however, one situation where this useless use of C<prompt()> in a
  void context is actually useful:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single);
      exit;
  
  Here, we're using prompt simply to pause the application after the data is
  printed. It doesn't matter what the user types in; the typing itself is the
  message (and the message is "move along").
  
  In such cases, the "useless use..." warning can be suppressed using the
  C<< -void >> option:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single, -void);
      exit;
  
  
  =head2 Simulating input
  
  IO::Prompter provides a mechanism with which you can "script" a sequence of
  inputs to an application. This is particularly useful when demonstrating
  software during a presentation, as you do not have to remember what to type,
  or concentrate on typing at all.
  
  If you pass a string as an argument to C<use IO::Prompter>, the
  individual lines of that string are used as successive input lines to
  any call to C<prompt()>. So for example, you could specify several sets
  of input data, like so:
  
      use IO::Prompter <<END_DATA
      Leslie
      45
      165
      Jessie
      28
      178
      Dana
      12
      120
      END_DATA
  
  and then read this data in an input loop:
  
      while (my $name   = prompt 'Name:') {
             my $age    = prompt 'Age:';
             my $height = prompt 'Height:';
  
             process($name, $age, $height);
      }
  
  Because the C<use IO::Prompter> supplies input data,
  the three calls to C<prompt()> will no longer read
  data from C<*ARGV>. Instead they will read it from
  the supplied input data.
  
  Moreover, each call to C<prompt()> will simulate the typing-in process
  automatically. That is, C<prompt()> uses a special input mode where,
  each time you press a keyboard letter, it echoes not that character, but
  rather the next character from the specified input. The effect is that
  you can just type on the keyboard at random, but have the correct input
  appear. This greatly increases the convincingness of the simulation.
  
  If at any point, you hit C<< <ENTER>/<RETURN> >> on the keyboard, C<prompt()>
  finishes typing in the input for you (using a realistic typing speed),
  and returns the input string. So you can also just hit C<< <ENTER>/<RETURN> >>
  when the prompt first appears, to have the entire line of input typed
  for you.
  
  Alternatively, if you hit C<< <ESC> >> at any point, C<prompt()> escapes
  from the simulated input mode for that particular call to C<prompt()>,
  and allows you to (temporarily) type text in directly. If you enter only
  a single C<< <ESC> >>, then C<prompt()> throws away the current line of
  simulated input; if you enter two C<< <ESC> >>'s, the simulated input is
  merely deferred to the next call to C<prompt()>.
  
  All these keyboard behaviours require the Term::ReadKey module to be
  available. If it isn't, C<prompt()> falls back on a simpler simulation,
  where it just autotypes each entire line for you and pauses at the
  end of the line, waiting for you to hit C<< <ENTER>/<RETURN> >> manually.
  
  Note that any line of the simulated input that begins with
  a <CTRL-D> or <CTRL-Z> is treated as an input failure (just as
  if you'd typed that character as input).
  
  =head1 DIAGNOSTICS
  
  All non-fatal diagnostics can be disabled using a C<no warnings> with the
  appropriate category.
  
  =over
  
  =item C<< prompt(): Can't open *ARGV: %s >>
  
  (F)  By default, C<prompt()> attempts to read input from
       the C<*ARGV> filehandle. However, it failed to open
       that filehandle. The reason is specified at the end of
       the message.
  
  
  =item C<< prompt(): Missing value for %s (expected %s) >>
  
  (F)  A named option that requires an argument was specified,
       but no argument was provided after the option. See
       L<"Summary of options">.
  
  
  =item C<< prompt(): Invalid value for %s (expected %s) >>
  
  (F)  The named option specified expects an particular type
       of argument, but found one of an incompatible type
       instead. See L<"Summary of options">.
  
  
  =item C<< prompt(): Unknown option %s ignored >>
  
  (W misc)  C<prompt()> was passed a string starting with
            a hyphen, but could not parse that string as a
            valid option. The option may have been misspelt.
            Alternatively, if the string was supposed to be
            (part of) the prompt, it will be necessary to use
            L<the C<-prompt> option|"Specifying what to
            prompt"> to specify it.
  
  
  =item C<< prompt(): Unexpected argument (% ref) ignored >>
  
  (W reserved)  C<prompt()> was passed a reference to
                an array or hash or subroutine in a position
                where an option flag or a prompt string was
                expected. This may indicate that a string
                variable in the argument list didn't contain
                what was expected, or a reference variable was
                not properly dereferenced. Alternatively, the
                argument may have been intended as the
                argument to an option, but has become
                separated from it somehow, or perhaps the
                option was deleted without removing the
                argument as well.
  
  
  =item C<< Useless use of prompt() in void context >>
  
  (W void)  C<prompt()> was called but its return value was
            not stored or used in any way. Since the
            subroutine has no side effects in void context,
            calling it this way achieves nothing. Either make
            use of the return value directly or, if the usage
            is deliberate, put a C<scalar> in front of the
            call to remove the void context.
  
  
  =item C<< prompt(): -default value does not satisfy -must constraints >>
  
  (W misc)  The C<-must> flag was used to specify one or more
            input constraints. The C<-default> flag was also
            specified. Unfortunately, the default value
            provided did not satisfy the requirements
            specified by the C<-must> flag. The call to
            C<prompt()> will still go ahead (after issuing the
            warning), but the default value will never be
            returned, since the constraint check will reject
            it. It is probably better simply to include the
            default value in the list of constraints.
  
  
  =item C<< prompt(): -keyletters found too many defaults >>
  
  (W ambiguous)  The C<-keyletters> option was specified,
                 but analysis of the prompt revealed two or
                 more character sequences enclosed in square
                 brackets. Since such sequences are taken to
                 indicate a default value, having two or more
                 makes the default ambiguous. The prompt
                 should be rewritten with no more than one set
                 of square brackets.
  
  
  =item C<< Warning: next input will be in plaintext >>
  
  (W bareword)  The C<prompt()> subroutine was called with
                the C<-echo> flag, but the Term::ReadKey
                module was not available to implement this
                feature. The input will proceed as normal, but
                this warning is issued to ensure that the user
                doesn't type in something secret, expecting it
                to remain hidden, which it won't.
  
  
  =item C<< prompt(): Too many menu items. Ignoring the final %d >>
  
  (W misc)  A C<-menu> was specified with more than 52 choices.
            Because, by default, menus use upper and lower-
            case alphabetic characters as their selectors,
            there were no available selectors for the extra
            items after the first 52. Either reduce the number
            of choices to 52 or less, or else add the
            C<-number> option to use numeric selectors instead.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Prompter can be configured by setting any of the following
  environment variables:
  
  =over
  
  =item C<$IO_PROMPTER_COMPLETE_KEY>
  
  Specifies the key used to initiate
  L<user-specified completions|"Input autocompletion">.
  Defaults to <TAB>
  
  =item C<$IO_PROMPTER_HISTORY_KEY>
  
  Specifies the key used to initiate
  L<history completions|"Completing from your input history">.
  Defaults to <CTRL-R>
  
  =item C<$IO_PROMPTER_COMPLETE_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for user-defined completions.  Defaults to C<'list+longest  full'>
  
  =item C<$IO_PROMPTER_HISTORY_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for history completions.  Defaults to C<'full'>.
  
  =back
  
  
  =head1 DEPENDENCIES
  
  Requires the Contextual::Return module.
  
  The module also works much better if Term::ReadKey is available
  (though this is not essential).
  
  
  =head1 INCOMPATIBILITIES
  
  This module does not play well with Moose (or more specifically, with
  Moose::Exporter) because both of them try to play sneaky games with
  Scalar::Util::blessed.
  
  The current solution is to make sure that you load Moose before
  loading IO::Prompter. Even just doing this:
  
      use Moose ();
      use IO::Prompter;
  
  is sufficient.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No unresolved bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-prompter@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@CPAN.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2009, Damian Conway C<< <DCONWAY@CPAN.org> >>.
  All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
IO_PROMPTER

$fatpacked{"IPC/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN';
  package IPC::Run;
  use bytes;
  
  =pod
  
  =head1 NAME
  
  IPC::Run - system() and background procs w/ piping, redirs, ptys (Unix, Win32)
  
  =head1 SYNOPSIS
  
     ## First,a command to run:
        my @cat = qw( cat );
  
     ## Using run() instead of system():
        use IPC::Run qw( run timeout );
  
        run \@cat, \$in, \$out, \$err, timeout( 10 ) or die "cat: $?";
  
        # Can do I/O to sub refs and filenames, too:
        run \@cat, '<', "in.txt", \&out, \&err or die "cat: $?";
        run \@cat, '<', "in.txt", '>>', "out.txt", '2>>', "err.txt";
  
  
        # Redirecting using pseudo-terminals instead of pipes.
        run \@cat, '<pty<', \$in,  '>pty>', \$out_and_err;
  
     ## Scripting subprocesses (like Expect):
  
        use IPC::Run qw( start pump finish timeout );
  
        # Incrementally read from / write to scalars. 
        # $in is drained as it is fed to cat's stdin,
        # $out accumulates cat's stdout
        # $err accumulates cat's stderr
        # $h is for "harness".
        my $h = start \@cat, \$in, \$out, \$err, timeout( 10 );
  
        $in .= "some input\n";
        pump $h until $out =~ /input\n/g;
  
        $in .= "some more input\n";
        pump $h until $out =~ /\G.*more input\n/;
  
        $in .= "some final input\n";
        finish $h or die "cat returned $?";
  
        warn $err if $err; 
        print $out;         ## All of cat's output
  
     # Piping between children
        run \@cat, '|', \@gzip;
  
     # Multiple children simultaneously (run() blocks until all
     # children exit, use start() for background execution):
        run \@foo1, '&', \@foo2;
  
     # Calling \&set_up_child in the child before it executes the
     # command (only works on systems with true fork() & exec())
     # exceptions thrown in set_up_child() will be propagated back
     # to the parent and thrown from run().
        run \@cat, \$in, \$out,
           init => \&set_up_child;
  
     # Read from / write to file handles you open and close
        open IN,  '<in.txt'  or die $!;
        open OUT, '>out.txt' or die $!;
        print OUT "preamble\n";
        run \@cat, \*IN, \*OUT or die "cat returned $?";
        print OUT "postamble\n";
        close IN;
        close OUT;
  
     # Create pipes for you to read / write (like IPC::Open2 & 3).
        $h = start
           \@cat,
              '<pipe', \*IN, # may also be a lexical filehandle e.g. \my $infh
              '>pipe', \*OUT,
              '2>pipe', \*ERR 
           or die "cat returned $?";
        print IN "some input\n";
        close IN;
        print <OUT>, <ERR>;
        finish $h;
  
     # Mixing input and output modes
        run \@cat, 'in.txt', \&catch_some_out, \*ERR_LOG;
  
     # Other redirection constructs
        run \@cat, '>&', \$out_and_err;
        run \@cat, '2>&1';
        run \@cat, '0<&3';
        run \@cat, '<&-';
        run \@cat, '3<', \$in3;
        run \@cat, '4>', \$out4;
        # etc.
  
     # Passing options:
        run \@cat, 'in.txt', debug => 1;
  
     # Call this system's shell, returns TRUE on 0 exit code
     # THIS IS THE OPPOSITE SENSE OF system()'s RETURN VALUE
        run "cat a b c" or die "cat returned $?";
  
     # Launch a sub process directly, no shell.  Can't do redirection
     # with this form, it's here to behave like system() with an
     # inverted result.
        $r = run "cat a b c";
  
     # Read from a file in to a scalar
        run io( "filename", 'r', \$recv );
        run io( \*HANDLE,   'r', \$recv );
  
  =head1 DESCRIPTION
  
  IPC::Run allows you to run and interact with child processes using files, pipes,
  and pseudo-ttys.  Both system()-style and scripted usages are supported and
  may be mixed.  Likewise, functional and OO API styles are both supported and
  may be mixed.
  
  Various redirection operators reminiscent of those seen on common Unix and DOS
  command lines are provided.
  
  Before digging in to the details a few LIMITATIONS are important enough
  to be mentioned right up front:
  
  =over
  
  =item Win32 Support
  
  Win32 support is working but B<EXPERIMENTAL>, but does pass all relevant tests
  on NT 4.0.  See L</Win32 LIMITATIONS>.
  
  =item pty Support
  
  If you need pty support, IPC::Run should work well enough most of the
  time, but IO::Pty is being improved, and IPC::Run will be improved to
  use IO::Pty's new features when it is released.
  
  The basic problem is that the pty needs to initialize itself before the
  parent writes to the master pty, or the data written gets lost.  So
  IPC::Run does a sleep(1) in the parent after forking to (hopefully) give
  the child a chance to run.  This is a kludge that works well on non
  heavily loaded systems :(.
  
  ptys are not supported yet under Win32, but will be emulated...
  
  =item Debugging Tip
  
  You may use the environment variable C<IPCRUNDEBUG> to see what's going on
  under the hood:
  
     $ IPCRUNDEBUG=basic   myscript     # prints minimal debugging
     $ IPCRUNDEBUG=data    myscript     # prints all data reads/writes
     $ IPCRUNDEBUG=details myscript     # prints lots of low-level details
     $ IPCRUNDEBUG=gory    myscript     # (Win32 only) prints data moving through
                                        # the helper processes.
  
  =back
  
  We now return you to your regularly scheduled documentation.
  
  =head2 Harnesses
  
  Child processes and I/O handles are gathered in to a harness, then
  started and run until the processing is finished or aborted.
  
  =head2 run() vs. start(); pump(); finish();
  
  There are two modes you can run harnesses in: run() functions as an
  enhanced system(), and start()/pump()/finish() allow for background
  processes and scripted interactions with them.
  
  When using run(), all data to be sent to the harness is set up in
  advance (though one can feed subprocesses input from subroutine refs to
  get around this limitation). The harness is run and all output is
  collected from it, then any child processes are waited for:
  
     run \@cmd, \<<IN, \$out;
     blah
     IN
  
     ## To precompile harnesses and run them later:
     my $h = harness \@cmd, \<<IN, \$out;
     blah
     IN
  
     run $h;
  
  The background and scripting API is provided by start(), pump(), and
  finish(): start() creates a harness if need be (by calling harness())
  and launches any subprocesses, pump() allows you to poll them for
  activity, and finish() then monitors the harnessed activities until they
  complete.
  
     ## Build the harness, open all pipes, and launch the subprocesses
     my $h = start \@cat, \$in, \$out;
     $in = "first input\n";
  
     ## Now do I/O.  start() does no I/O.
     pump $h while length $in;  ## Wait for all input to go
  
     ## Now do some more I/O.
     $in = "second input\n";
     pump $h until $out =~ /second input/;
  
     ## Clean up
     finish $h or die "cat returned $?";
  
  You can optionally compile the harness with harness() prior to
  start()ing or run()ing, and you may omit start() between harness() and
  pump().  You might want to do these things if you compile your harnesses
  ahead of time.
  
  =head2 Using regexps to match output
  
  As shown in most of the scripting examples, the read-to-scalar facility
  for gathering subcommand's output is often used with regular expressions
  to detect stopping points.  This is because subcommand output often
  arrives in dribbles and drabs, often only a character or line at a time.
  This output is input for the main program and piles up in variables like
  the C<$out> and C<$err> in our examples.
  
  Regular expressions can be used to wait for appropriate output in
  several ways.  The C<cat> example in the previous section demonstrates
  how to pump() until some string appears in the output.  Here's an
  example that uses C<smb> to fetch files from a remote server:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /src:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
  Notice that we carefully clear $out after the first command/response
  cycle? That's because IPC::Run does not delete $out when we continue,
  and we don't want to trip over the old output in the second
  command/response cycle.
  
  Say you want to accumulate all the output in $out and analyze it
  afterwards.  Perl offers incremental regular expression matching using
  the C<m//gc> and pattern matching idiom and the C<\G> assertion.
  IPC::Run is careful not to disturb the current C<pos()> value for
  scalars it appends data to, so we could modify the above so as not to
  destroy $out by adding a couple of C</gc> modifiers.  The C</g> keeps us
  from tripping over the previous prompt and the C</c> keeps us from
  resetting the prior match position if the expected prompt doesn't
  materialize immediately:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error cding to /src:\n$out" if $out =~ "ERR";
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
     analyze( $out );
  
  When using this technique, you may want to preallocate $out to have
  plenty of memory or you may find that the act of growing $out each time
  new input arrives causes an C<O(length($out)^2)> slowdown as $out grows.
  Say we expect no more than 10,000 characters of input at the most.  To
  preallocate memory to $out, do something like:
  
     my $out = "x" x 10_000;
     $out = "";
  
  C<perl> will allocate at least 10,000 characters' worth of space, then
  mark the $out as having 0 length without freeing all that yummy RAM.
  
  =head2 Timeouts and Timers
  
  More than likely, you don't want your subprocesses to run forever, and
  sometimes it's nice to know that they're going a little slowly.
  Timeouts throw exceptions after a some time has elapsed, timers merely
  cause pump() to return after some time has elapsed.  Neither is
  reset/restarted automatically.
  
  Timeout objects are created by calling timeout( $interval ) and passing
  the result to run(), start() or harness().  The timeout period starts
  ticking just after all the child processes have been fork()ed or
  spawn()ed, and are polled for expiration in run(), pump() and finish().
  If/when they expire, an exception is thrown.  This is typically useful
  to keep a subprocess from taking too long.
  
  If a timeout occurs in run(), all child processes will be terminated and
  all file/pipe/ptty descriptors opened by run() will be closed.  File
  descriptors opened by the parent process and passed in to run() are not
  closed in this event.
  
  If a timeout occurs in pump(), pump_nb(), or finish(), it's up to you to
  decide whether to kill_kill() all the children or to implement some more
  graceful fallback.  No I/O will be closed in pump(), pump_nb() or
  finish() by such an exception (though I/O is often closed down in those
  routines during the natural course of events).
  
  Often an exception is too harsh.  timer( $interval ) creates timer
  objects that merely prevent pump() from blocking forever.  This can be
  useful for detecting stalled I/O or printing a soothing message or "."
  to pacify an anxious user.
  
  Timeouts and timers can both be restarted at any time using the timer's
  start() method (this is not the start() that launches subprocesses).  To
  restart a timer, you need to keep a reference to the timer:
  
     ## Start with a nice long timeout to let smbclient connect.  If
     ## pump or finish take too long, an exception will be thrown.
  
   my $h;
   eval {
     $h = harness \@smbclient, \$in, \$out, \$err, ( my $t = timeout 30 );
     sleep 11;  # No effect: timer not running yet
  
     start $h;
     $in = "cd /src\n";
     pump $h until ! length $in;
  
     $in = "ls\n";
     ## Now use a short timeout, since this should be faster
     $t->start( 5 );
     pump $h until ! length $in;
  
     $t->start( 10 );  ## Give smbclient a little while to shut down.
     $h->finish;
   };
   if ( $@ ) {
     my $x = $@;    ## Preserve $@ in case another exception occurs
     $h->kill_kill; ## kill it gently, then brutally if need be, or just
                     ## brutally on Win32.
     die $x;
   }
  
  Timeouts and timers are I<not> checked once the subprocesses are shut
  down; they will not expire in the interval between the last valid
  process and when IPC::Run scoops up the processes' result codes, for
  instance.
  
  =head2 Spawning synchronization, child exception propagation
  
  start() pauses the parent until the child executes the command or CODE
  reference and propagates any exceptions thrown (including exec()
  failure) back to the parent.  This has several pleasant effects: any
  exceptions thrown in the child, including exec() failure, come flying
  out of start() or run() as though they had occurred in the parent.
  
  This includes exceptions your code thrown from init subs.  In this
  example:
  
     eval {
        run \@cmd, init => sub { die "blast it! foiled again!" };
     };
     print $@;
  
  the exception "blast it! foiled again" will be thrown from the child
  process (preventing the exec()) and printed by the parent.
  
  In situations like
  
     run \@cmd1, "|", \@cmd2, "|", \@cmd3;
  
  @cmd1 will be initted and exec()ed before @cmd2, and @cmd2 before @cmd3.
  This can save time and prevent oddball errors emitted by later commands
  when earlier commands fail to execute.  Note that IPC::Run doesn't start
  any commands unless it can find the executables referenced by all
  commands.  These executables must pass both the C<-f> and C<-x> tests
  described in L<perlfunc>.
  
  Another nice effect is that init() subs can take their time doing things
  and there will be no problems caused by a parent continuing to execute
  before a child's init() routine is complete.  Say the init() routine
  needs to open a socket or a temp file that the parent wants to connect
  to; without this synchronization, the parent will need to implement a
  retry loop to wait for the child to run, since often, the parent gets a
  lot of things done before the child's first timeslice is allocated.
  
  This is also quite necessary for pseudo-tty initialization, which needs
  to take place before the parent writes to the child via pty.  Writes
  that occur before the pty is set up can get lost.
  
  A final, minor, nicety is that debugging output from the child will be
  emitted before the parent continues on, making for much clearer debugging
  output in complex situations.
  
  The only drawback I can conceive of is that the parent can't continue to
  operate while the child is being initted.  If this ever becomes a
  problem in the field, we can implement an option to avoid this behavior,
  but I don't expect it to.
  
  B<Win32>: executing CODE references isn't supported on Win32, see
  L</Win32 LIMITATIONS> for details.
  
  =head2 Syntax
  
  run(), start(), and harness() can all take a harness specification
  as input.  A harness specification is either a single string to be passed
  to the systems' shell:
  
     run "echo 'hi there'";
  
  or a list of commands, io operations, and/or timers/timeouts to execute.
  Consecutive commands must be separated by a pipe operator '|' or an '&'.
  External commands are passed in as array references or L<IPC::Run::Win32Process>
  objects.  On systems supporting fork(), Perl code may be passed in as subs:
  
     run \@cmd;
     run \@cmd1, '|', \@cmd2;
     run \@cmd1, '&', \@cmd2;
     run \&sub1;
     run \&sub1, '|', \&sub2;
     run \&sub1, '&', \&sub2;
  
  '|' pipes the stdout of \@cmd1 the stdin of \@cmd2, just like a
  shell pipe.  '&' does not.  Child processes to the right of a '&'
  will have their stdin closed unless it's redirected-to.
  
  L<IPC::Run::IO> objects may be passed in as well, whether or not
  child processes are also specified:
  
     run io( "infile", ">", \$in ), io( "outfile", "<", \$in );
        
  as can L<IPC::Run::Timer> objects:
  
     run \@cmd, io( "outfile", "<", \$in ), timeout( 10 );
  
  Commands may be followed by scalar, sub, or i/o handle references for
  redirecting
  child process input & output:
  
     run \@cmd,  \undef,            \$out;
     run \@cmd,  \$in,              \$out;
     run \@cmd1, \&in, '|', \@cmd2, \*OUT;
     run \@cmd1, \*IN, '|', \@cmd2, \&out;
  
  This is known as succinct redirection syntax, since run(), start()
  and harness(), figure out which file descriptor to redirect and how.
  File descriptor 0 is presumed to be an input for
  the child process, all others are outputs.  The assumed file
  descriptor always starts at 0, unless the command is being piped to,
  in which case it starts at 1.
  
  To be explicit about your redirects, or if you need to do more complex
  things, there's also a redirection operator syntax:
  
     run \@cmd, '<', \undef, '>',  \$out;
     run \@cmd, '<', \undef, '>&', \$out_and_err;
     run(
        \@cmd1,
           '<', \$in,
        '|', \@cmd2,
           \$out
     );
  
  Operator syntax is required if you need to do something other than simple
  redirection to/from scalars or subs, like duping or closing file descriptors
  or redirecting to/from a named file.  The operators are covered in detail
  below.
  
  After each \@cmd (or \&foo), parsing begins in succinct mode and toggles to
  operator syntax mode when an operator (ie plain scalar, not a ref) is seen.
  Once in
  operator syntax mode, parsing only reverts to succinct mode when a '|' or
  '&' is seen.
  
  In succinct mode, each parameter after the \@cmd specifies what to
  do with the next highest file descriptor. These File descriptor start
  with 0 (stdin) unless stdin is being piped to (C<'|', \@cmd>), in which
  case they start with 1 (stdout).  Currently, being on the left of
  a pipe (C<\@cmd, \$out, \$err, '|'>) does I<not> cause stdout to be
  skipped, though this may change since it's not as DWIMerly as it
  could be.  Only stdin is assumed to be an
  input in succinct mode, all others are assumed to be outputs.
  
  If no piping or redirection is specified for a child, it will inherit
  the parent's open file handles as dictated by your system's
  close-on-exec behavior and the $^F flag, except that processes after a
  '&' will not inherit the parent's stdin. Also note that $^F does not
  affect file descriptors obtained via POSIX, since it only applies to
  full-fledged Perl file handles.  Such processes will have their stdin
  closed unless it has been redirected-to.
  
  If you want to close a child processes stdin, you may do any of:
  
     run \@cmd, \undef;
     run \@cmd, \"";
     run \@cmd, '<&-';
     run \@cmd, '0<&-';
  
  Redirection is done by placing redirection specifications immediately 
  after a command or child subroutine:
  
     run \@cmd1,      \$in, '|', \@cmd2,      \$out;
     run \@cmd1, '<', \$in, '|', \@cmd2, '>', \$out;
  
  If you omit the redirection operators, descriptors are counted
  starting at 0.  Descriptor 0 is assumed to be input, all others
  are outputs.  A leading '|' consumes descriptor 0, so this
  works as expected.
  
     run \@cmd1, \$in, '|', \@cmd2, \$out;
     
  The parameter following a redirection operator can be a scalar ref,
  a subroutine ref, a file name, an open filehandle, or a closed
  filehandle.
  
  If it's a scalar ref, the child reads input from or sends output to
  that variable:
  
     $in = "Hello World.\n";
     run \@cat, \$in, \$out;
     print $out;
  
  Scalars used in incremental (start()/pump()/finish()) applications are treated
  as queues: input is removed from input scalers, resulting in them dwindling
  to '', and output is appended to output scalars.  This is not true of 
  harnesses run() in batch mode.
  
  It's usually wise to append new input to be sent to the child to the input
  queue, and you'll often want to zap output queues to '' before pumping.
  
     $h = start \@cat, \$in;
     $in = "line 1\n";
     pump $h;
     $in .= "line 2\n";
     pump $h;
     $in .= "line 3\n";
     finish $h;
  
  The final call to finish() must be there: it allows the child process(es)
  to run to completion and waits for their exit values.
  
  =head1 OBSTINATE CHILDREN
  
  Interactive applications are usually optimized for human use.  This
  can help or hinder trying to interact with them through modules like
  IPC::Run.  Frequently, programs alter their behavior when they detect
  that stdin, stdout, or stderr are not connected to a tty, assuming that
  they are being run in batch mode.  Whether this helps or hurts depends
  on which optimizations change.  And there's often no way of telling
  what a program does in these areas other than trial and error and
  occasionally, reading the source.  This includes different versions
  and implementations of the same program.
  
  All hope is not lost, however.  Most programs behave in reasonably
  tractable manners, once you figure out what it's trying to do.
  
  Here are some of the issues you might need to be aware of.
  
  =over
  
  =item *
  
  fflush()ing stdout and stderr
  
  This lets the user see stdout and stderr immediately.  Many programs
  undo this optimization if stdout is not a tty, making them harder to
  manage by things like IPC::Run.
  
  Many programs decline to fflush stdout or stderr if they do not
  detect a tty there.  Some ftp commands do this, for instance.
  
  If this happens to you, look for a way to force interactive behavior,
  like a command line switch or command.  If you can't, you will
  need to use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  false prompts
  
  Interactive programs generally do not guarantee that output from user
  commands won't contain a prompt string.  For example, your shell prompt
  might be a '$', and a file named '$' might be the only file in a directory
  listing.
  
  This can make it hard to guarantee that your output parser won't be fooled
  into early termination of results.
  
  To help work around this, you can see if the program can alter it's 
  prompt, and use something you feel is never going to occur in actual
  practice.
  
  You should also look for your prompt to be the only thing on a line:
  
     pump $h until $out =~ /^<SILLYPROMPT>\s?\z/m;
  
  (use C<(?!\n)\Z> in place of C<\z> on older perls).
  
  You can also take the approach that IPC::ChildSafe takes and emit a
  command with known output after each 'real' command you issue, then
  look for this known output.  See new_appender() and new_chunker() for
  filters that can help with this task.
  
  If it's not convenient or possibly to alter a prompt or use a known
  command/response pair, you might need to autodetect the prompt in case
  the local version of the child program is different then the one
  you tested with, or if the user has control over the look & feel of
  the prompt.
  
  =item *
  
  Refusing to accept input unless stdin is a tty.
  
  Some programs, for security reasons, will only accept certain types
  of input from a tty.  su, notable, will not prompt for a password unless
  it's connected to a tty.
  
  If this is your situation, use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  Not prompting unless connected to a tty.
  
  Some programs don't prompt unless stdin or stdout is a tty.  See if you can
  turn prompting back on.  If not, see if you can come up with a command that
  you can issue after every real command and look for it's output, as
  IPC::ChildSafe does.   There are two filters included with IPC::Run that
  can help with doing this: appender and chunker (see new_appender() and
  new_chunker()).
  
  =item *
  
  Different output format when not connected to a tty.
  
  Some commands alter their formats to ease machine parsability when they
  aren't connected to a pipe.  This is actually good, but can be surprising.
  
  =back
  
  =head1 PSEUDO TERMINALS
  
  On systems providing pseudo terminals under /dev, IPC::Run can use IO::Pty
  (available on CPAN) to provide a terminal environment to subprocesses.
  This is necessary when the subprocess really wants to think it's connected
  to a real terminal.
  
  =head2 CAVEATS
  
  Pseudo-terminals are not pipes, though they are similar.  Here are some
  differences to watch out for.
  
  =over
  
  =item Echoing
  
  Sending to stdin will cause an echo on stdout, which occurs before each
  line is passed to the child program.  There is currently no way to
  disable this, although the child process can and should disable it for
  things like passwords.
  
  =item Shutdown
  
  IPC::Run cannot close a pty until all output has been collected.  This
  means that it is not possible to send an EOF to stdin by half-closing
  the pty, as we can when using a pipe to stdin.
  
  This means that you need to send the child process an exit command or
  signal, or run() / finish() will time out.  Be careful not to expect a
  prompt after sending the exit command.
  
  =item Command line editing
  
  Some subprocesses, notable shells that depend on the user's prompt
  settings, will reissue the prompt plus the command line input so far
  once for each character.
  
  =item '>pty>' means '&>pty>', not '1>pty>'
  
  The pseudo terminal redirects both stdout and stderr unless you specify
  a file descriptor.  If you want to grab stderr separately, do this:
  
     start \@cmd, '<pty<', \$in, '>pty>', \$out, '2>', \$err;
  
  =item stdin, stdout, and stderr not inherited
  
  Child processes harnessed to a pseudo terminal have their stdin, stdout,
  and stderr completely closed before any redirection operators take
  effect.  This casts of the bonds of the controlling terminal.  This is
  not done when using pipes.
  
  Right now, this affects all children in a harness that has a pty in use,
  even if that pty would not affect a particular child.  That's a bug and
  will be fixed.  Until it is, it's best not to mix-and-match children.
  
  =back
  
  =head2 Redirection Operators
  
     Operator       SHNP   Description
     ========       ====   ===========
     <, N<          SHN    Redirects input to a child's fd N (0 assumed)
  
     >, N>          SHN    Redirects output from a child's fd N (1 assumed)
     >>, N>>        SHN    Like '>', but appends to scalars or named files
     >&, &>         SHN    Redirects stdout & stderr from a child process
  
     <pty, N<pty    S      Like '<', but uses a pseudo-tty instead of a pipe
     >pty, N>pty    S      Like '>', but uses a pseudo-tty instead of a pipe
  
     N<&M                  Dups input fd N to input fd M
     M>&N                  Dups output fd N to input fd M
     N<&-                  Closes fd N
  
     <pipe, N<pipe     P   Pipe opens H for caller to read, write, close.
     >pipe, N>pipe     P   Pipe opens H for caller to read, write, close.
                        
  'N' and 'M' are placeholders for integer file descriptor numbers.  The
  terms 'input' and 'output' are from the child process's perspective.
  
  The SHNP field indicates what parameters an operator can take:
  
     S: \$scalar or \&function references.  Filters may be used with
        these operators (and only these).
     H: \*HANDLE or IO::Handle for caller to open, and close
     N: "file name".
     P: \*HANDLE or lexical filehandle opened by IPC::Run as the parent end of a pipe, but read
        and written to and closed by the caller (like IPC::Open3).
  
  =over
  
  =item Redirecting input: [n]<, [n]<pipe
  
  You can input the child reads on file descriptor number n to come from a
  scalar variable, subroutine, file handle, or a named file.  If stdin
  is not redirected, the parent's stdin is inherited.
  
     run \@cat, \undef          ## Closes child's stdin immediately
        or die "cat returned $?"; 
  
     run \@cat, \$in;
  
     run \@cat, \<<TOHERE;
     blah
     TOHERE
  
     run \@cat, \&input;       ## Calls &input, feeding data returned
                                ## to child's.  Closes child's stdin
                                ## when undef is returned.
  
  Redirecting from named files requires you to use the input
  redirection operator:
  
     run \@cat, '<.profile';
     run \@cat, '<', '.profile';
  
     open IN, "<foo";
     run \@cat, \*IN;
     run \@cat, *IN{IO};
  
  The form used second example here is the safest,
  since filenames like "0" and "&more\n" won't confuse &run:
  
  You can't do either of
  
     run \@a, *IN;      ## INVALID
     run \@a, '<', *IN; ## BUGGY: Reads file named like "*main::A"
     
  because perl passes a scalar containing a string that
  looks like "*main::A" to &run, and &run can't tell the difference
  between that and a redirection operator or a file name.  &run guarantees
  that any scalar you pass after a redirection operator is a file name.
  
  If your child process will take input from file descriptors other
  than 0 (stdin), you can use a redirection operator with any of the
  valid input forms (scalar ref, sub ref, etc.):
  
     run \@cat, '3<', \$in3;
  
  When redirecting input from a scalar ref, the scalar ref is
  used as a queue.  This allows you to use &harness and pump() to
  feed incremental bits of input to a coprocess.  See L</Coprocesses>
  below for more information.
  
  The <pipe operator opens the write half of a pipe on the filehandle
  glob reference it takes as an argument:
  
     $h = start \@cat, '<pipe', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  Unlike the other '<' operators, IPC::Run does nothing further with
  it: you are responsible for it.  The previous example is functionally
  equivalent to:
  
     pipe( \*R, \*IN ) or die $!;
     $h = start \@cat, '<', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  This is like the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Redirecting output: [n]>, [n]>>, [n]>&[m], [n]>pipe
  
  You can redirect any output the child emits
  to a scalar variable, subroutine, file handle, or file name.  You
  can have &run truncate or append to named files or scalars.  If
  you are redirecting stdin as well, or if the command is on the
  receiving end of a pipeline ('|'), you can omit the redirection
  operator:
  
     @ls = ( 'ls' );
     run \@ls, \undef, \$out
        or die "ls returned $?"; 
  
     run \@ls, \undef, \&out;  ## Calls &out each time some output
                                ## is received from the child's 
                                ## when undef is returned.
  
     run \@ls, \undef, '2>ls.err';
     run \@ls, '2>', 'ls.err';
  
  The two parameter form guarantees that the filename
  will not be interpreted as a redirection operator:
  
     run \@ls, '>', "&more";
     run \@ls, '2>', ">foo\n";
  
  You can pass file handles you've opened for writing:
  
     open( *OUT, ">out.txt" );
     open( *ERR, ">err.txt" );
     run \@cat, \*OUT, \*ERR;
  
  Passing a scalar reference and a code reference requires a little
  more work, but allows you to capture all of the output in a scalar
  or each piece of output by a callback:
  
  These two do the same things:
  
     run( [ 'ls' ], '2>', sub { $err_out .= $_[0] } );
  
  does the same basic thing as:
  
     run( [ 'ls' ], '2>', \$err_out );
  
  The subroutine will be called each time some data is read from the child.
  
  The >pipe operator is different in concept than the other '>' operators,
  although it's syntax is similar:
  
     $h = start \@cat, $in, '>pipe', \*OUT, '2>pipe', \*ERR;
     $in = "hello world\n";
     finish $h;
     print <OUT>;
     print <ERR>;
     close OUT;
     close ERR;
  
  causes two pipe to be created, with one end attached to cat's stdout
  and stderr, respectively, and the other left open on OUT and ERR, so
  that the script can manually
  read(), select(), etc. on them.  This is like
  the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Duplicating output descriptors: >&m, n>&m
  
  This duplicates output descriptor number n (default is 1 if n is omitted)
  from descriptor number m.
  
  =item Duplicating input descriptors: <&m, n<&m
  
  This duplicates input descriptor number n (default is 0 if n is omitted)
  from descriptor number m
  
  =item Closing descriptors: <&-, 3<&-
  
  This closes descriptor number n (default is 0 if n is omitted).  The
  following commands are equivalent:
  
     run \@cmd, \undef;
     run \@cmd, '<&-';
     run \@cmd, '<in.txt', '<&-';
  
  Doing
  
     run \@cmd, \$in, '<&-';    ## SIGPIPE recipe.
  
  is dangerous: the parent will get a SIGPIPE if $in is not empty.
  
  =item Redirecting both stdout and stderr: &>, >&, &>pipe, >pipe&
  
  The following pairs of commands are equivalent:
  
     run \@cmd, '>&', \$out;       run \@cmd, '>', \$out,     '2>&1';
     run \@cmd, '>&', 'out.txt';   run \@cmd, '>', 'out.txt', '2>&1';
  
  etc.
  
  File descriptor numbers are not permitted to the left or the right of
  these operators, and the '&' may occur on either end of the operator.
  
  The '&>pipe' and '>pipe&' variants behave like the '>pipe' operator, except
  that both stdout and stderr write to the created pipe.
  
  =item Redirection Filters
  
  Both input redirections and output redirections that use scalars or
  subs as endpoints may have an arbitrary number of filter subs placed
  between them and the child process.  This is useful if you want to
  receive output in chunks, or if you want to massage each chunk of
  data sent to the child.  To use this feature, you must use operator
  syntax:
  
     run(
        \@cmd
           '<', \&in_filter_2, \&in_filter_1, $in,
           '>', \&out_filter_1, \&in_filter_2, $out,
     );
  
  This capability is not provided for IO handles or named files.
  
  Two filters are provided by IPC::Run: appender and chunker.  Because
  these may take an argument, you need to use the constructor functions
  new_appender() and new_chunker() rather than using \& syntax:
  
     run(
        \@cmd
           '<', new_appender( "\n" ), $in,
           '>', new_chunker, $out,
     );
  
  =back
  
  =head2 Just doing I/O
  
  If you just want to do I/O to a handle or file you open yourself, you
  may specify a filehandle or filename instead of a command in the harness
  specification:
  
     run io( "filename", '>', \$recv );
  
     $h = start io( $io, '>', \$recv );
  
     $h = harness \@cmd, '&', io( "file", '<', \$send );
  
  =head2 Options
  
  Options are passed in as name/value pairs:
  
     run \@cat, \$in, debug => 1;
  
  If you pass the debug option, you may want to pass it in first, so you
  can see what parsing is going on:
  
     run debug => 1, \@cat, \$in;
  
  =over
  
  =item debug
  
  Enables debugging output in parent and child.  Debugging info is emitted
  to the STDERR that was present when IPC::Run was first C<use()>ed (it's
  C<dup()>ed out of the way so that it can be redirected in children without
  having debugging output emitted on it).
  
  =back
  
  =head1 RETURN VALUES
  
  harness() and start() return a reference to an IPC::Run harness.  This is
  blessed in to the IPC::Run package, so you may make later calls to
  functions as members if you like:
  
     $h = harness( ... );
     $h->start;
     $h->pump;
     $h->finish;
  
     $h = start( .... );
     $h->pump;
     ...
  
  Of course, using method call syntax lets you deal with any IPC::Run
  subclasses that might crop up, but don't hold your breath waiting for
  any.
  
  run() and finish() return TRUE when all subcommands exit with a 0 result
  code.  B<This is the opposite of perl's system() command>.
  
  All routines raise exceptions (via die()) when error conditions are
  recognized.  A non-zero command result is not treated as an error
  condition, since some commands are tests whose results are reported 
  in their exit codes.
  
  =head1 ROUTINES
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Exporter ();
  use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw{ Exporter };
  
      ## We use @EXPORT for the end user's convenience: there's only one function
      ## exported, it's homonymous with the module, it's an unusual name, and
      ## it can be suppressed by "use IPC::Run ();".
      @FILTER_IMP = qw( input_avail get_more_input );
      @FILTERS    = qw(
        new_appender
        new_chunker
        new_string_source
        new_string_sink
      );
      @API = qw(
        run
        harness start pump pumpable finish
        signal kill_kill reap_nb
        io timer timeout
        close_terminal
        binary
      );
      @EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
      %EXPORT_TAGS = (
          'filter_imp' => \@FILTER_IMP,
          'all'        => \@EXPORT_OK,
          'filters'    => \@FILTERS,
          'api'        => \@API,
      );
  
  }
  
  use strict;
  use warnings;
  use IPC::Run::Debug;
  use Exporter;
  use Fcntl;
  use POSIX ();
  
  BEGIN {
      if ( $] < 5.008 ) { require Symbol; }
  }
  use Carp;
  use File::Spec ();
  use IO::Handle;
  require IPC::Run::IO;
  require IPC::Run::Timer;
  
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  BEGIN {
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; 1;"
            or ( $@ && die )
            or die "$!";
      }
      else {
          eval "use File::Basename; 1;" or die $!;
      }
  }
  
  sub input_avail();
  sub get_more_input();
  
  ###############################################################################
  
  ##
  ## Error constants, not too locale-dependent
  use vars qw( $_EIO $_EAGAIN );
  use Errno qw(   EIO   EAGAIN );
  
  BEGIN {
      local $!;
      $!       = EIO;
      $_EIO    = qr/^$!/;
      $!       = EAGAIN;
      $_EAGAIN = qr/^$!/;
  }
  
  ##
  ## State machine states, set in $self->{STATE}
  ##
  ## These must be in ascending order numerically
  ##
  sub _newed()     { 0 }
  sub _harnessed() { 1 }
  sub _finished()  { 2 }    ## _finished behave almost exactly like _harnessed
  sub _started()   { 3 }
  
  ##
  ## Which fds have been opened in the parent.  This may have extra fds, since
  ## we aren't all that rigorous about closing these off, but that's ok.  This
  ## is used on Unixish OSs to close all fds in the child that aren't needed
  ## by that particular child.
  my %fds;
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  
  use vars qw( $cur_self );
  
  sub _debug_fd {
      return fileno STDERR unless defined $cur_self;
  
      if ( _debugging && !defined $cur_self->{DEBUG_FD} ) {
          my $fd = select STDERR;
          $| = 1;
          select $fd;
          $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
          _debug("debugging fd is $cur_self->{DEBUG_FD}\n")
            if _debugging_details;
      }
  
      return fileno STDERR unless defined $cur_self->{DEBUG_FD};
  
      return $cur_self->{DEBUG_FD};
  }
  
  sub DESTROY {
      ## We absolutely do not want to do anything else here.  We are likely
      ## to be in a child process and we don't want to do things like kill_kill
      ## ourself or cause other destruction.
      my IPC::Run $self = shift;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  
      for my $kid ( @{$self->{KIDS}} ) {
          for my $op ( @{$kid->{OPS}} ) {
              delete $op->{FILTERS};
          }
      }
  }
  
  ##
  ## Support routines (NOT METHODS)
  ##
  my %cmd_cache;
  
  sub _search_path {
      my ($cmd_name) = @_;
      if ( File::Spec->file_name_is_absolute($cmd_name) && -x $cmd_name ) {
          _debug "'", $cmd_name, "' is absolute"
            if _debugging_details;
          return $cmd_name;
      }
  
      my $dirsep = (
            Win32_MODE     ? '[/\\\\]'
          : $^O =~ /MacOS/ ? ':'
          : $^O =~ /VMS/   ? '[\[\]]'
          :                  '/'
      );
  
      if (   Win32_MODE
          && ( $cmd_name =~ /$dirsep/ )
          && ( $cmd_name !~ m!\.[^\\/\.]+$! ) ) {
  
          _debug "no extension(.exe), checking ENV{PATHEXT}" if _debugging;
          for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
              my $name = "$cmd_name$_";
              $cmd_name = $name, last if -f $name && -x _;
          }
          _debug "cmd_name is now '$cmd_name'" if _debugging;
      }
  
      if ( $cmd_name =~ /($dirsep)/ ) {
          _debug "'$cmd_name' contains '$1'" if _debugging;
          croak "file not found: $cmd_name"    unless -e $cmd_name;
          croak "not a file: $cmd_name"        unless -f $cmd_name;
          croak "permission denied: $cmd_name" unless -x $cmd_name;
          return $cmd_name;
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
            if _debugging;
          return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
          _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
            if _debugging;
          delete $cmd_cache{$cmd_name};
      }
  
      my @searched_in;
  
      ## This next bit is Unix/Win32 specific, unfortunately.
      ## There's been some conversation about extending File::Spec to provide
      ## a universal interface to PATH, but I haven't seen it yet.
      my $re = Win32_MODE ? qr/;/ : qr/:/;
  
    LOOP:
      for ( split( $re, $ENV{PATH} || '', -1 ) ) {
          $_ = "." unless length $_;
          push @searched_in, $_;
  
          my $prospect = File::Spec->catfile( $_, $cmd_name );
          my @prospects;
  
          @prospects =
            ( Win32_MODE && !( -f $prospect && -x _ ) )
            ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
            : ($prospect);
  
          for my $found (@prospects) {
              if ( -f $found && -x _ ) {
                  $cmd_cache{$cmd_name} = $found;
                  last LOOP;
              }
          }
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
            if _debugging_details;
          return $cmd_cache{$cmd_name};
      }
  
      croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
  }
  
  # Translate a command or CODE reference (a $kid->{VAL}) to a list of strings
  # suitable for passing to _debug().
  sub _debugstrings {
      my $operand = shift;
      if ( !defined $operand ) {
          return '<undef>';
      }
  
      my $ref = ref $operand;
      if ( !$ref ) {
          return length $operand < 50
            ? "'$operand'"
            : join( '', "'", substr( $operand, 0, 10 ), "...'" );
      }
      elsif ( $ref eq 'ARRAY' ) {
          return (
              '[ ',
              join( " ", map /[^\w.-]/ ? "'$_'" : $_, @$operand ),
              ' ]'
          );
      }
      elsif ( UNIVERSAL::isa( $operand, 'IPC::Run::Win32Process' ) ) {
          return "$operand";
      }
      return $ref;
  }
  
  sub _empty($) { !( defined $_[0] && length $_[0] ) }
  
  ## 'safe' versions of otherwise fun things to do. See also IPC::Run::Win32Helper.
  sub _close {
      confess 'undef' unless defined $_[0];
      my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
      if (Win32_MODE) {
  
          # Perl close() or POSIX::close() on the read end of a pipe hangs if
          # another process is in a read attempt on the same pipe
          # (https://github.com/Perl/perl5/issues/19963).  Since IPC::Run creates
          # pipes and shares them with user-defined kids, it's affected.  Work
          # around that by first using dup2() to replace the FD with a non-pipe.
          # Unfortunately, for socket FDs, dup2() closes the SOCKET with
          # CloseHandle().  CloseHandle() documentation leaves its behavior
          # undefined for sockets.  However, tests on Windows Server 2022 did not
          # leak memory, leak ports, or reveal any other obvious trouble.
          #
          # No failure here is fatal.  (_close() has worked that way, either due
          # to a principle or just due to a history of callers passing closed
          # FDs.)  croak() on EMFILE would be a bad user experience.  Better to
          # proceed and hope that $fd is not a being-read pipe.
          #
          # Since start() and other user-facing methods _close() many FDs, we
          # could optimize this by opening and closing the non-pipe FD just once
          # per method call.  The overhead of this simple approach was in the
          # noise, however.
          my $nul_fd = POSIX::open 'NUL';
          if ( !defined $nul_fd ) {
              _debug "open( NUL ) = ERROR $!" if _debugging_details;
          }
          else {
              my $r = POSIX::dup2( $nul_fd, $fd );
              _debug "dup2( $nul_fd, $fd ) = ERROR $!"
                if _debugging_details && !defined $r;
              $r = POSIX::close $nul_fd;
              _debug "close( $nul_fd (NUL) ) = ERROR $!"
                if _debugging_details && !defined $r;
          }
      }
      my $r = POSIX::close $fd;
      $r = $r ? '' : " ERROR $!";
      delete $fds{$fd};
      _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
  }
  
  sub _dup {
      confess 'undef' unless defined $_[0];
      my $r = POSIX::dup( $_[0] );
      croak "$!: dup( $_[0] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup( $_[0] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _dup2_rudely {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::dup2( $_[0], $_[1] );
      croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _exec {
      confess 'undef passed' if grep !defined, @_;
  
      #   exec @_ or croak "$!: exec( " . join( ', ', @_ ) . " )";
      _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
  
      #   {
  ## Commented out since we don't call this on Win32.
      #      # This works around the bug where 5.6.1 complains
      #      # "Can't exec ...: No error" after an exec on NT, where
      #      # exec() is simulated and actually returns in Perl's C
      #      # code, though Perl's &exec does not...
      #      no warnings "exec";
      #
      #      # Just in case the no warnings workaround
      #      # stops being a workaround, we don't want
      #      # old values of $! causing spurious strerr()
      #      # messages to appear in the "Can't exec" message
      #      undef $!;
      exec { $_[0] } @_;
  
      #   }
      #   croak "$!: exec( " . join( ', ', map "'$_'", @_ ) . " )";
      ## Fall through so $! can be reported to parent.
  }
  
  sub _sysopen {
      confess 'undef' unless defined $_[0] && defined $_[1];
      _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
        sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
        sprintf( "O_RDWR=0x%02x ",   O_RDWR ),
        sprintf( "O_TRUNC=0x%02x ",  O_TRUNC ),
        sprintf( "O_CREAT=0x%02x ",  O_CREAT ),
        sprintf( "O_APPEND=0x%02x ", O_APPEND ),
        if _debugging_details;
      my $r = POSIX::open( $_[0], $_[1], 0666 );
      croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
      _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
        if _debugging_data;
      $fds{$r} = {};
      return $r;
  }
  
  sub _pipe {
      ## Normal, blocking write for pipes that we read and the child writes,
      ## since most children expect writes to stdout to block rather than
      ## do a partial write.
      my ( $r, $w ) = POSIX::pipe;
      croak "$!: pipe()" unless defined $r;
      _debug "pipe() = ( $r, $w ) " if _debugging_details;
      @fds{$r, $w} = ( {}, {} );
      return ( $r, $w );
  }
  
  sub _pipe_nb {
      ## For pipes that we write, unblock the write side, so we can fill a buffer
      ## and continue to select().
      ## Contributed by Borislav Deianov <borislav@ensim.com>, with minor
      ## bugfix on fcntl result by me.
      local ( *R, *W );
      my $f = pipe( R, W );
      croak "$!: pipe()" unless defined $f;
      my ( $r, $w ) = ( fileno R, fileno W );
      _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
      unless (Win32_MODE) {
          ## POSIX::fcntl doesn't take fd numbers, so gotta use Perl's and
          ## then _dup the originals (which get closed on leaving this block)
          my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
          croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
          _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
      }
      ( $r, $w ) = ( _dup($r), _dup($w) );
      _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
      return ( $r, $w );
  }
  
  sub _pty {
      require IO::Pty;
      my $pty = IO::Pty->new();
      croak "$!: pty ()" unless $pty;
      $pty->autoflush();
      $pty->blocking(0) or croak "$!: pty->blocking ( 0 )";
      _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
        if _debugging_details;
      @fds{ $pty->fileno, $pty->slave->fileno } = ( {}, {} );
      return $pty;
  }
  
  sub _read {
      confess 'undef' unless defined $_[0];
      my $s = '';
      my $r = POSIX::read( $_[0], $s, 10_000 );
      croak "$!: read( $_[0] )" if not($r) and !$!{EINTR};
      $r ||= 0;
      _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
      return $s;
  }
  
  ## A METHOD, not a function.
  sub _spawn {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      croak "Can't spawn IPC::Run::Win32Process except on Win32"
        if UNIVERSAL::isa( $kid->{VAL}, 'IPC::Run::Win32Process' );
  
      _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
      my $sync_reader_fd;
      ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
      $kid->{PID} = fork();
      croak "$! during fork" unless defined $kid->{PID};
  
      unless ( $kid->{PID} ) {
          ## _do_kid_and_exit closes sync_reader_fd since it closes all unwanted and
          ## unloved fds.
          $self->_do_kid_and_exit($kid);
      }
      _debug "fork() = ", $kid->{PID} if _debugging_details;
  
      ## Wait for kid to get to it's exec() and see if it fails.
      _close $self->{SYNC_WRITER_FD};
      my $sync_pulse = _read $sync_reader_fd;
      _close $sync_reader_fd;
  
      if ( !defined $sync_pulse || length $sync_pulse ) {
          if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
              $kid->{RESULT} = $?;
          }
          else {
              $kid->{RESULT} = -1;
          }
          $sync_pulse = "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
            unless length $sync_pulse;
          croak $sync_pulse;
      }
      return $kid->{PID};
  
  ## Wait for pty to get set up.  This is a hack until we get synchronous
  ## selects.
      if ( keys %{ $self->{PTYS} } && $IO::Pty::VERSION < 0.9 ) {
          _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
          sleep 1;
      }
  }
  
  sub _write {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::write( $_[0], $_[1], length $_[1] );
      croak "$!: write( $_[0], '$_[1]' )" unless $r;
      _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
      return $r;
  }
  
  =pod
  
  =over
  
  =item run
  
  Run takes a harness or harness specification and runs it, pumping
  all input to the child(ren), closing the input pipes when no more
  input is available, collecting all output that arrives, until the
  pipes delivering output are closed, then waiting for the children to
  exit and reaping their result codes.
  
  You may think of C<run( ... )> as being like 
  
     start( ... )->finish();
  
  , though there is one subtle difference: run() does not
  set \$input_scalars to '' like finish() does.  If an exception is thrown
  from run(), all children will be killed off "gently", and then "annihilated"
  if they do not go gently (in to that dark night. sorry).
  
  If any exceptions are thrown, this does a L</kill_kill> before propagating
  them.
  
  =cut
  
  use vars qw( $in_run );    ## No, not Enron;)
  
  sub run {
      local $in_run = 1;     ## Allow run()-only optimizations.
      my IPC::Run $self = start(@_);
      my $r = eval {
          $self->{clear_ins} = 0;
          $self->finish;
      };
      if ($@) {
          my $x = $@;
          $self->kill_kill;
          die $x;
      }
      return $r;
  }
  
  =pod
  
  =item signal
  
     ## To send it a specific signal by name ("USR1"):
     signal $h, "USR1";
     $h->signal ( "USR1" );
  
  If $signal is provided and defined, sends a signal to all child processes.  Try
  not to send numeric signals, use C<"KILL"> instead of C<9>, for instance.
  Numeric signals aren't portable.
  
  Throws an exception if $signal is undef.
  
  This will I<not> clean up the harness, C<finish> it if you kill it.
  
  Normally TERM kills a process gracefully (this is what the command line utility
  C<kill> does by default), INT is sent by one of the keys C<^C>, C<Backspace> or
  C<E<lt>DelE<gt>>, and C<QUIT> is used to kill a process and make it coredump.
  
  The C<HUP> signal is often used to get a process to "restart", rereading 
  config files, and C<USR1> and C<USR2> for really application-specific things.
  
  Often, running C<kill -l> (that's a lower case "L") on the command line will
  list the signals present on your operating system.
  
  B<WARNING>: The signal subsystem is not at all portable.  We *may* offer
  to simulate C<TERM> and C<KILL> on some operating systems, submit code
  to me if you want this.
  
  B<WARNING 2>: Up to and including perl v5.6.1, doing almost anything in a
  signal handler could be dangerous.  The most safe code avoids all
  mallocs and system calls, usually by preallocating a flag before
  entering the signal handler, altering the flag's value in the
  handler, and responding to the changed value in the main system:
  
     my $got_usr1 = 0;
     sub usr1_handler { ++$got_signal }
  
     $SIG{USR1} = \&usr1_handler;
     while () { sleep 1; print "GOT IT" while $got_usr1--; }
  
  Even this approach is perilous if ++ and -- aren't atomic on your system
  (I've never heard of this on any modern CPU large enough to run perl).
  
  =cut
  
  sub signal {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      $self->_kill_kill_kill_pussycat_kill unless @_;
  
      Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
  
      my ($signal) = @_;
      croak "Undefined signal passed to signal" unless defined $signal;
      for ( grep $_->{PID} && !defined $_->{RESULT}, @{ $self->{KIDS} } ) {
          _debug "sending $signal to $_->{PID}"
            if _debugging;
          kill $signal, $_->{PID}
            or _debugging && _debug "$! sending $signal to $_->{PID}";
      }
  
      return;
  }
  
  =pod
  
  =item kill_kill
  
     ## To kill off a process:
     $h->kill_kill;
     kill_kill $h;
  
     ## To specify the grace period other than 30 seconds:
     kill_kill $h, grace => 5;
  
     ## To send QUIT instead of KILL if a process refuses to die:
     kill_kill $h, coup_d_grace => "QUIT";
  
  Sends a C<TERM>, waits for all children to exit for up to 30 seconds, then
  sends a C<KILL> to any that survived the C<TERM>.
  
  Will wait for up to 30 more seconds for the OS to successfully C<KILL> the
  processes.
  
  The 30 seconds may be overridden by setting the C<grace> option, this
  overrides both timers.
  
  The harness is then cleaned up.
  
  The doubled name indicates that this function may kill again and avoids
  colliding with the core Perl C<kill> function.
  
  Returns a 1 if the C<TERM> was sufficient, or a 0 if C<KILL> was 
  required.  Throws an exception if C<KILL> did not permit the children
  to be reaped.
  
  B<NOTE>: The grace period is actually up to 1 second longer than that
  given.  This is because the granularity of C<time> is 1 second.  Let me
  know if you need finer granularity, we can leverage Time::HiRes here.
  
  B<Win32>: Win32 does not know how to send real signals, so C<TERM> is
  a full-force kill on Win32.  Thus all talk of grace periods, etc. do
  not apply to Win32.
  
  =cut
  
  sub kill_kill {
      my IPC::Run $self = shift;
  
      my %options = @_;
      my $grace   = $options{grace};
      $grace = 30 unless defined $grace;
      ++$grace;    ## Make grace time a _minimum_
  
      my $coup_d_grace = $options{coup_d_grace};
      $coup_d_grace = "KILL" unless defined $coup_d_grace;
  
      delete $options{$_} for qw( grace coup_d_grace );
      Carp::cluck "Ignoring unknown options for kill_kill: ",
        join " ", keys %options
        if keys %options;
  
      if (Win32_MODE) {
  	# immediate brutal death for Win32
  	# TERM has unfortunate side-effects
  	$self->signal("KILL")
      }
      else {
  	$self->signal("TERM");
      }
  
      my $quitting_time = time + $grace;
      my $delay         = 0.01;
      my $accum_delay;
  
      my $have_killed_before;
  
      while () {
          ## delay first to yield to other processes
          select undef, undef, undef, $delay;
          $accum_delay += $delay;
  
          $self->reap_nb;
          last unless $self->_running_kids;
  
          if ( $accum_delay >= $grace * 0.8 ) {
              ## No point in checking until delay has grown some.
              if ( time >= $quitting_time ) {
                  if ( !$have_killed_before ) {
                      $self->signal($coup_d_grace);
                      $have_killed_before = 1;
                      $quitting_time += $grace;
                      $delay       = 0.01;
                      $accum_delay = 0;
                      next;
                  }
                  croak "Unable to reap all children, even after KILLing them";
              }
          }
  
          $delay *= 2;
          $delay = 0.5 if $delay >= 0.5;
      }
  
      $self->_cleanup;
      return $have_killed_before;
  }
  
  =pod
  
  =item harness
  
  Takes a harness specification and returns a harness.  This harness is
  blessed in to IPC::Run, allowing you to use method call syntax for
  run(), start(), et al if you like.
  
  harness() is provided so that you can pre-build harnesses if you
  would like to, but it's not required..
  
  You may proceed to run(), start() or pump() after calling harness() (pump()
  calls start() if need be).  Alternatively, you may pass your
  harness specification to run() or start() and let them harness() for
  you.  You can't pass harness specifications to pump(), though.
  
  =cut
  
  ##
  ## Notes: I've avoided handling a scalar that doesn't look like an
  ## opcode as a here document or as a filename, though I could DWIM
  ## those.  I'm not sure that the advantages outweigh the danger when
  ## the DWIMer guesses wrong.
  ##
  ## TODO: allow user to spec default shell. Hmm, globally, in the
  ## lexical scope hash, or per instance?  'Course they can do that
  ## now by using a [...] to hold the command.
  ##
  my $harness_id = 0;
  
  sub harness {
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      #   local $IPC::Run::debug = $options->{debug}
      #      if $options && defined $options->{debug};
  
      my @args;
      if ( @_ == 1 && !ref $_[0] ) {
          if (Win32_MODE) {
              my $command = $ENV{ComSpec} || 'cmd';
              @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
          }
          else {
              @args = ( [ qw( sh -c ), @_ ] );
          }
      }
      elsif ( @_ > 1 && !grep ref $_, @_ ) {
          @args = ( [@_] );
      }
      else {
          @args = map { !defined $_ ? bless(\$_, 'IPC::Run::Undef') : $_ } @_;
      }
  
      my @errs;    # Accum errors, emit them when done.
  
      my $succinct;    # set if no redir ops are required yet.  Cleared
                       # if an op is seen.
  
      my $cur_kid;     # references kid or handle being parsed
      my $next_kid_close_stdin = 0;
  
      my $assumed_fd = 0;    # fd to assume in succinct mode (no redir ops)
      my $handle_num = 0;    # 1... is which handle we're parsing
  
      my IPC::Run $self = bless {}, __PACKAGE__;
  
      local $cur_self = $self;
  
      $self->{ID}    = ++$harness_id;
      $self->{IOS}   = [];
      $self->{KIDS}  = [];
      $self->{PIPES} = [];
      $self->{PTYS}  = {};
      $self->{STATE} = _newed;
  
      if ($options) {
          $self->{$_} = $options->{$_} for keys %$options;
      }
  
      _debug "****** harnessing *****" if _debugging;
  
      my $first_parse;
      local $_;
      my $arg_count = @args;
      while (@args) {
          for ( shift @args ) {
              eval {
                  $first_parse = 1;
                  _debug( "parsing ", _debugstrings($_) ) if _debugging;
  
                REPARSE:
                  if (   ref eq 'ARRAY'
                      || UNIVERSAL::isa( $_, 'IPC::Run::Win32Process' )
                      || ( !$cur_kid && ref eq 'CODE' ) ) {
                      croak "Process control symbol ('|', '&') missing" if $cur_kid;
                      croak "Can't spawn a subroutine on Win32"
                        if Win32_MODE && ref eq "CODE";
                      $cur_kid = {
                          TYPE   => 'cmd',
                          VAL    => $_,
                          NUM    => @{ $self->{KIDS} } + 1,
                          OPS    => [],
                          PID    => '',
                          RESULT => undef,
                      };
  
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => 0,
                      } if $next_kid_close_stdin;
                      $next_kid_close_stdin = 0;
  
                      push @{ $self->{KIDS} }, $cur_kid;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
                      push @{ $self->{IOS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
                      push @{ $self->{TIMERS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif (/^(\d*)>&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 1,
                      };
                      _debug "redirect operators now required" if _debugging_details;
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&-$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*) (<pipe)()            ()  ()  $/x
                      || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
                      || /^(\d*) (<)    ()            ()  (.*)$/x ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = $2 . $4;
  
                      my $kfd = length $1 ? $1 : 0;
  
                      my $pty_id;
                      if ( $type eq '<pty<' ) {
                          $pty_id = length $3 ? $3 : '0';
                          ## do the require here to cause early error reporting
                          require IO::Pty;
                          ## Just flag the pyt's existence for now.  It'll be
                          ## converted to a real IO::Pty by _open_pipes.
                          $self->{PTYS}->{$pty_id} = undef;
                      }
  
                      my $source = $5;
  
                      my @filters;
                      my $binmode;
  
                      unless ( length $source ) {
                          if ( !$succinct ) {
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      push @filters, shift @args;
                                  }
                              }
                          }
                          $source = shift @args;
                          croak "'$_' missing a source" if _empty $source;
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s input fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
                      }
  
                      my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $source, $binmode, @filters );
  
                      if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
                          && $type !~ /^<p(ty<|ipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                          _dont_inherit($source) if Win32_MODE;
                      }
  
                      push @{ $cur_kid->{OPS} }, $pipe;
                  }
  
                  elsif (
                         /^()   (>>?)  (&)     ()      (.*)$/x
                      || /^()   (&)    (>pipe) ()      ()  $/x
                      || /^()   (>pipe)(&)     ()      ()  $/x
                      || /^(\d*)()     (>pipe) ()      ()  $/x
                      || /^()   (&)    (>pty)  ( \w*)> ()  $/x
  ## TODO:    ||   /^()   (>pty) (\d*)> (&) ()  $/x
                      || /^(\d*)()     (>pty)  ( \w*)> ()  $/x
                      || /^()   (&)    (>>?)   ()      (.*)$/x || /^(\d*)()     (>>?)   ()      (.*)$/x
                    ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = (
                            $2 eq '>pipe' || $3 eq '>pipe' ? '>pipe'
                          : $2 eq '>pty'  || $3 eq '>pty'  ? '>pty>'
                          :                                  '>'
                      );
                      my $kfd = length $1 ? $1 : 1;
                      my $trunc = !( $2 eq '>>' || $3 eq '>>' );
                      my $pty_id = (
                            $2 eq '>pty' || $3 eq '>pty'
                          ? length $4
                                ? $4
                                : 0
                          : undef
                      );
  
                      my $stderr_too =
                           $2 eq '&'
                        || $3 eq '&'
                        || ( !length $1 && substr( $type, 0, 4 ) eq '>pty' );
  
                      my $dest = $5;
                      my @filters;
                      my $binmode = 0;
                      unless ( length $dest ) {
                          if ( !$succinct ) {
                              ## unshift...shift: '>' filters source...sink left...right
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      unshift @filters, shift @args;
                                  }
                              }
                          }
  
  			if ( @args && ref $args[0] eq 'IPC::Run::Undef' ) {
  			    require Symbol;
  			    ${ $args[0] } = $dest = Symbol::gensym();
  			    shift @args;
  			}
  			else {
  			    $dest = shift @args;
  			}
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s output fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
  
                          if ( $type eq '>pty>' ) {
                              ## do the require here to cause early error reporting
                              require IO::Pty;
                              ## Just flag the pyt's existence for now.  _open_pipes()
                              ## will new an IO::Pty for each key.
                              $self->{PTYS}->{$pty_id} = undef;
                          }
                      }
  
                      croak "'$_' missing a destination" if _empty $dest;
                      my $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $dest, $binmode, @filters );
                      $pipe->{TRUNC} = $trunc;
  
                      if ( ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
                          && $type !~ /^>(pty>|pipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                      }
                      push @{ $cur_kid->{OPS} }, $pipe;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => 1,
                          KFD2 => 2,
                      } if $stderr_too;
                  }
  
                  elsif ( $_ eq "|" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => '|',
                          KFD  => 1,
                      };
                      $succinct   = 1;
                      $assumed_fd = 1;
                      $cur_kid    = undef;
                  }
  
                  elsif ( $_ eq "&" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      $next_kid_close_stdin = 1;
                      $succinct             = 1;
                      $assumed_fd           = 0;
                      $cur_kid              = undef;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( !ref $_ ) {
                      $self->{$_} = shift @args;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( $succinct && $first_parse ) {
                      ## It's not an opcode, and no explicit opcodes have been
                      ## seen yet, so assume it's a file name.
                      unshift @args, $_;
                      if ( !$assumed_fd ) {
                          $_ = "$assumed_fd<",
                      }
                      else {
                          $_ = "$assumed_fd>",
                      }
                      _debug "assuming '", $_, "'" if _debugging_details;
                      ++$assumed_fd;
                      $first_parse = 0;
                      goto REPARSE;
                  }
  
                  else {
                      croak join(
                          '',
                          'Unexpected ',
                          ( ref() ? $_ : 'scalar' ),
                          ' in harness() parameter ',
                          $arg_count - @args
                      );
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      die join( '', @errs ) if @errs;
  
      $self->{STATE} = _harnessed;
  
      #   $self->timeout( $options->{timeout} ) if exists $options->{timeout};
      return $self;
  }
  
  sub _open_pipes {
      my IPC::Run $self = shift;
  
      my @errs;
  
      my @close_on_fail;
  
      ## When a pipe character is seen, a pipe is created.  $pipe_read_fd holds
      ## the dangling read end of the pipe until we get to the next process.
      my $pipe_read_fd;
  
      ## Output descriptors for the last command are shared by all children.
      ## @output_fds_accum accumulates the current set of output fds.
      my @output_fds_accum;
  
      for ( sort keys %{ $self->{PTYS} } ) {
          _debug "opening pty '", $_, "'" if _debugging_details;
          my $pty = _pty;
          $self->{PTYS}->{$_} = $pty;
      }
  
      for ( @{ $self->{IOS} } ) {
          eval { $_->init; };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
          else {
              push @close_on_fail, $_;
          }
      }
  
      ## Loop through the kids and their OPS, interpreting any that require
      ## parent-side actions.
      for my $kid ( @{ $self->{KIDS} } ) {
          if ( ref $kid->{VAL} eq 'ARRAY' ) {
              $kid->{PATH} = _search_path $kid->{VAL}->[0];
          }
          if ( defined $pipe_read_fd ) {
              _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
                if _debugging_details;
              unshift @{ $kid->{OPS} }, {
                  TYPE => 'PIPE',          ## Prevent next loop from triggering on this
                  KFD  => 0,
                  TFD  => $pipe_read_fd,
              };
              $pipe_read_fd = undef;
          }
          @output_fds_accum = ();
          for my $op ( @{ $kid->{OPS} } ) {
  
              #         next if $op->{IS_DEBUG};
              my $ok = eval {
                  if ( $op->{TYPE} eq '<' ) {
                      my $source = $op->{SOURCE};
                      if ( !ref $source ) {
                          _debug(
                              "kid ",              $kid->{NUM}, " to read ", $op->{KFD},
                              " from '" . $source, "' (read only)"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen( $source, O_RDONLY );
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif (UNIVERSAL::isa( $source, 'GLOB' )
                          || UNIVERSAL::isa( $source, 'IO::Handle' ) ) {
                          croak "Unopened filehandle in input redirect for $op->{KFD}"
                            unless defined fileno $source;
                          $op->{TFD} = fileno $source;
                          _debug(
                              "kid ",      $kid->{NUM}, " to read ", $op->{KFD},
                              " from fd ", $op->{TFD}
                          ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                          _debug(
                              "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                              " from SCALAR"
                          ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                          _debug( 'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE' ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      else {
                          croak( "'" . ref($source) . "' not allowed as a source for input redirection" );
                      }
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pipe' ) {
                      _debug(
                          'kid to read ', $op->{KFD},
                          ' from a pipe IPC::Run opens and returns',
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
                      _debug "caller will write to ", fileno $op->{SOURCE}
                        if _debugging_details;
  
                      $op->{TFD} = $r;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pty<' ) {
                      _debug(
                          'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
                      ) if _debugging_details;
  
                      for my $source ( $op->{SOURCE} ) {
                          if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                              _debug(
                                  "kid ",                   $kid->{NUM},   " to read ", $op->{KFD},
                                  " from SCALAR via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
  
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                              _debug(
                                  "kid ",                 $kid->{NUM},   " to read ", $op->{KFD},
                                  " from CODE via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          else {
                              croak( "'" . ref($source) . "' not allowed as a source for '<pty<' redirection" );
                          }
                      }
                      $op->{FD}  = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD} = undef;                                      # The fd isn't known until after fork().
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '>' ) {
                      ## N> output redirection.
                      my $dest = $op->{DEST};
                      if ( !ref $dest ) {
                          _debug(
                              "kid ",  $kid->{NUM}, " to write ", $op->{KFD},
                              " to '", $dest,       "' (write only, create, ",
                              ( $op->{TRUNC} ? 'truncate' : 'append' ),
                              ")"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen(
                              $dest,
                              ( O_WRONLY | O_CREAT | ( $op->{TRUNC} ? O_TRUNC : O_APPEND ) )
                          );
                          if (Win32_MODE) {
                              ## I have no idea why this is needed to make the current
                              ## file position survive the gyrations TFD must go
                              ## through...
                              POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
                          }
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
                          croak("Unopened filehandle in output redirect, command $kid->{NUM}") unless defined fileno $dest;
                          ## Turn on autoflush, mostly just to flush out
                          ## existing output.
                          my $old_fh = select($dest);
                          $| = 1;
                          select($old_fh);
                          $op->{TFD} = fileno $dest;
                          _debug( 'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD} ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug( "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR" ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug("kid $kid->{NUM} to write $op->{KFD} to CODE") if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
  
                  elsif ( $op->{TYPE} eq '>pipe' ) {
                      ## N> output redirection to a pipe we open, but don't select()
                      ## on.
                      _debug(
                          "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                          ' to a pipe IPC::Run opens and returns'
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
                      _debug "caller will read from ", fileno $op->{DEST}
                        if _debugging_details;
  
                      $op->{TFD} = $w;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
  
                      $output_fds_accum[ $op->{KFD} ] = $op;
                  }
                  elsif ( $op->{TYPE} eq '>pty>' ) {
                      my $dest = $op->{DEST};
                      if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug(
                              "kid ",                 $kid->{NUM},   " to write ", $op->{KFD},
                              " to SCALAR via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
  
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug(
                              "kid ",               $kid->{NUM},   " to write ", $op->{KFD},
                              " to CODE via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
  
                      $op->{FD}                       = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD}                      = undef;                                      # The fd isn't known until after fork().
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '|' ) {
                      _debug( "pipelining $kid->{NUM} and " . ( $kid->{NUM} + 1 ) ) if _debugging_details;
                      ( $pipe_read_fd, $op->{TFD} ) = _pipe;
                      if (Win32_MODE) {
                          _dont_inherit($pipe_read_fd);
                          _dont_inherit( $op->{TFD} );
                      }
                      @output_fds_accum = ();
                  }
                  elsif ( $op->{TYPE} eq '&' ) {
                      @output_fds_accum = ();
                  }    # end if $op->{TYPE} tree
                  1;
              };    # end eval
              unless ($ok) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }    # end for ( OPS }
      }
  
      if (@errs) {
          for (@close_on_fail) {
              _close($_);
              $_ = undef;
          }
          for ( keys %{ $self->{PTYS} } ) {
              next unless $self->{PTYS}->{$_};
              close $self->{PTYS}->{$_};
              $self->{PTYS}->{$_} = undef;
          }
          die join( '', @errs );
      }
  
      ## give all but the last child all of the output file descriptors
      ## These will be reopened (and thus rendered useless) if the child
      ## dup2s on to these descriptors, since we unshift these.  This way
      ## each process emits output to the same file descriptors that the
      ## last child will write to.  This is probably not quite correct,
      ## since each child should write to the file descriptors inherited
      ## from the parent.
      ## TODO: fix the inheritance of output file descriptors.
      ## NOTE: This sharing of OPS among kids means that we can't easily put
      ## a kid number in each OPS structure to ping the kid when all ops
      ## have closed (when $self->{PIPES} has emptied).  This means that we
      ## need to scan the KIDS whenever @{$self->{PIPES}} is empty to see
      ## if there any of them are still alive.
      for ( my $num = 0; $num < $#{ $self->{KIDS} }; ++$num ) {
          for ( reverse @output_fds_accum ) {
              next unless defined $_;
              _debug(
                  'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
                  ' to ', ref $_->{DEST}
              ) if _debugging_details;
              unshift @{ $self->{KIDS}->[$num]->{OPS} }, $_;
          }
      }
  
      ## Open the debug pipe if we need it
      ## Create the list of PIPES we need to scan and the bit vectors needed by
      ## select().  Do this first so that _cleanup can _clobber() them if an
      ## exception occurs.
      @{ $self->{PIPES} } = ();
      $self->{RIN} = '';
      $self->{WIN} = '';
      $self->{EIN} = '';
      ## PIN is a vec()tor that indicates who's paused.
      $self->{PIN} = '';
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{FD} ) {
                  _debug(
                      'kid ',    $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
                      ' is my ', $_->{FD}
                  ) if _debugging_details;
                  vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $_->{FD}, 1 ) = 1;
                  push @{ $self->{PIPES} }, $_;
              }
          }
      }
  
      for my $io ( @{ $self->{IOS} } ) {
          my $fd = $io->fileno;
          vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
          vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
  
          #      vec( $self->{EIN}, $fd, 1 ) = 1;
          push @{ $self->{PIPES} }, $io;
      }
  
      ## Put filters on the end of the filter chains to read & write the pipes.
      ## Clear pipe states
      for my $pipe ( @{ $self->{PIPES} } ) {
          $pipe->{SOURCE_EMPTY} = 0;
          $pipe->{PAUSED}       = 0;
          if ( $pipe->{TYPE} =~ /^>/ ) {
              my $pipe_reader = sub {
                  my ( undef, $out_ref ) = @_;
  
                  return undef unless defined $pipe->{FD};
                  return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
  
                  vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
  
                  _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
                  my $in = eval { _read( $pipe->{FD} ) };
                  if ($@) {
                      $in = '';
                      ## IO::Pty throws the Input/output error if the kid dies.
                      ## read() throws the bad file descriptor message if the
                      ## kid dies on Win32.
                      die $@
                        unless $@ =~ $_EIO
                        || ( $@ =~ /input or output/ && $^O =~ /aix/ )
                        || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
                  }
  
                  unless ( length $in ) {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  ## Protect the position so /.../g matches may be used.
                  my $pos = pos $$out_ref;
                  $$out_ref .= $in;
                  pos($$out_ref) = $pos;
                  return 1;
              };
              ## Input filters are the last filters
              push @{ $pipe->{FILTERS} },      $pipe_reader;
              push @{ $self->{TEMP_FILTERS} }, $pipe_reader;
          }
          else {
              my $pipe_writer = sub {
                  my ( $in_ref, $out_ref ) = @_;
                  return undef unless defined $pipe->{FD};
                  return 0
                    unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
                    || $pipe->{PAUSED};
  
                  vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
  
                  if ( !length $$in_ref ) {
                      if ( !defined get_more_input ) {
                          $self->_clobber($pipe);
                          return undef;
                      }
                  }
  
                  unless ( length $$in_ref ) {
                      unless ( $pipe->{PAUSED} ) {
                          _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
                          vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
  
                          #		  vec( $self->{EIN}, $pipe->{FD}, 1 ) = 0;
                          vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
                          $pipe->{PAUSED} = 1;
                      }
                      return 0;
                  }
                  _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
  
                  if ( length $$in_ref && $$in_ref ) {
                      my $c = _write( $pipe->{FD}, $$in_ref );
                      substr( $$in_ref, 0, $c, '' );
                  }
                  else {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  return 1;
              };
              ## Output filters are the first filters
              unshift @{ $pipe->{FILTERS} }, $pipe_writer;
              push @{ $self->{TEMP_FILTERS} }, $pipe_writer;
          }
      }
  }
  
  sub _dup2_gently {
      ## A METHOD, NOT A FUNCTION, NEEDS $self!
      my IPC::Run $self = shift;
      my ( $files, $fd1, $fd2 ) = @_;
      ## Moves TFDs that are using the destination fd out of the
      ## way before calling _dup2
      for (@$files) {
          next unless defined $_->{TFD};
          $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
      }
      if ( defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2 ) {
          $self->{DEBUG_FD} = _dup $self->{DEBUG_FD};
          $fds{$self->{DEBUG_FD}}{needed} = 1;
      }
      _dup2_rudely( $fd1, $fd2 );
  }
  
  =pod
  
  =item close_terminal
  
  This is used as (or in) an init sub to cast off the bonds of a controlling
  terminal.  It must precede all other redirection ops that affect
  STDIN, STDOUT, or STDERR to be guaranteed effective.
  
  =cut
  
  sub close_terminal {
      ## Cast of the bonds of a controlling terminal
  
      # Just in case the parent (I'm talking to you FCGI) had these tied.
      untie *STDIN;
      untie *STDOUT;
      untie *STDERR;
  
      POSIX::setsid() || croak "POSIX::setsid() failed";
      _debug "closing stdin, out, err"
        if _debugging_details;
      close STDIN;
      close STDERR;
      close STDOUT;
  }
  
  sub _do_kid_and_exit {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      my ( $s1, $s2 );
      if ( $] < 5.008 ) {
          ## For unknown reasons, placing these two statements in the eval{}
          ## causes the eval {} to not catch errors after they are executed in
          ## perl 5.6.0, godforsaken version that it is...not sure about 5.6.1.
          ## Part of this could be that these symbols get destructed when
          ## exiting the eval, and that destruction might be what's (wrongly)
          ## confusing the eval{}, allowing the exception to propagate.
          $s1 = Symbol::gensym();
          $s2 = Symbol::gensym();
      }
  
      eval {
          local $cur_self = $self;
  
          if (_debugging) {
              _set_child_debug_name(
                  ref $kid->{VAL} eq "CODE"
                  ? "CODE"
                  : basename( $kid->{VAL}->[0] )
              );
          }
  
          ## close parent FD's first so they're out of the way.
          ## Don't close STDIN, STDOUT, STDERR: they should be inherited or
          ## overwritten below.
          do { $_->{needed} = 1 for @fds{0..2} }
             unless $self->{noinherit};
  
          $fds{$self->{SYNC_WRITER_FD}}{needed} = 1;
          $fds{$self->{DEBUG_FD}}{needed} = 1 if defined $self->{DEBUG_FD};
  
          $fds{$_->{TFD}}{needed} = 1
             foreach grep { defined $_->{TFD} } @{$kid->{OPS} };
  
  
          ## TODO: use the forthcoming IO::Pty to close the terminal and
          ## make the first pty for this child the controlling terminal.
          ## This will also make it so that pty-laden kids don't cause
          ## other kids to lose stdin/stdout/stderr.
  
          if ( %{ $self->{PTYS} } ) {
              ## Clean up the parent's fds.
              for ( keys %{ $self->{PTYS} } ) {
                  _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
                  $self->{PTYS}->{$_}->make_slave_controlling_terminal;
                  my $slave = $self->{PTYS}->{$_}->slave;
   	        delete $fds{$self->{PTYS}->{$_}->fileno};
                  close $self->{PTYS}->{$_};
                  $self->{PTYS}->{$_} = $slave;
              }
  
              close_terminal;
              delete @fds{0..2};
          }
  
          for my $sibling ( @{ $self->{KIDS} } ) {
              for ( @{ $sibling->{OPS} } ) {
                  if ( $_->{TYPE} =~ /^.pty.$/ ) {
                      $_->{TFD} = $self->{PTYS}->{ $_->{PTY_ID} }->fileno;
                      $fds{$_->{TFD}}{needed} = 1;
                  }
  
                  #	    for ( $_->{FD}, ( $sibling != $kid ? $_->{TFD} : () ) ) {
                  #	       if ( defined $_ && ! $closed[$_] && ! $needed[$_] ) {
                  #		  _close( $_ );
                  #		  $closed[$_] = 1;
                  #		  $_ = undef;
                  #	       }
                  #	    }
              }
          }
  
          ## This is crude: we have no way of keeping track of browsing all open
          ## fds, so we scan to a fairly high fd.
          _debug "open fds: ", join " ", keys %fds if _debugging_details;
  
          _close( $_ ) foreach grep { ! $fds{$_}{needed} } keys %fds;
  
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{TFD} ) {
  
                  # we're always creating KFD
                  $fds{$_->{KFD}}{needed} = 1;
  
                  unless ( $_->{TFD} == $_->{KFD} ) {
                      $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
                      $fds{$_->{TFD}}{lazy_close} = 1;
                  } else {
                      my $fd = _dup($_->{TFD});
                      $self->_dup2_gently( $kid->{OPS}, $fd, $_->{KFD} );
                      _close($fd);
                  }
              }
              elsif ( $_->{TYPE} eq 'dup' ) {
                  $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
                    unless $_->{KFD1} == $_->{KFD2};
                  $fds{$_->{KFD2}}{needed} = 1;
              }
              elsif ( $_->{TYPE} eq 'close' ) {
                  for ( $_->{KFD} ) {
                      if ( $fds{$_} ) {
                          _close($_);
                          $_ = undef;
                      }
                  }
              }
              elsif ( $_->{TYPE} eq 'init' ) {
                  $_->{SUB}->();
              }
          }
  
          _close( $_ ) foreach grep { $fds{$_}{lazy_close} } keys %fds;
  
          if ( ref $kid->{VAL} ne 'CODE' ) {
              open $s1, ">&=$self->{SYNC_WRITER_FD}"
                or croak "$! setting filehandle to fd SYNC_WRITER_FD";
              fcntl $s1, F_SETFD, 1;
  
              if ( defined $self->{DEBUG_FD} ) {
                  open $s2, ">&=$self->{DEBUG_FD}"
                    or croak "$! setting filehandle to fd DEBUG_FD";
                  fcntl $s2, F_SETFD, 1;
              }
  
              if (_debugging) {
                  my @cmd = ( $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] );
                  _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd;
              }
  
              die "exec failed: simulating exec() failure"
                if $self->{_simulate_exec_failure};
  
              _exec $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ];
  
              croak "exec failed: $!";
          }
      };
      if ($@) {
          _write $self->{SYNC_WRITER_FD}, $@;
          ## Avoid DESTROY.
          POSIX::_exit(1);
      }
  
      ## We must be executing code in the child, otherwise exec() would have
      ## prevented us from being here.
      _close $self->{SYNC_WRITER_FD};
      _debug 'calling fork()ed CODE ref' if _debugging;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      ## TODO: Overload CORE::GLOBAL::exit...
      $kid->{VAL}->();
  
      ## There are bugs in perl closures up to and including 5.6.1
      ## that may keep this next line from having any effect, and it
      ## won't have any effect if our caller has kept a copy of it, but
      ## this may cause the closure to be cleaned up.  Maybe.
      $kid->{VAL} = undef;
  
      ## Use POSIX::_exit to avoid global destruction, since this might
      ## cause DESTROY() to be called on objects created in the parent
      ## and thus cause double cleanup.  For instance, if DESTROY() unlinks
      ## a file in the child, we don't want the parent to suddenly miss
      ## it.
      POSIX::_exit(0);
  }
  
  =pod
  
  =item start
  
     $h = start(
        \@cmd, \$in, \$out, ...,
        timeout( 30, name => "process timeout" ),
        $stall_timeout = timeout( 10, name => "stall timeout"   ),
     );
  
     $h = start \@cmd, '<', \$in, '|', \@cmd2, ...;
  
  start() accepts a harness or harness specification and returns a harness
  after building all of the pipes and launching (via fork()/exec(), or, maybe
  someday, spawn()) all the child processes.  It does not send or receive any
  data on the pipes, see pump() and finish() for that.
  
  You may call harness() and then pass it's result to start() if you like,
  but you only need to if it helps you structure or tune your application.
  If you do call harness(), you may skip start() and proceed directly to
  pump.
  
  start() also starts all timers in the harness.  See L<IPC::Run::Timer>
  for more information.
  
  start() flushes STDOUT and STDERR to help you avoid duplicate output.
  It has no way of asking Perl to flush all your open filehandles, so
  you are going to need to flush any others you have open.  Sorry.
  
  Here's how if you don't want to alter the state of $| for your
  filehandle:
  
     $ofh = select HANDLE; $of = $|; $| = 1; $| = $of; select $ofh;
  
  If you don't mind leaving output unbuffered on HANDLE, you can do
  the slightly shorter
  
     $ofh = select HANDLE; $| = 1; select $ofh;
  
  Or, you can use IO::Handle's flush() method:
  
     use IO::Handle;
     flush HANDLE;
  
  Perl needs the equivalent of C's fflush( (FILE *)NULL ).
  
  =cut
  
  sub start {
  
      # $SIG{__DIE__} = sub { my $s = shift; Carp::cluck $s; die $s };
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      my IPC::Run $self;
      if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
          $self = shift;
          $self->{$_} = $options->{$_} for keys %$options;
      }
      else {
          $self = harness( @_, $options ? $options : () );
      }
  
      local $cur_self = $self;
  
      $self->kill_kill if $self->{STATE} == _started;
  
      _debug "** starting" if _debugging;
  
      $_->{RESULT} = undef for @{ $self->{KIDS} };
  
      ## Assume we're not being called from &run.  It will correct our
      ## assumption if need be.  This affects whether &_select_loop clears
      ## input queues to '' when they're empty.
      $self->{clear_ins} = 1;
  
      IPC::Run::Win32Helper::optimize $self
        if Win32_MODE && $in_run;
  
      my @errs;
  
      for ( @{ $self->{TIMERS} } ) {
          eval { $_->start };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
      }
  
      eval { $self->_open_pipes };
      if ($@) {
          push @errs, $@;
          _debug 'caught ', $@ if _debugging;
      }
  
      if ( !@errs ) {
          ## This is a bit of a hack, we should do it for all open filehandles.
          ## Since there's no way I know of to enumerate open filehandles, we
          ## autoflush STDOUT and STDERR.  This is done so that the children don't
          ## inherit output buffers chock full o' redundant data.  It's really
          ## confusing to track that down.
          { my $ofh = select STDOUT; my $of = $|; $| = 1; $| = $of; select $ofh; }
          { my $ofh = select STDERR; my $of = $|; $| = 1; $| = $of; select $ofh; }
          for my $kid ( @{ $self->{KIDS} } ) {
              $kid->{RESULT} = undef;
              _debug "child: ", _debugstrings( $kid->{VAL} )
                if _debugging_details;
              eval {
                  croak "simulated failure of fork"
                    if $self->{_simulate_fork_failure};
                  unless (Win32_MODE) {
                      $self->_spawn($kid);
                  }
                  else {
  ## TODO: Test and debug spawning code.  Someday.
                      _debug(
                          'spawning ',
                          _debugstrings(
                              [
                                  $kid->{PATH},
                                  @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ]
                              ]
                          )
                      ) if $kid->{PATH} && _debugging;
                      ## The external kid wouldn't know what to do with it anyway.
                      ## This is only used by the "helper" pump processes on Win32.
                      _dont_inherit( $self->{DEBUG_FD} );
                      ( $kid->{PID}, $kid->{PROCESS} ) = IPC::Run::Win32Helper::win32_spawn(
                          ref( $kid->{VAL} ) eq "ARRAY"
                          ? [ $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] ]
                          : $kid->{VAL},
                          $kid->{OPS},
                      );
                      _debug "spawn() = ", $kid->{PID} if _debugging;
                      if ($self->{_sleep_after_win32_spawn}) {
                        sleep $self->{_sleep_after_win32_spawn};
                        _debug "after sleep $self->{_sleep_after_win32_spawn}"
                            if _debugging;
                      }
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      ## Close all those temporary filehandles that the kids needed.
      for my $pty ( values %{ $self->{PTYS} } ) {
          close $pty->slave;
      }
  
      my @closed;
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              my $close_it = eval {
                       defined $_->{TFD}
                    && !$_->{DONT_CLOSE}
                    && !$closed[ $_->{TFD} ]
                    && ( !Win32_MODE || !$_->{RECV_THROUGH_TEMP_FILE} )    ## Win32 hack
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
              if ( $close_it || $@ ) {
                  eval {
                      _close( $_->{TFD} );
                      $closed[ $_->{TFD} ] = 1;
                      $_->{TFD} = undef;
                  };
                  if ($@) {
                      push @errs, $@;
                      _debug 'caught ', $@ if _debugging;
                  }
              }
          }
      }
      confess "gak!" unless defined $self->{PIPES};
  
      if (@errs) {
          eval { $self->_cleanup };
          warn $@ if $@;
          die join( '', @errs );
      }
  
      $self->{STATE} = _started;
      return $self;
  }
  
  =item adopt
  
  Experimental feature. NOT FUNCTIONAL YET, NEED TO CLOSE FDS BETTER IN CHILDREN.  SEE t/adopt.t for a test suite.
  
  =cut
  
  sub adopt {
      my IPC::Run $self = shift;
  
      for my $adoptee (@_) {
          push @{ $self->{IOS} }, @{ $adoptee->{IOS} };
          ## NEED TO RENUMBER THE KIDS!!
          push @{ $self->{KIDS} },  @{ $adoptee->{KIDS} };
          push @{ $self->{PIPES} }, @{ $adoptee->{PIPES} };
          $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_} for keys %{ $adoptee->{PYTS} };
          push @{ $self->{TIMERS} }, @{ $adoptee->{TIMERS} };
          $adoptee->{STATE} = _finished;
      }
  }
  
  sub _clobber {
      my IPC::Run $self = shift;
      my ($file) = @_;
      _debug_desc_fd( "closing", $file ) if _debugging_details;
      my $doomed = $file->{FD};
      my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
      vec( $self->{$dir}, $doomed, 1 ) = 0;
  
      #   vec( $self->{EIN},  $doomed, 1 ) = 0;
      vec( $self->{PIN}, $doomed, 1 ) = 0;
      if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
          if ( $1 eq '>' ) {
              ## Only close output ptys.  This is so that ptys as inputs are
              ## never autoclosed, which would risk losing data that was
              ## in the slave->parent queue.
              _debug_desc_fd "closing pty", $file if _debugging_details;
              close $self->{PTYS}->{ $file->{PTY_ID} }
                if defined $self->{PTYS}->{ $file->{PTY_ID} };
              $self->{PTYS}->{ $file->{PTY_ID} } = undef;
          }
      }
      elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
          $file->close unless $file->{DONT_CLOSE};
      }
      else {
          _close($doomed);
      }
  
      @{ $self->{PIPES} } = grep
        defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed ),
        @{ $self->{PIPES} };
  
      $file->{FD} = undef;
  }
  
  sub _select_loop {
      my IPC::Run $self = shift;
  
      my $io_occurred;
  
      my $not_forever = 0.01;
  
    SELECT:
      while ( $self->pumpable ) {
          if ( $io_occurred && $self->{break_on_io} ) {
              _debug "exiting _select(): io occurred and break_on_io set"
                if _debugging_details;
              last;
          }
  
          my $timeout = $self->{non_blocking} ? 0 : undef;
  
          if ( @{ $self->{TIMERS} } ) {
              my $now = time;
              my $time_left;
              for ( @{ $self->{TIMERS} } ) {
                  next unless $_->is_running;
                  $time_left = $_->check($now);
                  ## Return when a timer expires
                  return if defined $time_left && !$time_left;
                  $timeout = $time_left
                    if !defined $timeout || $time_left < $timeout;
              }
          }
  
          ##
          ## See if we can unpause any input channels
          ##
          my $paused = 0;
  
          for my $file ( @{ $self->{PIPES} } ) {
              next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
  
              _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
              my $did;
              1 while $did = $file->_do_filters($self);
              if ( defined $file->{FD} && !defined($did) || $did ) {
                  _debug_desc_fd( "unpausing", $file ) if _debugging_details;
                  $file->{PAUSED} = 0;
                  vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $file->{FD}, 1 ) = 1;
                  vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
              }
              else {
                  ## This gets incremented occasionally when the IO channel
                  ## was actually closed.  That's a bug, but it seems mostly
                  ## harmless: it causes us to exit if break_on_io, or to set
                  ## the timeout to not be forever.  I need to fix it, though.
                  ++$paused;
              }
          }
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{RIN}, $_, 1 );
                      $out = $out ? 'b' : 'w' if vec( $self->{WIN}, $_, 1 );
                      $out = 'p' if !$out && vec( $self->{PIN}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EIN}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 1024 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug 'fds for select: ', $map if _debugging_details;
          }
  
          ## _do_filters may have closed our last fd, and we need to see if
          ## we have I/O, or are just waiting for children to exit.
          my $p = $self->pumpable;
          last unless $p;
          if ( $p != 0 && ( !defined $timeout || $timeout > 0.1 ) ) {
              ## No I/O will wake the select loop up, but we have children
              ## lingering, so we need to poll them with a short timeout.
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          ## Make sure we don't block forever in select() because inputs are
          ## paused.
          if ( !defined $timeout && !( @{ $self->{PIPES} } - $paused ) ) {
              ## Need to return if we're in pump and all input is paused, or
              ## we'll loop until all inputs are unpaused, which is darn near
              ## forever.  And a day.
              if ( $self->{break_on_io} ) {
                  _debug "exiting _select(): no I/O to do and timeout=forever"
                    if _debugging;
                  last;
              }
  
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          _debug 'timeout=', defined $timeout ? $timeout : 'forever'
            if _debugging_details;
  
          my $nfound;
          unless (Win32_MODE) {
              $nfound = select(
                  $self->{ROUT} = $self->{RIN},
                  $self->{WOUT} = $self->{WIN},
                  $self->{EOUT} = $self->{EIN},
                  $timeout
              );
          }
          else {
              my @in = map $self->{$_}, qw( RIN WIN EIN );
              ## Win32's select() on Win32 seems to die if passed vectors of
              ## all 0's.  Need to report this when I get back online.
              for (@in) {
                  $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
              }
  
              $nfound = select(
                  $self->{ROUT} = $in[0],
                  $self->{WOUT} = $in[1],
                  $self->{EOUT} = $in[2],
                  $timeout
              );
  
              for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
                  $_ = "" unless defined $_;
              }
          }
          last if !$nfound && $self->{non_blocking};
  
          if ( $nfound < 0 ) {
              if ( $!{EINTR} ) {
  
                  # Caught a signal before any FD went ready.  Ensure that
                  # the bit fields reflect "no FDs ready".
                  $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
                  $nfound = 0;
              }
              else {
                  croak "$! in select";
              }
          }
          ## TODO: Analyze the EINTR failure mode and see if this patch
          ## is adequate and optimal.
          ## TODO: Add an EINTR test to the test suite.
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{ROUT}, $_, 1 );
                      $out = $out ? 'b'      : 'w' if vec( $self->{WOUT}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EOUT}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 128 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug "selected  ", $map;
          }
  
          ## Need to copy since _clobber alters @{$self->{PIPES}}.
          ## TODO: Rethink _clobber().  Rethink $file->{PAUSED}, too.
          my @pipes = @{ $self->{PIPES} };
          $io_occurred = $_->poll($self) ? 1 : $io_occurred for @pipes;
  
          #   FILE:
          #      for my $pipe ( @pipes ) {
          #         ## Pipes can be shared among kids.  If another kid closes the
          #         ## pipe, then it's {FD} will be undef.  Also, on Win32, pipes can
          #	 ## be optimized to be files, in which case the FD is left undef
          #	 ## so we don't try to select() on it.
          #         if ( $pipe->{TYPE} =~ /^>/
          #            && defined $pipe->{FD}
          #            && vec( $self->{ROUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data from", $pipe ) if _debugging_details;
          #confess "phooey" unless UNIVERSAL::isa( $pipe, "IPC::Run::IO" );
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #	 ## On Win32, pipes to the child can be optimized to be files
          #	 ## and FD left undefined so we won't select on it.
          #         if ( $pipe->{TYPE} =~ /^</
          #            && defined $pipe->{FD}
          #            && vec( $self->{WOUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data to", $pipe ) if _debugging_details;
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #         if ( defined $pipe->{FD} && vec( $self->{EOUT}, $pipe->{FD}, 1 ) ) {
          #            ## BSD seems to sometimes raise the exceptional condition flag
          #            ## when a pipe is closed before we read it's last data.  This
          #            ## causes spurious warnings and generally renders the exception
          #            ## mechanism useless for our purposes.  The exception
          #            ## flag semantics are too variable (they're device driver
          #            ## specific) for me to easily map to any automatic action like
          #            ## warning or croaking (try running v0.42 if you don't believe me
          #            ## :-).
          #            warn "Exception on descriptor $pipe->{FD}";
          #         }
          #      }
      }
  
      return;
  }
  
  sub _cleanup {
      my IPC::Run $self = shift;
      _debug "cleaning up" if _debugging_details;
  
      for ( values %{ $self->{PTYS} } ) {
          next unless ref $_;
          eval {
              _debug "closing slave fd ", fileno $_->slave if _debugging_data;
              close $_->slave;
          };
          carp $@ . " while closing ptys" if $@;
          eval {
              _debug "closing master fd ", fileno $_ if _debugging_data;
              close $_;
          };
          carp $@ . " closing ptys" if $@;
      }
  
      _debug "cleaning up pipes" if _debugging_details;
      ## _clobber modifies PIPES
      $self->_clobber( $self->{PIPES}->[0] ) while @{ $self->{PIPES} };
  
      for my $kid ( @{ $self->{KIDS} } ) {
          _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
          if ( !length $kid->{PID} ) {
              _debug 'never ran child ', $kid->{NUM}, ", can't reap"
                if _debugging;
              for my $op ( @{ $kid->{OPS} } ) {
                  _close( $op->{TFD} )
                    if defined $op->{TFD} && !defined $op->{TEMP_FILE_HANDLE};
              }
          }
          elsif ( !defined $kid->{RESULT} ) {
              _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
                if _debugging;
              my $pid = waitpid $kid->{PID}, 0;
              $kid->{RESULT} = $?;
              _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
                if _debugging;
          }
  
          #      if ( defined $kid->{DEBUG_FD} ) {
          #	 die;
          #         @{$kid->{OPS}} = grep
          #            ! defined $_->{KFD} || $_->{KFD} != $kid->{DEBUG_FD},
          #            @{$kid->{OPS}};
          #         $kid->{DEBUG_FD} = undef;
          #      }
  
          _debug "cleaning up filters" if _debugging_details;
          for my $op ( @{ $kid->{OPS} } ) {
              @{ $op->{FILTERS} } = grep {
                  my $filter = $_;
                  !grep $filter == $_, @{ $self->{TEMP_FILTERS} };
              } @{ $op->{FILTERS} };
          }
  
          for my $op ( @{ $kid->{OPS} } ) {
              $op->_cleanup($self) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
          }
      }
      $self->{STATE} = _finished;
      @{ $self->{TEMP_FILTERS} } = ();
      _debug "done cleaning up" if _debugging_details;
  
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  }
  
  =pod
  
  =item pump
  
     pump $h;
     $h->pump;
  
  Pump accepts a single parameter harness.  It blocks until it delivers some
  input or receives some output.  It returns TRUE if there is still input or
  output to be done, FALSE otherwise.
  
  pump() will automatically call start() if need be, so you may call harness()
  then proceed to pump() if that helps you structure your application.
  
  If pump() is called after all harnessed activities have completed, a "process
  ended prematurely" exception to be thrown.  This allows for simple scripting
  of external applications without having to add lots of error handling code at
  each step of the script:
  
     $h = harness \@smbclient, \$in, \$out, $err;
  
     $in = "cd /foo\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /foo:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $h->finish;
  
     warn $err if $err;
  
  =cut
  
  sub pump {
      die "pump() takes only a single harness as a parameter"
        unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
  
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      _debug "** pumping"
        if _debugging;
  
      #   my $r = eval {
      $self->start if $self->{STATE} < _started;
      croak "process ended prematurely" unless $self->pumpable;
  
      $self->{auto_close_ins} = 0;
      $self->{break_on_io}    = 1;
      $self->_select_loop;
      return $self->pumpable;
  
      #   };
      #   if ( $@ ) {
      #      my $x = $@;
      #      _debug $x if _debugging && $x;
      #      eval { $self->_cleanup };
      #      warn $@ if $@;
      #      die $x;
      #   }
      #   return $r;
  }
  
  =pod
  
  =item pump_nb
  
     pump_nb $h;
     $h->pump_nb;
  
  "pump() non-blocking", pumps if anything's ready to be pumped, returns
  immediately otherwise.  This is useful if you're doing some long-running
  task in the foreground, but don't want to starve any child processes.
  
  =cut
  
  sub pump_nb {
      my IPC::Run $self = shift;
  
      $self->{non_blocking} = 1;
      my $r = eval { $self->pump };
      $self->{non_blocking} = 0;
      die $@ if $@;
      return $r;
  }
  
  =pod
  
  =item pumpable
  
  Returns TRUE if calling pump() won't throw an immediate "process ended
  prematurely" exception.  This means that there are open I/O channels or
  active processes. May yield the parent processes' time slice for 0.01
  second if all pipes are to the child and all are paused.  In this case
  we can't tell if the child is dead, so we yield the processor and
  then attempt to reap the child in a nonblocking way.
  
  =cut
  
  ## Undocumented feature (don't depend on it outside this module):
  ## returns -1 if we have I/O channels open, or >0 if no I/O channels
  ## open, but we have kids running.  This allows the select loop
  ## to poll for child exit.
  sub pumpable {
      my IPC::Run $self = shift;
  
      ## There's a catch-22 we can get in to if there is only one pipe left
      ## open to the child and it's paused (ie the SCALAR it's tied to
      ## is '').  It's paused, so we're not select()ing on it, so we don't
      ## check it to see if the child attached to it is alive and it stays
      ## in @{$self->{PIPES}} forever.  So, if all pipes are paused, see if
      ## we can reap the child.
      return -1 if grep !$_->{PAUSED}, @{ $self->{PIPES} };
  
      ## See if the child is dead.
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      ## If we reap_nb and it's not dead yet, yield to it to see if it
      ## exits.
      ##
      ## A better solution would be to unpause all the pipes, but I tried that
      ## and it never errored on linux.  Sigh.
      select undef, undef, undef, 0.0001;
  
      ## try again
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      return -1;    ## There are pipes waiting
  }
  
  sub _running_kids {
      my IPC::Run $self = shift;
      return grep
        defined $_->{PID} && !defined $_->{RESULT},
        @{ $self->{KIDS} };
  }
  
  =pod
  
  =item reap_nb
  
  Attempts to reap child processes, but does not block.
  
  Does not currently take any parameters, one day it will allow specific
  children to be reaped.
  
  Only call this from a signal handler if your C<perl> is recent enough
  to have safe signal handling (5.6.1 did not, IIRC, but it was being discussed
  on perl5-porters).  Calling this (or doing any significant work) in a signal
  handler on older C<perl>s is asking for seg faults.
  
  =cut
  
  my $still_runnings;
  
  sub reap_nb {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      ## No more pipes, look to see if all the kids yet live, reaping those
      ## that haven't.  I'd use $SIG{CHLD}/$SIG{CLD}, but that's broken
      ## on older (SYSV) platforms and perhaps less portable than waitpid().
      ## This could be slow with a lot of kids, but that's rare and, well,
      ## a lot of kids is slow in the first place.
      ## Oh, and this keeps us from reaping other children the process
      ## may have spawned.
      for my $kid ( @{ $self->{KIDS} } ) {
          if (Win32_MODE) {
              next if !defined $kid->{PROCESS} || defined $kid->{RESULT};
              unless ( $kid->{PROCESS}->Wait(0) ) {
                  _debug "kid $kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                if _debugging;
  
              $kid->{PROCESS}->GetExitCode( $kid->{RESULT} )
                or croak "$! while GetExitCode()ing for Win32 process";
  
              unless ( defined $kid->{RESULT} ) {
                  $kid->{RESULT} = "0 but true";
                  $? = $kid->{RESULT} = 0x0F;
              }
              else {
                  $? = $kid->{RESULT} << 8;
              }
          }
          else {
              next if !defined $kid->{PID} || defined $kid->{RESULT};
              my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
              unless ($pid) {
                  _debug "$kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              if ( $pid < 0 ) {
                  _debug "No such process: $kid->{PID}\n" if _debugging;
                  $kid->{RESULT} = "unknown result, unknown PID";
              }
              else {
                  _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                    if _debugging;
  
                  confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
                    unless $pid == $kid->{PID};
                  _debug "$kid->{PID} returned $?\n" if _debugging;
                  $kid->{RESULT} = $?;
              }
          }
      }
  }
  
  =pod
  
  =item finish
  
  This must be called after the last start() or pump() call for a harness,
  or your system will accumulate defunct processes and you may "leak"
  file descriptors.
  
  finish() returns TRUE if all children returned 0 (and were not signaled and did
  not coredump, ie ! $?), and FALSE otherwise (this is like run(), and the
  opposite of system()).
  
  Once a harness has been finished, it may be run() or start()ed again,
  including by pump()s auto-start.
  
  If this throws an exception rather than a normal exit, the harness may
  be left in an unstable state, it's best to kill the harness to get rid
  of all the child processes, etc.
  
  Specifically, if a timeout expires in finish(), finish() will not
  kill all the children.  Call C<<$h->kill_kill>> in this case if you care.
  This differs from the behavior of L</run>.
  
  =cut
  
  sub finish {
      my IPC::Run $self = shift;
      my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
  
      local $cur_self = $self;
  
      _debug "** finishing" if _debugging;
  
      $self->{non_blocking}   = 0;
      $self->{auto_close_ins} = 1;
      $self->{break_on_io}    = 0;
  
      # We don't alter $self->{clear_ins}, start() and run() control it.
  
      while ( $self->pumpable ) {
          $self->_select_loop($options);
      }
      $self->_cleanup;
  
      return !$self->full_result;
  }
  
  =pod
  
  =item result
  
     $h->result;
  
  Returns the first non-zero result code (ie $? >> 8).  See L</full_result> to 
  get the $? value for a child process.
  
  To get the result of a particular child, do:
  
     $h->result( 0 );  # first child's $? >> 8
     $h->result( 1 );  # second child
  
  or
  
     ($h->results)[0]
     ($h->results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub _assert_finished {
      my IPC::Run $self = $_[0];
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  }
  
  sub _child_result {
      my IPC::Run $self = shift;
  
      my ($which) = @_;
      croak(
          "Only ",
          scalar( @{ $self->{KIDS} } ),
          " child processes, no process $which"
      ) unless $which >= 0 && $which <= $#{ $self->{KIDS} };
      return $self->{KIDS}->[$which]->{RESULT};
  }
  
  sub result {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which) >> 8;
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
          }
      }
  }
  
  =pod
  
  =item results
  
  Returns a list of child exit values.  See L</full_results> if you want to
  know if a signal killed the child.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      # we add 0 here to stop warnings associated with "unknown result, unknown PID"
      return map { ( 0 + $_->{RESULT} ) >> 8 } @{ $self->{KIDS} };
  }
  
  =pod
  
  =item full_result
  
     $h->full_result;
  
  Returns the first non-zero $?.  See L</result> to get the first $? >> 8 
  value for a child process.
  
  To get the result of a particular child, do:
  
     $h->full_result( 0 );  # first child's $?
     $h->full_result( 1 );  # second child
  
  or
  
     ($h->full_results)[0]
     ($h->full_results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub full_result {
      &_assert_finished;
  
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which);
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} if $_->{RESULT};
          }
      }
  }
  
  =pod
  
  =item full_results
  
  Returns a list of child exit values as returned by C<wait>.  See L</results>
  if you don't care about coredumps or signals.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub full_results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  
      return map $_->{RESULT}, @{ $self->{KIDS} };
  }
  
  ##
  ## Filter Scaffolding
  ##
  use vars (
      '$filter_op',     ## The op running a filter chain right now
      '$filter_num',    ## Which filter is being run right now.
  );
  
  ##
  ## A few filters and filter constructors
  ##
  
  =pod
  
  =back
  
  =back
  
  =head1 FILTERS
  
  These filters are used to modify input our output between a child
  process and a scalar or subroutine endpoint.
  
  =over
  
  =item binary
  
     run \@cmd, ">", binary, \$out;
     run \@cmd, ">", binary, \$out;  ## Any TRUE value to enable
     run \@cmd, ">", binary 0, \$out;  ## Any FALSE value to disable
  
  This is a constructor for a "binmode" "filter" that tells IPC::Run to keep
  the carriage returns that would ordinarily be edited out for you (binmode
  is usually off).  This is not a real filter, but an option masquerading as
  a filter.
  
  It's not named "binmode" because you're likely to want to call Perl's binmode
  in programs that are piping binary data around.
  
  =cut
  
  sub binary(;$) {
      my $enable = @_ ? shift : 1;
      return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
  }
  
  =pod
  
  =item new_chunker
  
  This breaks a stream of data in to chunks, based on an optional
  scalar or regular expression parameter.  The default is the Perl
  input record separator in $/, which is a newline be default.
  
     run \@cmd, '>', new_chunker, \&lines_handler;
     run \@cmd, '>', new_chunker( "\r\n" ), \&lines_handler;
  
  Because this uses $/ by default, you should always pass in a parameter
  if you are worried about other code (modules, etc) modifying $/.
  
  If this filter is last in a filter chain that dumps in to a scalar,
  the scalar must be set to '' before a new chunk will be written to it.
  
  As an example of how a filter like this can be written, here's a
  chunker that splits on newlines:
  
     sub line_splitter {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/\A(.*?\n)// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  
  =cut
  
  sub new_chunker(;$) {
      my ($re) = @_;
      $re = $/ if _empty $re;
      $re = quotemeta($re) unless ref $re eq 'Regexp';
      $re = qr/\A(.*?$re)/s;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return 0 if length $$out_ref;
  
          return input_avail && do {
              while (1) {
                  if ( $$in_ref =~ s/$re// ) {
                      $$out_ref .= $1;
                      return 1;
                  }
                  my $hmm = get_more_input;
                  unless ( defined $hmm ) {
                      $$out_ref = $$in_ref;
                      $$in_ref  = '';
                      return length $$out_ref ? 1 : 0;
                  }
                  return 0 if $hmm eq 0;
              }
            }
      };
  }
  
  =pod
  
  =item new_appender
  
  This appends a fixed string to each chunk of data read from the source
  scalar or sub.  This might be useful if you're writing commands to a
  child process that always must end in a fixed string, like "\n":
  
     run( \@cmd,
        '<', new_appender( "\n" ), \&commands,
     );
  
  Here's a typical filter sub that might be created by new_appender():
  
     sub newline_appender {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, "\n" );
           $$in_ref = '';
           1;
        }
     };
  
  =cut
  
  sub new_appender($) {
      my ($suffix) = @_;
      croak "\$suffix undefined" unless defined $suffix;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
              $$in_ref = '';
              1;
            }
      };
  }
  
  =item new_string_source
  
  TODO: Needs confirmation. Was previously undocumented. in this module.
  
  This is a filter which is exportable. Returns a sub which appends the data passed in to the output buffer and returns 1 if data was appended. 0 if it was an empty string and undef if no data was passed. 
  
  NOTE: Any additional variables passed to new_string_source will be passed to the sub every time it's called and appended to the output. 
  
  =cut
  
  sub new_string_source {
      my $ref;
      if ( @_ > 1 ) {
          $ref = [@_],
      }
      else {
          $ref = shift;
      }
  
      return ref $ref eq 'SCALAR'
        ? sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return defined $$ref
            ? do {
              $$out_ref .= $$ref;
              my $r = length $$ref ? 1 : 0;
              $$ref = undef;
              $r;
            }
            : undef;
        }
        : sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return @$ref
            ? do {
              my $s = shift @$ref;
              $$out_ref .= $s;
              length $s ? 1 : 0;
            }
            : undef;
        }
  }
  
  =item new_string_sink
  
  TODO: Needs confirmation. Was previously undocumented.
  
  This is a filter which is exportable. Returns a sub which pops the data out of the input stream and pushes it onto the string.
  
  =cut
  
  sub new_string_sink {
      my ($string_ref) = @_;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$string_ref .= $$in_ref;
              $$in_ref = '';
              1;
            }
      };
  }
  
  #=item timeout
  #
  #This function defines a time interval, starting from when start() is
  #called, or when timeout() is called.  If all processes have not finished
  #by the end of the timeout period, then a "process timed out" exception
  #is thrown.
  #
  #The time interval may be passed in seconds, or as an end time in
  #"HH:MM:SS" format (any non-digit other than '.' may be used as
  #spacing and punctuation).  This is probably best shown by example:
  #
  #   $h->timeout( $val );
  #
  #   $val                     Effect
  #   ======================== =====================================
  #   undef                    Timeout timer disabled
  #   ''                       Almost immediate timeout
  #   0                        Almost immediate timeout
  #   0.000001                 timeout > 0.0000001 seconds
  #   30                       timeout > 30 seconds
  #   30.0000001               timeout > 30 seconds
  #   10:30                    timeout > 10 minutes, 30 seconds
  #
  #Timeouts are currently evaluated with a 1 second resolution, though
  #this may change in the future.  This means that setting
  #timeout($h,1) will cause a pokey child to be aborted sometime after
  #one second has elapsed and typically before two seconds have elapsed.
  #
  #This sub does not check whether or not the timeout has expired already.
  #
  #Returns the number of seconds set as the timeout (this does not change
  #as time passes, unless you call timeout( val ) again).
  #
  #The timeout does not include the time needed to fork() or spawn()
  #the child processes, though some setup time for the child processes can
  #included.  It also does not include the length of time it takes for
  #the children to exit after they've closed all their pipes to the
  #parent process.
  #
  #=cut
  #
  #sub timeout {
  #   my IPC::Run $self = shift;
  #
  #   if ( @_ ) {
  #      ( $self->{TIMEOUT} ) = @_;
  #      $self->{TIMEOUT_END} = undef;
  #      if ( defined $self->{TIMEOUT} ) {
  #	 if ( $self->{TIMEOUT} =~ /[^\d.]/ ) {
  #	    my @f = split( /[^\d\.]+/i, $self->{TIMEOUT} );
  #	    unshift @f, 0 while @f < 3;
  #	    $self->{TIMEOUT} = (($f[0]*60)+$f[1])*60+$f[2];
  #	 }
  #	 elsif ( $self->{TIMEOUT} =~ /^(\d*)(?:\.(\d*))/ ) {
  #	    $self->{TIMEOUT} = $1 + 1;
  #	 }
  #	 $self->_calc_timeout_end if $self->{STATE} >= _started;
  #      }
  #   }
  #   return $self->{TIMEOUT};
  #}
  #
  #
  #sub _calc_timeout_end {
  #   my IPC::Run $self = shift;
  #
  #   $self->{TIMEOUT_END} = defined $self->{TIMEOUT}
  #      ? time + $self->{TIMEOUT}
  #      : undef;
  #
  #   ## We add a second because we might be at the very end of the current
  #   ## second, and we want to guarantee that we don't have a timeout even
  #   ## one second less then the timeout period.
  #   ++$self->{TIMEOUT_END} if $self->{TIMEOUT};
  #}
  
  =pod
  
  =item io
  
  Takes a filename or filehandle, a redirection operator, optional filters,
  and a source or destination (depends on the redirection operator).  Returns
  an IPC::Run::IO object suitable for harness()ing (including via start()
  or run()).
  
  This is shorthand for 
  
  
     require IPC::Run::IO;
  
        ... IPC::Run::IO->new(...) ...
  
  =cut
  
  sub io {
      require IPC::Run::IO;
      IPC::Run::IO->new(@_);
  }
  
  =pod
  
  =item timer
  
     $h = start( \@cmd, \$in, \$out, $t = timer( 5 ) );
  
     pump $h until $out =~ /expected stuff/ || $t->is_expired;
  
  Instantiates a non-fatal timer.  pump() returns once each time a timer
  expires.  Has no direct effect on run(), but you can pass a subroutine
  to fire when the timer expires. 
  
  See L</timeout> for building timers that throw exceptions on
  expiration.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timer;
  *timer = \&IPC::Run::Timer::timer;
  
  =pod
  
  =item timeout
  
     $h = start( \@cmd, \$in, \$out, $t = timeout( 5 ) );
  
     pump $h until $out =~ /expected stuff/;
  
  Instantiates a timer that throws an exception when it expires.
  If you don't provide an exception, a default exception that matches
  /^IPC::Run: .*timed out/ is thrown by default.  You can pass in your own
  exception scalar or reference:
  
     $h = start(
        \@cmd, \$in, \$out,
        $t = timeout( 5, exception => 'slowpoke' ),
     );
  
  or set the name used in debugging message and in the default exception
  string:
  
     $h = start(
        \@cmd, \$in, \$out,
        timeout( 50, name => 'process timer' ),
        $stall_timer = timeout( 5, name => 'stall timer' ),
     );
  
     pump $h until $out =~ /started/;
  
     $in = 'command 1';
     $stall_timer->start;
     pump $h until $out =~ /command 1 finished/;
  
     $in = 'command 2';
     $stall_timer->start;
     pump $h until $out =~ /command 2 finished/;
  
     $in = 'very slow command 3';
     $stall_timer->start( 10 );
     pump $h until $out =~ /command 3 finished/;
  
     $stall_timer->start( 5 );
     $in = 'command 4';
     pump $h until $out =~ /command 4 finished/;
  
     $stall_timer->reset; # Prevent restarting or expirng
     finish $h;
  
  See L</timer> for building non-fatal timers.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timeout;
  *timeout = \&IPC::Run::Timer::timeout;
  
  =pod
  
  =back
  
  =head1 FILTER IMPLEMENTATION FUNCTIONS
  
  These functions are for use from within filters.
  
  =over
  
  =item input_avail
  
  Returns TRUE if input is available.  If none is available, then 
  &get_more_input is called and its result is returned.
  
  This is usually used in preference to &get_more_input so that the
  calling filter removes all data from the $in_ref before more data
  gets read in to $in_ref.
  
  C<input_avail> is usually used as part of a return expression:
  
     return input_avail && do {
        ## process the input just gotten
        1;
     };
  
  This technique allows input_avail to return the undef or 0 that a
  filter normally returns when there's no input to process.  If a filter
  stores intermediate values, however, it will need to react to an
  undef:
  
     my $got = input_avail;
     if ( ! defined $got ) {
        ## No more input ever, flush internal buffers to $out_ref
     }
     return $got unless $got;
     ## Got some input, move as much as need be
     return 1 if $added_to_out_ref;
  
  =cut
  
  sub input_avail() {
      confess "Undefined FBUF ref for $filter_num+1"
        unless defined $filter_op->{FBUFS}->[ $filter_num + 1 ];
      length ${ $filter_op->{FBUFS}->[ $filter_num + 1 ] } || get_more_input;
  }
  
  =pod
  
  =item get_more_input
  
  This is used to fetch more input in to the input variable.  It returns
  undef if there will never be any more input, 0 if there is none now,
  but there might be in the future, and TRUE if more input was gotten.
  
  C<get_more_input> is usually used as part of a return expression,
  see L</input_avail> for more information.
  
  =cut
  
  ##
  ## Filter implementation interface
  ##
  sub get_more_input() {
      ++$filter_num;
      my $r = eval {
          confess "get_more_input() called and no more filters in chain"
            unless defined $filter_op->{FILTERS}->[$filter_num];
          $filter_op->{FILTERS}->[$filter_num]->(
              $filter_op->{FBUFS}->[ $filter_num + 1 ],
              $filter_op->{FBUFS}->[$filter_num],
          );    # if defined ${$filter_op->{FBUFS}->[$filter_num+1]};
      };
      --$filter_num;
      die $@ if $@;
      return $r;
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 TODO
  
  These will be addressed as needed and as time allows.
  
  Stall timeout.
  
  Expose a list of child process objects.  When I do this,
  each child process is likely to be blessed into IPC::Run::Proc.
  
  $kid->abort(), $kid->kill(), $kid->signal( $num_or_name ).
  
  Write tests for /(full_)?results?/ subs.
  
  Currently, pump() and run() only work on systems where select() works on the
  filehandles returned by pipe().  This does *not* include ActiveState on Win32,
  although it does work on cygwin under Win32 (thought the tests whine a bit).
  I'd like to rectify that, suggestions and patches welcome.
  
  Likewise start() only fully works on fork()/exec() machines (well, just
  fork() if you only ever pass perl subs as subprocesses).  There's
  some scaffolding for calling Open3::spawn_with_handles(), but that's
  untested, and not that useful with limited select().
  
  Support for C<\@sub_cmd> as an argument to a command which
  gets replaced with /dev/fd or the name of a temporary file containing foo's
  output.  This is like <(sub_cmd ...) found in bash and csh (IIRC).
  
  Allow multiple harnesses to be combined as independent sets of processes
  in to one 'meta-harness'.
  
  Allow a harness to be passed in place of an \@cmd.  This would allow
  multiple harnesses to be aggregated.
  
  Ability to add external file descriptors w/ filter chains and endpoints.
  
  Ability to add timeouts and timing generators (i.e. repeating timeouts).
  
  High resolution timeouts.
  
  =head1 Win32 LIMITATIONS
  
  =over
  
  =item argument-passing rules are program-specific
  
  Win32 programs receive all arguments in a single "command line" string.
  IPC::Run assembles this string so programs using L<standard command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>
  will see an C<argv> that matches the array reference specifying the command.
  Some programs use different rules to parse their command line.  Notable examples
  include F<cmd.exe>, F<cscript.exe>, and Cygwin programs called from non-Cygwin
  programs.  Use L<IPC::Run::Win32Process> to call these and other nonstandard
  programs.
  
  =item batch files
  
  Properly escaping a batch file argument depends on how the script will use that
  argument, because some uses experience multiple levels of caret (escape
  character) removal.  Avoid calling batch files with arguments, particularly when
  the argument values originate outside your program or contain non-alphanumeric
  characters.  Perl scripts and PowerShell scripts are sound alternatives.  If you
  do use batch file arguments, IPC::Run escapes them so the batch file can pass
  them, unquoted, to a program having standard command line parsing rules.  If the
  batch file enables delayed environment variable expansion, it must disable that
  feature before expanding its arguments.  For example, if F<foo.cmd> contains
  C<perl %*>, C<run ['foo.cmd', @list]> will create a Perl process in which
  C<@ARGV> matches C<@list>.  Prepending a C<setlocal enabledelayedexpansion> line
  would make the batch file malfunction, silently.  Another silent-malfunction
  example is C<run ['outer.bat', @list]> for F<outer.bat> containing C<foo.cmd
  %*>.
  
  =item Fails on Win9X
  
  If you want Win9X support, you'll have to debug it or fund me because I
  don't use that system any more.  The Win32 subsysem has been extended to
  use temporary files in simple run() invocations and these may actually
  work on Win9X too, but I don't have time to work on it.
  
  =item May deadlock on Win2K (but not WinNT4 or WinXPPro)
  
  Spawning more than one subprocess on Win2K causes a deadlock I haven't
  figured out yet, but simple uses of run() often work.  Passes all tests
  on WinXPPro and WinNT.
  
  =item no support yet for <pty< and >pty>
  
  These are likely to be implemented as "<" and ">" with binmode on, not
  sure.
  
  =item no support for file descriptors higher than 2 (stderr)
  
  Win32 only allows passing explicit fds 0, 1, and 2.  If you really, really need to pass file handles, us Win32API:: GetOsFHandle() or ::FdGetOsFHandle() to
  get the integer handle and pass it to the child process using the command
  line, environment, stdin, intermediary file, or other IPC mechanism.  Then
  use that handle in the child (Win32API.pm provides ways to reconstitute
  Perl file handles from Win32 file handles).
  
  =item no support for subroutine subprocesses (CODE refs)
  
  Can't fork(), so the subroutines would have no context, and closures certainly
  have no meaning
  
  Perhaps with Win32 fork() emulation, this can be supported in a limited
  fashion, but there are other very serious problems with that: all parent
  fds get dup()ed in to the thread emulating the forked process, and that
  keeps the parent from being able to close all of the appropriate fds.
  
  =item no support for init => sub {} routines.
  
  Win32 processes are created from scratch, there is no way to do an init
  routine that will affect the running child.  Some limited support might
  be implemented one day, do chdir() and %ENV changes can be made.
  
  =item signals
  
  Win32 does not fully support signals.  signal() is likely to cause errors
  unless sending a signal that Perl emulates, and C<kill_kill()> is immediately
  fatal (there is no grace period).
  
  =item helper processes
  
  IPC::Run uses helper processes, one per redirected file, to adapt between the
  anonymous pipe connected to the child and the TCP socket connected to the
  parent.  This is a waste of resources and will change in the future to either
  use threads (instead of helper processes) or a WaitForMultipleObjects call
  (instead of select).  Please contact me if you can help with the
  WaitForMultipleObjects() approach; I haven't figured out how to get at it
  without C code.
  
  =item shutdown pause
  
  There seems to be a pause of up to 1 second between when a child program exits
  and the corresponding sockets indicate that they are closed in the parent.
  Not sure why.
  
  =item binmode
  
  binmode is not supported yet.  The underpinnings are implemented, just ask
  if you need it.
  
  =item IPC::Run::IO
  
  IPC::Run::IO objects can be used on Unix to read or write arbitrary files.  On
  Win32, they will need to use the same helper processes to adapt from
  non-select()able filehandles to select()able ones (or perhaps
  WaitForMultipleObjects() will work with them, not sure).
  
  =item startup race conditions
  
  There seems to be an occasional race condition between child process startup
  and pipe closings.  It seems like if the child is not fully created by the time
  CreateProcess returns and we close the TCP socket being handed to it, the
  parent socket can also get closed.  This is seen with the Win32 pumper
  applications, not the "real" child process being spawned.
  
  I assume this is because the kernel hasn't gotten around to incrementing the
  reference count on the child's end (since the child was slow in starting), so
  the parent's closing of the child end causes the socket to be closed, thus
  closing the parent socket.
  
  Being a race condition, it's hard to reproduce, but I encountered it while
  testing this code on a drive share to a samba box.  In this case, it takes
  t/run.t a long time to spawn it's child processes (the parent hangs in the
  first select for several seconds until the child emits any debugging output).
  
  I have not seen it on local drives, and can't reproduce it at will,
  unfortunately.  The symptom is a "bad file descriptor in select()" error, and,
  by turning on debugging, it's possible to see that select() is being called on
  a no longer open file descriptor that was returned from the _socket() routine
  in Win32Helper.  There's a new confess() that checks for this ("PARENT_HANDLE
  no longer open"), but I haven't been able to reproduce it (typically).
  
  =back
  
  =head1 LIMITATIONS
  
  On Unix, requires a system that supports C<waitpid( $pid, WNOHANG )> so
  it can tell if a child process is still running.
  
  PTYs don't seem to be non-blocking on some versions of Solaris. Here's a
  test script contributed by Borislav Deianov <borislav@ensim.com> to see
  if you have the problem.  If it dies, you have the problem.
  
     #!/usr/bin/perl
  
     use IPC::Run qw(run);
     use Fcntl;
     use IO::Pty;
  
     sub makecmd {
         return ['perl', '-e', 
                 '<STDIN>, print "\n" x '.$_[0].'; while(<STDIN>){last if /end/}'];
     }
  
     #pipe R, W;
     #fcntl(W, F_SETFL, O_NONBLOCK);
     #while (syswrite(W, "\n", 1)) { $pipebuf++ };
     #print "pipe buffer size is $pipebuf\n";
     my $pipebuf=4096;
     my $in = "\n" x ($pipebuf * 2) . "end\n";
     my $out;
  
     $SIG{ALRM} = sub { die "Never completed!\n" };
  
     print "reading from scalar via pipe...";
     alarm( 2 );
     run(makecmd($pipebuf * 2), '<', \$in, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     print "reading from code via pipe... ";
     alarm( 2 );
     run(makecmd($pipebuf * 3), '<', sub { $t = $in; undef $in; $t}, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     $pty = IO::Pty->new();
     $pty->blocking(0);
     $slave = $pty->slave();
     while ($pty->syswrite("\n", 1)) { $ptybuf++ };
     print "pty buffer size is $ptybuf\n";
     $in = "\n" x ($ptybuf * 3) . "end\n";
  
     print "reading via pty... ";
     alarm( 2 );
     run(makecmd($ptybuf * 3), '<pty<', \$in, '>', \$out);
     alarm(0);
     print "done\n";
  
  No support for ';', '&&', '||', '{ ... }', etc: use perl's, since run()
  returns TRUE when the command exits with a 0 result code.
  
  Does not provide shell-like string interpolation.
  
  No support for C<cd>, C<setenv>, or C<export>: do these in an init() sub
  
     run(
        \cmd,
           ...
           init => sub {
              chdir $dir or die $!;
              $ENV{FOO}='BAR'
           }
     );
  
  Timeout calculation does not allow absolute times, or specification of
  days, months, etc.
  
  B<WARNING:> Function coprocesses (C<run \&foo, ...>) suffer from two
  limitations.  The first is that it is difficult to close all filehandles the
  child inherits from the parent, since there is no way to scan all open
  FILEHANDLEs in Perl and it both painful and a bit dangerous to close all open
  file descriptors with C<POSIX::close()>. Painful because we can't tell which
  fds are open at the POSIX level, either, so we'd have to scan all possible fds
  and close any that we don't want open (normally C<exec()> closes any
  non-inheritable but we don't C<exec()> for &sub processes.
  
  The second problem is that Perl's DESTROY subs and other on-exit cleanup gets
  run in the child process.  If objects are instantiated in the parent before the
  child is forked, the DESTROY will get run once in the parent and once in
  the child.  When coprocess subs exit, POSIX::_exit is called to work around this,
  but it means that objects that are still referred to at that time are not
  cleaned up.  So setting package vars or closure vars to point to objects that
  rely on DESTROY to affect things outside the process (files, etc), will
  lead to bugs.
  
  I goofed on the syntax: "<pipe" vs. "<pty<" and ">filename" are both
  oddities.
  
  =head1 TODO
  
  =over
  
  =item Allow one harness to "adopt" another:
  
     $new_h = harness \@cmd2;
     $h->adopt( $new_h );
  
  =item Close all filehandles not explicitly marked to stay open.
  
  The problem with this one is that there's no good way to scan all open
  FILEHANDLEs in Perl, yet you don't want child processes inheriting handles
  willy-nilly.
  
  =back
  
  =head1 INSPIRATION
  
  Well, select() and waitpid() badly needed wrapping, and open3() isn't
  open-minded enough for me.
  
  The shell-like API inspired by a message Russ Allbery sent to perl5-porters,
  which included:
  
     I've thought for some time that it would be
     nice to have a module that could handle full Bourne shell pipe syntax
     internally, with fork and exec, without ever invoking a shell.  Something
     that you could give things like:
  
     pipeopen (PIPE, [ qw/cat file/ ], '|', [ 'analyze', @args ], '>&3');
  
  Message ylln51p2b6.fsf@windlord.stanford.edu, on 2000/02/04.
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the GitHub bug tracker
  
  L<https://github.com/toddr/IPC-Run/issues>
  
  =head1 AUTHORS
  
  Adam Kennedy <adamk@cpan.org>
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2008 - 2009 Adam Kennedy.
  
  Copyright 1999 Barrie Slaymaker.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the README file.
  
  =cut
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Debug - debugging routines for IPC::Run
  
  =head1 SYNOPSIS
  
     ##
     ## Environment variable usage
     ##
     ## To force debugging off and shave a bit of CPU and memory
     ## by compile-time optimizing away all debugging code in IPC::Run
     ## (debug => ...) options to IPC::Run will be ignored.
     export IPCRUNDEBUG=none
  
     ## To force debugging on (levels are from 0..10)
     export IPCRUNDEBUG=basic
  
     ## Leave unset or set to "" to compile in debugging support and
     ## allow runtime control of it using the debug option.
  
  =head1 DESCRIPTION
  
  Controls IPC::Run debugging.  Debugging levels are now set by using words,
  but the numbers shown are still supported for backwards compatibility:
  
     0  none         disabled (special, see below)
     1  basic        what's running
     2  data         what's being sent/received
     3  details      what's going on in more detail
     4  gory         way too much detail for most uses
     10 all          use this when submitting bug reports
        noopts       optimizations forbidden due to inherited STDIN
  
  The C<none> level is special when the environment variable IPCRUNDEBUG
  is set to this the first time IPC::Run::Debug is loaded: it prevents
  the debugging code from being compiled in to the remaining IPC::Run modules,
  saving a bit of cpu.
  
  To do this in a script, here's a way that allows it to be overridden:
  
     BEGIN {
        unless ( defined $ENV{IPCRUNDEBUG} ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	    or die $@;
        }
     }
  
  This should force IPC::Run to not be debuggable unless somebody sets
  the IPCRUNDEBUG flag; modify this formula to grep @ARGV if need be:
  
     BEGIN {
        unless ( grep /^--debug/, @ARGV ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	 or die $@;
     }
  
  Both of those are untested.
  
  =cut
  
  ## We use @EXPORT for the end user's convenience: there's only one function
  ## exported, it's homonymous with the module, it's an unusual name, and
  ## it can be suppressed by "use IPC::Run ();".
  
  use strict;
  use warnings;
  use Exporter;
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        _debug
        _debug_desc_fd
        _debugging
        _debugging_data
        _debugging_details
        _debugging_gory_details
        _debugging_not_optimized
        _set_child_debug_name
      );
  
      @EXPORT_OK = qw(
        _debug_init
        _debugging_level
        _map_fds
      );
      %EXPORT_TAGS = (
          default => \@EXPORT,
          all => [ @EXPORT, @EXPORT_OK ],
      );
  }
  
  my $disable_debugging = defined $ENV{IPCRUNDEBUG}
    && ( !$ENV{IPCRUNDEBUG}
      || lc $ENV{IPCRUNDEBUG} eq "none" );
  
  eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX ();
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $in_use;
     my $dummy;
     for my $fd (0..63) {
        ## I'd like a quicker way (less user, cpu & especially sys and kernel
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        ## but that segfaults on Win32
        my $test_fd = POSIX::dup( $fd );
        $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        $map .= $in_use ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to its own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self && defined $IPC::Run::cur_self->{ID}
           ? "#$IPC::Run::cur_self->{ID}"
           : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
  
  =pod
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>, with numerous suggestions by p5p.
  
  =cut
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_IO';
  package IPC::Run::IO;
  
  =head1 NAME
  
  IPC::Run::IO -- I/O channels for IPC::Run.
  
  =head1 SYNOPSIS
  
  B<NOT IMPLEMENTED YET ON Win32! Win32 does not allow select() on
  normal file descriptors; IPC::RUN::IO needs to use IPC::Run::Win32Helper
  to do this.>
  
     use IPC::Run qw( io );
  
     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv );
     $io = io( "filename", 'r',  \$recv );
  
     ## Append to $recv:
     $io = io( "filename", '>>', \$recv );
     $io = io( "filename", 'ra', \$recv );
  
     $io = io( "filename", '<',  \$send );
     $io = io( "filename", 'w',  \$send );
  
     $io = io( "filename", '<<', \$send );
     $io = io( "filename", 'wa', \$send );
  
     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send );
  
     $f = IO::Handle->new( ... ); # Any subclass of IO::Handle
     $io = io( $f, '<', \$send );
  
     require IPC::Run::IO;
     $io = IPC::Run::IO->new( ... );
  
     ## Then run(), harness(), or start():
     run $io, ...;
  
     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... );
  
  =head1 DESCRIPTION
  
  This class and module allows filehandles and filenames to be harnessed for
  I/O when used IPC::Run, independent of anything else IPC::Run is doing
  (except that errors & exceptions can affect all things that IPC::Run is
  doing).
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: due to the awkwardness introduced in ripping pseudohashes
  out of Perl, this class I<no longer> uses the fields pragma.
  
  =cut
  
  ## This class is also used internally by IPC::Run in a very intimate way,
  ## since this is a partial factoring of code from IPC::Run plus some code
  ## needed to do standalone channels.  This factoring process will continue
  ## at some point.  Don't know how far how fast.
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  
  use IPC::Run::Debug;
  use IPC::Run qw( Win32_MODE );
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
            or ( $@ && die )
            or die "$!";
      }
  }
  
  sub _empty($);
  *_empty = \&IPC::Run::_empty;
  
  =head1 SUBROUTINES
  
  =over 4
  
  =item new
  
  I think it takes >> or << along with some other data.
  
  TODO: Needs more thorough documentation. Patches welcome.
  
  =cut
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my ( $external, $type, $internal ) = ( shift, shift, pop );
  
      croak "$class: '$_' is not a valid I/O operator"
        unless $type =~ /^(?:<<?|>>?)$/;
  
      my IPC::Run::IO $self = $class->_new_internal( $type, undef, undef, $internal, undef, @_ );
  
      if ( !ref $external ) {
          $self->{FILENAME} = $external;
      }
      elsif ( ref $external eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
          $self->{HANDLE}     = $external;
          $self->{DONT_CLOSE} = 1;
      }
      else {
          croak "$class: cannot accept " . ref($external) . " to do I/O with";
      }
  
      return $self;
  }
  
  ## IPC::Run uses this ctor, since it preparses things and needs more
  ## smarts.
  sub _new_internal {
      my $class = shift;
      $class = ref $class || $class;
  
      $class = "IPC::Run::Win32IO"
        if Win32_MODE && $class eq "IPC::Run::IO";
  
      my IPC::Run::IO $self;
      $self = bless {}, $class;
  
      my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
  
      # Older perls (<=5.00503, at least) don't do list assign to
      # psuedo-hashes well.
      $self->{TYPE}   = $type;
      $self->{KFD}    = $kfd;
      $self->{PTY_ID} = $pty_id;
      $self->binmode($binmode);
      $self->{FILTERS} = [@filters];
  
      ## Add an adapter to the end of the filter chain (which is usually just the
      ## read/writer sub pushed by IPC::Run) to the DEST or SOURCE, if need be.
      if ( $self->op =~ />/ ) {
          croak "'$_' missing a destination" if _empty $internal;
          $self->{DEST} = $internal;
          if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
              ## Put a filter on the end of the filter chain to pass the
              ## output on to the CODE ref.  For SCALAR refs, the last
              ## filter in the chain writes directly to the scalar itself.  See
              ## _init_filters().  For CODE refs, however, we need to adapt from
              ## the SCALAR to calling the CODE.
              unshift(
                  @{ $self->{FILTERS} },
                  sub {
                      my ($in_ref) = @_;
  
                      return IPC::Run::input_avail() && do {
                          $self->{DEST}->($$in_ref);
                          $$in_ref = '';
                          1;
                        }
                  }
              );
          }
      }
      else {
          croak "'$_' missing a source" if _empty $internal;
          $self->{SOURCE} = $internal;
          if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      return undef
                        if $self->{SOURCE_EMPTY};
  
                      my $in = $internal->();
                      unless ( defined $in ) {
                          $self->{SOURCE_EMPTY} = 1;
                          return undef;
                      }
                      return 0 unless length $in;
                      $$out_ref = $in;
  
                      return 1;
                  }
              );
          }
          elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      ## pump() clears auto_close_ins, finish() sets it.
                      return $self->{HARNESS}->{auto_close_ins} ? undef : 0
                        if IPC::Run::_empty ${ $self->{SOURCE} }
                        || $self->{SOURCE_EMPTY};
  
                      $$out_ref = $$internal;
                      eval { $$internal = '' }
                        if $self->{HARNESS}->{clear_ins};
  
                      $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
  
                      return 1;
                  }
              );
          }
      }
  
      return $self;
  }
  
  =item filename
  
  Gets/sets the filename.  Returns the value after the name change, if
  any.
  
  =cut
  
  sub filename {
      my IPC::Run::IO $self = shift;
      $self->{FILENAME} = shift if @_;
      return $self->{FILENAME};
  }
  
  =item init
  
  Does initialization required before this can be run.  This includes open()ing
  the file, if necessary, and clearing the destination scalar if necessary.
  
  =cut
  
  sub init {
      my IPC::Run::IO $self = shift;
  
      $self->{SOURCE_EMPTY} = 0;
      ${ $self->{DEST} } = ''
        if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
  
      $self->open if defined $self->filename;
      $self->{FD} = $self->fileno;
  
      if ( !$self->{FILTERS} ) {
          $self->{FBUFS} = undef;
      }
      else {
          @{ $self->{FBUFS} } = map {
              my $s = "";
              \$s;
          } ( @{ $self->{FILTERS} }, '' );
  
          $self->{FBUFS}->[0] = $self->{DEST}
            if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
          push @{ $self->{FBUFS} }, $self->{SOURCE};
      }
  
      return undef;
  }
  
  =item open
  
  If a filename was passed in, opens it.  Determines if the handle is open
  via fileno().  Throws an exception on error.
  
  =cut
  
  my %open_flags = (
      '>'  => O_RDONLY,
      '>>' => O_RDONLY,
      '<'  => O_WRONLY | O_CREAT | O_TRUNC,
      '<<' => O_WRONLY | O_CREAT | O_APPEND,
  );
  
  sub open {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: Can't open() a file with no name"
        unless defined $self->{FILENAME};
      $self->{HANDLE} = gensym unless $self->{HANDLE};
  
      _debug "opening '", $self->filename, "' mode '", $self->mode, "'"
        if _debugging_data;
      sysopen(
          $self->{HANDLE},
          $self->filename,
          $open_flags{ $self->op },
      ) or croak "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
  
      return undef;
  }
  
  =item open_pipe
  
  If this is a redirection IO object, this opens the pipe in a platform
  independent manner.
  
  =cut
  
  sub _do_open {
      my $self = shift;
      my ( $child_debug_fd, $parent_handle ) = @_;
  
      if ( $self->dir eq "<" ) {
          ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
          if ($parent_handle) {
              CORE::open $parent_handle, ">&=$self->{FD}"
                or croak "$! duping write end of pipe for caller";
          }
      }
      else {
          ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
          if ($parent_handle) {
              CORE::open $parent_handle, "<&=$self->{FD}"
                or croak "$! duping read end of pipe for caller";
          }
      }
  }
  
  sub open_pipe {
      my IPC::Run::IO $self = shift;
  
      ## Hmmm, Maybe allow named pipes one day.  But until then...
      croak "IPC::Run::IO: Can't pipe() when a file name has been set"
        if defined $self->{FILENAME};
  
      $self->_do_open(@_);
  
      ## return ( child_fd, parent_fd )
      return $self->dir eq "<"
        ? ( $self->{TFD}, $self->{FD} )
        : ( $self->{FD}, $self->{TFD} );
  }
  
  sub _cleanup {    ## Called from Run.pm's _cleanup
      my $self = shift;
      undef $self->{FAKE_PIPE};
  }
  
  =item close
  
  Closes the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub close {
      my IPC::Run::IO $self = shift;
  
      if ( defined $self->{HANDLE} ) {
          close $self->{HANDLE}
            or croak(
              "IPC::Run::IO: $! closing "
                . (
                  defined $self->{FILENAME}
                  ? "'$self->{FILENAME}'"
                  : "handle"
                )
            );
      }
      else {
          IPC::Run::_close( $self->{FD} );
      }
  
      $self->{FD} = undef;
  
      return undef;
  }
  
  =item fileno
  
  Returns the fileno of the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub fileno {
      my IPC::Run::IO $self = shift;
  
      my $fd = fileno $self->{HANDLE};
      croak(
          "IPC::Run::IO: $! "
            . (
              defined $self->{FILENAME}
              ? "'$self->{FILENAME}'"
              : "handle"
            )
      ) unless defined $fd;
  
      return $fd;
  }
  
  =item mode
  
  Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
  'ra', unlike Perl's open(), which indicates that data read from the
  handle or file will be appended to the output if the output is a scalar.
  This is only meaningful if the output is a scalar, it has no effect if
  the output is a subroutine.
  
  The redirection operators can be a little confusing, so here's a reference
  table:
  
     >      r      Read from handle in to process
     <      w      Write from process out to handle
     >>     ra     Read from handle in to process, appending it to existing
                   data if the destination is a scalar.
     <<     wa     Write from process out to handle, appending to existing
                   data if IPC::Run::IO opened a named file.
  
  =cut
  
  sub mode {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
  
      ## TODO: Optimize this
      return ( $self->{TYPE} =~ /</ ? 'w' : 'r' ) . ( $self->{TYPE} =~ /<<|>>/ ? 'a' : '' );
  }
  
  =item op
  
  Returns the operation: '<', '>', '<<', '>>'.  See L</mode> if you want
  to spell these 'r', 'w', etc.
  
  =cut
  
  sub op {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
  
      return $self->{TYPE};
  }
  
  =item binmode
  
  Sets/gets whether this pipe is in binmode or not.  No effect off of Win32
  OSs, of course, and on Win32, no effect after the harness is start()ed.
  
  =cut
  
  sub binmode {
      my IPC::Run::IO $self = shift;
  
      $self->{BINMODE} = shift if @_;
  
      return $self->{BINMODE};
  }
  
  =item dir
  
  Returns the first character of $self->op.  This is either "<" or ">".
  
  =cut
  
  sub dir {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
  
      return substr $self->{TYPE}, 0, 1;
  }
  
  ##
  ## Filter Scaffolding
  ##
  #my $filter_op ;        ## The op running a filter chain right now
  #my $filter_num;        ## Which filter is being run right now.
  
  use vars (
      '$filter_op',    ## The op running a filter chain right now
      '$filter_num'    ## Which filter is being run right now.
  );
  
  sub _init_filters {
      my IPC::Run::IO $self = shift;
  
      confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
      $self->{FBUFS} = [];
  
      $self->{FBUFS}->[0] = $self->{DEST}
        if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
  
      return unless $self->{FILTERS} && @{ $self->{FILTERS} };
  
      push @{ $self->{FBUFS} }, map {
          my $s = "";
          \$s;
      } ( @{ $self->{FILTERS} }, '' );
  
      push @{ $self->{FBUFS} }, $self->{SOURCE};
  }
  
  =item poll
  
  TODO: Needs confirmation that this is correct. Was previously undocumented.
  
  I believe this is polling the IO for new input and then returns undef if there will never be any more input, 0 if there is none now, but there might be in the future, and TRUE if more input was gotten.
  
  =cut
  
  sub poll {
      my IPC::Run::IO $self = shift;
      my ($harness) = @_;
  
      if ( defined $self->{FD} ) {
          my $d = $self->dir;
          if ( $d eq "<" ) {
              if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data to", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
          elsif ( $d eq ">" ) {
              if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data from", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
      }
      return 0;
  }
  
  sub _do_filters {
      my IPC::Run::IO $self = shift;
  
      ( $self->{HARNESS} ) = @_;
  
      my ( $saved_op, $saved_num ) = ( $IPC::Run::filter_op, $IPC::Run::filter_num );
      $IPC::Run::filter_op  = $self;
      $IPC::Run::filter_num = -1;
      my $redos = 0;
      my $r;
      {
          $@ = '';
          $r = eval { IPC::Run::get_more_input(); };
  
          # Detect Resource temporarily unavailable and re-try 200 times (2 seconds),  assuming select behaves (which it doesn't always? need ref)
          if ( ( $@ || '' ) =~ $IPC::Run::_EAGAIN && $redos++ < 200 ) {
              select( undef, undef, undef, 0.01 );
              redo;
          }
      }
      ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
      $self->{HARNESS} = undef;
      die "ack ", $@ if $@;
      return $r;
  }
  
  =back
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 TODO
  
  Implement bidirectionality.
  
  =cut
  
  1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_TIMER';
  package IPC::Run::Timer;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Timer -- Timer channels for IPC::Run.
  
  =head1 SYNOPSIS
  
     use IPC::Run qw( run  timer timeout );
     ## or IPC::Run::Timer ( timer timeout );
     ## or IPC::Run::Timer ( :all );
  
     ## A non-fatal timer:
     $t = timer( 5 ); # or...
     $t = IO::Run::Timer->new( 5 );
     run $t, ...;
  
     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ); # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" );
  
  =head1 DESCRIPTION
  
  This class and module allows timers and timeouts to be created for use
  by IPC::Run.  A timer simply expires when it's time is up.  A timeout
  is a timer that throws an exception when it expires.
  
  Timeouts are usually a bit simpler to use  than timers: they throw an
  exception on expiration so you don't need to check them:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/;
  
  You do need to check timers:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $t->is_expired || $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired;
  
  Timers and timeouts that are reset get started by start() and
  pump().  Timers change state only in pump().  Since run() and
  finish() both call pump(), they act like pump() with respect to
  timers.
  
  Timers and timeouts have three states: reset, running, and expired.
  Setting the timeout value resets the timer, as does calling
  the reset() method.  The start() method starts (or restarts) a
  timer with the most recently set time value, no matter what state
  it's in.
  
  =head2 Time values
  
  All time values are in seconds.  Times may be any kind of perl number,
  e.g. as integer or floating point seconds, optionally preceded by
  punctuation-separated days, hours, and minutes.
  
  Examples:
  
     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds
     'inf'       the infinity perl special number (the timer never finishes)
  
  Absolute date/time strings are *not* accepted: year, month and
  day-of-month parsing is not available (patches welcome :-).
  
  =head2 Interval fudging
  
  When calculating an end time from a start time and an interval, IPC::Run::Timer
  instances add a little fudge factor.  This is to ensure that no time will
  expire before the interval is up.
  
  First a little background.  Time is sampled in discrete increments.  We'll
  call the
  exact moment that the reported time increments from one interval to the
  next a tick, and the interval between ticks as the time period.  Here's
  a diagram of three ticks and the periods between them:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                   ^                   ^
      |<--- period 0 ---->|<--- period 1 ---->|
      |                   |                   |
    tick 0              tick 1              tick 2
  
  To see why the fudge factor is necessary, consider what would happen
  when a timer with an interval of 1 second is started right at the end of
  period 0:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^                   ^
      |                |  |                   |
      |                |  |                   |
    tick 0             |tick 1              tick 2
                       |
                   start $t
  
  Assuming that check() is called many times per period, then the timer
  is likely to expire just after tick 1, since the time reported will have
  lept from the value '0' to the value '1':
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^   ^               ^
      |                |  |   |               |
      |                |  |   |               |
    tick 0             |tick 1|             tick 2
                       |      |
                   start $t   |
  		            |
  			check $t
  
  Adding a fudge of '1' in this example means that the timer is guaranteed
  not to expire before tick 2.
  
  The fudge is not added to an interval of '0'.
  
  This means that intervals guarantee a minimum interval.  Given that
  the process running perl may be suspended for some period of time, or that
  it gets busy doing something time-consuming, there are no other guarantees on
  how long it will take a timer to expire.
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: Due to the awkwardness introduced by ripping
  pseudohashes out of Perl, this class I<no longer> uses the fields
  pragma.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  use Exporter;
  use Scalar::Util ();
  use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
  
  BEGIN {
      $VERSION   = '20220807.0';
      @ISA       = qw( Exporter );
      @EXPORT_OK = qw(
        check
        end_time
        exception
        expire
        interval
        is_expired
        is_reset
        is_running
        name
        reset
        start
        timeout
        timer
      );
  
      %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  }
  
  require IPC::Run;
  use IPC::Run::Debug;
  
  ##
  ## Some helpers
  ##
  my $resolution = 1;
  
  sub _parse_time {
      for ( $_[0] ) {
          my $val;
          if ( not defined $_ ) {
              $val = $_;
          }
          else {
              my @f = split( /:/, $_, -1 );
              if ( scalar @f > 4 ) {
                  croak "IPC::Run: expected <= 4 elements in time string '$_'";
              }
              for (@f) {
                  if ( not Scalar::Util::looks_like_number($_) ) {
                      croak "IPC::Run: non-numeric element '$_' in time string '$_'";
                  }
              }
              my ( $s, $m, $h, $d ) = reverse @f;
              $val = ( ( ( $d || 0 ) * 24 + ( $h || 0 ) ) * 60 + ( $m || 0 ) ) * 60 + ( $s || 0 );
          }
          return $val;
      }
  }
  
  sub _calc_end_time {
      my IPC::Run::Timer $self = shift;
      my $interval = $self->interval;
      $interval += $resolution if $interval;
      $self->end_time( $self->start_time + $interval );
  }
  
  =item timer
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timer( 5 );
     $t = timer( 5, name => 'stall timer', debug => 1 );
  
     $t = timer;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timer( 5 );
  
  This convenience function is a shortened spelling of
  
     IPC::Run::Timer->new( ... );
     
  .  It returns a timer in the reset state with a given interval.
  
  If an exception is provided, it will be thrown when the timer notices that
  it has expired (in check()).  The name is for debugging usage, if you plan on
  having multiple timers around.  If no name is provided, a name like "timer #1"
  will be provided.
  
  =cut
  
  sub timer {
      return IPC::Run::Timer->new(@_);
  }
  
  =item timeout
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timeout( 5 );
     $t = timeout( 5, exception => "kablooey" );
     $t = timeout( 5, name => "stall", exception => "kablooey" );
  
     $t = timeout;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timeout( 5 );
  
  A This convenience function is a shortened spelling of 
  
     IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... );
     
  .  It returns a timer in the reset state that will throw an
  exception when it expires.
  
  Takes the same parameters as L</timer>, any exception passed in overrides
  the default exception.
  
  =cut
  
  sub timeout {
      my $t = IPC::Run::Timer->new(@_);
      $t->exception( "IPC::Run: timeout on " . $t->name )
        unless defined $t->exception;
      return $t;
  }
  
  =item new
  
     IPC::Run::Timer->new()  ;
     IPC::Run::Timer->new( 5 )  ;
     IPC::Run::Timer->new( 5, exception => 'kablooey' )  ;
  
  Constructor.  See L</timer> for details.
  
  =cut
  
  my $timer_counter;
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my IPC::Run::Timer $self = bless {}, $class;
  
      $self->{STATE} = 0;
      $self->{DEBUG} = 0;
      $self->{NAME}  = "timer #" . ++$timer_counter;
  
      while (@_) {
          my $arg = shift;
          if ( $arg eq 'exception' ) {
              $self->exception(shift);
          }
          elsif ( $arg eq 'name' ) {
              $self->name(shift);
          }
          elsif ( $arg eq 'debug' ) {
              $self->debug(shift);
          }
          else {
              $self->interval($arg);
          }
      }
  
      _debug $self->name . ' constructed'
        if $self->{DEBUG} || _debugging_details;
  
      return $self;
  }
  
  =item check
  
     check $t;
     check $t, $now;
     $t->check;
  
  Checks to see if a timer has expired since the last check.  Has no effect
  on non-running timers.  This will throw an exception if one is defined.
  
  IPC::Run::pump() calls this routine for any timers in the harness.
  
  You may pass in a version of now, which is useful in case you have
  it lying around or you want to check several timers with a consistent
  concept of the current time.
  
  Returns the time left before end_time or 0 if end_time is no longer
  in the future or the timer is not running
  (unless, of course, check() expire()s the timer and this
  results in an exception being thrown).
  
  Returns undef if the timer is not running on entry, 0 if check() expires it,
  and the time left if it's left running.
  
  =cut
  
  sub check {
      my IPC::Run::Timer $self = shift;
      return undef if !$self->is_running;
      return 0     if $self->is_expired;
  
      my ($now) = @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      _debug( "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now ) if $self->{DEBUG} || _debugging_details;
  
      my $left = $self->end_time - $now;
      return $left if $left > 0;
  
      $self->expire;
      return 0;
  }
  
  =item debug
  
  Sets/gets the current setting of the debugging flag for this timer.  This
  has no effect if debugging is not enabled for the current harness.
  
  =cut
  
  sub debug {
      my IPC::Run::Timer $self = shift;
      $self->{DEBUG} = shift if @_;
      return $self->{DEBUG};
  }
  
  =item end_time
  
     $et = $t->end_time;
     $et = end_time $t;
  
     $t->end_time( time + 10 );
  
  Returns the time when this timer will or did expire.  Even if this time is
  in the past, the timer may not be expired, since check() may not have been
  called yet.
  
  Note that this end_time is not start_time($t) + interval($t), since some
  small extra amount of time is added to make sure that the timer does not
  expire before interval() elapses.  If this were not so, then 
  
  Changing end_time() while a timer is running will set the expiration time.
  Changing it while it is expired has no affect, since reset()ing a timer always
  clears the end_time().
  
  =cut
  
  sub end_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{END_TIME} = shift;
          _debug $self->name, ' end_time set to ', $self->{END_TIME}
            if $self->{DEBUG} > 2 || _debugging_details;
      }
      return $self->{END_TIME};
  }
  
  =item exception
  
     $x = $t->exception;
     $t->exception( $x );
     $t->exception( undef );
  
  Sets/gets the exception to throw, if any.  'undef' means that no
  exception will be thrown.  Exception does not need to be a scalar: you 
  may ask that references be thrown.
  
  =cut
  
  sub exception {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{EXCEPTION} = shift;
          _debug $self->name, ' exception set to ', $self->{EXCEPTION}
            if $self->{DEBUG} || _debugging_details;
      }
      return $self->{EXCEPTION};
  }
  
  =item interval
  
     $i = interval $t;
     $i = $t->interval;
     $t->interval( $i );
  
  Sets the interval.  Sets the end time based on the start_time() and the
  interval (and a little fudge) if the timer is running.
  
  =cut
  
  sub interval {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{INTERVAL} = _parse_time(shift);
          _debug $self->name, ' interval set to ', $self->{INTERVAL}
            if $self->{DEBUG} > 2 || _debugging_details;
  
          $self->_calc_end_time if $self->state;
      }
      return $self->{INTERVAL};
  }
  
  =item expire
  
     expire $t;
     $t->expire;
  
  Sets the state to expired (undef).
  Will throw an exception if one
  is defined and the timer was not already expired.  You can expire a
  reset timer without starting it.
  
  =cut
  
  sub expire {
      my IPC::Run::Timer $self = shift;
      if ( defined $self->state ) {
          _debug $self->name . ' expired'
            if $self->{DEBUG} || _debugging;
  
          $self->state(undef);
          croak $self->exception if $self->exception;
      }
      return undef;
  }
  
  =item is_running
  
  =cut
  
  sub is_running {
      my IPC::Run::Timer $self = shift;
      return $self->state ? 1 : 0;
  }
  
  =item is_reset
  
  =cut
  
  sub is_reset {
      my IPC::Run::Timer $self = shift;
      return defined $self->state && $self->state == 0;
  }
  
  =item is_expired
  
  =cut
  
  sub is_expired {
      my IPC::Run::Timer $self = shift;
      return !defined $self->state;
  }
  
  =item name
  
  Sets/gets this timer's name.  The name is only used for debugging
  purposes so you can tell which freakin' timer is doing what.
  
  =cut
  
  sub name {
      my IPC::Run::Timer $self = shift;
  
      $self->{NAME} = shift if @_;
      return
          defined $self->{NAME}      ? $self->{NAME}
        : defined $self->{EXCEPTION} ? 'timeout'
        :                              'timer';
  }
  
  =item reset
  
     reset $t;
     $t->reset;
  
  Resets the timer to the non-running, non-expired state and clears
  the end_time().
  
  =cut
  
  sub reset {
      my IPC::Run::Timer $self = shift;
      $self->state(0);
      $self->end_time(undef);
      _debug $self->name . ' reset'
        if $self->{DEBUG} || _debugging;
  
      return undef;
  }
  
  =item start
  
     start $t;
     $t->start;
     start $t, $interval;
     start $t, $interval, $now;
  
  Starts or restarts a timer.  This always sets the start_time.  It sets the
  end_time based on the interval if the timer is running or if no end time
  has been set.
  
  You may pass an optional interval or current time value.
  
  Not passing a defined interval causes the previous interval setting to be
  re-used unless the timer is reset and an end_time has been set
  (an exception is thrown if no interval has been set).  
  
  Not passing a defined current time value causes the current time to be used.
  
  Passing a current time value is useful if you happen to have a time value
  lying around or if you want to make sure that several timers are started
  with the same concept of start time.  You might even need to lie to an
  IPC::Run::Timer, occasionally.
  
  =cut
  
  sub start {
      my IPC::Run::Timer $self = shift;
  
      my ( $interval, $now ) = map { _parse_time($_) } @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      $self->interval($interval) if defined $interval;
  
      ## start()ing a running or expired timer clears the end_time, so that the
      ## interval is used.  So does specifying an interval.
      $self->end_time(undef) if !$self->is_reset || $interval;
  
      croak "IPC::Run: no timer interval or end_time defined for " . $self->name
        unless defined $self->interval || defined $self->end_time;
  
      $self->state(1);
      $self->start_time($now);
      ## The "+ 1" is in case the START_TIME was sampled at the end of a
      ## tick (which are one second long in this module).
      $self->_calc_end_time
        unless defined $self->end_time;
  
      _debug(
          $self->name, " started at ", $self->start_time,
          ", with interval ", $self->interval, ", end_time ", $self->end_time
      ) if $self->{DEBUG} || _debugging;
      return undef;
  }
  
  =item start_time
  
  Sets/gets the start time, in seconds since the epoch.  Setting this manually
  is a bad idea, it's better to call L</start>() at the correct time.
  
  =cut
  
  sub start_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{START_TIME} = _parse_time(shift);
          _debug $self->name, ' start_time set to ', $self->{START_TIME}
            if $self->{DEBUG} > 2 || _debugging;
      }
  
      return $self->{START_TIME};
  }
  
  =item state
  
     $s = state $t;
     $t->state( $s );
  
  Get/Set the current state.  Only use this if you really need to transfer the
  state to/from some variable.
  Use L</expire>, L</start>, L</reset>, L</is_expired>, L</is_running>,
  L</is_reset>.
  
  Note:  Setting the state to 'undef' to expire a timer will not throw an
  exception.
  
  =back
  
  =cut
  
  sub state {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{STATE} = shift;
          _debug $self->name, ' state set to ', $self->{STATE}
            if $self->{DEBUG} > 2 || _debugging;
      }
      return $self->{STATE};
  }
  
  1;
  
  =pod
  
  =head1 TODO
  
  use Time::HiRes; if it's present.
  
  Add detection and parsing of [[[HH:]MM:]SS formatted times and intervals.
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =cut
IPC_RUN_TIMER

$fatpacked{"IPC/Run/Win32Helper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32HELPER';
  package IPC::Run::Win32Helper;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Helper - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32Helper;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select() loop
  will work on Win32. This seems to only work on WinNT and Win2K at this time, not
  sure if it will ever work on Win95 or Win98. If you have experience in this area, please
  contact me at barries@slaysys.com, thanks!.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use vars qw{ $VERSION @ISA @EXPORT };
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        win32_spawn
        win32_parse_cmd_line
        _dont_inherit
        _inherit
      );
  }
  
  require POSIX;
  
  use File::Spec ();
  use Text::ParseWords;
  use Win32 ();
  use Win32::Process;
  use Win32::ShellQuote ();
  use IPC::Run::Debug;
  use Win32API::File qw(
    FdGetOsFHandle
    SetHandleInformation
    HANDLE_FLAG_INHERIT
    INVALID_HANDLE_VALUE
  );
  
  ## Takes an fd or a GLOB ref, never never never a Win32 handle.
  sub _dont_inherit {
      for (@_) {
          next unless defined $_;
          my $fd = $_;
          $fd = fileno $fd if ref $fd;
          _debug "disabling inheritance of ", $fd if _debugging_details;
          my $osfh = FdGetOsFHandle $fd;
          croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
      }
  }
  
  sub _inherit {    #### REMOVE
      for (@_) {    #### REMOVE
          next unless defined $_;    #### REMOVE
          my $fd = $_;               #### REMOVE
          $fd = fileno $fd if ref $fd;    #### REMOVE
          _debug "enabling inheritance of ", $fd if _debugging_details;    #### REMOVE
          my $osfh = FdGetOsFHandle $fd;                                   #### REMOVE
          croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;    #### REMOVE
          #### REMOVE
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );           #### REMOVE
      }    #### REMOVE
  }    #### REMOVE
  #### REMOVE
  #sub _inherit {
  #   for ( @_ ) {
  #      next unless defined $_;
  #      my $osfh = GetOsFHandle $_;
  #      croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  #      SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT );
  #   }
  #}
  
  =pod
  
  =head1 FUNCTIONS
  
  =over
  
  =item optimize()
  
  Most common incantations of C<run()> (I<not> C<harness()>, C<start()>,
  or C<finish()>) now use temporary files to redirect input and output
  instead of pumper processes.
  
  Temporary files are used when sending to child processes if input is
  taken from a scalar with no filter subroutines.  This is the only time
  we can assume that the parent is not interacting with the child's
  redirected input as it runs.
  
  Temporary files are used when receiving from children when output is
  to a scalar or subroutine with or without filters, but only if
  the child in question closes its inputs or takes input from 
  unfiltered SCALARs or named files.  Normally, a child inherits its STDIN
  from its parent; to close it, use "0<&-" or the C<< noinherit => 1 >> option.
  If data is sent to the child from CODE refs, filehandles or from
  scalars through filters than the child's outputs will not be optimized
  because C<optimize()> assumes the parent is interacting with the child.
  It is ok if the output is filtered or handled by a subroutine, however.
  
  This assumes that all named files are real files (as opposed to named
  pipes) and won't change; and that a process is not communicating with
  the child indirectly (through means not visible to IPC::Run).
  These can be an invalid assumptions, but are the 99% case.
  Write me if you need an option to enable or disable optimizations; I
  suspect it will work like the C<binary()> modifier.
  
  To detect cases that you might want to optimize by closing inputs, try
  setting the C<IPCRUNDEBUG> environment variable to the special C<notopt>
  value:
  
     C:> set IPCRUNDEBUG=notopt
     C:> my_app_that_uses_IPC_Run.pl
  
  =item optimizer() rationalizations
  
  Only for that limited case can we be sure that it's ok to batch all the
  input in to a temporary file.  If STDIN is from a SCALAR or from a named
  file or filehandle (again, only in C<run()>), then outputs to CODE refs
  are also assumed to be safe enough to batch through a temp file,
  otherwise only outputs to SCALAR refs are batched.  This can cause a bit
  of grief if the parent process benefits from or relies on a bit of
  "early returns" coming in before the child program exits.  As long as
  the output is redirected to a SCALAR ref, this will not be visible.
  When output is redirected to a subroutine or (deprecated) filters, the
  subroutine will not get any data until after the child process exits,
  and it is likely to get bigger chunks of data at once.
  
  The reason for the optimization is that, without it, "pumper" processes
  are used to overcome the inconsistencies of the Win32 API.  We need to
  use anonymous pipes to connect to the child processes' stdin, stdout,
  and stderr, yet select() does not work on these.  select() only works on
  sockets on Win32.  So for each redirected child handle, there is
  normally a "pumper" process that connects to the parent using a
  socket--so the parent can select() on that fd--and to the child on an
  anonymous pipe--so the child can read/write a pipe.
  
  Using a socket to connect directly to the child (as at least one MSDN
  article suggests) seems to cause the trailing output from most children
  to be lost.  I think this is because child processes rarely close their
  stdout and stderr explicitly, and the winsock dll does not seem to flush
  output when a process that uses it exits without explicitly closing
  them.
  
  Because of these pumpers and the inherent slowness of Win32
  CreateProcess(), child processes with redirects are quite slow to
  launch; so this routine looks for the very common case of
  reading/writing to/from scalar references in a run() routine and
  converts such reads and writes in to temporary file reads and writes.
  
  Such files are marked as FILE_ATTRIBUTE_TEMPORARY to increase speed and
  as FILE_FLAG_DELETE_ON_CLOSE so it will be cleaned up when the child
  process exits (for input files).  The user's default permissions are
  used for both the temporary files and the directory that contains them,
  hope your Win32 permissions are secure enough for you.  Files are
  created with the Win32API::File defaults of
  FILE_SHARE_READ|FILE_SHARE_WRITE.
  
  Setting the debug level to "details" or "gory" will give detailed
  information about the optimization process; setting it to "basic" or
  higher will tell whether or not a given call is optimized.  Setting
  it to "notopt" will highlight those calls that aren't optimized.
  
  =cut
  
  sub optimize {
      my ($h) = @_;
  
      my @kids = @{ $h->{KIDS} };
  
      my $saw_pipe;
  
      my ( $ok_to_optimize_outputs, $veto_output_optimization );
  
      for my $kid (@kids) {
          ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
            unless $saw_pipe;
  
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
            if _debugging_details && $ok_to_optimize_outputs;
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
            if _debugging_details && $veto_output_optimization;
  
          if ( $h->{noinherit} && !$ok_to_optimize_outputs ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
                if _debugging_details && $ok_to_optimize_outputs;
              $ok_to_optimize_outputs = 1;
          }
  
          for ( @{ $kid->{OPS} } ) {
              if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
                  if ( $_->{TYPE} eq "<" ) {
                      if ( @{ $_->{FILTERS} } > 1 ) {
                          ## Can't assume that the filters are idempotent.
                      }
                      elsif (ref $_->{SOURCE} eq "SCALAR"
                          || ref $_->{SOURCE} eq "GLOB"
                          || UNIVERSAL::isa( $_, "IO::Handle" ) ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
                                ref $_->{SOURCE},
                                ", ok to optimize outputs"
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          $_->{SEND_THROUGH_TEMP_FILE} = 1;
                          next;
                      }
                      elsif ( !ref $_->{SOURCE} && defined $_->{SOURCE} ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          next;
                      }
                  }
                  _debug
                    "Win32 optimizer: (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{SOURCE}
                    ? ref $_->{SOURCE}
                        ? ref $_->{SOURCE}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } > 1 ? " with filters" : (),
                    ", VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
                  $veto_output_optimization = 1;
              }
              elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
                  $ok_to_optimize_outputs = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
                    if _debugging_details;
              }
              elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
                  $veto_output_optimization = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
              }
              elsif ( $_->{TYPE} eq "|" ) {
                  $saw_pipe = 1;
              }
          }
  
          if ( !$ok_to_optimize_outputs && !$veto_output_optimization ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
                if _debugging_details || _debugging_not_optimized;
              $veto_output_optimization = 1;
          }
  
          if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
              $ok_to_optimize_outputs = 0;
              _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
                if _debugging_details || _debugging_not_optimized;
          }
  
          ## SOURCE/DEST ARRAY means it's a filter.
          ## TODO: think about checking to see if the final input/output of
          ## a filter chain (an ARRAY SOURCE or DEST) is a scalar...but
          ## we may be deprecating filters.
  
          for ( @{ $kid->{OPS} } ) {
              if ( $_->{TYPE} eq ">" ) {
                  if (
                      ref $_->{DEST} eq "SCALAR"
                      || (
                          (
                                 @{ $_->{FILTERS} } > 1
                              || ref $_->{DEST} eq "CODE"
                              || ref $_->{DEST} eq "ARRAY"    ## Filters?
                          )
                          && ( $ok_to_optimize_outputs && !$veto_output_optimization )
                      )
                    ) {
                      $_->{RECV_THROUGH_TEMP_FILE} = 1;
                      next;
                  }
                  _debug
                    "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{DEST}
                    ? ref $_->{DEST}
                        ? ref $_->{DEST}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } ? " with filters" : (),
                    if _debugging_details;
              }
          }
      }
  
  }
  
  =pod
  
  =item win32_parse_cmd_line
  
     @words = win32_parse_cmd_line( q{foo bar 'baz baz' "bat bat"} );
  
  returns 4 words. This parses like the bourne shell (see
  the bit about shellwords() in L<Text::ParseWords>), assuming we're
  trying to be a little cross-platform here.  The only difference is
  that "\" is *not* treated as an escape except when it precedes 
  punctuation, since it's used all over the place in DOS path specs.
  
  TODO: strip caret escapes?
  
  TODO: use
  https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments
  
  TODO: globbing? probably not (it's unDOSish).
  
  TODO: shebang emulation? Probably, but perhaps that should be part
  of Run.pm so all spawned processes get the benefit.
  
  LIMITATIONS: shellwords dies silently on malformed input like 
  
     a\"
  
  =cut
  
  sub win32_parse_cmd_line {
      my $line = shift;
      $line =~ s{(\\[\w\s])}{\\$1}g;
      return shellwords $line;
  }
  
  =pod
  
  =item win32_spawn
  
  Spawns a child process, possibly with STDIN, STDOUT, and STDERR (file descriptors 0, 1, and 2, respectively) redirected.
  
  B<LIMITATIONS>.
  
  Cannot redirect higher file descriptors due to lack of support for this in the
  Win32 environment.
  
  This can be worked around by marking a handle as inheritable in the
  parent (or leaving it marked; this is the default in perl), obtaining it's
  Win32 handle with C<Win32API::GetOSFHandle(FH)> or
  C<Win32API::FdGetOsFHandle($fd)> and passing it to the child using the command
  line, the environment, or any other IPC mechanism (it's a plain old integer).
  The child can then use C<OsFHandleOpen()> or C<OsFHandleOpenFd()> and possibly
  C<<open FOO ">&BAR">> or C<<open FOO ">&$fd>> as need be.  Ach, the pain!
  
  Remember to check the Win32 handle against INVALID_HANDLE_VALUE.
  
  =cut
  
  sub _save {
      my ( $saved, $saved_as, $fd ) = @_;
  
      ## We can only save aside the original fds once.
      return if exists $saved->{$fd};
  
      my $saved_fd = IPC::Run::_dup($fd);
      _dont_inherit $saved_fd;
  
      $saved->{$fd}          = $saved_fd;
      $saved_as->{$saved_fd} = $fd;
  
      _dont_inherit $saved->{$fd};
  }
  
  sub _dup2_gently {
      my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
      _save $saved, $saved_as, $fd2;
  
      if ( exists $saved_as->{$fd2} ) {
          ## The target fd is colliding with a saved-as fd, gotta bump
          ## the saved-as fd to another fd.
          my $orig_fd  = delete $saved_as->{$fd2};
          my $saved_fd = IPC::Run::_dup($fd2);
          _dont_inherit $saved_fd;
  
          $saved->{$orig_fd}     = $saved_fd;
          $saved_as->{$saved_fd} = $orig_fd;
      }
      _debug "moving $fd1 to kid's $fd2" if _debugging_details;
      IPC::Run::_dup2_rudely( $fd1, $fd2 );
  }
  
  sub win32_spawn {
      my ( $cmd, $ops ) = @_;
  
      my ( $app, $cmd_line );
      my $need_pct = 0;
      if ( UNIVERSAL::isa( $cmd, 'IPC::Run::Win32Process' ) ) {
          $app      = $cmd->{lpApplicationName};
          $cmd_line = $cmd->{lpCommandLine};
      }
      elsif ( $cmd->[0] !~ /\.(bat|cmd) *$/i ) {
          $app      = $cmd->[0];
          $cmd_line = Win32::ShellQuote::quote_native(@$cmd);
      }
      else {
          # Batch file, so follow the batch-specific guidance of
          # https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
          # There's no one true way to locate cmd.exe.  In the unlikely event that
          # %COMSPEC% is missing, fall back on a Windows API.  We could search
          # %PATH% like _wsystem() does.  That would be prone to security bugs,
          # and one fallback is enough.
          $app = (
              $ENV{COMSPEC}
                || File::Spec->catfile(
                  Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                  'cmd.exe'
                )
          );
  
          # Win32 rejects attempts to create files with names containing certain
          # characters.  Ignore most, but reject the subset that might otherwise
          # cause us to execute the wrong file instead of failing cleanly.
          if ( $cmd->[0] =~ /["\r\n\0]/ ) {
              croak "invalid batch file name";
          }
  
          # Make cmd.exe see the batch file name as quoted.  Suppose we instead
          # used caret escapes, as we do for arguments.  cmd.exe could then "break
          # the command token at the first occurrence of <space> , ; or ="
          # (https://stackoverflow.com/a/4095133).
          my @parts = qq{"$cmd->[0]"};
  
          # cmd.exe will strip escapes once when parsing our $cmd_line and again
          # where the batch file injects the argument via %*, %1, etc.  Compensate
          # by adding one extra cmd_escape layer.
          if ( @$cmd > 1 ) {
              my @q = Win32::ShellQuote::quote_cmd( @{$cmd}[ 1 .. $#{$cmd} ] );
              push @parts, map { Win32::ShellQuote::cmd_escape($_) } @q;
          }
  
          # One can't stop cmd.exe from expanding %var%, so inject each literal %
          # via an environment variable.  Delete that variable before the real
          # child can see it.  See
          # https://www.dostips.com/forum/viewtopic.php?f=3&t=10131 for more on
          # this technique and the limitations of alternatives.
          $cmd_line = join ' ', @parts;
          if ( $cmd_line =~ s/%/%ipcrunpct%/g ) {
              $cmd_line = qq{/c "set "ipcrunpct=" & $cmd_line"};
              $need_pct = 1;
          }
          else {
              $cmd_line = qq{/c "$cmd_line"};
          }
      }
      _debug "app: ", $app
        if _debugging;
      _debug "cmd line: ", $cmd_line
        if _debugging;
  
      ## NOTE: The debug pipe write handle is passed to pump processes as STDOUT.
      ## and is not to the "real" child process, since they would not know
      ## what to do with it...unlike Unix, we have no code executing in the
      ## child before the "real" child is exec()ed.
  
      my %saved;       ## Map of parent's orig fd -> saved fd
      my %saved_as;    ## Map of parent's saved fd -> orig fd, used to
      ## detect collisions between a KFD and the fd a
      ## parent's fd happened to be saved to.
  
      for my $op (@$ops) {
          _dont_inherit $op->{FD} if defined $op->{FD};
  
          if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
              ## TODO: Detect this in harness()
              ## TODO: enable temporary redirections if ever necessary, not
              ## sure why they would be...
              ## 4>&1 1>/dev/null 1>&4 4>&-
              croak "Can't redirect fd #", $op->{KFD}, " on Win32";
          }
  
          ## This is very similar logic to IPC::Run::_do_kid_and_exit().
          if ( defined $op->{TFD} ) {
              unless ( $op->{TFD} == $op->{KFD} ) {
                  _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
                  _dont_inherit $op->{TFD};
              }
          }
          elsif ( $op->{TYPE} eq "dup" ) {
              _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
                unless $op->{KFD1} == $op->{KFD2};
          }
          elsif ( $op->{TYPE} eq "close" ) {
              _save \%saved, \%saved_as, $op->{KFD};
              IPC::Run::_close( $op->{KFD} );
          }
          elsif ( $op->{TYPE} eq "init" ) {
              ## TODO: detect this in harness()
              croak "init subs not allowed on Win32";
          }
      }
  
      local $ENV{ipcrunpct} = '%' if $need_pct;
      my $process;
      Win32::Process::Create(
          $process,
          $app,
          $cmd_line,
          1,    ## Inherit handles
          0,    ## Inherit parent priortiy class. Was NORMAL_PRIORITY_CLASS
          ".",
        )
        or do {
          my $err = Win32::FormatMessage( Win32::GetLastError() );
          $err =~ s/\r?\n$//s;
          croak "$err: Win32::Process::Create()";
        };
  
      for my $orig_fd ( keys %saved ) {
          IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
          IPC::Run::_close( $saved{$orig_fd} );
      }
  
      return ( $process->GetProcessID(), $process );
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32HELPER

$fatpacked{"IPC/Run/Win32IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32IO';
  package IPC::Run::Win32IO;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32IO - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32IO;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select()
  loop will work on Win32. This seems to only work on WinNT and Win2K at this
  time, not sure if it will ever work on Win95 or Win98. If you have experience
  in this area, please contact me at barries@slaysys.com, thanks!.
  
  =head1 DESCRIPTION
  
  A specialized IO class used on Win32.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use Socket;
  require POSIX;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  use Socket qw( IPPROTO_TCP TCP_NODELAY );
  use Symbol;
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug qw( :default _debugging_level );
  use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
  use Fcntl qw( O_TEXT O_RDONLY );
  
  use base qw( IPC::Run::IO );
  my @cleanup_fields;
  
  BEGIN {
      ## These fields will be set to undef in _cleanup to close
      ## the handles.
      @cleanup_fields = (
          'SEND_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'RECV_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'TEMP_FILE_NAME',            ## The name of the temp file, needed for
          ## error reporting / debugging only.
  
          'PARENT_HANDLE',             ## The handle of the socket for the parent
          'PUMP_SOCKET_HANDLE',        ## The socket handle for the pump
          'PUMP_PIPE_HANDLE',          ## The anon pipe handle for the pump
          'CHILD_HANDLE',              ## The anon pipe handle for the child
  
          'TEMP_FILE_HANDLE',          ## The Win32 filehandle for the temp file
      );
  }
  
  ## REMOVE OSFHandleOpen
  use Win32API::File qw(
    GetOsFHandle
    OsFHandleOpenFd
    OsFHandleOpen
    FdGetOsFHandle
    SetHandleInformation
    SetFilePointer
    HANDLE_FLAG_INHERIT
    INVALID_HANDLE_VALUE
  
    createFile
    WriteFile
    ReadFile
    CloseHandle
  
    FILE_ATTRIBUTE_TEMPORARY
    FILE_FLAG_DELETE_ON_CLOSE
    FILE_FLAG_WRITE_THROUGH
  
    FILE_BEGIN
  );
  
  #   FILE_ATTRIBUTE_HIDDEN
  #   FILE_ATTRIBUTE_SYSTEM
  
  BEGIN {
      ## Force AUTOLOADED constants to be, well, constant by getting them
      ## to AUTOLOAD before compilation continues.  Sigh.
      () = (
          SOL_SOCKET,
          SO_REUSEADDR,
          IPPROTO_TCP,
          TCP_NODELAY,
          HANDLE_FLAG_INHERIT,
          INVALID_HANDLE_VALUE,
      );
  }
  
  use constant temp_file_flags => ( FILE_ATTRIBUTE_TEMPORARY() | FILE_FLAG_DELETE_ON_CLOSE() | FILE_FLAG_WRITE_THROUGH() );
  
  #   FILE_ATTRIBUTE_HIDDEN()    |
  #   FILE_ATTRIBUTE_SYSTEM()    |
  my $tmp_file_counter;
  my $tmp_dir;
  
  sub _cleanup {
      my IPC::Run::Win32IO $self = shift;
      my ($harness) = @_;
  
      $self->_recv_through_temp_file($harness)
        if $self->{RECV_THROUGH_TEMP_FILE};
  
      CloseHandle( $self->{TEMP_FILE_HANDLE} )
        if defined $self->{TEMP_FILE_HANDLE};
  
      close( $self->{CHILD_HANDLE} )
        if defined $self->{CHILD_HANDLE};
  
      $self->{$_} = undef for @cleanup_fields;
  }
  
  sub _create_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## Create a hidden temp file that Win32 will delete when we close
      ## it.
      unless ( defined $tmp_dir ) {
          $tmp_dir = File::Spec->catdir( File::Spec->tmpdir, "IPC-Run.tmp" );
  
          ## Trust in the user's umask.
          ## This could possibly be a security hole, perhaps
          ## we should offer an option.  Hmmmm, really, people coding
          ## security conscious apps should audit this code and
          ## tell me how to make it better.  Nice cop-out :).
          unless ( -d $tmp_dir ) {
              mkdir $tmp_dir or croak "$!: $tmp_dir";
          }
      }
  
      $self->{TEMP_FILE_NAME} = File::Spec->catfile(
          ## File name is designed for easy sorting and not conflicting
          ## with other processes.  This should allow us to use "t"runcate
          ## access in CreateFile in case something left some droppings
          ## around (which should never happen because we specify
          ## FLAG_DELETE_ON_CLOSE.
          ## heh, belt and suspenders are better than bug reports; God forbid
          ## that NT should ever crash before a temp file gets deleted!
          $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
      );
  
      $self->{TEMP_FILE_HANDLE} = createFile(
          $self->{TEMP_FILE_NAME},
          "trw",    ## new, truncate, read, write
          {
              Flags => temp_file_flags,
          },
      ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
  
      $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
      $self->{FD} = undef;
  
      _debug
        "Win32 Optimizer: temp file (",
        $self->{KFD},
        $self->{TYPE},
        $self->{TFD},
        ", fh ",
        $self->{TEMP_FILE_HANDLE},
        "): ",
        $self->{TEMP_FILE_NAME}
        if _debugging_details;
  }
  
  sub _reset_temp_file_pointer {
      my $self = shift;
      SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
        or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
  }
  
  sub _send_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      _debug "Win32 optimizer: optimizing " . " $self->{KFD} $self->{TYPE} temp file instead of ",
        ref $self->{SOURCE} || $self->{SOURCE}
        if _debugging_details;
  
      $self->_create_temp_file;
  
      if ( defined ${ $self->{SOURCE} } ) {
          my $bytes_written = 0;
          my $data_ref;
          if ( $self->binmode ) {
              $data_ref = $self->{SOURCE};
          }
          else {
              my $data = ${ $self->{SOURCE} };    # Ugh, a copy.
              $data =~ s/(?<!\r)\n/\r\n/g;
              $data_ref = \$data;
          }
  
          WriteFile(
              $self->{TEMP_FILE_HANDLE},
              $$data_ref,
              0,                                  ## Write entire buffer
              $bytes_written,
              [],                                 ## Not overlapped.
          ) or croak "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
          _debug "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
            if _debugging_data;
  
          $self->_reset_temp_file_pointer;
  
      }
  
      _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
        if _debugging_details;
  }
  
  sub _init_recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      $self->_create_temp_file;
  }
  
  ## TODO: Use the Win32 API in the select loop to see if the file has grown
  ## and read it incrementally if it has.
  sub _recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## This next line kicks in if the run() never got to initting things
      ## and needs to clean up.
      return undef unless defined $self->{TEMP_FILE_HANDLE};
  
      push @{ $self->{FILTERS} }, sub {
          my ( undef, $out_ref ) = @_;
  
          return undef unless defined $self->{TEMP_FILE_HANDLE};
  
          my $r;
          my $s;
          ReadFile(
              $self->{TEMP_FILE_HANDLE},
              $s,
              999_999,    ## Hmmm, should read the size.
              $r,
              []
          ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
  
          _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
  
          return undef unless $r;
  
          $s =~ s/\r\n/\n/g unless $self->binmode;
  
          my $pos = pos $$out_ref;
          $$out_ref .= $s;
          pos($out_ref) = $pos;
          return 1;
      };
  
      my ($harness) = @_;
  
      $self->_reset_temp_file_pointer;
  
      1 while $self->_do_filters($harness);
  
      pop @{ $self->{FILTERS} };
  
      IPC::Run::_close( $self->{TFD} );
  }
  
  =head1 SUBROUTINES
  
  =over
  
  =item poll
  
  Windows version of IPC::Run::IP::poll.
  
  =back
  
  =cut
  
  sub poll {
      my IPC::Run::Win32IO $self = shift;
  
      return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
  
      return $self->SUPER::poll(@_);
  }
  
  ## When threaded Perls get good enough, we should use threads here.
  ## The problem with threaded perls is that they dup() all sorts of
  ## filehandles and fds and don't allow sufficient control over
  ## closing off the ones we don't want.
  
  sub _spawn_pumper {
      my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
      my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
  
      _debug "pumper stdin = ",  $stdin_fd  if _debugging_details;
      _debug "pumper stdout = ", $stdout_fd if _debugging_details;
      _inherit $stdin_fd, $stdout_fd, $debug_fd;
      my @I_options = map qq{"-I$_"}, @INC;
  
      my $cmd_line = join(
          " ",
          qq{"$^X"},
          @I_options,
          qw(-MIPC::Run::Win32Pump -e 1 ),
  ## I'm using this clunky way of passing filehandles to the child process
  ## in order to avoid some kind of premature closure of filehandles
  ## problem I was having with VCP's test suite when passing them
  ## via CreateProcess.  All of the ## REMOVE code is stuff I'd like
  ## to be rid of and the ## ADD code is what I'd like to use.
          FdGetOsFHandle($stdin_fd),     ## REMOVE
          FdGetOsFHandle($stdout_fd),    ## REMOVE
          FdGetOsFHandle($debug_fd),     ## REMOVE
          $binmode ? 1 : 0,
          $$, $^T, _debugging_level, qq{"$child_label"},
          @opts
      );
  
      #   open SAVEIN,  "<&STDIN"  or croak "$! saving STDIN";       #### ADD
      #   open SAVEOUT, ">&STDOUT" or croak "$! saving STDOUT";       #### ADD
      #   open SAVEERR, ">&STDERR" or croak "$! saving STDERR";       #### ADD
      #   _dont_inherit \*SAVEIN;       #### ADD
      #   _dont_inherit \*SAVEOUT;       #### ADD
      #   _dont_inherit \*SAVEERR;       #### ADD
      #   open STDIN,  "<&$stdin_fd"  or croak "$! dup2()ing $stdin_fd (pumper's STDIN)";       #### ADD
      #   open STDOUT, ">&$stdout_fd" or croak "$! dup2()ing $stdout_fd (pumper's STDOUT)";       #### ADD
      #   open STDERR, ">&$debug_fd" or croak "$! dup2()ing $debug_fd (pumper's STDERR/debug_fd)";       #### ADD
  
      _debug "pump cmd line: ", $cmd_line if _debugging_details;
  
      my $process;
      Win32::Process::Create(
          $process,
          $^X,
          $cmd_line,
          1,    ## Inherit handles
          NORMAL_PRIORITY_CLASS,
          ".",
      ) or croak "$!: Win32::Process::Create()";
  
      #   open STDIN,  "<&SAVEIN"  or croak "$! restoring STDIN";       #### ADD
      #   open STDOUT, ">&SAVEOUT" or croak "$! restoring STDOUT";       #### ADD
      #   open STDERR, ">&SAVEERR" or croak "$! restoring STDERR";       #### ADD
      #   close SAVEIN             or croak "$! closing SAVEIN";       #### ADD
      #   close SAVEOUT            or croak "$! closing SAVEOUT";       #### ADD
      #   close SAVEERR            or croak "$! closing SAVEERR";       #### ADD
  
      # In case of a sleep right here, need the IPC::Run::_close() treatment.
      IPC::Run::_close fileno($stdin);
      close $stdin;
      IPC::Run::_close fileno($stdout);
      close $stdout;
  
      # Don't close $debug_fd, we need it, as do other pumpers.
  
      # Pause a moment to allow the child to get up and running and emit
      # debug messages.  This does not always work.
      #   select undef, undef, undef, 1 if _debugging_details;
  
      _debug "_spawn_pumper pid = ", $process->GetProcessID
        if _debugging_data;
  }
  
  my $loopback  = inet_aton "127.0.0.1";
  my $tcp_proto = getprotobyname('tcp');
  croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
  
  sub _socket {
      my ($server) = @_;
      $server ||= gensym;
      my $client = gensym;
  
      my $listener = gensym;
      socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
        or croak "$!: socket()";
      setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack( "l", 0 )
        or croak "$!: setsockopt()";
  
      unless ( bind $listener, sockaddr_in( 0, $loopback ) ) {
          croak "Error binding: $!";
      }
  
      my ($port) = sockaddr_in( getsockname($listener) );
  
      _debug "win32 port = $port" if _debugging_details;
  
      listen $listener, my $queue_size = 1
        or croak "$!: listen()";
  
      {
          socket $client, PF_INET, SOCK_STREAM, $tcp_proto
            or croak "$!: socket()";
  
          my $paddr = sockaddr_in( $port, $loopback );
  
          connect $client, $paddr
            or croak "$!: connect()";
  
          croak "$!: accept" unless defined $paddr;
  
          ## The windows "default" is SO_DONTLINGER, which should make
          ## sure all socket data goes through.  I have my doubts based
          ## on experimentation, but nothing prompts me to set SO_LINGER
          ## at this time...
          setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack( "l", 0 )
            or croak "$!: setsockopt()";
      }
  
      {
          _debug "accept()ing on port $port" if _debugging_details;
          my $paddr = accept( $server, $listener );
          croak "$!: accept()" unless defined $paddr;
      }
  
      _debug "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port"
        if _debugging_details;
      return ( $server, $client );
  }
  
  sub _open_socket_pipe {
      my IPC::Run::Win32IO $self = shift;
      my ( $debug_fd, $parent_handle ) = @_;
  
      my $is_send_to_child = $self->dir eq "<";
  
      $self->{CHILD_HANDLE}     = gensym;
      $self->{PUMP_PIPE_HANDLE} = gensym;
  
      (
          $self->{PARENT_HANDLE},
          $self->{PUMP_SOCKET_HANDLE}
      ) = _socket $parent_handle;
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{PARENT_HANDLE}      or die $!;
      binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
  
      _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
        if _debugging_details;
  ##my $buf;
  ##$buf = "write on child end of " . fileno( $self->{WRITE_HANDLE} ) . "\n\n\n\n\n";
  ##POSIX::write(fileno $self->{WRITE_HANDLE}, $buf, length $buf) or warn "$! in syswrite";
  ##$buf = "write on parent end of " . fileno( $self->{CHILD_HANDLE} ) . "\r\n";
  ##POSIX::write(fileno $self->{CHILD_HANDLE},$buf, length $buf) or warn "$! in syswrite";
  ##   $self->{CHILD_HANDLE}->autoflush( 1 );
  ##   $self->{WRITE_HANDLE}->autoflush( 1 );
  
      ## Now fork off a data pump and arrange to return the correct fds.
      if ($is_send_to_child) {
          pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
      else {
          pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{CHILD_HANDLE};
      binmode $self->{PUMP_PIPE_HANDLE};
  
      ## No child should ever see this.
      _dont_inherit $self->{PARENT_HANDLE};
  
      ## We clear the inherit flag so these file descriptors are not inherited.
      ## It'll be dup()ed on to STDIN/STDOUT/STDERR before CreateProcess is
      ## called and *that* fd will be inheritable.
      _dont_inherit $self->{PUMP_SOCKET_HANDLE};
      _dont_inherit $self->{PUMP_PIPE_HANDLE};
      _dont_inherit $self->{CHILD_HANDLE};
  
      ## Need to return $self so the HANDLEs don't get freed.
      ## Return $self, $parent_fd, $child_fd
      my ( $parent_fd, $child_fd ) = (
          fileno $self->{PARENT_HANDLE},
          fileno $self->{CHILD_HANDLE}
      );
  
      ## Both PUMP_..._HANDLEs will be closed, no need to worry about
      ## inheritance.
      _debug "binmode on" if _debugging_data && $self->binmode;
      _spawn_pumper(
          $is_send_to_child
          ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
          : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
          $debug_fd,
          $self->binmode,
          $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
      );
  
      {
          my $foo;
          confess "PARENT_HANDLE no longer open"
            unless POSIX::read( $parent_fd, $foo, 0 );
      }
  
      _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
        if _debugging_details;
  
      $self->{FD}  = $parent_fd;
      $self->{TFD} = $child_fd;
  }
  
  sub _do_open {
      my IPC::Run::Win32IO $self = shift;
  
      if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
          return $self->_send_through_temp_file(@_);
      }
      elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
          return $self->_init_recv_through_temp_file(@_);
      }
      else {
          return $self->_open_socket_pipe(@_);
      }
  }
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32IO

$fatpacked{"IPC/Run/Win32Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PROCESS';
  package IPC::Run::Win32Process;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Process -- deliver nonstandard command lines via IPC::Run.
  
  =head1 SYNOPSIS
  
     use File::Spec ();
     use IPC::Run qw(run);
     use IPC::Run::Win32Process ();
     use Win32 ();
  
     $find_exe = File::Spec->catfile(Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                                     'find.exe');
     run(IPC::Run::Win32Process->new($ENV{COMSPEC}, q{cmd.exe /c echo ""}),
         '|', IPC::Run::Win32Process->new($find_exe, q{find_exe """"""}),
         '>', \$out);
  
  =head1 DESCRIPTION
  
  This class facilitates executing Windows programs that don't use L<standard
  command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>.
  Notable programs having nonstandard rules include F<cmd.exe>, F<cscript.exe>,
  and Cygwin programs called from non-Cygwin programs.  IPC::Run will use the two
  strings, verbatim, as the lpApplicationName and lpCommandLine arguments of
  CreateProcessA().  This furnishes unfiltered control over the child process
  command line.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  
  use overload '""' => sub {
      my ($self) = @_;
      return join(
          '',
          'IPC::Run::Win32Process(',
          $self->{lpApplicationName},
          ', ',
          $self->{lpCommandLine},
          ')'
      );
  };
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  =item new
  
     IPC::Run::Win32Process->new( $lpApplicationName, $lpCommandLine );
     IPC::Run::Win32Process->new( $ENV{COMSPEC}, q{cmd.exe /c echo ""} );
  
  Constructor.
  
  =back
  
  =cut
  
  sub new {
      my ( $class, $lpApplicationName, $lpCommandLine ) = @_;
      $class = ref $class || $class;
  
      croak "missing lpApplicationName" if !defined $lpApplicationName;
      croak "missing lpCommandLine"     if !defined $lpCommandLine;
  
      my IPC::Run::Win32Process $self = bless {}, $class;
      $self->{lpApplicationName} = $lpApplicationName;
      $self->{lpCommandLine}     = $lpCommandLine;
  
      return $self;
  }
  
  1;
IPC_RUN_WIN32PROCESS

$fatpacked{"IPC/Run/Win32Pump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PUMP';
  package IPC::Run::Win32Pump;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Pump - helper processes to shovel data to/from parent, child
  
  =head1 SYNOPSIS
  
  Internal use only; see IPC::Run::Win32IO and best of luck to you.
  
  =head1 DESCRIPTION
  
  See L<IPC::Run::Win32Helper|IPC::Run::Win32Helper> for details.  This
  module is used in subprocesses that are spawned to shovel data to/from
  parent processes from/to their child processes.  Where possible, pumps
  are optimized away.
  
  NOTE: This is not a real module: it's a script in module form, designed
  to be run like
  
     $^X -MIPC::Run::Win32Pumper -e 1 ...
  
  It parses a bunch of command line parameters from IPC::Run::Win32IO.
  
  =cut
  
  use strict;
  use warnings;
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  use Win32API::File qw(
    OsFHandleOpen
  );
  
  my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
  
  BEGIN {
      ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
      ## Rather than letting IPC::Run::Debug export all-0 constants
      ## when not debugging, we do it manually in order to not even
      ## load IPC::Run::Debug.
      if ($debug) {
          eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
            or die $@;
      }
      else {
          eval <<STUBS_END or die $@;
  	 sub _debug {}
  	 sub _debug_init {}
  	 sub _debugging() { 0 }
  	 sub _debugging_data() { 0 }
  	 sub _debugging_details() { 0 }
  	 sub _debugging_gory_details() { 0 }
  	 1;
  STUBS_END
      }
  }
  
  ## For some reason these get created with binmode on.  AAargh, gotta       #### REMOVE
  ## do it by hand below.       #### REMOVE
  if ($debug) {    #### REMOVE
      close STDERR;    #### REMOVE
      OsFHandleOpen( \*STDERR, $debug_fh, "w" )    #### REMOVE
        or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";    #### REMOVE
  }               #### REMOVE
  close STDIN;    #### REMOVE
  OsFHandleOpen( \*STDIN, $stdin_fh, "r" )    #### REMOVE
    or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";    #### REMOVE
  close STDOUT;                                                          #### REMOVE
  OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )                             #### REMOVE
    or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";  #### REMOVE
  
  binmode STDIN;
  binmode STDOUT;
  $| = 1;
  select STDERR;
  $| = 1;
  select STDOUT;
  
  $child_label ||= "pump";
  _debug_init(
      $parent_pid,
      $parent_start_time,
      $debug,
      fileno STDERR,
      $child_label,
  );
  
  _debug "Entered" if _debugging_details;
  
  # No need to close all fds; win32 doesn't seem to pass any on to us.
  $| = 1;
  my $buf;
  my $total_count = 0;
  while (1) {
      my $count = sysread STDIN, $buf, 10_000;
      last unless $count;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars revc: ", $count ), $msg;
      }
      $total_count += $count;
      $buf =~ s/\r//g unless $binmode;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars sent: ", $count ), $msg;
      }
      print $buf;
  }
  
  _debug "Exiting, transferred $total_count chars" if _debugging_details;
  
  ## Perform a graceful socket shutdown.  Windows defaults to SO_DONTLINGER,
  ## which should cause a "graceful shutdown in the background" on sockets.
  ## but that's only true if the process closes the socket manually, it
  ## seems; if the process exits and lets the OS clean up, the OS is not
  ## so kind.  STDOUT is not always a socket, of course, but it won't hurt
  ## to close a pipe and may even help.  With a closed source OS, who
  ## can tell?
  ##
  ## In any case, this close() is one of the main reasons we have helper
  ## processes; if the OS closed socket fds gracefully when an app exits,
  ## we'd just redirect the client directly to what is now the pump end
  ## of the socket.  As it is, however, we need to let the client play with
  ## pipes, which don't have the abort-on-app-exit behavior, and then
  ## adapt to the sockets in the helper processes to allow the parent to
  ## select.
  ##
  ## Possible alternatives / improvements:
  ##
  ## 1) use helper threads instead of processes.  I don't trust perl's threads
  ## as of 5.005 or 5.6 enough (which may be myopic of me).
  ##
  ## 2) figure out if/how to get at WaitForMultipleObjects() with pipe
  ## handles.  May be able to take the Win32 handle and pass it to
  ## Win32::Event::wait_any, dunno.
  ##
  ## 3) Use Inline::C or a hand-tooled XS module to do helper threads.
  ## This would be faster than #1, but would require a ppm distro.
  ##
  close STDOUT;
  close STDERR;
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32PUMP

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2:tw=78
  package Module::Metadata; # git description: v1.000037-8-g92dec6c
  # ABSTRACT: Gather package and POD information from perl module files
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  sub __clean_eval { eval $_[0] }
  use strict;
  use warnings;
  
  our $VERSION = '1.000038';
  
  use Carp qw/croak/;
  use File::Spec;
  BEGIN {
         # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
         eval {
                 require Fcntl; Fcntl->import('SEEK_SET'); 1;
         } or *SEEK_SET = sub { 0 }
  }
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
      Log::Contextual->import('log_info',
        '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
      );
    }
    else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?      # optional version number
    \s*                   # optional whitespace
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $CLASS_REGEXP = qr{  # match a class declaration (core since 5.38)
    ^[\s\{;]*             # intro chars on a line
    class                 # the word 'class'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?      # optional version number
    \s*                   # optional whitespace
    [;\{]                 # semicolon line terminator or block start
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
            if ( defined( $version ) ) {
              if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                $err .= "  $p->{file} ($p->{version})\n";
              }
              else {
                # same version declared multiple times, ignore
              }
            }
            else {
              $file    = $p->{file};
              $version = $p->{version};
            }
          }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep $args{version} eq $_, qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      }
      else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec->abs2rel( $file, $dir );
        my @path = File::Spec->splitdir( $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            }
            else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          }
          else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              $result->{err}
            };
  
          }
          elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
          if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              };
            }
  
          }
          else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
          }
          else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
          }
  
        }
        else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
              $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc decode_pod );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( not $handle ) {
      my $filename = $self->{filename};
      open $handle, '<', $filename
        or croak( "Can't open '$filename': $!" );
  
      $self->_handle_bom($handle, $filename);
    }
    $self->_parse_fh($handle);
  
    @{$self->{packages}} = __uniq(@{$self->{packages}});
  
    unless($self->{module} and length($self->{module})) {
      # CAVEAT (possible TODO): .pmc files not treated the same as .pm
      if ($self->{filename} =~ /\.pm$/) {
        my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
        $f =~ s/\..+$//;
        my @candidates = grep /(^|::)$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # this may be undef
      }
      else {
        # this seems like an atrocious heuristic, albeit marginally better than
        # what was here before. It should be rewritten entirely to be more like
        # "if it's not a .pm file, it's not require()able as a name, therefore
        # name() should be undef."
        if ((grep /main/, @{$self->{packages}})
            or (grep /main/, keys %{$self->{versions}})) {
          $self->{module} = 'main';
        }
        else {
          # TODO: this should maybe default to undef instead
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
      if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      # CAVEAT (possible TODO): .pmc files are not discoverable here
      $testfile .= '.pm';
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile;
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sigil, $variable_name, $package);
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $package ) {
        $package = ($package eq '::') ? 'main' : $package;
        $package =~ s/::$//;
      }
    }
  
    return ( $sigil, $variable_name, $package );
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = tell $fh;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = read $fh, $buf, length $buf;
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    }
    elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    }
    elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = read $fh, $buf, length $buf;
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        binmode( $fh, ":encoding($encoding)" );
      }
    }
    else {
      seek $fh, $pos, SEEK_SET
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @packages, %vers, %pod, @pod );
    my $package = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
    my $encoding = '';
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
          push( @pod, $1 );
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = $1;
        }
        elsif ( $self->{collect_pod} ) {
          if ( $self->{decode_pod} && $line =~ /^=encoding ([\w-]+)/ ) {
            $encoding = $1;
          }
          $pod_data .= "$line\n";
        }
        next;
      }
      elsif ( $is_cut ) {
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
        next;
      }
  
      # Skip after __END__
      next if $in_end;
  
      # Skip comments in code
      next if $line =~ /^\s*#/;
  
      # Would be nice if we could also check $in_string or something too
      if ($line eq '__END__') {
        $in_end++;
        next;
      }
  
      last if $line eq '__DATA__';
  
      # parse $line to see if it's a $VERSION declaration
      my( $version_sigil, $version_fullname, $version_package ) =
        index($line, 'VERSION') >= 1
          ? $self->_parse_version_expression( $line )
          : ();
  
      if ( $line =~ /$PKG_REGEXP/o or $line =~ /$CLASS_REGEXP/ ) {
        $package = $1;
        my $version = $2;
        push( @packages, $package ) unless grep( $package eq $_, @packages );
        $need_vers = defined $version ? 0 : 1;
  
        if ( not exists $vers{$package} and defined $version ){
          # Upgrade to a version object.
          my $dwim_version = eval { _dwim_version($version) };
          croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
            unless defined $dwim_version;  # "0" is OK!
          $vers{$package} = $dwim_version;
        }
      }
  
      # VERSION defined with full package spec, i.e. $Module::VERSION
      elsif ( $version_fullname && $version_package ) {
        # we do NOT save this package in found @packages
        $need_vers = 0 if $version_package eq $package;
  
        unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
          $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        }
      }
  
      # first non-comment line in undeclared package main is VERSION
      elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
        $need_vers = 0;
        my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        $vers{$package} = $v;
        push( @packages, 'main' );
      }
  
      # first non-comment line in undeclared package defines package main
      elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
        $need_vers = 1;
        $vers{main} = '';
        push( @packages, 'main' );
      }
  
      # only keep if this is the first $VERSION seen
      elsif ( $version_fullname && $need_vers ) {
        $need_vers = 0;
        my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
  
        unless ( defined $vers{$package} && length $vers{$package} ) {
          $vers{$package} = $v;
        }
      }
    } # end loop over each line
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    if ( $self->{decode_pod} && $encoding ) {
      require Encode;
      $_ = Encode::decode( $encoding, $_ ) for values %pod;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@packages;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  sub __uniq (@)
  {
      my (%seen, $key);
      grep !$seen{ $key = $_ }++, @_;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $variable_name, $line ) = @_;
  
    # We compile into a local sub because 'use version' would cause
    # compiletime/runtime issues with local()
    $pn++; # everybody gets their own package
    my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        return \$$variable_name if defined \$$variable_name;
        return \$Module::Metadata::_version::p${pn}::$variable_name;
      };
    };
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    my $vsub = __clean_eval($eval);
    # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      $vsub = __clean_eval($eval);
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
  
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
  
    my $result = eval { $vsub->() };
    # FIXME: $eval is not the right thing to print here
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    # FIXME: $eval is not the right thing to print here
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
           exists( $self->{versions}{$mod} ) ) {
          return $self->{versions}{$mod};
      }
      else {
          return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
           exists( $self->{pod}{$sect} ) ) {
          return $self->{pod}{$sect};
      }
      else {
          return undef;
      }
  }
  
  sub is_indexable {
    my ($self, $package) = @_;
  
    my @indexable_packages = grep $_ ne 'main', $self->packages_inside;
  
    # check for specific package, if provided
    return !! grep $_ eq $package, @indexable_packages if $package;
  
    # otherwise, check for any indexable packages at all
    return !! @indexable_packages;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 VERSION
  
  version 1.000038
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 CLASS METHODS
  
  =head2 C<< new_from_file($filename, collect_pod => 1, decode_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  Alternatively, if C<decode_pod> is set, it will decode the collected pod
  sections according to the C<=encoding> declaration.
  
  =head2 C<< new_from_handle($handle, $filename, collect_pod => 1, decode_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs, decode_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> and C<decode_pod> arguments as
  described above, this method accepts a C<inc> argument which is a reference to
  an array of directories to search for the module.  If none are given, the
  default is @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =head2 C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =head2 C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =head2 C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =head1 OBJECT METHODS
  
  =head2 C<< name() >>
  
  Returns the name of the package represented by this module. If there
  is more than one package, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =head2 C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =head2 C<< filename() >>
  
  Returns the absolute path to the file.
  Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
  
  =head2 C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =head2 C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =head2 C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =head2 C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
  
  Available since version 1.000020.
  
  Returns a boolean indicating whether the package (if provided) or any package
  (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
  Note This only checks for valid C<package> declarations, and does not take any
  ownership information into account.
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata>
  (or L<bug-Module-Metadata@rt.cpan.org|mailto:bug-Module-Metadata@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/cpan-workers.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge David Golden Vincent Pit Matt S Trout Chris Nehren Graham Knop Olivier Mengué Tomas Doran Christian Walde Craig A. Berry Tatsuhiko Miyagawa tokuhirom 'BinGOs' Williams Mitchell Steinbrunner Edward Zborowski Gareth Harper James Raspass Jerry D. Hedden Josh Jore Kent Fredric Leon Timmermans Peter Rabbitson Steve Hay
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Vincent Pit <perl@profvince.com>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Tomas Doran <bobtfish@bobtfish.net>
  
  =item *
  
  Christian Walde <walde.christian@googlemail.com>
  
  =item *
  
  Craig A. Berry <cberry@cpan.org>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  tokuhirom <tokuhirom@gmail.com>
  
  =item *
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =item *
  
  David Mitchell <davem@iabyn.com>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  Gareth Harper <gareth@broadbean.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jerry D. Hedden <jdhedden@cpan.org>
  
  =item *
  
  Josh Jore <jjore@cpan.org>
  
  =item *
  
  Kent Fredric <kentnl@cpan.org>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Steve Hay <steve.m.hay@googlemail.com>
  
  =back
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
MODULE_METADATA

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  # Convert POD data to formatted *roff input.
  #
  # This module translates POD documentation into *roff markup using the man
  # macro set, and is intended for converting POD documents written as Unix
  # manual pages to manual pages that can be read by the man(1) command.  It is
  # a replacement for the pod2man command distributed with versions of Perl
  # prior to 5.6.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Man;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Carp qw(carp croak);
  use Pod::Simple ();
  
  # Conditionally import Encode and set $HAS_ENCODE if it is available.  This is
  # required to support building as part of Perl core, since podlators is built
  # before Encode is.
  my $HAS_ENCODE;
  BEGIN {
      $HAS_ENCODE = eval { require Encode };
  }
  
  our @ISA = qw(Pod::Simple);
  our $VERSION = '5.01';
  
  # Ensure that $Pod::Simple::nbsp and $Pod::Simple::shy are available.  Code
  # taken from Pod::Simple 3.32, but was only added in 3.30.
  my ($NBSP, $SHY);
  if ($Pod::Simple::VERSION ge 3.30) {
      $NBSP = $Pod::Simple::nbsp;
      $SHY  = $Pod::Simple::shy;
  } else {
      $NBSP = chr utf8::unicode_to_native(0xA0);
      $SHY  = chr utf8::unicode_to_native(0xAD);
  }
  
  # Import the ASCII constant from Pod::Simple.  This is true iff we're in an
  # ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
  # generally only false for EBCDIC.
  BEGIN { *ASCII = \&Pod::Simple::ASCII }
  
  # Formatting instructions for various types of blocks.  cleanup makes hyphens
  # hard, adds spaces between consecutive underscores, and escapes backslashes.
  # convert translates characters into escapes.  guesswork means to apply the
  # transformations done by the guesswork sub (if enabled).  literal says to
  # protect literal quotes from being turned into UTF-8 quotes.  By default, all
  # transformations are on except literal, but some elements override.
  #
  # DEFAULT specifies the default settings.  All other elements should list only
  # those settings that they are overriding.  Data indicates =for roff blocks,
  # which should be passed along completely verbatim.
  #
  # Formatting inherits negatively, in the sense that if the parent has turned
  # off guesswork, all child elements should leave it off.
  my %FORMATTING = (
      DEFAULT  => { cleanup => 1, convert => 1, guesswork => 1, literal => 0 },
      Data     => { cleanup => 0, convert => 0, guesswork => 0, literal => 0 },
      Verbatim => {                             guesswork => 0, literal => 1 },
      C        => {                             guesswork => 0, literal => 1 },
      X        => { cleanup => 0,               guesswork => 0               },
  );
  
  # Try to map an encoding as understood by Perl Encode to an encoding
  # understood by groff's preconv.  Encode doesn't care about hyphens or
  # capitalization, but preconv does.  The key is the canonicalized Encode
  # encoding, and the value is something preconv might understand.
  #
  # FreeBSD mandoc only understands utf-8 and iso-latin-1 as of 2022-09-24.
  # groff preconv prefers iso-8859-1, but also understands iso-latin-1, so
  # convert ISO-8859-1 to iso-latin-1 for FreeBSD.
  my %ENCODINGS = (
      ascii     => 'us-ascii',
      big5      => 'big5',
      big5eten  => 'big5',
      cp950     => 'big5',
      cp1047    => 'cp1047',
      euccn     => 'gb2312',
      eucjp     => 'euc-jp',
      euckr     => 'euc-kr',
      gb2312    => 'gb2312',
      gb2312raw => 'gb2312',
      iso88591  => 'iso-latin-1',
      iso88592  => 'iso-8859-2',
      iso88595  => 'iso-8859-5',
      iso88597  => 'iso-8859-7',
      iso88599  => 'iso-8859-9',
      iso885913 => 'iso-8859-13',
      iso885915 => 'iso-8859-15',
      koi8r     => 'koi8-r',
      latin1    => 'iso-8859-1',
      usascii   => 'us-ascii',
      utf8      => 'utf-8',
      utf16     => 'utf-16',
      utf16be   => 'utf-16be',
      utf16le   => 'utf-16le',
  );
  
  ##############################################################################
  # Translation tables
  ##############################################################################
  
  # The following table is adapted from Tom Christiansen's pod2man.  It is only
  # used with roff output.  It assumes that the standard preamble has already
  # been printed, since that's what defines all of the accent marks.  We really
  # want to do something better than this when *roff actually supports other
  # character sets itself, since these results are pretty poor.
  #
  # This only works in an ASCII world.  What to do in a non-ASCII world is very
  # unclear, so we just output what we get and hope for the best.
  my %ESCAPES;
  @ESCAPES{0xA0 .. 0xFF} = (
      $NBSP, undef, undef, undef,            undef, undef, undef, undef,
      undef, undef, undef, undef,            undef, $SHY,  undef, undef,
  
      undef, undef, undef, undef,            undef, undef, undef, undef,
      undef, undef, undef, undef,            undef, undef, undef, undef,
  
      "A\\*`",  "A\\*'", "A\\*^", "A\\*~",   "A\\*:", "A\\*o", "\\*(Ae", "C\\*,",
      "E\\*`",  "E\\*'", "E\\*^", "E\\*:",   "I\\*`", "I\\*'", "I\\*^",  "I\\*:",
  
      "\\*(D-", "N\\*~", "O\\*`", "O\\*'",   "O\\*^", "O\\*~", "O\\*:",  undef,
      "O\\*/",  "U\\*`", "U\\*'", "U\\*^",   "U\\*:", "Y\\*'", "\\*(Th", "\\*8",
  
      "a\\*`",  "a\\*'", "a\\*^", "a\\*~",   "a\\*:", "a\\*o", "\\*(ae", "c\\*,",
      "e\\*`",  "e\\*'", "e\\*^", "e\\*:",   "i\\*`", "i\\*'", "i\\*^",  "i\\*:",
  
      "\\*(d-", "n\\*~", "o\\*`", "o\\*'",   "o\\*^", "o\\*~", "o\\*:",  undef,
      "o\\*/" , "u\\*`", "u\\*'", "u\\*^",   "u\\*:", "y\\*'", "\\*(th", "y\\*:",
  ) if ASCII;
  
  ##############################################################################
  # Utility functions
  ##############################################################################
  
  # Quote an argument to a macro.
  #
  # $arg - Intended argument to the macro
  #
  # Returns: $arg suitably escaped and quoted
  sub _quote_macro_argument {
      my ($arg) = @_;
      if (length($arg) > 0 && $arg !~ m{ [\s\"] }xms) {
          return $arg;
      }
      $arg =~ s{ \" }{""}xmsg;
      return qq("$arg");
  }
  
  # Returns whether the given encoding needs a call to Encode::encode.
  sub _needs_encode {
      my ($encoding) = @_;
      return $encoding ne 'roff' && $encoding ne 'groff';
  }
  
  ##############################################################################
  # Object initialization
  ##############################################################################
  
  # Initialize the object and set various Pod::Simple options that we need.
  # Here, we also process any additional options passed to the constructor or
  # set up defaults if none were given.  Note that all internal object keys are
  # in all-caps, reserving all lower-case object keys for Pod::Simple and user
  # arguments.
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new;
  
      # Tell Pod::Simple to keep whitespace whenever possible.
      if (my $preserve_whitespace = $self->can ('preserve_whitespace')) {
          $self->$preserve_whitespace (1);
      } else {
          $self->fullstop_space_harden (1);
      }
  
      # The =for and =begin targets that we accept.
      $self->accept_targets (qw/man MAN roff ROFF/);
  
      # Ensure that contiguous blocks of code are merged together.  Otherwise,
      # some of the guesswork heuristics don't work right.
      $self->merge_text (1);
  
      # Pod::Simple doesn't do anything useful with our arguments, but we want
      # to put them in our object as hash keys and values.  This could cause
      # problems if we ever clash with Pod::Simple's own internal class
      # variables.
      my %opts = @_;
      my @opts = map { ("opt_$_", $opts{$_}) } keys %opts;
      %$self = (%$self, @opts);
  
      # Pod::Simple uses encoding internally, so we need to store it as
      # ENCODING.  Set the default to UTF-8 if not specified.
      #
      # Degrade to the old roff encoding if Encode is not available.
      #
      # Suppress the warning message when PERL_CORE is set, indicating this is
      # running as part of the core Perl build.  Perl builds podlators (and all
      # pure Perl modules) before Encode and other XS modules, so Encode won't
      # yet be available.  Rely on the Perl core build to generate man pages
      # later, after all the modules are available, so that UTF-8 handling will
      # be correct.
      my %options = @_;
      if (defined $self->{opt_encoding}) {
          $$self{ENCODING} = $self->{opt_encoding};
      } elsif (ASCII) {
          $$self{ENCODING} = 'UTF-8';
      } else {
          $$self{ENCODING} = 'groff';
      }
      if (_needs_encode($$self{ENCODING}) && !$HAS_ENCODE) {
          if (!$ENV{PERL_CORE}) {
              carp ('encoding requested but Encode module not available,'
                      . ' falling back to groff escapes');
          }
          $$self{ENCODING} = 'groff';
      }
  
      # Send errors to stderr if requested.
      if ($self->{opt_stderr} and not $self->{opt_errors}) {
          $self->{opt_errors} = 'stderr';
      }
      delete $self->{opt_stderr};
  
      # Validate the errors parameter and act on it.
      $self->{opt_errors} //= 'pod';
      if ($self->{opt_errors} eq 'stderr' || $self->{opt_errors} eq 'die') {
          $self->no_errata_section (1);
          $self->complain_stderr (1);
          if ($self->{opt_errors} eq 'die') {
              $self->{complain_die} = 1;
          }
      } elsif ($self->{opt_errors} eq 'pod') {
          $self->no_errata_section (0);
          $self->complain_stderr (0);
      } elsif ($self->{opt_errors} eq 'none') {
          $self->no_errata_section (1);
          $self->no_whining (1);
      } else {
          croak (qq(Invalid errors setting: "$self->{opt_errors}"));
      }
      delete $self->{opt_errors};
  
      # Initialize various other internal constants based on our arguments.
      $self->init_fonts;
      $self->init_quotes;
      $self->init_page;
  
      # Configure guesswork based on options.
      my $guesswork = $self->{opt_guesswork} || q{};
      my %guesswork = map { $_ => 1 } split(m{,}xms, $guesswork);
      if (!%guesswork || $guesswork{all}) {
          #<<<
          $$self{GUESSWORK} = {
              functions => 1,
              manref    => 1,
              quoting   => 1,
              variables => 1,
          };
          #>>>
      } elsif ($guesswork{none}) {
          $$self{GUESSWORK} = {};
      } else {
          $$self{GUESSWORK} = {%guesswork};
      }
  
      return $self;
  }
  
  # Translate a font string into an escape.
  sub toescape { (length ($_[0]) > 1 ? '\f(' : '\f') . $_[0] }
  
  # Determine which fonts the user wishes to use and store them in the object.
  # Regular, italic, bold, and bold-italic are constants, but the fixed width
  # fonts may be set by the user.  Sets the internal hash key FONTS which is
  # used to map our internal font escapes to actual *roff sequences later.
  sub init_fonts {
      my ($self) = @_;
  
      # Figure out the fixed-width font.  If user-supplied, make sure that they
      # are the right length.
      for (qw(fixed fixedbold fixeditalic fixedbolditalic)) {
          my $font = $self->{"opt_$_"};
          if (defined($font) && (length($font) < 1 || length($font) > 2)) {
              croak(qq(roff font should be 1 or 2 chars, not "$font"));
          }
      }
  
      # Set the default fonts.  We can't be sure portably across different
      # implementations what fixed bold-italic may be called (if it's even
      # available), so default to just bold.
      #<<<
      $self->{opt_fixed}           ||= 'CW';
      $self->{opt_fixedbold}       ||= 'CB';
      $self->{opt_fixeditalic}     ||= 'CI';
      $self->{opt_fixedbolditalic} ||= 'CB';
      #>>>
  
      # Set up a table of font escapes.  First number is fixed-width, second is
      # bold, third is italic.
      $self->{FONTS} = {
          '000' => '\fR',
          '001' => '\fI',
          '010' => '\fB',
          '011' => '\f(BI',
          '100' => toescape($self->{opt_fixed}),
          '101' => toescape($self->{opt_fixeditalic}),
          '110' => toescape($self->{opt_fixedbold}),
          '111' => toescape($self->{opt_fixedbolditalic}),
      };
  
      # Precalculate a regex that matches all fixed-width fonts, which will be
      # used later by switchquotes.
      my @fixedpat = map { quotemeta($self->{FONTS}{$_}) } qw(100 101 110 111);
      my $fixedpat = join('|', @fixedpat);
      $self->{FIXEDPAT} = qr{ $fixedpat }xms;
  }
  
  # Initialize the quotes that we'll be using for C<> text.  This requires some
  # special handling, both to parse the user parameters if given and to make
  # sure that the quotes will be safe against *roff.  Sets the internal hash
  # keys LQUOTE and RQUOTE.
  sub init_quotes {
      my ($self) = (@_);
  
      # Handle the quotes option first, which sets both quotes at once.
      $self->{opt_quotes} ||= '"';
      if ($self->{opt_quotes} eq 'none') {
          $$self{LQUOTE} = $$self{RQUOTE} = '';
      } elsif (length ($self->{opt_quotes}) == 1) {
          $$self{LQUOTE} = $$self{RQUOTE} = $self->{opt_quotes};
      } elsif (length ($self->{opt_quotes}) % 2 == 0) {
          my $length = length ($self->{opt_quotes}) / 2;
          $$self{LQUOTE} = substr ($self->{opt_quotes}, 0, $length);
          $$self{RQUOTE} = substr ($self->{opt_quotes}, $length);
      } else {
          croak(qq(Invalid quote specification "$self->{opt_quotes}"))
      }
  
      # Now handle the lquote and rquote options.
      if (defined($self->{opt_lquote})) {
          $self->{opt_lquote} = q{} if $self->{opt_lquote} eq 'none';
          $$self{LQUOTE} = $self->{opt_lquote};
      }
      if (defined $self->{opt_rquote}) {
          $self->{opt_rquote} = q{} if $self->{opt_rquote} eq 'none';
          $$self{RQUOTE} = $self->{opt_rquote};
      }
  }
  
  # Initialize the page title information and indentation from our arguments.
  sub init_page {
      my ($self) = @_;
  
      # Get the version from the running Perl.
      my @version = ($] =~ /^(\d+)\.(\d{3})(\d+)$/);
      for (@version) { $_ += 0 }
      my $version = join ('.', @version);
  
      # Set the defaults for page titles and indentation if the user didn't
      # override anything.
      $self->{opt_center}  //= 'User Contributed Perl Documentation';
      $self->{opt_release} //= 'perl v' . $version;
      $self->{opt_indent}  //= 4;
  }
  
  ##############################################################################
  # Core parsing
  ##############################################################################
  
  # This is the glue that connects the code below with Pod::Simple itself.  The
  # goal is to convert the event stream coming from the POD parser into method
  # calls to handlers once the complete content of a tag has been seen.  Each
  # paragraph or POD command will have textual content associated with it, and
  # as soon as all of a paragraph or POD command has been seen, that content
  # will be passed in to the corresponding method for handling that type of
  # object.  The exceptions are handlers for lists, which have opening tag
  # handlers and closing tag handlers that will be called right away.
  #
  # The internal hash key PENDING is used to store the contents of a tag until
  # all of it has been seen.  It holds a stack of open tags, each one
  # represented by a tuple of the attributes hash for the tag, formatting
  # options for the tag (which are inherited), and the contents of the tag.
  
  # Add a block of text to the contents of the current node, formatting it
  # according to the current formatting instructions as we do.
  sub _handle_text {
      my ($self, $text) = @_;
      my $tag = $$self{PENDING}[-1];
      $$tag[2] .= $self->format_text ($$tag[1], $text);
  }
  
  # Given an element name, get the corresponding method name.
  sub method_for_element {
      my ($self, $element) = @_;
      $element =~ tr/A-Z-/a-z_/;
      $element =~ tr/_a-z0-9//cd;
      return $element;
  }
  
  # Handle the start of a new element.  If cmd_element is defined, assume that
  # we need to collect the entire tree for this element before passing it to the
  # element method, and create a new tree into which we'll collect blocks of
  # text and nested elements.  Otherwise, if start_element is defined, call it.
  sub _handle_element_start {
      my ($self, $element, $attrs) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, we need to accumulate the contents of the
      # tag before calling it.  Turn off IN_NAME for any command other than
      # <Para> and the formatting codes so that IN_NAME isn't still set for the
      # first heading after the NAME heading.
      if ($self->can ("cmd_$method")) {
          $$self{IN_NAME} = 0 if ($element ne 'Para' && length ($element) > 1);
  
          # How we're going to format embedded text blocks depends on the tag
          # and also depends on our parent tags.  Thankfully, inside tags that
          # turn off guesswork and reformatting, nothing else can turn it back
          # on, so this can be strictly inherited.
          my $formatting = {
              %{ $$self{PENDING}[-1][1] || $FORMATTING{DEFAULT} },
              %{ $FORMATTING{$element} || {} },
          };
          push (@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
      } elsif (my $start_method = $self->can ("start_$method")) {
          $self->$start_method ($attrs, '');
      }
  }
  
  # Handle the end of an element.  If we had a cmd_ method for this element,
  # this is where we pass along the tree that we built.  Otherwise, if we have
  # an end_ method for the element, call that.
  sub _handle_element_end {
      my ($self, $element) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, pull off the pending text and pass it to
      # the handler along with the saved attribute hash.
      if (my $cmd_method = $self->can ("cmd_$method")) {
          my $tag = pop @{ $$self{PENDING} };
          my $text = $self->$cmd_method ($$tag[0], $$tag[2]);
          if (defined $text) {
              if (@{ $$self{PENDING} } > 1) {
                  $$self{PENDING}[-1][2] .= $text;
              } else {
                  $self->output ($text);
              }
          }
      } elsif (my $end_method = $self->can ("end_$method")) {
          $self->$end_method ();
      }
  }
  
  ##############################################################################
  # General formatting
  ##############################################################################
  
  # Format a text block.  Takes a hash of formatting options and the text to
  # format.  Currently, the only formatting options are guesswork, cleanup, and
  # convert, all of which are boolean.
  sub format_text {
      my ($self, $options, $text) = @_;
      my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
      my $cleanup = $$options{cleanup};
      my $convert = $$options{convert};
      my $literal = $$options{literal};
  
      # Cleanup just tidies up a few things, telling *roff that the hyphens are
      # hard, putting a bit of space between consecutive underscores, escaping
      # backslashes, and converting zero-width spaces to zero-width break
      # points.
      if ($cleanup) {
          $text =~ s/\\/\\e/g;
          $text =~ s/-/\\-/g;
          $text =~ s/_(?=_)/_\\|/g;
          $text =~ s/\x{200B}/\\:/g;
      }
  
      # Except in <Data> blocks, if groff or roff encoding is requested and
      # we're in an ASCII environment, do the encoding.  For EBCDIC, we just
      # write what we get and hope for the best.  Leave non-breaking spaces and
      # soft hyphens alone; we'll convert those at the last minute.
      if ($convert) {
          if (ASCII) {
              if ($$self{ENCODING} eq 'groff') {
                  $text =~ s{ ([^\x00-\x7F\xA0\xAD]) }{
                      '\\[u' . sprintf('%04X', ord($1)) . ']'
                  }xmsge;
              } elsif ($$self{ENCODING} eq 'roff') {
                  $text =~ s/([^\x00-\x7F\xA0\xAD])/$ESCAPES{ord ($1)} || "X"/eg;
              }
          }
      }
  
      # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
      # but don't mess up accent escapes.
      if ($literal) {
          $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
          $text =~ s/(?<!\\\*)\`/\\\`/g;
      }
  
      # If guesswork is is viable for this block, do that.
      if ($guesswork) {
          $text = $self->guesswork ($text);
      }
  
      return $text;
  }
  
  # Handles C<> text, deciding whether to put \*C` around it or not.  This is a
  # whole bunch of messy heuristics to try to avoid overquoting, originally from
  # Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
  sub quote_literal {
      my $self = shift;
      local $_ = shift;
  
      # If in NAME section, just return an ASCII quoted string to avoid
      # confusing tools like whatis.
      if ($$self{IN_NAME}) {
          return $self->{LQUOTE} . $_ . $self->{RQUOTE};
      }
  
      # A regex that matches the portion of a variable reference that's the
      # array or hash index, separated out just because we want to use it in
      # several places in the following regex.
      my $index = '(?: \[[^]]+\] | \{[^}]+\} )?';
  
      # Check for things that we don't want to quote, and if we find any of
      # them, return the string with just a font change and no quoting.
      #
      # Traditionally, Pod::Man has not quoted Perl variables, functions,
      # numbers, or hex constants, but this is not always desirable.  Make this
      # optional on the quoting guesswork flag.
      my $extra = qr{(?!)}xms;    # never matches
      if ($$self{GUESSWORK}{quoting}) {
          $extra = qr{
               \$+ [\#^]? \S $index                    # special ($^F, $")
             | [\$\@%&*]+ \#? [:\'\w]+ $index          # plain var or func
             | [\$\@%&*]* [:\'\w]+
               (?: \\-> )? \(\s*[^\s,\)]*\s*\)         # 0/1-arg func call
             | (?: [+] || \\- )? ( \d[\d.]* | \.\d+ )
               (?: [eE] (?: [+] || \\- )? \d+ )?       # a number
             | 0x [a-fA-F\d]+                          # a hex constant
           }xms;
      }
      m{
        ^\s*
        (?:
           ( [\'\"] ) .* \1                    # already quoted
         | \\\*\(Aq .* \\\*\(Aq                # quoted and escaped
         | \\?\` .* ( \' | \\?\` | \\\*\(Aq )  # `quoted' or `quoted`
         | $extra
        )
        \s*\z
       }xms and return '\f(FS' . $_ . '\f(FE';
  
      # If we didn't return, go ahead and quote the text.
      return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
  }
  
  # Takes a text block to perform guesswork on.  Returns the text block with
  # formatting codes added.  This is the code that marks up various Perl
  # constructs and things commonly used in man pages without requiring the user
  # to add any explicit markup, and is applied to all non-literal text.  Note
  # that the inserted font sequences must be treated later with mapfonts.
  #
  # This method is very fragile, both in the regular expressions it uses and in
  # the ordering of those modifications.  Care and testing is required when
  # modifying it.
  sub guesswork {
      my $self = shift;
      local $_ = shift;
  
      # By the time we reach this point, all hyphens will be escaped by adding a
      # backslash.  We want to undo that escaping if they're part of regular
      # words and there's only a single dash, since that's a real hyphen that
      # *roff gets to consider a possible break point.  Make sure that a dash
      # after the first character of a word stays non-breaking, however.
      #
      # Note that this is not user-controllable; we pretty much have to do this
      # transformation or *roff will mangle the output in unacceptable ways.
      s{
          ( (?:\G|^|\s|$NBSP) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|$NBSP|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;
  
      # Embolden functions in the form func(), including functions that are in
      # all capitals, but don't embolden if there's anything inside the parens.
      # The function must start with an alphabetic character or underscore and
      # then consist of word characters or colons.
      if ($$self{GUESSWORK}{functions}) {
          s{
              (?<! \\ )
              \b
              ( [A-Za-z_] [:\w]+ \(\) )
          } {
              '\f(BS' . $1 . '\f(BE'
          }egx;
      }
  
      # Change references to manual pages to put the page name in bold but
      # the number in the regular font, with a thin space between the name and
      # the number.  Only recognize func(n) where func starts with an alphabetic
      # character or underscore and contains only word characters, periods (for
      # configuration file man pages), or colons, and n is a single digit,
      # optionally followed by some number of lowercase letters.  Note that this
      # does not recognize man page references like perl(l) or socket(3SOCKET).
      if ($$self{GUESSWORK}{manref}) {
          s{
              \b
              (?<! \\ )                                   # rule out \e0(1)
              ( [A-Za-z_] (?:[.:\w] | \\-)+ )
              ( \( \d [a-z]* \) )
          } {
              '\f(BS' . $1 . '\f(BE\|' . $2
          }egx;
      }
  
      # Convert simple Perl variable references to a fixed-width font.  Be
      # careful not to convert functions, though; there are too many subtleties
      # with them to want to perform this transformation.
      if ($$self{GUESSWORK}{variables}) {
          s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx;
      }
  
      # Done.
      return $_;
  }
  
  ##############################################################################
  # Output
  ##############################################################################
  
  # When building up the *roff code, we don't use real *roff fonts.  Instead, we
  # embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
  # F, S stands for start, and E stands for end.  This method turns these into
  # the right start and end codes.
  #
  # We add this level of complexity because the old pod2man didn't get code like
  # B<< someI<thing> else>> right.  After I<> it switched back to normal text
  # rather than bold.  We take care of this by using variables that state
  # whether bold, italic, or fixed are turned on as a combined pointer to our
  # current font sequence, and set each to the number of current nestings of
  # start tags for that font.
  #
  # The base font must be either \fP or \fR.  \fP changes to the previous font,
  # but only one previous font is kept.  Unfortunately, there is a bug in
  # Solaris 2.6 nroff (not present in GNU groff) where the sequence
  # \fB\fP\f(CW\fP leaves the font set to B rather than R, presumably because
  # \f(CW doesn't actually do a font change.  Because of this, we prefer to use
  # \fR where possible.
  #
  # Unfortunately, this isn't possible for arguments to heading macros, since
  # there we don't know what the outside level font is.  In that case, arrange
  # things so that the outside font is always the "previous" font and end with
  # \fP instead of \fR.  Idea from Zack Weinberg.
  #
  # This function used to be much simpler outside of macro arguments because it
  # went directly from \fB to \f(CW and relied on \f(CW clearing bold since it
  # wasn't \f(CB.  Unfortunately, while this works for mandoc, this is not how
  # groff works; \fBfoo\f(CWbar still prints bar in bold.  Therefore, we force
  # the font back to the base font before each font change.
  sub mapfonts {
      my ($self, $text, $base) = @_;
  
      # The closure used to process each font escape, expected to be called from
      # the right-hand side of an s/// expression.
      my ($fixed, $bold, $italic) = (0, 0, 0);
      my %magic = (F => \$fixed, B => \$bold, I => \$italic);
      my $last = '\fR';
      my $process = sub {
          my ($style, $start_stop) = @_;
          my $sequence = ($last ne '\fR') ? $base : q{};
          ${ $magic{$style} } += ($start_stop eq 'S') ? 1 : -1;
          my $f = $self->{FONTS}{($fixed && 1) . ($bold && 1) . ($italic && 1)};
          return q{} if ($f eq $last);
          if ($f ne '\fR') {
              $sequence .= $f;
          }
          $last = $f;
          return $sequence;
      };
  
      # Now, do the actual work.
      $text =~ s{ \\f\((.)(.) }{$process->($1, $2)}xmsge;
  
      # We can do a bit of cleanup by collapsing sequences like \fR\fB\fR\fI
      # into just \fI.
      $text =~ s{ (?: \\fR )? (?: \\f (.|\(..) \\fR )+ }{\\fR}xms;
  
      return $text;
  }
  
  # Given a command and a single argument that may or may not contain double
  # quotes and fixed-width text, handle double-quote formatting for it.  If
  # there is no fixed-width text, just return the command followed by the
  # argument with proper quoting.  If there is fixed-width text, work around a
  # Solaris nroff bug with fixed-width fonts by converting fixed-width to
  # regular fonts (nroff sees no difference).
  sub switchquotes {
      my ($self, $command, $text, $extra) = @_;
  
      # Separate troff from nroff if there are any fixed-width fonts in use to
      # work around problems with Solaris nroff.
      if ($text =~ $self->{FIXEDPAT}) {
          my $nroff = $text;
          my $troff = $text;
  
          # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
          # to Roman rather than the actual previous font when used in headings.
          # troff output may still be broken, but at least we can fix nroff by
          # just switching the font changes to the non-fixed versions.
          my $font_end = qr{ (?: \\f[PR] | \Q$self->{FONTS}{100}\E ) }xms;
          $nroff =~ s{\Q$self->{FONTS}{100}\E(.*?)\\f([PR])}{$1}xmsg;
          $nroff =~ s{\Q$self->{FONTS}{101}\E}{\\fI}xmsg;
          $nroff =~ s{\Q$self->{FONTS}{110}\E}{\\fB}xmsg;
          $nroff =~ s{\Q$self->{FONTS}{111}\E}{\\f\(BI}xmsg;
  
          # We have to deal with \*C` and \*C', which are used to add the quotes
          # around C<> text, since they may expand to " and if they do this
          # confuses the .SH macros and the like no end.  Expand them ourselves.
          my $c_is_quote = index("$self->{LQUOTE}$self->{RQUOTE}", qq(\")) != -1;
          if ($c_is_quote && $text =~ m{ \\[*]\(C[\'\`] }xms) {
              $nroff =~ s{ \\[*]\(C\` }{$self->{LQUOTE}}xmsg;
              $nroff =~ s{ \\[*]\(C\' }{$self->{RQUOTE}}xmsg;
              $troff =~ s{ \\[*]\(C[\'\`] }{}xmsg;
          }
  
          # Now finally output the command.  Bother with .ie only if the nroff
          # and troff output aren't the same.
          $nroff = _quote_macro_argument($nroff) . ($extra ? " $extra" : '');
          $troff = _quote_macro_argument($troff) . ($extra ? " $extra" : '');
          if ($nroff ne $troff) {
              return ".ie n $command $nroff\n.el $command $troff\n";
          } else {
              return "$command $nroff\n";
          }
      } else {
          $text = _quote_macro_argument($text) . ($extra ? " $extra" : '');
          return "$command $text\n";
      }
  }
  
  # Protect leading quotes and periods against interpretation as commands.  Also
  # protect anything starting with a backslash, since it could expand or hide
  # something that *roff would interpret as a command.  This is overkill, but
  # it's much simpler than trying to parse *roff here.
  sub protect {
      my ($self, $text) = @_;
      $text =~ s/^([.\'\\])/\\&$1/mg;
      return $text;
  }
  
  # Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
  # level the situation.  This function is needed since in *roff one has to
  # create vertical whitespace after paragraphs and between some things, but
  # other macros create their own whitespace.  Also close out a sequence of
  # repeated =items, since calling makespace means we're about to begin the item
  # body.
  sub makespace {
      my ($self) = @_;
      $self->output (".PD\n") if $$self{ITEMS} > 1;
      $$self{ITEMS} = 0;
      $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
          if $$self{NEEDSPACE};
  }
  
  # Output any pending index entries, and optionally an index entry given as an
  # argument.  Support multiple index entries in X<> separated by slashes, and
  # strip special escapes from index entries.
  sub outindex {
      my ($self, $section, $index) = @_;
      my @entries = map { split m%\s*/\s*% } @{ $$self{INDEX} };
      return unless ($section || @entries);
  
      # We're about to output all pending entries, so clear our pending queue.
      $$self{INDEX} = [];
  
      # Build the output.  Regular index entries are marked Xref, and headings
      # pass in their own section.  Undo some *roff formatting on headings.
      my @output;
      if (@entries) {
          push @output, [ 'Xref', join (' ', @entries) ];
      }
      if ($section) {
          $index =~ s/\\-/-/g;
          $index =~ s/\\(?:s-?\d|.\(..|.)//g;
          push @output, [ $section, $index ];
      }
  
      # Print out the .IX commands.
      for (@output) {
          my ($type, $entry) = @$_;
          $entry =~ s/\s+/ /g;
          $entry =~ s/\"/\"\"/g;
          $entry =~ s/\\/\\\\/g;
          $self->output (".IX $type " . '"' . $entry . '"' . "\n");
      }
  }
  
  # Output some text, without any additional changes.
  sub output {
      my ($self, @text) = @_;
      my $text = join('', @text);
      $text =~ s{$NBSP}{\\ }g;
      $text =~ s{$SHY}{\\%}g;
  
      if ($$self{ENCODE} && _needs_encode($$self{ENCODING})) {
          my $check = sub {
              my ($char) = @_;
              my $display = '"\x{' . hex($char) . '}"';
              my $error = "$display does not map to $$self{ENCODING}";
              $self->whine ($self->line_count(), $error);
              return Encode::encode ($$self{ENCODING}, chr($char));
          };
          my $output = Encode::encode ($$self{ENCODING}, $text, $check);
          print { $$self{output_fh} } $output;
      } else {
          print { $$self{output_fh} } $text;
      }
  }
  
  ##############################################################################
  # Document initialization
  ##############################################################################
  
  # Handle the start of the document.  Here we handle empty documents, as well
  # as setting up our basic macros in a preamble and building the page title.
  sub start_document {
      my ($self, $attrs) = @_;
      if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
          $$self{CONTENTLESS} = 1;
      } else {
          delete $$self{CONTENTLESS};
      }
  
      # When an encoding is requested, check whether our output file handle
      # already has a PerlIO encoding layer set.  If it does not, we'll need to
      # encode our output before printing it (handled in the output() sub).
      # Wrap the check in an eval to handle versions of Perl without PerlIO.
      #
      # PerlIO::get_layers still requires its argument be a glob, so coerce the
      # file handle to a glob.
      $$self{ENCODE} = 0;
      if ($$self{ENCODING}) {
          $$self{ENCODE} = 1;
          eval {
              my @options = (output => 1, details => 1);
              my @layers = PerlIO::get_layers (*{$$self{output_fh}}, @options);
              if ($layers[-1] && ($layers[-1] & PerlIO::F_UTF8 ())) {
                  $$self{ENCODE} = 0;
              }
          }
      }
  
      # Determine information for the preamble and then output it unless the
      # document was content-free.
      if (!$$self{CONTENTLESS}) {
          my ($name, $section);
          if (defined $self->{opt_name}) {
              $name = $self->{opt_name};
              $section = $self->{opt_section} || 1;
          } else {
              ($name, $section) = $self->devise_title;
          }
          my $date = $self->{opt_date} // $self->devise_date();
          $self->preamble ($name, $section, $date)
              unless $self->bare_output;
      }
  
      # Initialize a few per-document variables.
      $$self{INDENT}    = 0;      # Current indentation level.
      $$self{INDENTS}   = [];     # Stack of indentations.
      $$self{INDEX}     = [];     # Index keys waiting to be printed.
      $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
      $$self{ITEMS}     = 0;      # The number of consecutive =items.
      $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
      $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
      $$self{SHIFTS}    = [];     # Stack of .RS shifts.
      $$self{PENDING}   = [[]];   # Pending output.
  }
  
  # Handle the end of the document.  This handles dying on POD errors, since
  # Pod::Parser currently doesn't.  Otherwise, does nothing but print out a
  # final comment at the end of the document under debugging.
  sub end_document {
      my ($self) = @_;
      if ($$self{complain_die} && $self->errors_seen) {
          croak ("POD document had syntax errors");
      }
      return if $self->bare_output;
      return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
  }
  
  # Try to figure out the name and section from the file name and return them as
  # a list, returning an empty name and section 1 if we can't find any better
  # information.  Uses File::Basename and File::Spec as necessary.
  sub devise_title {
      my ($self) = @_;
      my $name = $self->source_filename || '';
      my $section = $self->{opt_section} || 1;
      $section = 3 if (!$self->{opt_section} && $name =~ /\.pm\z/i);
      $name =~ s/\.p(od|[lm])\z//i;
  
      # If Pod::Parser gave us an IO::File reference as the source file name,
      # convert that to the empty string as well.  Then, if we don't have a
      # valid name, convert it to STDIN.
      #
      # In podlators 4.00 through 4.07, this also produced a warning, but that
      # was surprising to a lot of programs that had expected to be able to pipe
      # POD through pod2man without specifying the name.  In the name of
      # backward compatibility, just quietly set STDIN as the page title.
      if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i) {
          $name = '';
      }
      if ($name eq '') {
          $name = 'STDIN';
      }
  
      # If the section isn't 3, then the name defaults to just the basename of
      # the file.
      if ($section !~ /^3/) {
          require File::Basename;
          $name = uc File::Basename::basename ($name);
      } else {
          require File::Spec;
          my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
  
          # Otherwise, assume we're dealing with a module.  We want to figure
          # out the full module name from the path to the file, but we don't
          # want to include too much of the path into the module name.  Lose
          # anything up to the first of:
          #
          #     */lib/*perl*/         standard or site_perl module
          #     */*perl*/lib/         from -Dprefix=/opt/perl
          #     */*perl*/             random module hierarchy
          #
          # Also strip off a leading site, site_perl, or vendor_perl component,
          # any OS-specific component, and any version number component, and
          # strip off an initial component of "lib" or "blib/lib" since that's
          # what ExtUtils::MakeMaker creates.
          #
          # splitdir requires at least File::Spec 0.8.
          my @dirs = File::Spec->splitdir ($dirs);
          if (@dirs) {
              my $cut = 0;
              my $i;
              for ($i = 0; $i < @dirs; $i++) {
                  if ($dirs[$i] =~ /perl/) {
                      $cut = $i + 1;
                      $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                      last;
                  }
              }
              if ($cut > 0) {
                  splice (@dirs, 0, $cut);
                  shift @dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
                  shift @dirs if ($dirs[0] =~ /^[\d.]+$/);
                  shift @dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
              }
              shift @dirs if $dirs[0] eq 'lib';
              splice (@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');
          }
  
          # Remove empty directories when building the module name; they
          # occur too easily on Unix by doubling slashes.
          $name = join ('::', (grep { $_ ? $_ : () } @dirs), $file);
      }
      return ($name, $section);
  }
  
  # Determine the modification date and return that, properly formatted in ISO
  # format.
  #
  # If POD_MAN_DATE is set, that overrides anything else.  This can be used for
  # reproducible generation of the same file even if the input file timestamps
  # are unpredictable or the POD comes from standard input.
  #
  # Otherwise, if SOURCE_DATE_EPOCH is set and can be parsed as seconds since
  # the UNIX epoch, base the timestamp on that.  See
  # <https://reproducible-builds.org/specs/source-date-epoch/>
  #
  # Otherwise, use the modification date of the input if we can stat it.  Be
  # aware that Pod::Simple returns the stringification of the file handle as
  # source_filename for input from a file handle, so we'll stat some random ref
  # string in that case.  If that fails, instead use the current time.
  #
  # $self - Pod::Man object, used to get the source file
  #
  # Returns: YYYY-MM-DD date suitable for the left-hand footer
  sub devise_date {
      my ($self) = @_;
  
      # If POD_MAN_DATE is set, always use it.
      if (defined($ENV{POD_MAN_DATE})) {
          return $ENV{POD_MAN_DATE};
      }
  
      # If SOURCE_DATE_EPOCH is set and can be parsed, use that.
      my $time;
      if (defined($ENV{SOURCE_DATE_EPOCH}) && $ENV{SOURCE_DATE_EPOCH} !~ /\D/) {
          $time = $ENV{SOURCE_DATE_EPOCH};
      }
  
      # Otherwise, get the input filename and try to stat it.  If that fails,
      # use the current time.
      if (!defined $time) {
          my $input = $self->source_filename;
          if ($input) {
              $time = (stat($input))[9] || time();
          } else {
              $time = time();
          }
      }
  
      # Can't use POSIX::strftime(), which uses Fcntl, because MakeMaker uses
      # this and it has to work in the core which can't load dynamic libraries.
      # Use gmtime instead of localtime so that the generated man page does not
      # depend on the local time zone setting and is more reproducible
      my ($year, $month, $day) = (gmtime($time))[5,4,3];
      return sprintf("%04d-%02d-%02d", $year + 1900, $month + 1, $day);
  }
  
  # Print out the preamble and the title.  The meaning of the arguments to .TH
  # unfortunately vary by system; some systems consider the fourth argument to
  # be a "source" and others use it as a version number.  Generally it's just
  # presented as the left-side footer, though, so it doesn't matter too much if
  # a particular system gives it another interpretation.
  #
  # The order of date and release used to be reversed in older versions of this
  # module, but this order is correct for both Solaris and Linux.
  sub preamble {
      my ($self, $name, $section, $date) = @_;
      my $preamble = $self->preamble_template();
  
      # groff's preconv script will use this line to correctly determine the
      # input encoding if the encoding is one of the ones it recognizes.  It
      # must be the first or second line.
      #
      # If the output encoding is some version of Unicode, we could also add a
      # Unicode Byte Order Mark to the start of the file, but the BOM is now
      # deprecated and I am concerned that may break a *roff implementation that
      # might otherwise cope with Unicode.  Revisit this if someone files a bug
      # report about it.
      if (_needs_encode($$self{ENCODING})) {
          my $normalized = lc($$self{ENCODING});
          $normalized =~ s{-}{}g;
          my $coding = $ENCODINGS{$normalized} || lc($$self{ENCODING});
          if ($coding ne 'us-ascii') {
              $self->output(qq{.\\\" -*- mode: troff; coding: $coding -*-\n});
          }
      }
  
      # Substitute into the preamble the configuration options.  Because it's
      # used as the argument to defining a string, any leading double quote (but
      # no other double quotes) in LQUOTE and RQUOTE has to be doubled.
      $preamble =~ s{ [@] CFONT [@] }{$self->{opt_fixed}}xms;
      my $lquote = $self->{LQUOTE};
      my $rquote = $self->{RQUOTE};
      $lquote =~ s{ \A \" }{""}xms;
      $rquote =~ s{ \A \" }{""}xms;
      $preamble =~ s{ [@] LQUOTE [@] }{$lquote}xms;
      $preamble =~ s{ [@] RQUOTE [@] }{$rquote}xms;
      chomp($preamble);
  
      # Get the version information.
      my $version = $self->version_report();
  
      # Build the index line and make sure that it will be syntactically valid.
      my $index = _quote_macro_argument("$name $section");
  
      # Quote the arguments to the .TH macro.  (Section should never require
      # this, but we may as well be cautious.)
      $name = _quote_macro_argument($name);
      $section = _quote_macro_argument($section);
      $date = _quote_macro_argument($date);
      my $center = _quote_macro_argument($self->{opt_center});
      my $release = _quote_macro_argument($self->{opt_release});
  
      # Output the majority of the preamble.
      $self->output (<<"----END OF HEADER----");
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title $index
  .TH $name $section $date $release $center
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
  
      # If the language was specified, output the language configuration.
      if ($self->{opt_language}) {
          $self->output(".mso $self->{opt_language}.tmac\n");
          $self->output(".hla $self->{opt_language}\n");
      }
  }
  
  ##############################################################################
  # Text blocks
  ##############################################################################
  
  # Handle a basic block of text.  The only tricky part of this is if this is
  # the first paragraph of text after an =over, in which case we have to change
  # indentations for *roff.
  sub cmd_para {
      my ($self, $attrs, $text) = @_;
      my $line = $$attrs{start_line};
  
      # Output the paragraph.  We also have to handle =over without =item.  If
      # there's an =over without =item, SHIFTWAIT will be set, and we need to
      # handle creation of the indent here.  Add the shift to SHIFTS so that it
      # will be cleaned up on =back.
      $self->makespace;
      if ($$self{SHIFTWAIT}) {
          $self->output (".RS $$self{INDENT}\n");
          push (@{ $$self{SHIFTS} }, $$self{INDENT});
          $$self{SHIFTWAIT} = 0;
      }
  
      # Force exactly one newline at the end and strip unwanted trailing
      # whitespace at the end, but leave "\ " backslashed space from an S< > at
      # the end of a line.  Reverse the text first, to avoid having to scan the
      # entire paragraph.
      $text = reverse $text;
      $text =~ s/\A\s*?(?= \\|\S|\z)/\n/;
      $text = reverse $text;
  
      # Output the paragraph.
      $self->output($self->protect($self->mapfonts($text, '\fR')));
      $self->outindex();
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Handle a verbatim paragraph.  Put a null token at the beginning of each line
  # to protect against commands and wrap in .Vb/.Ve (which we define in our
  # prelude).
  sub cmd_verbatim {
      my ($self, $attrs, $text) = @_;
  
      # Ignore an empty verbatim paragraph.
      return if $text !~ m{ \S }xms;
  
      # Force exactly one newline at the end and strip unwanted trailing
      # whitespace at the end.
      $text =~ s{ \s* \z }{\n}xms;
  
      # Get a count of the number of lines before the first blank line, which
      # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
      # lines together.  We don't want to tell *roff to keep huge blocks
      # together.
      my @lines = split (m{ \n }xms, $text);
      my $unbroken = 0;
      for my $line (@lines) {
          last if $line =~ m{ \A \s* \z }xms;
          $unbroken++;
      }
      if ($unbroken > 12) {
          $unbroken = 10;
      }
  
      # Prepend a null token to each line to preserve indentation.
      $text =~ s{ ^ }{\\&}xmsg;
  
      # Output the results.
      $self->makespace();
      $self->output(".Vb $unbroken\n$text.Ve\n");
      $$self{NEEDSPACE} = 1;
      return q{};
  }
  
  # Handle literal text (produced by =for and similar constructs).  Just output
  # it with the minimum of changes.
  sub cmd_data {
      my ($self, $attrs, $text) = @_;
      $text =~ s{ \A \n+ }{}xms;
      $text =~ s{ \n{0,2} \z }{\n}xms;
      $self->output($text);
      return q{};
  }
  
  ##############################################################################
  # Headings
  ##############################################################################
  
  # Common code for all headings.  This is called before the actual heading is
  # output.  It returns the cleaned up heading text (putting the heading all on
  # one line) and may do other things, like closing bad =item blocks.
  sub heading_common {
      my ($self, $text, $line) = @_;
      $text =~ s/\s+$//;
      $text =~ s/\s*\n\s*/ /g;
  
      # This should never happen; it means that we have a heading after =item
      # without an intervening =back.  But just in case, handle it anyway.
      if ($$self{ITEMS} > 1) {
          $$self{ITEMS} = 0;
          $self->output (".PD\n");
      }
  
      return $text;
  }
  
  # First level heading.  We can't output .IX in the NAME section due to a bug
  # in some versions of catman, so don't output a .IX for that section.  .SH
  # already uses small caps, so remove \s0 and \s-1.  Maintain IN_NAME as
  # appropriate.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\\s-?\d//g;
      $text = $self->heading_common ($text, $$attrs{start_line});
      my $isname = ($text eq 'NAME' || $text =~ /\(NAME\)/);
      $self->output($self->switchquotes('.SH', $self->mapfonts($text, '\fP')));
      $self->outindex ('Header', $text) unless $isname;
      $$self{NEEDSPACE} = 0;
      $$self{IN_NAME} = $isname;
      return '';
  }
  
  # Second level heading.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->output($self->switchquotes('.SS', $self->mapfonts($text, '\fP')));
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 0;
      return '';
  }
  
  # Third level heading.  *roff doesn't have this concept, so just put the
  # heading in italics as a normal paragraph.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->makespace;
      $self->output($self->mapfonts('\f(IS' . $text . '\f(IE', '\fR') . "\n");
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  # Fourth level heading.  *roff doesn't have this concept, so just put the
  # heading as a normal paragraph.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $text = $self->heading_common ($text, $$attrs{start_line});
      $self->makespace;
      $self->output($self->mapfonts($text, '\fR') . "\n");
      $self->outindex ('Subsection', $text);
      $$self{NEEDSPACE} = 1;
      return '';
  }
  
  ##############################################################################
  # Formatting codes
  ##############################################################################
  
  # All of the formatting codes that aren't handled internally by the parser,
  # other than L<> and X<>.
  sub cmd_b { return $_[0]->{IN_NAME} ? $_[2] : '\f(BS' . $_[2] . '\f(BE' }
  sub cmd_i { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
  sub cmd_f { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
  sub cmd_c { return $_[0]->quote_literal ($_[2]) }
  
  # Convert all internal whitespace to $NBSP.
  sub cmd_s {
      my ($self, $attrs, $text) = @_;
      $text =~ s{ \s }{$NBSP}xmsg;
      return $text;
  }
  
  # Index entries are just added to the pending entries.
  sub cmd_x {
      my ($self, $attrs, $text) = @_;
      push (@{ $$self{INDEX} }, $text);
      return '';
  }
  
  # Links reduce to the text that we're given, wrapped in angle brackets if it's
  # a URL, followed by the URL.  We take an option to suppress the URL if anchor
  # text is given.  We need to format the "to" value of the link before
  # comparing it to the text since we may escape hyphens.
  sub cmd_l {
      my ($self, $attrs, $text) = @_;
      if ($$attrs{type} eq 'url') {
          my $to = $$attrs{to};
          if (defined $to) {
              my $tag = $$self{PENDING}[-1];
              $to = $self->format_text ($$tag[1], $to);
          }
          if (not defined ($to) or $to eq $text) {
              return "<$text>";
          } elsif ($self->{opt_nourls}) {
              return $text;
          } else {
              return "$text <$$attrs{to}>";
          }
      } else {
          return $text;
      }
  }
  
  ##############################################################################
  # List handling
  ##############################################################################
  
  # Handle the beginning of an =over block.  Takes the type of the block as the
  # first argument, and then the attr hash.  This is called by the handlers for
  # the four different types of lists (bullet, number, text, and block).
  sub over_common_start {
      my ($self, $type, $attrs) = @_;
      my $line = $$attrs{start_line};
      my $indent = $$attrs{indent};
  
      # Find the indentation level.
      unless (defined ($indent) && $indent =~ /^[-+]?\d{1,4}\s*$/) {
          $indent = $self->{opt_indent};
      }
  
      # If we've gotten multiple indentations in a row, we need to emit the
      # pending indentation for the last level that we saw and haven't acted on
      # yet.  SHIFTS is the stack of indentations that we've actually emitted
      # code for.
      if (@{ $$self{SHIFTS} } < @{ $$self{INDENTS} }) {
          $self->output (".RS $$self{INDENT}\n");
          push (@{ $$self{SHIFTS} }, $$self{INDENT});
      }
  
      # Now, do record-keeping.  INDENTS is a stack of indentations that we've
      # seen so far, and INDENT is the current level of indentation.  ITEMTYPES
      # is a stack of list types that we've seen.
      push (@{ $$self{INDENTS} }, $$self{INDENT});
      push (@{ $$self{ITEMTYPES} }, $type);
      $$self{INDENT} = $indent + 0;
      $$self{SHIFTWAIT} = 1;
  }
  
  # End an =over block.  Takes no options other than the class pointer.
  # Normally, once we close a block and therefore remove something from INDENTS,
  # INDENTS will now be longer than SHIFTS, indicating that we also need to emit
  # *roff code to close the indent.  This isn't *always* true, depending on the
  # circumstance.  If we're still inside an indentation, we need to emit another
  # .RE and then a new .RS to unconfuse *roff.
  sub over_common_end {
      my ($self) = @_;
      $$self{INDENT} = pop @{ $$self{INDENTS} };
      pop @{ $$self{ITEMTYPES} };
  
      # If we emitted code for that indentation, end it.
      if (@{ $$self{SHIFTS} } > @{ $$self{INDENTS} }) {
          $self->output (".RE\n");
          pop @{ $$self{SHIFTS} };
      }
  
      # If we're still in an indentation, *roff will have now lost track of the
      # right depth of that indentation, so fix that.
      if (@{ $$self{INDENTS} } > 0) {
          $self->output (".RE\n");
          $self->output (".RS $$self{INDENT}\n");
      }
      $$self{NEEDSPACE} = 1;
      $$self{SHIFTWAIT} = 0;
  }
  
  # Dispatch the start and end calls as appropriate.
  sub start_over_bullet { my $s = shift; $s->over_common_start ('bullet', @_) }
  sub start_over_number { my $s = shift; $s->over_common_start ('number', @_) }
  sub start_over_text   { my $s = shift; $s->over_common_start ('text',   @_) }
  sub start_over_block  { my $s = shift; $s->over_common_start ('block',  @_) }
  sub end_over_bullet { $_[0]->over_common_end }
  sub end_over_number { $_[0]->over_common_end }
  sub end_over_text   { $_[0]->over_common_end }
  sub end_over_block  { $_[0]->over_common_end }
  
  # The common handler for all item commands.  Takes the type of the item, the
  # attributes, and then the text of the item.
  #
  # Emit an index entry for anything that's interesting, but don't emit index
  # entries for things like bullets and numbers.  Newlines in an item title are
  # turned into spaces since *roff can't handle them embedded.
  sub item_common {
      my ($self, $type, $attrs, $text) = @_;
      my $line = $$attrs{start_line};
  
      # Clean up the text.  We want to end up with two variables, one ($text)
      # which contains any body text after taking out the item portion, and
      # another ($item) which contains the actual item text.
      $text =~ s/\s+$//;
      my ($item, $index);
      if ($type eq 'bullet') {
          $item = "\\\(bu";
          $text =~ s/\n*$/\n/;
      } elsif ($type eq 'number') {
          $item = $$attrs{number} . '.';
      } else {
          $item = $text;
          $item =~ s/\s*\n\s*/ /g;
          $text = '';
          $index = $item if ($item =~ /\w/);
      }
  
      # Take care of the indentation.  If shifts and indents are equal, close
      # the top shift, since we're about to create an indentation with .IP.
      # Also output .PD 0 to turn off spacing between items if this item is
      # directly following another one.  We only have to do that once for a
      # whole chain of items so do it for the second item in the change.  Note
      # that makespace is what undoes this.
      if (@{ $$self{SHIFTS} } == @{ $$self{INDENTS} }) {
          $self->output (".RE\n");
          pop @{ $$self{SHIFTS} };
      }
      $self->output (".PD 0\n") if ($$self{ITEMS} == 1);
  
      # Now, output the item tag itself.
      $item = $self->mapfonts($item, '\fR');
      $self->output($self->switchquotes('.IP', $item, $$self{INDENT}));
      $$self{NEEDSPACE} = 0;
      $$self{ITEMS}++;
      $$self{SHIFTWAIT} = 0;
  
      # If body text for this item was included, go ahead and output that now.
      if ($text) {
          $text =~ s/\s*$/\n/;
          $self->makespace;
          $self->output($self->protect($self->mapfonts($text, '\fR')));
          $$self{NEEDSPACE} = 1;
      }
      $self->outindex ($index ? ('Item', $index) : ());
  }
  
  # Dispatch the item commands to the appropriate place.
  sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
  sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
  sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
  sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
  
  ##############################################################################
  # Backward compatibility
  ##############################################################################
  
  # Reset the underlying Pod::Simple object between calls to parse_from_file so
  # that the same object can be reused to convert multiple pages.
  sub parse_from_file {
      my $self = shift;
      $self->reinit;
  
      # Fake the old cutting option to Pod::Parser.  This fiddles with internal
      # Pod::Simple state and is quite ugly; we need a better approach.
      if (ref ($_[0]) eq 'HASH') {
          my $opts = shift @_;
          if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
              $$self{in_pod} = 1;
              $$self{last_was_blank} = 1;
          }
      }
  
      # Do the work.
      my $retval = $self->SUPER::parse_from_file (@_);
  
      # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
      # close the file descriptor if we had to open one, but we can't easily
      # figure this out.
      my $fh = $self->output_fh ();
      my $oldfh = select $fh;
      my $oldflush = $|;
      $| = 1;
      print $fh '';
      $| = $oldflush;
      select $oldfh;
      return $retval;
  }
  
  # Pod::Simple failed to provide this backward compatibility function, so
  # implement it ourselves.  File handles are one of the inputs that
  # parse_from_file supports.
  sub parse_from_filehandle {
      my $self = shift;
      return $self->parse_from_file (@_);
  }
  
  # Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
  # ourself unless it was already set by the caller, since our documentation has
  # always said that this should work.
  sub parse_file {
      my ($self, $in) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_file ($in);
  }
  
  # Do the same for parse_lines, just to be polite.  Pod::Simple's man page
  # implies that the caller is responsible for setting this, but I don't see any
  # reason not to set a default.
  sub parse_lines {
      my ($self, @lines) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_lines (@lines);
  }
  
  # Likewise for parse_string_document.
  sub parse_string_document {
      my ($self, $doc) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_string_document ($doc);
  }
  
  ##############################################################################
  # Premable
  ##############################################################################
  
  # The preamble which starts all *roff output we generate.  Most is static
  # except for the font to use as a fixed-width font (designed by @CFONT@), and
  # the left and right quotes to use for C<> text (designated by @LQOUTE@ and
  # @RQUOTE@).  Accent marks are only defined if the output encoding is roff.
  sub preamble_template {
      my ($self) = @_;
      my $preamble = <<'----END OF PREAMBLE----';
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
  .ie n \{\
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .nr rF 0
  .if \n(.g .if rF .nr rF 1
  .if (\n(rF:(\n(.g==0)) \{\
  .    if \nF \{\
  .        de IX
  .        tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .        if !\nF==2 \{\
  .            nr % 0
  .            nr F 2
  .        \}
  .    \}
  .\}
  .rr rF
  ----END OF PREAMBLE----
  #'# for cperl-mode
  
      if ($$self{ENCODING} eq 'roff') {
          $preamble .= <<'----END OF PREAMBLE----'
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h'|\\n:u'
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
  #`# for cperl-mode
      }
      return $preamble;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =encoding UTF-8
  
  =for stopwords
  en em ALLCAPS teeny fixedbold fixeditalic fixedbolditalic stderr utf8 UTF-8
  Allbery Sean Burke Ossanna Solaris formatters troff uppercased Christiansen
  nourls parsers Kernighan lquote rquote unrepresentable mandoc NetBSD PostScript
  SMP macOS EBCDIC fallbacks manref reflowed reflowing FH overridable
  
  =head1 NAME
  
  Pod::Man - Convert POD data to formatted *roff input
  
  =head1 SYNOPSIS
  
      use Pod::Man;
      my $parser = Pod::Man->new (release => $VERSION, section => 8);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_file (\*STDIN);
  
      # Read POD from file.pod and write to file.1.
      $parser->parse_from_file ('file.pod', 'file.1');
  
  =head1 DESCRIPTION
  
  Pod::Man is a module to convert documentation in the POD format (the
  preferred language for documenting Perl) into *roff input using the man
  macro set.  The resulting *roff code is suitable for display on a terminal
  using L<nroff(1)>, normally via L<man(1)>, or printing using L<troff(1)>.
  It is conventionally invoked using the driver script B<pod2man>, but it can
  also be used directly.
  
  By default (on non-EBCDIC systems), Pod::Man outputs UTF-8.  Its output should
  work with the B<man> program on systems that use B<groff> (most Linux
  distributions) or B<mandoc> (most BSD variants), but may result in mangled
  output on older UNIX systems.  To choose a different, possibly more
  backward-compatible output mangling on such systems, set the C<encoding>
  option to C<roff> (the default in earlier Pod::Man versions).  See the
  C<encoding> option and L</ENCODING> for more details.
  
  See L</COMPATIBILTY> for the versions of Pod::Man with significant
  backward-incompatible changes (other than constructor options, whose versions
  are documented below), and the versions of Perl that included them.
  
  =head1 CLASS METHODS
  
  =over 4
  
  =item new(ARGS)
  
  Create a new Pod::Man object.  ARGS should be a list of key/value pairs, where
  the keys are chosen from the following.  Each option is annotated with the
  version of Pod::Man in which that option was added with its current meaning.
  
  =over 4
  
  =item center
  
  [1.00] Sets the centered page header for the C<.TH> macro.  The default, if
  this option is not specified, is C<User Contributed Perl Documentation>.
  
  =item date
  
  [4.00] Sets the left-hand footer for the C<.TH> macro.  If this option is not
  set, the contents of the environment variable POD_MAN_DATE, if set, will be
  used.  Failing that, the value of SOURCE_DATE_EPOCH, the modification date of
  the input file, or the current time if stat() can't find that file (which will
  be the case if the input is from C<STDIN>) will be used.  If taken from any
  source other than POD_MAN_DATE (which is used verbatim), the date will be
  formatted as C<YYYY-MM-DD> and will be based on UTC (so that the output will
  be reproducible regardless of local time zone).
  
  =item encoding
  
  [5.00] Specifies the encoding of the output.  The value must be an encoding
  recognized by the L<Encode> module (see L<Encode::Supported>), or the special
  values C<roff> or C<groff>.  The default on non-EBCDIC systems is UTF-8.
  
  If the output contains characters that cannot be represented in this encoding,
  that is an error that will be reported as configured by the C<errors> option.
  If error handling is other than C<die>, the unrepresentable character will be
  replaced with the Encode substitution character (normally C<?>).
  
  If the C<encoding> option is set to the special value C<groff> (the default on
  EBCDIC systems), or if the Encode module is not available and the encoding is
  set to anything other than C<roff>, Pod::Man will translate all non-ASCII
  characters to C<\[uNNNN]> Unicode escapes.  These are not traditionally part
  of the *roff language, but are supported by B<groff> and B<mandoc> and thus by
  the majority of manual page processors in use today.
  
  If the C<encoding> option is set to the special value C<roff>, Pod::Man will
  do its historic transformation of (some) ISO 8859-1 characters into *roff
  escapes that may be adequate in troff and may be readable (if ugly) in nroff.
  This was the default behavior of versions of Pod::Man before 5.00.  With this
  encoding, all other non-ASCII characters will be replaced with C<X>.  It may
  be required for very old troff and nroff implementations that do not support
  UTF-8, but its representation of any non-ASCII character is very poor and
  often specific to European languages.
  
  If the output file handle has a PerlIO encoding layer set, setting C<encoding>
  to anything other than C<groff> or C<roff> will be ignored and no encoding
  will be done by Pod::Man.  It will instead rely on the encoding layer to make
  whatever output encoding transformations are desired.
  
  WARNING: The input encoding of the POD source is independent from the output
  encoding, and setting this option does not affect the interpretation of the
  POD input.  Unless your POD source is US-ASCII, its encoding should be
  declared with the C<=encoding> command in the source.  If this is not done,
  Pod::Simple will will attempt to guess the encoding and may be successful if
  it's Latin-1 or UTF-8, but it will produce warnings.  See L<perlpod(1)> for
  more information.
  
  =item errors
  
  [2.27] How to report errors.  C<die> says to throw an exception on any POD
  formatting error.  C<stderr> says to report errors on standard error, but not
  to throw an exception.  C<pod> says to include a POD ERRORS section in the
  resulting documentation summarizing the errors.  C<none> ignores POD errors
  entirely, as much as possible.
  
  The default is C<pod>.
  
  =item fixed
  
  [1.00] The fixed-width font to use for verbatim text and code.  Defaults to
  C<CW>.  Some systems prefer C<CR> instead.  Only matters for B<troff> output.
  
  =item fixedbold
  
  [1.00] Bold version of the fixed-width font.  Defaults to C<CB>.  Only matters
  for B<troff> output.
  
  =item fixeditalic
  
  [1.00] Italic version of the fixed-width font (something of a misnomer, since
  most fixed-width fonts only have an oblique version, not an italic version).
  Defaults to C<CI>.  Only matters for B<troff> output.
  
  =item fixedbolditalic
  
  [1.00] Bold italic (in theory, probably oblique in practice) version of the
  fixed-width font.  Pod::Man doesn't assume you have this, and defaults to
  C<CB>.  Some systems (such as Solaris) have this font available as C<CX>.
  Only matters for B<troff> output.
  
  =item guesswork
  
  [5.00] By default, Pod::Man applies some default formatting rules based on
  guesswork and regular expressions that are intended to make writing Perl
  documentation easier and require less explicit markup.  These rules may not
  always be appropriate, particularly for documentation that isn't about Perl.
  This option allows turning all or some of it off.
  
  The special value C<all> enables all guesswork.  This is also the default for
  backward compatibility reasons.  The special value C<none> disables all
  guesswork.  Otherwise, the value of this option should be a comma-separated
  list of one or more of the following keywords:
  
  =over 4
  
  =item functions
  
  Convert function references like C<foo()> to bold even if they have no markup.
  The function name accepts valid Perl characters for function names (including
  C<:>), and the trailing parentheses must be present and empty.
  
  =item manref
  
  Make the first part (before the parentheses) of manual page references like
  C<foo(1)> bold even if they have no markup.  The section must be a single
  number optionally followed by lowercase letters.
  
  =item quoting
  
  If no guesswork is enabled, any text enclosed in CZ<><> is surrounded by
  double quotes in nroff (terminal) output unless the contents are already
  quoted.  When this guesswork is enabled, quote marks will also be suppressed
  for Perl variables, function names, function calls, numbers, and hex
  constants.
  
  =item variables
  
  Convert Perl variable names to a fixed-width font even if they have no markup.
  This transformation will only be apparent in troff output, or some other
  output format (unlike nroff terminal output) that supports fixed-width fonts.
  
  =back
  
  Any unknown guesswork name is silently ignored (for potential future
  compatibility), so be careful about spelling.
  
  =item language
  
  [5.00] Add commands telling B<groff> that the input file is in the given
  language.  The value of this setting must be a language abbreviation for which
  B<groff> provides supplemental configuration, such as C<ja> (for Japanese) or
  C<zh> (for Chinese).
  
  Specifically, this adds:
  
      .mso <language>.tmac
      .hla <language>
  
  to the start of the file, which configure correct line breaking for the
  specified language.  Without these commands, groff may not know how to add
  proper line breaks for Chinese and Japanese text if the manual page is
  installed into the normal manual page directory, such as F</usr/share/man>.
  
  On many systems, this will be done automatically if the manual page is
  installed into a language-specific manual page directory, such as
  F</usr/share/man/zh_CN>.  In that case, this option is not required.
  
  Unfortunately, the commands added with this option are specific to B<groff>
  and will not work with other B<troff> and B<nroff> implementations.
  
  =item lquote
  
  =item rquote
  
  [4.08] Sets the quote marks used to surround CE<lt>> text.  C<lquote> sets the
  left quote mark and C<rquote> sets the right quote mark.  Either may also be
  set to the special value C<none>, in which case no quote mark is added on that
  side of CE<lt>> text (but the font is still changed for troff output).
  
  Also see the C<quotes> option, which can be used to set both quotes at once.
  If both C<quotes> and one of the other options is set, C<lquote> or C<rquote>
  overrides C<quotes>.
  
  =item name
  
  [4.08] Set the name of the manual page for the C<.TH> macro.  Without this
  option, the manual name is set to the uppercased base name of the file being
  converted unless the manual section is 3, in which case the path is parsed to
  see if it is a Perl module path.  If it is, a path like C<.../lib/Pod/Man.pm>
  is converted into a name like C<Pod::Man>.  This option, if given, overrides
  any automatic determination of the name.
  
  If generating a manual page from standard input, the name will be set to
  C<STDIN> if this option is not provided.  In this case, providing this option
  is strongly recommended to set a meaningful manual page name.
  
  =item nourls
  
  [2.27] Normally, LZ<><> formatting codes with a URL but anchor text are
  formatted to show both the anchor text and the URL.  In other words:
  
      L<foo|http://example.com/>
  
  is formatted as:
  
      foo <http://example.com/>
  
  This option, if set to a true value, suppresses the URL when anchor text
  is given, so this example would be formatted as just C<foo>.  This can
  produce less cluttered output in cases where the URLs are not particularly
  important.
  
  =item quotes
  
  [4.00] Sets the quote marks used to surround CE<lt>> text.  If the value is a
  single character, it is used as both the left and right quote.  Otherwise, it
  is split in half, and the first half of the string is used as the left quote
  and the second is used as the right quote.
  
  This may also be set to the special value C<none>, in which case no quote
  marks are added around CE<lt>> text (but the font is still changed for troff
  output).
  
  Also see the C<lquote> and C<rquote> options, which can be used to set the
  left and right quotes independently.  If both C<quotes> and one of the other
  options is set, C<lquote> or C<rquote> overrides C<quotes>.
  
  =item release
  
  [1.00] Set the centered footer for the C<.TH> macro.  By default, this is set
  to the version of Perl you run Pod::Man under.  Setting this to the empty
  string will cause some *roff implementations to use the system default value.
  
  Note that some system C<an> macro sets assume that the centered footer will be
  a modification date and will prepend something like C<Last modified: >.  If
  this is the case for your target system, you may want to set C<release> to the
  last modified date and C<date> to the version number.
  
  =item section
  
  [1.00] Set the section for the C<.TH> macro.  The standard section numbering
  convention is to use 1 for user commands, 2 for system calls, 3 for functions,
  4 for devices, 5 for file formats, 6 for games, 7 for miscellaneous
  information, and 8 for administrator commands.  There is a lot of variation
  here, however; some systems (like Solaris) use 4 for file formats, 5 for
  miscellaneous information, and 7 for devices.  Still others use 1m instead of
  8, or some mix of both.  About the only section numbers that are reliably
  consistent are 1, 2, and 3.
  
  By default, section 1 will be used unless the file ends in C<.pm> in which
  case section 3 will be selected.
  
  =item stderr
  
  [2.19] If set to a true value, send error messages about invalid POD to
  standard error instead of appending a POD ERRORS section to the generated
  *roff output.  This is equivalent to setting C<errors> to C<stderr> if
  C<errors> is not already set.
  
  This option is for backward compatibility with Pod::Man versions that did not
  support C<errors>.  Normally, the C<errors> option should be used instead.
  
  =item utf8
  
  [2.21] This option used to set the output encoding to UTF-8.  Since this is
  now the default, it is ignored and does nothing.
  
  =back
  
  =back
  
  =head1 INSTANCE METHODS
  
  As a derived class from Pod::Simple, Pod::Man supports the same methods and
  interfaces.  See L<Pod::Simple> for all the details.  This section summarizes
  the most-frequently-used methods and the ones added by Pod::Man.
  
  =over 4
  
  =item output_fh(FH)
  
  Direct the output from parse_file(), parse_lines(), or parse_string_document()
  to the file handle FH instead of C<STDOUT>.
  
  =item output_string(REF)
  
  Direct the output from parse_file(), parse_lines(), or parse_string_document()
  to the scalar variable pointed to by REF, rather than C<STDOUT>.  For example:
  
      my $man = Pod::Man->new();
      my $output;
      $man->output_string(\$output);
      $man->parse_file('/some/input/file');
  
  Be aware that the output in that variable will already be encoded in UTF-8.
  
  =item parse_file(PATH)
  
  Read the POD source from PATH and format it.  By default, the output is sent
  to C<STDOUT>, but this can be changed with the output_fh() or output_string()
  methods.
  
  =item parse_from_file(INPUT, OUTPUT)
  
  =item parse_from_filehandle(FH, OUTPUT)
  
  Read the POD source from INPUT, format it, and output the results to OUTPUT.
  
  parse_from_filehandle() is provided for backward compatibility with older
  versions of Pod::Man.  parse_from_file() should be used instead.
  
  =item parse_lines(LINES[, ...[, undef]])
  
  Parse the provided lines as POD source, writing the output to either C<STDOUT>
  or the file handle set with the output_fh() or output_string() methods.  This
  method can be called repeatedly to provide more input lines.  An explicit
  C<undef> should be passed to indicate the end of input.
  
  This method expects raw bytes, not decoded characters.
  
  =item parse_string_document(INPUT)
  
  Parse the provided scalar variable as POD source, writing the output to either
  C<STDOUT> or the file handle set with the output_fh() or output_string()
  methods.
  
  This method expects raw bytes, not decoded characters.
  
  =back
  
  =head1 ENCODING
  
  As of Pod::Man 5.00, the default output encoding for Pod::Man is UTF-8.  This
  should work correctly on any modern system that uses either B<groff> (most
  Linux distributions) or B<mandoc> (Alpine Linux and most BSD variants,
  including macOS).
  
  The user will probably have to use a UTF-8 locale to see correct output.  This
  may be done by default; if not, set the LANG or LC_CTYPE environment variables
  to an appropriate local.  The locale C<C.UTF-8> is available on most systems
  if one wants correct output without changing the other things locales affect,
  such as collation.
  
  The backward-compatible output format used in Pod::Man versions before 5.00 is
  available by setting the C<encoding> option to C<roff>.  This may produce
  marginally nicer results on older UNIX versions that do not use B<groff> or
  B<mandoc>, but none of the available options will correctly render Unicode
  characters on those systems.
  
  Below are some additional details about how this choice was made and some
  discussion of alternatives.
  
  =head2 History
  
  The default output encoding for Pod::Man has been a long-standing problem.
  B<troff> and B<nroff> predate Unicode by a significant margin, and their
  implementations for many UNIX systems reflect that legacy.  It's common for
  Unicode to not be supported in any form.
  
  Because of this, versions of Pod::Man prior to 5.00 maintained the highly
  conservative output of the original pod2man, which output pure ASCII with
  complex macros to simulate common western European accented characters when
  processed with troff.  The nroff output was awkward and sometimes incorrect,
  and characters not used in western European scripts were replaced with C<X>.
  This choice maximized backwards compatibility with B<man> and
  B<nroff>/B<troff> implementations at the cost of incorrect rendering of many
  POD documents, particularly those containing people's names.
  
  The modern implementations, B<groff> (used in most Linux distributions) and
  B<mandoc> (used by most BSD variants), do now support Unicode.  Other UNIX
  systems often do not, but they're now a tiny minority of the systems people
  use on a daily basis.  It's increasingly common (for very good reasons) to use
  Unicode characters for POD documents rather than using ASCII conversions of
  people's names or avoiding non-English text, making the limitations in the old
  output format more apparent.
  
  Four options have been proposed to fix this:
  
  =over 2
  
  =item * 
  
  Optionally support UTF-8 output but don't change the default.  This is the
  approach taken since Pod::Man 2.1.0, which added the C<utf8> option.  Some
  Pod::Man users use this option for better output on platforms known to support
  Unicode, but since the defaults have not changed, people continued to
  encounter (and file bug reports about) the poor default rendering.
  
  =item *
  
  Convert characters to troff C<\(xx> escapes.  This requires maintaining a
  large translation table and addresses only a tiny part of the problem, since
  many Unicode characters have no standard troff name.  B<groff> has the largest
  list, but if one is willing to assume B<groff> is the formatter, the next
  option is better.
  
  =item *
  
  Convert characters to groff C<\[uNNNN]> escapes.  This is implemented as the
  C<groff> encoding for those who want to use it, and is supported by both
  B<groff> and B<mandoc>.  However, it is no better than UTF-8 output for
  portability to other implementations.  See L</Testing results> for more
  details.
  
  =item *
  
  Change the default output format to UTF-8 and ask those who want maximum
  backward compatibility to explicitly select the old encoding.  This fixes the
  issue for most users at the cost of backwards compatibility.  While the
  rendering of non-ASCII characters is different on older systems that don't
  support UTF-8, it's not always worse than the old output.
  
  =back
  
  Pod::Man 5.00 and later makes the last choice.  This arguably produces worse
  output when manual pages are formatted with B<troff> into PostScript or PDF,
  but doing this is rare and normally manual, so the encoding can be changed in
  those cases.  The older output encoding is available by setting C<encoding> to
  C<roff>.
  
  =head2 Testing results
  
  Here is the results of testing C<encoding> values of C<utf-8> and C<groff> on
  various operating systems.  The testing methodology was to create F<man/man1>
  in the current directory, copy F<encoding.utf8> or F<encoding.groff> from the
  podlators 5.00 distribution to F<man/man1/encoding.1>, and then run:
  
      LANG=C.UTF-8 MANPATH=$(pwd)/man man 1 encoding
  
  If the locale is not explicitly set to one that includes UTF-8, the Unicode
  characters were usually converted to ASCII (by, for example, dropping an
  accent) or deleted or replaced with C<< <?> >> if there was no conversion.
  
  Tested on 2022-09-25.  Many thanks to the GCC Compile Farm project for access
  to testing hosts.
  
      OS                   UTF-8      groff
      ------------------   -------    -------
      AIX 7.1              no [1]     no [2]
      Alpine 3.15.0        yes        yes
      CentOS 7.9           yes        yes
      Debian 7             yes        yes
      FreeBSD 13.0         yes        yes
      NetBSD 9.2           yes        yes
      OpenBSD 7.1          yes        yes
      openSUSE Leap 15.4   yes        yes
      Solaris 10           yes        no [2]
      Solaris 11           no [3]     no [3]
  
  I did not have access to a macOS system for testing, but since it uses
  B<mandoc>, it's behavior is probably the same as the BSD hosts.
  
  Notes:
  
  =over 4
  
  =item [1]
  
  Unicode characters were converted to one or two random ASCII characters
  unrelated to the original character.
  
  =item [2]
  
  Unicode characters were shown as the body of the groff escape rather than the
  indicated character (in other words, text like C<[u00EF]>).
  
  =item [3]
  
  Unicode characters were deleted entirely, as if they weren't there.  Using
  C<nroff -man> instead of B<man> to format the page showed the same results as
  Solaris 10.  Using C<groff -k -man -Tutf8> to format the page produced the
  correct output.
  
  =back
  
  PostScript and PDF output using groff on a Debian 12 system do not support
  combining accent marks or SMP characters due to a lack of support in the
  default output font.
  
  Testing on additional platforms is welcome.  Please let the author know if you
  have additional results.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item roff font should be 1 or 2 chars, not "%s"
  
  (F) You specified a *roff font (using C<fixed>, C<fixedbold>, etc.) that
  wasn't either one or two characters.  Pod::Man doesn't support *roff fonts
  longer than two characters, although some *roff extensions do (the
  canonical versions of B<nroff> and B<troff> don't either).
  
  =item Invalid errors setting "%s"
  
  (F) The C<errors> parameter to the constructor was set to an unknown value.
  
  =item Invalid quote specification "%s"
  
  (F) The quote specification given (the C<quotes> option to the
  constructor) was invalid.  A quote specification must be either one
  character long or an even number (greater than one) characters long.
  
  =item POD document had syntax errors
  
  (F) The POD document being formatted had syntax errors and the C<errors>
  option was set to C<die>.
  
  =back
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item PERL_CORE
  
  If set and Encode is not available, silently fall back to an encoding of
  C<groff> without complaining to standard error.  This environment variable is
  set during Perl core builds, which build Encode after podlators.  Encode is
  expected to not (yet) be available in that case.
  
  =item POD_MAN_DATE
  
  If set, this will be used as the value of the left-hand footer unless the
  C<date> option is explicitly set, overriding the timestamp of the input
  file or the current time.  This is primarily useful to ensure reproducible
  builds of the same output file given the same source and Pod::Man version,
  even when file timestamps may not be consistent.
  
  =item SOURCE_DATE_EPOCH
  
  If set, and POD_MAN_DATE and the C<date> options are not set, this will be
  used as the modification time of the source file, overriding the timestamp of
  the input file or the current time.  It should be set to the desired time in
  seconds since UNIX epoch.  This is primarily useful to ensure reproducible
  builds of the same output file given the same source and Pod::Man version,
  even when file timestamps may not be consistent.  See
  L<https://reproducible-builds.org/specs/source-date-epoch/> for the full
  specification.
  
  (Arguably, according to the specification, this variable should be used only
  if the timestamp of the input file is not available and Pod::Man uses the
  current time.  However, for reproducible builds in Debian, results were more
  reliable if this variable overrode the timestamp of the input file.)
  
  =back
  
  =head1 COMPATIBILITY
  
  Pod::Man 1.02 (based on L<Pod::Parser>) was the first version included with
  Perl, in Perl 5.6.0.
  
  The current API based on L<Pod::Simple> was added in Pod::Man 2.00.  Pod::Man
  2.04 was included in Perl 5.9.3, the first version of Perl to incorporate
  those changes.  This is the first version that correctly supports all modern
  POD syntax.  The parse_from_filehandle() method was re-added for backward
  compatibility in Pod::Man 2.09, included in Perl 5.9.4.
  
  Support for anchor text in LZ<><> links of type URL was added in Pod::Man
  2.23, included in Perl 5.11.5.
  
  parse_lines(), parse_string_document(), and parse_file() set a default output
  file handle of C<STDOUT> if one was not already set as of Pod::Man 2.28,
  included in Perl 5.19.5.
  
  Support for SOURCE_DATE_EPOCH and POD_MAN_DATE was added in Pod::Man 4.00,
  included in Perl 5.23.7, and generated dates were changed to use UTC instead
  of the local time zone.  This is also the first release that aligned the
  module version and the version of the podlators distribution.  All modules
  included in podlators, and the podlators distribution itself, share the same
  version number from this point forward.
  
  Pod::Man 4.10, included in Perl 5.27.8, changed the formatting for manual page
  references and function names to bold instead of italic, following the current
  Linux manual page standard.
  
  Pod::Man 5.00 changed the default output encoding to UTF-8, overridable with
  the new C<encoding> option.  It also fixed problems with bold or italic
  extending too far when used with CZ<><> escapes, and began converting Unicode
  zero-width spaces (U+200B) to the C<\:> *roff escape.  It also dropped
  attempts to add subtle formatting corrections in the output that would only be
  visible when typeset with B<troff>, which had previously been a significant
  source of bugs.
  
  =head1 BUGS
  
  There are numerous bugs and language-specific assumptions in the nroff
  fallbacks for accented characters in the C<roff> encoding.  Since the point of
  this encoding is backward compatibility with the output from earlier versions
  of Pod::Man, and it is deprecated except when necessary to support old
  systems, those bugs are unlikely to ever be fixed.
  
  Pod::Man doesn't handle font names longer than two characters.  Neither do
  most B<troff> implementations, but groff does as an extension.  It would be
  nice to support as an option for those who want to use it.
  
  =head1 CAVEATS
  
  =head2 Sentence spacing
  
  Pod::Man copies the input spacing verbatim to the output *roff document.  This
  means your output will be affected by how B<nroff> generally handles sentence
  spacing.
  
  B<nroff> dates from an era in which it was standard to use two spaces after
  sentences, and will always add two spaces after a line-ending period (or
  similar punctuation) when reflowing text.  For example, the following input:
  
      =pod
  
      One sentence.
      Another sentence.
  
  will result in two spaces after the period when the text is reflowed.  If you
  use two spaces after sentences anyway, this will be consistent, although you
  will have to be careful to not end a line with an abbreviation such as C<e.g.>
  or C<Ms.>.  Output will also be consistent if you use the *roff style guide
  (and L<XKCD 1285|https://xkcd.com/1285/>) recommendation of putting a line
  break after each sentence, although that will consistently produce two spaces
  after each sentence, which may not be what you want.
  
  If you prefer one space after sentences (which is the more modern style), you
  will unfortunately need to ensure that no line in the middle of a paragraph
  ends in a period or similar sentence-ending paragraph.  Otherwise, B<nroff>
  will add a two spaces after that sentence when reflowing, and your output
  document will have inconsistent spacing.
  
  =head2 Hyphens
  
  The handling of hyphens versus dashes is somewhat fragile, and one may get a
  the wrong one under some circumstances.  This will normally only matter for
  line breaking and possibly for troff output.
  
  =head1 AUTHOR
  
  Written by Russ Allbery <rra@cpan.org>, based on the original B<pod2man> by
  Tom Christiansen <tchrist@mox.perl.com>.
  
  The modifications to work with Pod::Simple instead of Pod::Parser were
  contributed by Sean Burke <sburke@cpan.org>, but I've since hacked them beyond
  recognition and all bugs are mine.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999-2010, 2012-2020, 2022 Russ Allbery <rra@cpan.org>
  
  Substantial contributions by Sean Burke <sburke@cpan.org>.
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Encode::Supported>, L<Pod::Simple>, L<perlpod(1)>, L<pod2man(1)>,
  L<nroff(1)>, L<troff(1)>, L<man(1)>, L<man(7)>
  
  Ossanna, Joseph F., and Brian W. Kernighan.  "Troff User's Manual,"
  Computing Science Technical Report No. 54, AT&T Bell Laboratories.  This is
  the best documentation of standard B<nroff> and B<troff>.  At the time of
  this writing, it's available at L<http://www.troff.org/54.pdf>.
  
  The manual page documenting the man macro set may be L<man(5)> instead of
  L<man(7)> on your system.
  
  See L<perlpodstyle(1)> for documentation on writing manual pages in POD if
  you've not done it before and aren't familiar with the conventions.
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  # Parse an L<> formatting code in POD text.
  #
  # This module implements parsing of the text of an L<> formatting code as
  # defined in perlpodspec.  It should be suitable for any POD formatter.  It
  # exports only one function, parselink(), which returns the five-item parse
  # defined in perlpodspec.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::ParseLink;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(parselink);
  our $VERSION = '5.01';
  
  ##############################################################################
  # Implementation
  ##############################################################################
  
  # Parse the name and section portion of a link into a name and section.
  sub _parse_section {
      my ($link) = @_;
      $link =~ s/^\s+//;
      $link =~ s/\s+$//;
  
      # If the whole link is enclosed in quotes, interpret it all as a section
      # even if it contains a slash.
      return (undef, $1) if ($link =~ /^"\s*(.*?)\s*"$/);
  
      # Split into page and section on slash, and then clean up quoting in the
      # section.  If there is no section and the name contains spaces, also
      # guess that it's an old section link.
      my ($page, $section) = split (/\s*\/\s*/, $link, 2);
      $section =~ s/^"\s*(.*?)\s*"$/$1/ if $section;
      if ($page && $page =~ / / && !defined ($section)) {
          $section = $page;
          $page = undef;
      } else {
          $page = undef unless $page;
          $section = undef unless $section;
      }
      return ($page, $section);
  }
  
  # Infer link text from the page and section.
  sub _infer_text {
      my ($page, $section) = @_;
      my $inferred;
      if ($page && !$section) {
          $inferred = $page;
      } elsif (!$page && $section) {
          $inferred = '"' . $section . '"';
      } elsif ($page && $section) {
          $inferred = '"' . $section . '" in ' . $page;
      }
      return $inferred;
  }
  
  # Given the contents of an L<> formatting code, parse it into the link text,
  # the possibly inferred link text, the name or URL, the section, and the type
  # of link (pod, man, or url).
  sub parselink {
      my ($link) = @_;
      $link =~ s/\s+/ /g;
      my $text;
      if ($link =~ /\|/) {
          ($text, $link) = split (/\|/, $link, 2);
      }
      if ($link =~ /\A\w+:[^:\s]\S*\Z/) {
          my $inferred;
          if (defined ($text) && length ($text) > 0) {
              return ($text, $text, $link, undef, 'url');
          } else {
              return ($text, $link, $link, undef, 'url');
          }
      } else {
          my ($name, $section) = _parse_section ($link);
          my $inferred;
          if (defined ($text) && length ($text) > 0) {
              $inferred = $text;
          } else {
              $inferred = _infer_text ($name, $section);
          }
          my $type = ($name && $name =~ /\(\S*\)/) ? 'man' : 'pod';
          return ($text, $inferred, $name, $section, $type);
      }
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  # Ensure we evaluate to true.
  1;
  __END__
  
  =for stopwords
  markup Allbery URL
  
  =head1 NAME
  
  Pod::ParseLink - Parse an LE<lt>E<gt> formatting code in POD text
  
  =head1 SYNOPSIS
  
      use Pod::ParseLink;
      my $link = get_link();
      my ($text, $inferred, $name, $section, $type) = parselink($link);
  
  =head1 DESCRIPTION
  
  This module only provides a single function, parselink(), which takes the
  text of an LE<lt>E<gt> formatting code and parses it.  It returns the
  anchor text for the link (if any was given), the anchor text possibly
  inferred from the name and section, the name or URL, the section if any,
  and the type of link.  The type will be one of C<url>, C<pod>, or C<man>,
  indicating a URL, a link to a POD page, or a link to a Unix manual page.
  
  Parsing is implemented per L<perlpodspec>.  For backward compatibility,
  links where there is no section and name contains spaces, or links where the
  entirety of the link (except for the anchor text if given) is enclosed in
  double-quotes are interpreted as links to a section (LE<lt>/sectionE<gt>).
  
  The inferred anchor text is implemented per L<perlpodspec>:
  
      L<name>         =>  L<name|name>
      L</section>     =>  L<"section"|/section>
      L<name/section> =>  L<"section" in name|name/section>
  
  The name may contain embedded EE<lt>E<gt> and ZE<lt>E<gt> formatting codes,
  and the section, anchor text, and inferred anchor text may contain any
  formatting codes.  Any double quotes around the section are removed as part
  of the parsing, as is any leading or trailing whitespace.
  
  If the text of the LE<lt>E<gt> escape is entirely enclosed in double
  quotes, it's interpreted as a link to a section for backward
  compatibility.
  
  No attempt is made to resolve formatting codes.  This must be done after
  calling parselink() (since EE<lt>E<gt> formatting codes can be used to
  escape characters that would otherwise be significant to the parser and
  resolving them before parsing would result in an incorrect parse of a
  formatting code like:
  
      L<verticalE<verbar>barE<sol>slash>
  
  which should be interpreted as a link to the C<vertical|bar/slash> POD page
  and not as a link to the C<slash> section of the C<bar> POD page with an
  anchor text of C<vertical>.  Note that not only the anchor text will need to
  have formatting codes expanded, but so will the target of the link (to deal
  with EE<lt>E<gt> and ZE<lt>E<gt> formatting codes), and special handling of
  the section may be necessary depending on whether the translator wants to
  consider markup in sections to be significant when resolving links.  See
  L<perlpodspec> for more information.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2001, 2008, 2009, 2014, 2018-2019, 2022 Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Parser>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_PARSELINK

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  package Pod::Simple;
  use strict;
  use warnings;
  use Carp ();
  BEGIN           { *DEBUG = sub () {0} unless defined &DEBUG }
  use integer;
  use Pod::Escapes 1.04 ();
  use Pod::Simple::LinkSection ();
  use Pod::Simple::BlackBox ();
  use Pod::Simple::TiedOutFH;
  #use utf8;
  
  our @ISA = ('Pod::Simple::BlackBox');
  our $VERSION = '3.45';
  
  our @Known_formatting_codes = qw(I B C L E F S X Z);
  our %Known_formatting_codes = map(($_=>1), @Known_formatting_codes);
  our @Known_directives       = qw(head1 head2 head3 head4 head5 head6 item over back);
  our %Known_directives       = map(($_=>'Plain'), @Known_directives);
  our $NL = $/ unless defined $NL;
  
  #-----------------------------------------------------------------------------
  # Set up some constants:
  
  BEGIN {
    if(defined &ASCII)    { }
    elsif(chr(65) eq 'A') { *ASCII = sub () {1}  }
    else                  { *ASCII = sub () {''} }
  
    unless(defined &MANY_LINES) { *MANY_LINES = sub () {20} }
    DEBUG > 4 and print STDERR "MANY_LINES is ", MANY_LINES(), "\n";
    unless(MANY_LINES() >= 1) {
      die "MANY_LINES is too small (", MANY_LINES(), ")!\nAborting";
    }
    if(defined &UNICODE) { }
    elsif($] >= 5.008)   { *UNICODE = sub() {1}  }
    else                 { *UNICODE = sub() {''} }
  }
  if(DEBUG > 2) {
    print STDERR "# We are ", ASCII ? '' : 'not ', "in ASCII-land\n";
    print STDERR "# We are under a Unicode-safe Perl.\n";
  }
  
  # The NO BREAK SPACE and SOFT HYHPEN are used in several submodules.
  if ($] ge 5.007_003) {  # On sufficiently modern Perls we can handle any
                          # character set
    $Pod::Simple::nbsp = chr utf8::unicode_to_native(0xA0);
    $Pod::Simple::shy  = chr utf8::unicode_to_native(0xAD);
  }
  elsif (Pod::Simple::ASCII) {  # Hard code ASCII early Perl
    $Pod::Simple::nbsp = "\xA0";
    $Pod::Simple::shy  = "\xAD";
  }
  else { # EBCDIC on early Perl.  We know what the values are for the code
          # pages supported then.
    $Pod::Simple::nbsp = "\x41";
    $Pod::Simple::shy  = "\xCA";
  }
  
  # Design note:
  # This is a parser for Pod.  It is not a parser for the set of Pod-like
  #  languages which happens to contain Pod -- it is just for Pod, plus possibly
  #  some extensions.
  
  # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  __PACKAGE__->_accessorize(
    '_output_is_for_JustPod', # For use only by Pod::Simple::JustPod,
                         # If non-zero, don't expand Z<> E<> S<> L<>,
                         # and count how many brackets in format codes
    'nbsp_for_S',        # Whether to map S<...>'s to \xA0 characters
    'source_filename',   # Filename of the source, for use in warnings
    'source_dead',       # Whether to consider this parser's source dead
  
    'output_fh',         # The filehandle we're writing to, if applicable.
                         # Used only in some derived classes.
  
    'hide_line_numbers', # For some dumping subclasses: whether to pointedly
                         # suppress the start_line attribute
  
    'line_count',        # the current line number
    'pod_para_count',    # count of pod paragraphs seen so far
  
    'no_whining',        # whether to suppress whining
    'no_errata_section', # whether to suppress the errata section
    'complain_stderr',   # whether to complain to stderr
  
    'doc_has_started',   # whether we've fired the open-Document event yet
  
    'bare_output',       # For some subclasses: whether to prepend
                         #  header-code and postpend footer-code
  
    'keep_encoding_directive',  # whether to emit =encoding
    'nix_X_codes',       # whether to ignore X<...> codes
    'merge_text',        # whether to avoid breaking a single piece of
                         #  text up into several events
  
    'preserve_whitespace', # whether to try to keep whitespace as-is
    'strip_verbatim_indent', # What indent to strip from verbatim
    'expand_verbatim_tabs',  # 0: preserve tabs in verbatim blocks
                             # n: expand tabs to stops every n columns
  
    'parse_characters',  # Whether parser should expect chars rather than octets
  
   'content_seen',      # whether we've seen any real Pod content
   'errors_seen',       # TODO: document.  whether we've seen any errors (fatal or not)
  
   'codes_in_verbatim', # for PseudoPod extensions
  
   'code_handler',      # coderef to call when a code (non-pod) line is seen
   'cut_handler',       # ... when a =cut line is seen
   'pod_handler',       # ... when a =pod line is seen
   'whiteline_handler', # ... when a line with only whitespace is seen
   #Called like:
   # $code_handler->($line, $self->{'line_count'}, $self) if $code_handler;
   #  $cut_handler->($line, $self->{'line_count'}, $self) if $cut_handler;
   #  $pod_handler->($line, $self->{'line_count'}, $self) if $pod_handler;
   #   $wl_handler->($line, $self->{'line_count'}, $self) if $wl_handler;
   'parse_empty_lists', # whether to acknowledge empty =over/=back blocks
   'raw_mode',          # to report entire raw lines instead of Pod elements
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub any_errata_seen {  # good for using as an exit() value...
    return shift->{'errors_seen'} || 0;
  }
  
  sub errata_seen {
    return shift->{'all_errata'} || {};
  }
  
  # Returns the encoding only if it was recognized as being handled and set
  sub detected_encoding {
    return shift->{'detected_encoding'};
  }
  
  sub encoding {
    my $this = shift;
    return $this->{'encoding'} unless @_;  # GET.
  
    $this->_handle_encoding_line("=encoding $_[0]");
    if ($this->{'_processed_encoding'}) {
      delete $this->{'_processed_encoding'};
      if(! $this->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n";
      } elsif( $this->{'encoding_command_statuses'}[-1] ) {
        $this->scream( "=encoding $_[0]",
           sprintf "Couldn't do %s: %s",
           $this->{'encoding_command_reqs'  }[-1],
           $this->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (encoding successfully handled.)\n";
      }
      return $this->{'encoding'};
    } else {
      return undef;
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  # Pull in some functions that, for some reason, I expect to see here too:
  BEGIN {
    *pretty        = \&Pod::Simple::BlackBox::pretty;
    *stringify_lol = \&Pod::Simple::BlackBox::stringify_lol;
    *my_qr         = \&Pod::Simple::BlackBox::my_qr;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub version_report {
    my $class = ref($_[0]) || $_[0];
    if($class eq __PACKAGE__) {
      return "$class $VERSION";
    } else {
      my $v = $class->VERSION;
      return "$class $v (" . __PACKAGE__ . " $VERSION)";
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  #sub curr_open { # read-only list accessor
  #  return @{ $_[0]{'curr_open'} || return() };
  #}
  #sub _curr_open_listref { $_[0]{'curr_open'} ||= [] }
  
  
  sub output_string {
    # Works by faking out output_fh.  Simplifies our code.
    #
    my $this = shift;
    return $this->{'output_string'} unless @_;  # GET.
  
    my $x = (defined($_[0]) and ref($_[0])) ? $_[0] : \( $_[0] );
    $$x = '' unless defined $$x;
    DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";
    $this->{'output_fh'} = Pod::Simple::TiedOutFH->handle_on($_[0]);
    return
      $this->{'output_string'} = $_[0];
      #${ ${ $this->{'output_fh'} } };
  }
  
  sub abandon_output_string { $_[0]->abandon_output_fh; delete $_[0]{'output_string'} }
  sub abandon_output_fh     { $_[0]->output_fh(undef) }
  # These don't delete the string or close the FH -- they just delete our
  #  references to it/them.
  # TODO: document these
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub new {
    # takes no parameters
    my $class = ref($_[0]) || $_[0];
    #Carp::croak(__PACKAGE__ . " is a virtual base class -- see perldoc "
    #  . __PACKAGE__ );
    my $obj = bless {
      'accept_codes'      => { map( ($_=>$_), @Known_formatting_codes ) },
      'accept_directives' => { %Known_directives },
      'accept_targets'    => {},
    }, $class;
  
    $obj->expand_verbatim_tabs(8);
    return $obj;
  }
  
  
  
  # TODO: an option for whether to interpolate E<...>'s, or just resolve to codes.
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {     # OVERRIDE IN DERIVED CLASS
    my($self, $element_name, $attr_hash_r) = @_;
    return;
  }
  
  sub _handle_element_end {       # OVERRIDE IN DERIVED CLASS
    my($self, $element_name) = @_;
    return;
  }
  
  sub _handle_text          {     # OVERRIDE IN DERIVED CLASS
    my($self, $text) = @_;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now directives (not targets)
  
  sub accept_directive_as_verbatim  { shift->_accept_directives('Verbatim', @_) }
  sub accept_directive_as_data      { shift->_accept_directives('Data',     @_) }
  sub accept_directive_as_processed { shift->_accept_directives('Plain',    @_) }
  
  sub _accept_directives {
    my($this, $type) = splice @_,0,2;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "\"$d\" is already a reserved Pod directive name"
       if exists $Known_directives{$d};
      $this->{'accept_directives'}{$d} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n";
    }
    DEBUG > 6 and print STDERR "$this\'s accept_directives : ",
     pretty($this->{'accept_directives'}), "\n";
  
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  # TODO: document these:
  
  sub unaccept_directive { shift->unaccept_directives(@_) };
  
  sub unaccept_directives {
    my $this = shift;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "But you must accept \"$d\" directives -- it's a builtin!"
       if exists $Known_directives{$d};
      delete $this->{'accept_directives'}{$d};
      DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n";
    }
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now targets (not directives)
  
  sub accept_target         { shift->accept_targets(@_)         } # alias
  sub accept_target_as_text { shift->accept_targets_as_text(@_) } # alias
  
  
  sub accept_targets         { shift->_accept_targets('1', @_) }
  
  sub accept_targets_as_text { shift->_accept_targets('force_resolve', @_) }
   # forces them to be processed, even when there's no ":".
  
  sub _accept_targets {
    my($this, $type) = splice @_,0,2;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      $this->{'accept_targets'}{$t} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n";
    }
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_target         { shift->unaccept_targets(@_) }
  
  sub unaccept_targets {
    my $this = shift;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      delete $this->{'accept_targets'}{$t};
      DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n";
    }
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now codes (not targets or directives)
  
  # XXX Probably it is an error that the digit '9' is excluded from these re's.
  # Broken for early Perls on EBCDIC
  my $xml_name_re = my_qr('[^-.0-8:A-Z_a-z[:^ascii:]]', '9');
  $xml_name_re = qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/
                                                              unless $xml_name_re;
  
  sub accept_code { shift->accept_codes(@_) } # alias
  
  sub accept_codes {  # Add some codes
    my $this = shift;
  
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      $this->{'accept_codes'}{$new_code} = $new_code;
  
      # Yes, map to itself -- just so that when we
      #  see "=extend W [whatever] thatelementname", we say that W maps
      #  to whatever $this->{accept_codes}{thatelementname} is,
      #  i.e., "thatelementname".  Then when we go re-mapping,
      #  a "W" in the treelet turns into "thatelementname".  We only
      #  remap once.
      # If we say we accept "W", then a "W" in the treelet simply turns
      #  into "W".
    }
  
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_code { shift->unaccept_codes(@_) }
  
  sub unaccept_codes { # remove some codes
    my $this = shift;
  
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!"
       if grep $new_code eq $_, @Known_formatting_codes;
  
      delete $this->{'accept_codes'}{$new_code};
  
      DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n";
    }
  
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_string_document {
    my $self = shift;
    my @lines;
    foreach my $line_group (@_) {
      next unless defined $line_group and length $line_group;
      pos($line_group) = 0;
      while($line_group =~
        m/([^\n\r]*)(\r?\n?)/g # supports \r, \n ,\r\n
        #m/([^\n\r]*)((?:\r?\n)?)/g
      ) {
        #print(">> $1\n"),
        $self->parse_lines($1)
         if length($1) or length($2)
          or pos($line_group) != length($line_group);
         # I.e., unless it's a zero-length "empty line" at the very
         #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
      }
    }
    $self->parse_lines(undef); # to signal EOF
    return $self;
  }
  
  sub _init_fh_source {
    my($self, $source) = @_;
  
    #DEBUG > 1 and print STDERR "Declaring $source as :raw for starters\n";
    #$self->_apply_binmode($source, ':raw');
    #binmode($source, ":raw");
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  #
  
  sub parse_file {
    my($self, $source) = (@_);
  
    if(!defined $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } elsif(ref(\$source) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($source);
    } elsif(ref $source) {
      $self->{'source_filename'} = '' . ($source);
    } elsif(!length $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } else {
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$source") || Carp::croak("Can't open $source: $!");
        $self->{'source_filename'} = $source;
        $source = *PODSOURCE{IO};
      }
      $self->_init_fh_source($source);
    }
    # By here, $source is a FH.
  
    $self->{'source_fh'} = $source;
  
    my($i, @lines);
    until( $self->{'source_dead'} ) {
      splice @lines;
  
      for($i = MANY_LINES; $i--;) {  # read those many lines at a time
        local $/ = $NL;
        push @lines, scalar(<$source>);  # readline
        last unless defined $lines[-1];
         # but pass thru the undef, which will set source_dead to true
      }
  
      my $at_eof = ! $lines[-1]; # keep track of the undef
      pop @lines if $at_eof; # silence warnings
  
      # be eol agnostic
      s/\r\n?/\n/g for @lines;
  
      # make sure there are only one line elements for parse_lines
      @lines = split(/(?<=\n)/, join('', @lines));
  
      # push the undef back after popping it to set source_dead to true
      push @lines, undef if $at_eof;
  
      $self->parse_lines(@lines);
    }
    delete($self->{'source_fh'}); # so it can be GC'd
    return $self;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub parse_from_file {
    # An emulation of Pod::Parser's interface, for the sake of Perldoc.
    # Basically just a wrapper around parse_file.
  
    my($self, $source, $to) = @_;
    $self = $self->new unless ref($self); # so we tolerate being a class method
  
    if(!defined $source)             { $source = *STDIN{IO}
    } elsif(ref(\$source) eq 'GLOB') { # stet
    } elsif(ref($source)           ) { # stet
    } elsif(!length $source
       or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i
    ) {
      $source = *STDIN{IO};
    }
  
    if(!defined $to) {             $self->output_fh( *STDOUT{IO}   );
    } elsif(ref(\$to) eq 'GLOB') { $self->output_fh( $to );
    } elsif(ref($to)) {            $self->output_fh( $to );
    } elsif(!length $to
       or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i
    ) {
      $self->output_fh( *STDOUT{IO} );
    } elsif($to =~ m/^>&(?:STDERR|2)$/i) {
      $self->output_fh( *STDERR{IO} );
    } else {
      require Symbol;
      my $out_fh = Symbol::gensym();
      DEBUG and print STDERR "Write-opening to $to\n";
      open($out_fh, ">$to")  or  Carp::croak "Can't write-open $to: $!";
      binmode($out_fh)
       if $self->can('write_with_binmode') and $self->write_with_binmode;
      $self->output_fh($out_fh);
    }
  
    return $self->parse_file($source);
  }
  
  #-----------------------------------------------------------------------------
  
  sub whine {
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    if($self->{'no_whining'}) {
      DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";
      return;
    }
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub scream {    # like whine, but not suppressible
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub _complain_warn {
    my($self,$line,$complaint) = @_;
    return printf STDERR "%s around line %s: %s\n",
      $self->{'source_filename'} || 'Pod input', $line, $complaint;
  }
  
  sub _complain_errata {
    my($self,$line,$complaint) = @_;
    if( $self->{'no_errata_section'} ) {
      DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n";
    } else {
      DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";
      push @{$self->{'errata'}{$line}}, $complaint
        # for a report to be generated later!
    }
    return 1;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _get_initial_item_type {
    # A hack-wrapper here for when you have like "=over\n\n=item 456\n\n"
    my($self, $para) = @_;
    return $para->[1]{'~type'}  if $para->[1]{'~type'};
  
    return $para->[1]{'~type'} = 'text'
     if join("\n", @{$para}[2 .. $#$para]) =~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';
    # Else fall thru to the general case:
    return $self->_get_item_type($para);
  }
  
  
  
  sub _get_item_type {       # mutates the item!!
    my($self, $para) = @_;
    return $para->[1]{'~type'} if $para->[1]{'~type'};
  
  
    # Otherwise we haven't yet been to this node.  Maybe alter it...
  
    my $content = join "\n", @{$para}[2 .. $#$para];
  
    if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s) {
      # Like: "=item *", "=item   *   ", "=item"
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      $para->[1]{'~orig_content'} = $content;
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*\*\s+(.+)/s) {  # tolerance
  
      # Like: "=item * Foo bar baz";
      $para->[1]{'~orig_content'}      = $content;
      $para->[1]{'~_freaky_para_hack'} = $1;
      DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*(\d+)\.?\s*$/s) {
      # Like: "=item 1.", "=item    123412"
  
      $para->[1]{'~orig_content'} = $content;
      $para->[1]{'number'} = $1;  # Yes, stores the number there!
  
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'number';
  
    } else {
      # It's anything else.
      return $para->[1]{'~type'} = 'text';
  
    }
  }
  
  #-----------------------------------------------------------------------------
  
  sub _make_treelet {
    my $self = shift;  # and ($para, $start_line)
    my $treelet;
    if(!@_) {
      return [''];
    } if(ref $_[0] and ref $_[0][0] and $_[0][0][0] eq '~Top') {
      # Hack so we can pass in fake-o pre-cooked paragraphs:
      #  just have the first line be a reference to a ['~Top', {}, ...]
      # We use this feechure in gen_errata and stuff.
  
      DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";
      $treelet = $_[0][0];
      splice @$treelet, 0, 2;  # lop the top off
      return $treelet;
    } else {
      $treelet = $self->_treelet_from_formatting_codes(@_);
    }
  
    if( ! $self->{'_output_is_for_JustPod'}   # Retain these as-is for pod output
       && $self->_remap_sequences($treelet) )
    {
      $self->_treat_Zs($treelet);  # Might as well nix these first
      $self->_treat_Ls($treelet);  # L has to precede E and S
      $self->_treat_Es($treelet);
      $self->_treat_Ss($treelet);  # S has to come after E
      $self->_wrap_up($treelet); # Nix X's and merge texties
  
    } else {
      DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n";
       # Very common case!
    }
  
    splice @$treelet, 0, 2;  # lop the top off
  
    return $treelet;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _wrap_up {
    my($self, @stack) = @_;
    my $nixx  = $self->{'nix_X_codes'};
    my $merge = $self->{'merge_text' };
    return unless $nixx or $merge;
  
    DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",
     $merge ? (" Merge mode on\n") : (),
     $nixx  ? (" Nix-X mode on\n") : (),
    ;
  
  
    my($i, $treelet);
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        DEBUG > 3 and print STDERR " Considering child at $i ", pretty($treelet->[$i]), "\n";
        if($nixx and ref $treelet->[$i] and $treelet->[$i][0] eq 'X') {
          DEBUG > 3 and print STDERR "   Nixing X node at $i\n";
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          # no need to back-update the counter just yet
          redo;
  
        } elsif($merge and $i != 2 and  # non-initial
           !ref $treelet->[$i] and !ref $treelet->[$i - 1]
        ) {
          DEBUG > 3 and print STDERR "   Merging ", $i-1,
           ":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";
          $treelet->[$i-1] .= ( splice(@$treelet, $i, 1) )[0];
          DEBUG > 4 and print STDERR "    Now: ", $i-1, ":[$treelet->[$i-1]]\n";
          --$i;
          next;
          # since we just pulled the possibly last node out from under
          #  ourselves, we can't just redo()
  
        } elsif( ref $treelet->[$i] ) {
          DEBUG > 4 and print STDERR "  Enqueuing ", pretty($treelet->[$i]), " for traversal.\n";
          push @stack, $treelet->[$i];
  
          if($treelet->[$i][0] eq 'L') {
            my $thing;
            foreach my $attrname ('section', 'to') {
              if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
                unshift @stack, $thing;
                DEBUG > 4 and print STDERR "  +Enqueuing ",
                 pretty( $treelet->[$i][1]{$attrname} ),
                 " as an attribute value to tweak.\n";
              }
            }
          }
        }
      }
    }
    DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _remap_sequences {
    my($self,@stack) = @_;
  
    if(@stack == 1 and @{ $stack[0] } == 3 and !ref $stack[0][2]) {
      # VERY common case: abort it.
      DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";
      return 0;
    }
  
    my $map = ($self->{'accept_codes'} || die "NO accept_codes in $self?!?");
  
    my $start_line = $stack[0][1]{'start_line'};
    DEBUG > 2 and printf
     "\nAbout to start _remap_sequences on treelet from line %s.\n",
     $start_line || '[?]'
    ;
    DEBUG > 3 and print STDERR " Map: ",
      join('; ', map "$_=" . (
          ref($map->{$_}) ? join(",", @{$map->{$_}}) : $map->{$_}
        ),
        sort keys %$map ),
      ("B~C~E~F~I~L~S~X~Z" eq join '~', sort keys %$map)
       ? "  (all normal)\n" : "\n"
    ;
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    my($is, $was, $i, $treelet); # scratch
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
  
        DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";
  
        $is = $treelet->[$i][0] = $map->{ $was = $treelet->[$i][0] };
        if( DEBUG > 3 ) {
          if(!defined $is) {
            print STDERR "   Code $was<> is UNKNOWN!\n";
          } elsif($is eq $was) {
            DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n";
          } else  {
            print STDERR "   Code $was<> maps to ",
             ref($is)
              ? ( "tags ", map("$_<", @$is), '...', map('>', @$is), "\n" )
              : "tag $is<...>.\n";
          }
        }
  
        if(!defined $is) {
          $self->whine($start_line, "Deleting unknown formatting code $was<>");
          $is = $treelet->[$i][0] = '1';  # But saving the children!
          # I could also insert a leading "$was<" and tailing ">" as
          # children of this node, but something about that seems icky.
        }
        if(ref $is) {
          my @dynasty = @$is;
          DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";
          $treelet->[$i][0] = pop @dynasty;
          my $nugget;
          while(@dynasty) {
            DEBUG > 4 and printf
             "    Grafting a new %s node between %s and %s\n",
             $dynasty[-1], $treelet->[0], $treelet->[$i][0],
            ;
  
            #$nugget = ;
            splice @$treelet, $i, 1, [pop(@dynasty), {}, $treelet->[$i]];
              # relace node with a new parent
          }
        } elsif($is eq '0') {
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          --$i;  # back-update the counter
        } elsif($is eq '1') {
          splice(@$treelet, $i, 1 # replace this node with its children!
            => splice @{ $treelet->[$i] },2
                # (not catching its first two (non-child) items)
          );
          --$i;  # back up for new stuff
        } else {
          # otherwise it's unremarkable
          unshift @stack, $treelet->[$i];  # just recurse
        }
      }
    }
  
    DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";
  
    if(@_ == 2 and @{ $_[1] } == 3 and !ref $_[1][2]) {
      DEBUG and print STDERR "Noting that the treelet is now formatless.\n";
      return 0;
    }
    return 1;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _ponder_extend {
  
    # "Go to an extreme, move back to a more comfortable place"
    #  -- /Oblique Strategies/,  Brian Eno and Peter Schmidt
  
    my($self, $para) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";
  
    if($content =~
      m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs
    ) {
      my $new_letter = $1;
      my $fallbacks_one = $2;
      my $elements_one;
      $elements_one = defined($3) ? $3 : $1;
  
      DEBUG > 2 and print STDERR "Extensor has good syntax.\n";
  
      unless($new_letter =~ m/^[A-Z]$/s or $new_letter) {
        DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can extend only formatting codes A-Z, not like \"$new_letter\""
        );
        return;
      }
  
      if(grep $new_letter eq $_, @Known_formatting_codes) {
        DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can't extend an established code like \"$new_letter\""
        );
  
        #TODO: or allow if last bit is same?
  
        return;
      }
  
      unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s  # like "B", "M,I", etc.
        or $fallbacks_one eq '0' or $fallbacks_one eq '1'
      ) {
        $self->whine(
          $para->[1]{'start_line'},
          "Format for second =extend parameter must be like"
          . " M or 1 or 0 or M,N or M,N,O but you have it like "
          . $fallbacks_one
        );
        return;
      }
  
      unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s) { # like "B", "M,I", etc.
        $self->whine(
          $para->[1]{'start_line'},
          "Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like "
          . $elements_one
        );
        return;
      }
  
      my @fallbacks  = split ',', $fallbacks_one,  -1;
      my @elements   = split ',', $elements_one, -1;
  
      foreach my $f (@fallbacks) {
        next if exists $Known_formatting_codes{$f} or $f eq '0' or $f eq '1';
        DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";
        $self->whine(
          $para->[1]{'start_line'},
          "Can't use unknown formatting code '$f' as a fallback for '$new_letter'"
        );
        return;
      }
  
      DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",
       @fallbacks, @elements;
  
      my $canonical_form;
      foreach my $e (@elements) {
        if(exists $self->{'accept_codes'}{$e}) {
          DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";
          $canonical_form = $e;
          last; # first acceptable elementname wins!
        } else {
          DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n";
        }
      }
  
  
      if( defined $canonical_form ) {
        # We found a good N => elementname mapping
        $self->{'accept_codes'}{$new_letter} = $canonical_form;
        DEBUG > 2 and print
         "Extensor maps $new_letter => known element $canonical_form.\n";
      } else {
        # We have to use the fallback(s), which might be '0', or '1'.
        $self->{'accept_codes'}{$new_letter}
          = (@fallbacks == 1) ? $fallbacks[0] : \@fallbacks;
        DEBUG > 2 and print
         "Extensor maps $new_letter => fallbacks @fallbacks.\n";
      }
  
    } else {
      DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";
      $self->whine(
        $para->[1]{'start_line'},
        "Unknown =extend syntax: $content"
      )
    }
    return;
  }
  
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _treat_Zs {  # Nix Z<...>'s
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'Z') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
  
        DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";
  
        # bitch UNLESS it's empty
        unless(  @{$treelet->[$i]} == 2
             or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "A non-empty Z<>" );
        }      # but kill it anyway
  
        splice(@$treelet, $i, 1); # thereby just nix this node.
        --$i;
  
      }
    }
  
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  # Quoting perlpodspec:
  
  # In parsing an L<...> code, Pod parsers must distinguish at least four
  # attributes:
  
  ############# Not used.  Expressed via the element children plus
  #############  the value of the "content-implicit" flag.
  # First:
  # The link-text. If there is none, this must be undef. (E.g., in "L<Perl
  # Functions|perlfunc>", the link-text is "Perl Functions". In
  # "L<Time::HiRes>" and even "L<|Time::HiRes>", there is no link text. Note
  # that link text may contain formatting.)
  #
  
  ############# The element children
  # Second:
  # The possibly inferred link-text -- i.e., if there was no real link text,
  # then this is the text that we'll infer in its place. (E.g., for
  # "L<Getopt::Std>", the inferred link text is "Getopt::Std".)
  #
  
  ############# The "to" attribute (which might be text, or a treelet)
  # Third:
  # The name or URL, or undef if none. (E.g., in "L<Perl
  # Functions|perlfunc>", the name -- also sometimes called the page -- is
  # "perlfunc". In "L</CAVEATS>", the name is undef.)
  #
  
  ############# The "section" attribute (which might be next, or a treelet)
  # Fourth:
  # The section (AKA "item" in older perlpods), or undef if none. E.g., in
  # Getopt::Std/DESCRIPTION, "DESCRIPTION" is the section. (Note that this
  # is not the same as a manpage section like the "5" in "man 5 crontab".
  # "Section Foo" in the Pod sense means the part of the text that's
  # introduced by the heading or item whose text is "Foo".)
  #
  # Pod parsers may also note additional attributes including:
  #
  
  ############# The "type" attribute.
  # Fifth:
  # A flag for whether item 3 (if present) is a URL (like
  # "http://lists.perl.org" is), in which case there should be no section
  # attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
  # possibly a man page name (like "crontab(5)" is).
  #
  
  ############# The "raw" attribute that is already there.
  # Sixth:
  # The raw original L<...> content, before text is split on "|", "/", etc,
  # and before E<...> codes are expanded.
  
  
  # For L<...> codes without a "name|" part, only E<...> and Z<> codes may
  # occur -- no other formatting codes. That is, authors should not use
  # "L<B<Foo::Bar>>".
  #
  # Note, however, that formatting codes and Z<>'s can occur in any and all
  # parts of an L<...> (i.e., in name, section, text, and url).
  
  sub _treat_Ls {  # Process our dear dear friends, the L<...> sequences
  
    # L<name>
    # L<name/"sec"> or L<name/sec>
    # L</"sec"> or L</sec> or L<"sec">
    # L<text|name>
    # L<text|name/"sec"> or L<text|name/sec>
    # L<text|/"sec"> or L<text|/sec> or L<text|"sec">
    # L<scheme:...>
    # L<text|scheme:...>
  
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) {
        # iterate over children of current tree node
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'L') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
  
  
        # By here, $treelet->[$i] is definitely an L node
        my $ell = $treelet->[$i];
        DEBUG > 1 and print STDERR "Ogling L node " . pretty($ell) . "\n";
  
        # bitch if it's empty or is just '/'
        if (@{$ell} == 3 and $ell->[2] =~ m!\A\s*/\s*\z!) {
          $self->whine( $start_line, "L<> contains only '/'" );
          $treelet->[$i] = 'L</>';  # just make it a text node
          next;  # and move on
        }
        if(  @{$ell} == 2
         or (@{$ell} == 3 and $ell->[2] eq '')
        ) {
          $self->whine( $start_line, "An empty L<>" );
          $treelet->[$i] = 'L<>';  # just make it a text node
          next;  # and move on
        }
  
        if( (! ref $ell->[2]  && $ell->[2] =~ /\A\s/)
          ||(! ref $ell->[-1] && $ell->[-1] =~ /\s\z/)
        ) {
          $self->whine( $start_line, "L<> starts or ends with whitespace" );
        }
  
        # Catch URLs:
  
        # there are a number of possible cases:
        # 1) text node containing url: http://foo.com
        #   -> [ 'http://foo.com' ]
        # 2) text node containing url and text: foo|http://foo.com
        #   -> [ 'foo|http://foo.com' ]
        # 3) text node containing url start: mailto:xE<at>foo.com
        #   -> [ 'mailto:x', [ E ... ], 'foo.com' ]
        # 4) text node containing url start and text: foo|mailto:xE<at>foo.com
        #   -> [ 'foo|mailto:x', [ E ... ], 'foo.com' ]
        # 5) other nodes containing text and url start: OE<39>Malley|http://foo.com
        #   -> [ 'O', [ E ... ], 'Malley', '|http://foo.com' ]
        # ... etc.
  
        # anything before the url is part of the text.
        # anything after it is part of the url.
        # the url text node itself may contain parts of both.
  
        if (my ($url_index, $text_part, $url_part) =
          # grep is no good here; we want to bail out immediately so that we can
          # use $1, $2, etc. without having to do the match twice.
          sub {
            for (2..$#$ell) {
              next if ref $ell->[$_];
              next unless $ell->[$_] =~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;
              return ($_, $1, $2);
            }
            return;
          }->()
        ) {
          $ell->[1]{'type'} = 'url';
  
          my @text = @{$ell}[2..$url_index-1];
          push @text, $text_part if defined $text_part;
  
          my @url  = @{$ell}[$url_index+1..$#$ell];
          unshift @url, $url_part;
  
          unless (@text) {
            $ell->[1]{'content-implicit'} = 'yes';
            @text = @url;
          }
  
          $ell->[1]{to} = Pod::Simple::LinkSection->new(
            @url == 1
            ? $url[0]
            : [ '', {}, @url ],
          );
  
          splice @$ell, 2, $#$ell, @text;
  
          next;
        }
  
        # Catch some very simple and/or common cases
        if(@{$ell} == 3 and ! ref $ell->[2]) {
          my $it = $ell->[2];
          if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s) { # man sections
            # Hopefully neither too broad nor too restrictive a RE
            DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";
            $ell->[1]{'type'} = 'man';
            # This's the only place where man links can get made.
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
  
            next;
          }
          if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s) {
            # Extremely forgiving idea of what constitutes a bare
            #  modulename link like L<Foo::Bar> or even L<Thing::1.0::Docs::Tralala>
            DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";
            $ell->[1]{'type'} = 'pod';
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
            next;
          }
          # else fall thru...
        }
  
  
  
        # ...Uhoh, here's the real L<...> parsing stuff...
        # "With the ill behavior, with the ill behavior, with the ill behavior..."
  
        DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";
  
  
        my $link_text; # set to an arrayref if found
        my @ell_content = @$ell;
        splice @ell_content,0,2; # Knock off the 'L' and {} bits
  
        DEBUG > 3 and print STDERR " Ell content to start: ",
         pretty(@ell_content), "\n";
  
  
        # Look for the "|" -- only in CHILDREN (not all underlings!)
        # Like L<I like the strictness|strict>
        DEBUG > 3 and
           print STDERR "  Peering at L content for a '|' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";
  
          if($ell_content[$j] =~ m/^([^\|]*)\|(.*)$/s) {
            my @link_text = ($1);   # might be 0-length
            $ell_content[$j] = $2;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";
  
            if ($link_text[0] =~ m{[|/]}) {
              $self->whine(
                $start_line,
                "alternative text '$link_text[0]' contains non-escaped | or /"
              );
            }
  
            unshift @link_text, splice @ell_content, 0, $j;
              # leaving only things at J and after
            @ell_content =  grep ref($_)||length($_), @ell_content ;
            $link_text   = [grep ref($_)||length($_), @link_text  ];
            DEBUG > 3 and printf
             "  So link text is %s\n  and remaining ell content is %s\n",
              pretty($link_text), pretty(@ell_content);
            last;
          }
        }
  
  
        # Now look for the "/" -- only in CHILDREN (not all underlings!)
        # And afterward, anything left in @ell_content will be the raw name
        # Like L<Foo::Bar/Object Methods>
        my $section_name;  # set to arrayref if found
        DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";
  
          if($ell_content[$j] =~ m/^([^\/]*)\/(.*)$/s) {
            my @section_name = ($2); # might be 0-length
            $ell_content[$j] =  $1;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '/' in it.",
               "  Splitting to page [...$1] + section [$2...]\n";
  
            push @section_name, splice @ell_content, 1+$j;
              # leaving only things before and including J
  
            @ell_content  = grep ref($_)||length($_), @ell_content  ;
            @section_name = grep ref($_)||length($_), @section_name ;
  
            # Turn L<.../"foo"> into L<.../foo>
            if(@section_name
              and !ref($section_name[0]) and !ref($section_name[-1])
              and $section_name[ 0] =~ m/^\"/s
              and $section_name[-1] =~ m/\"$/s
              and !( # catch weird degenerate case of L<"> !
                @section_name == 1 and $section_name[0] eq '"'
              )
            ) {
              $section_name[ 0] =~ s/^\"//s;
              $section_name[-1] =~ s/\"$//s;
              DEBUG > 3 and
               print STDERR "     Quotes removed: ", pretty(@section_name), "\n";
            } else {
              DEBUG > 3 and
               print STDERR "     No need to remove quotes in ", pretty(@section_name), "\n";
            }
  
            $section_name = \@section_name;
            last;
          }
        }
  
        # Turn L<"Foo Bar"> into L</Foo Bar>
        if(!$section_name and @ell_content
           and !ref($ell_content[0]) and !ref($ell_content[-1])
           and $ell_content[ 0] =~ m/^\"/s
           and $ell_content[-1] =~ m/\"$/s
           and !( # catch weird degenerate case of L<"> !
             @ell_content == 1 and $ell_content[0] eq '"'
           )
        ) {
          $section_name = [splice @ell_content];
          $section_name->[ 0] =~ s/^\"//s;
          $section_name->[-1] =~ s/\"$//s;
          $ell->[1]{'~tolerated'} = 1;
        }
  
        # Turn L<Foo Bar> into L</Foo Bar>.
        if(!$section_name and !$link_text and @ell_content
           and grep !ref($_) && m/ /s, @ell_content
        ) {
          $section_name = [splice @ell_content];
          $ell->[1]{'~deprecated'} = 1;
          # That's support for the now-deprecated syntax.
          # Note that it deliberately won't work on L<...|Foo Bar>
        }
  
  
        # Now make up the link_text
        # L<Foo>     -> L<Foo|Foo>
        # L</Bar>    -> L<"Bar"|Bar>
        # L<Foo/Bar> -> L<"Bar" in Foo/Foo>
        unless($link_text) {
          $ell->[1]{'content-implicit'} = 'yes';
          $link_text = [];
          push @$link_text, '"', @$section_name, '"' if $section_name;
  
          if(@ell_content) {
            $link_text->[-1] .= ' in ' if $section_name;
            push @$link_text, @ell_content;
          }
        }
  
  
        # And the E resolver will have to deal with all our treeletty things:
  
        if(@ell_content == 1 and !ref($ell_content[0])
           and $ell_content[0] =~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s
        ) {
          $ell->[1]{'type'}    = 'man';
          DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n";
        } else {
          $ell->[1]{'type'}    = 'pod';
          DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n";
        }
  
        if( defined $section_name ) {
          $ell->[1]{'section'} = Pod::Simple::LinkSection->new(
            ['', {}, @$section_name]
          );
          DEBUG > 3 and print STDERR "L-section content: ", pretty($ell->[1]{'section'}), "\n";
        }
  
        if( @ell_content ) {
          $ell->[1]{'to'} = Pod::Simple::LinkSection->new(
            ['', {}, @ell_content]
          );
          DEBUG > 3 and print STDERR "L-to content: ", pretty($ell->[1]{'to'}), "\n";
        }
  
        # And update children to be the link-text:
        @$ell = (@$ell[0,1], defined($link_text) ? splice(@$link_text) : '');
  
        DEBUG > 2 and print STDERR "End of L-parsing for this node " . pretty($treelet->[$i]) . "\n";
  
        unshift @stack, $treelet->[$i]; # might as well recurse
      }
    }
  
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Es {
    my($self,@stack) = @_;
  
    my($i, $treelet, $content, $replacer, $charnum);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
  
    # Has frightening side effects on L nodes' attributes.
  
    #my @ells_to_tweak;
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        if($treelet->[$i][0] eq 'L') {
          # SPECIAL STUFF for semi-processed L<>'s
  
          my $thing;
          foreach my $attrname ('section', 'to') {
            if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
              unshift @stack, $thing;
              DEBUG > 2 and print STDERR "  Enqueuing ",
               pretty( $treelet->[$i][1]{$attrname} ),
               " as an attribute value to tweak.\n";
            }
          }
  
          unshift @stack, $treelet->[$i]; # recurse
          next;
        } elsif($treelet->[$i][0] ne 'E') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
  
        DEBUG > 1 and print STDERR "Ogling E node ", pretty($treelet->[$i]), "\n";
  
        # bitch if it's empty
        if(  @{$treelet->[$i]} == 2
         or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "An empty E<>" );
          $treelet->[$i] = 'E<>'; # splice in a literal
          next;
        }
  
        # bitch if content is weird
        unless(@{$treelet->[$i]} == 3 and !ref($content = $treelet->[$i][2])) {
          $self->whine( $start_line, "An E<...> surrounding strange content" );
          $replacer = $treelet->[$i]; # scratch
          splice(@$treelet, $i, 1,   # fake out a literal
            'E<',
            splice(@$replacer,2), # promote its content
            '>'
          );
          # Don't need to do --$i, as the 'E<' we just added isn't interesting.
          next;
        }
  
        DEBUG > 1 and print STDERR "Ogling E<$content>\n";
  
        # XXX E<>'s contents *should* be a valid char in the scope of the current
        # =encoding directive. Defaults to iso-8859-1, I believe. Fix this in the
        # future sometime.
  
        $charnum  = Pod::Escapes::e2charnum($content);
        DEBUG > 1 and print STDERR " Considering E<$content> with char ",
          defined($charnum) ? $charnum : "undef", ".\n";
  
        if(!defined( $charnum )) {
          DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";
          $self->whine( $start_line, "Unknown E content in E<$content>" );
          $replacer = "E<$content>"; # better than nothing
        } elsif($charnum >= 255 and !UNICODE) {
          $replacer = ASCII ? "\xA4" : "?";
          DEBUG > 1 and print STDERR "This Perl version can't handle ",
            "E<$content> (chr $charnum), so replacing with $replacer\n";
        } else {
          $replacer = Pod::Escapes::e2char($content);
          DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n";
        }
  
        splice(@$treelet, $i, 1, $replacer); # no need to back up $i, tho
      }
    }
  
    return;
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Ss {
    my($self,$treelet) = @_;
  
    _change_S_to_nbsp($treelet,0) if $self->{'nbsp_for_S'};
  
    # TODO: or a change_nbsp_to_S
    #  Normalizing nbsp's to S is harder: for each text node, make S content
    #  out of anything matching m/([^ \xA0]*(?:\xA0+[^ \xA0]*)+)/
  
  
    return;
  }
  
  sub _change_S_to_nbsp { #  a recursive function
    # Sanely assumes that the top node in the excursion won't be an S node.
    my($treelet, $in_s) = @_;
  
    my $is_s = ('S' eq $treelet->[0]);
    $in_s ||= $is_s; # So in_s is on either by this being an S element,
                     #  or by an ancestor being an S element.
  
    for(my $i = 2; $i < @$treelet; ++$i) {
      if(ref $treelet->[$i]) {
        if( _change_S_to_nbsp( $treelet->[$i], $in_s ) ) {
          my $to_pull_up = $treelet->[$i];
          splice @$to_pull_up,0,2;   # ...leaving just its content
          splice @$treelet, $i, 1, @$to_pull_up;  # Pull up content
          $i +=  @$to_pull_up - 1;   # Make $i skip the pulled-up stuff
        }
      } else {
        $treelet->[$i] =~ s/\s/$Pod::Simple::nbsp/g if $in_s;
  
         # Note that if you apply nbsp_for_S to text, and so turn
         # "foo S<bar baz> quux" into "foo bar&#160;faz quux", you
         # end up with something that fails to say "and don't hyphenate
         # any part of 'bar baz'".  However, hyphenation is such a vexing
         # problem anyway, that most Pod renderers just don't render it
         # at all.  But if you do want to implement hyphenation, I guess
         # that you'd better have nbsp_for_S off.
      }
    }
  
    return $is_s;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _accessorize {  # A simple-minded method-maker
    no strict 'refs';
    foreach my $attrname (@_) {
      next if $attrname =~ m/::/; # a hack
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
  
        (@_ == 1) ?  $_[0]->{$attrname}
                  : ($_[0]->{$attrname} = $_[1]);
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #=============================================================================
  
  sub filter {
    my($class, $source) = @_;
    my $new = $class->new;
    $new->output_fh(*STDOUT{IO});
  
    if(ref($source || '') eq 'SCALAR') {
      $new->parse_string_document( $$source );
    } elsif(ref($source)) {  # it's a file handle
      $new->parse_file($source);
    } else {  # it's a filename
      $new->parse_file($source);
    }
  
    return $new;
  }
  
  
  #-----------------------------------------------------------------------------
  
  sub _out {
    # For use in testing: Class->_out($source)
    #  returns the transformation of $source
  
    my $class = shift(@_);
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    DEBUG and print STDERR "\n\n", '#' x 76,
     "\nAbout to parse source: {{\n$_[0]\n}}\n\n";
  
  
    my $parser = ref $class && $class->isa(__PACKAGE__) ? $class : $class->new;
    $parser->hide_line_numbers(1);
  
    my $out = '';
    $parser->output_string( \$out );
    DEBUG and print STDERR " _out to ", \$out, "\n";
  
    $mutor->($parser) if $mutor;
  
    $parser->parse_string_document( $_[0] );
    # use Data::Dumper; print STDERR Dumper($parser), "\n";
    return $out;
  }
  
  
  sub _duo {
    # For use in testing: Class->_duo($source1, $source2)
    #  returns the parse trees of $source1 and $source2.
    # Good in things like: &ok( Class->duo(... , ...) );
  
    my $class = shift(@_);
  
    Carp::croak "But $class->_duo is useful only in list context!"
     unless wantarray;
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    Carp::croak "But $class->_duo takes two parameters, not: @_"
     unless @_ == 2;
  
    my(@out);
  
    while( @_ ) {
      my $parser = $class->new;
  
      push @out, '';
      $parser->output_string( \( $out[-1] ) );
  
      DEBUG and print STDERR " _duo out to ", $parser->output_string(),
        " = $parser->{'output_string'}\n";
  
      $parser->hide_line_numbers(1);
      $mutor->($parser) if $mutor;
      $parser->parse_string_document( shift( @_ ) );
      # use Data::Dumper; print STDERR Dumper($parser), "\n";
    }
  
    return @out;
  }
  
  
  
  #-----------------------------------------------------------------------------
  1;
  __END__
  
  TODO:
  A start_formatting_code and end_formatting_code methods, which in the
  base class call start_L, end_L, start_C, end_C, etc., if they are
  defined.
  
  have the POD FORMATTING ERRORS section note the localtime, and the
  version of Pod::Simple.
  
  option to delete all E<shy>s?
  option to scream if under-0x20 literals are found in the input, or
  under-E<32> E codes are found in the tree. And ditto \x7f-\x9f
  
  Option to turn highbit characters into their compromised form? (applies
  to E parsing too)
  
  TODO: BOM/encoding things.
  
  TODO: ascii-compat things in the XML classes?
  
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;
  #
  # "What's in the box?"  "Pain."
  #
  ###########################################################################
  #
  # This is where all the scary things happen: parsing lines into
  #  paragraphs; and then into directives, verbatims, and then also
  #  turning formatting sequences into treelets.
  #
  # Are you really sure you want to read this code?
  #
  #-----------------------------------------------------------------------------
  #
  # The basic work of this module Pod::Simple::BlackBox is doing the dirty work
  # of parsing Pod into treelets (generally one per non-verbatim paragraph), and
  # to call the proper callbacks on the treelets.
  #
  # Every node in a treelet is a ['name', {attrhash}, ...children...]
  
  use integer; # vroom!
  use strict;
  use warnings;
  use Carp ();
  our $VERSION = '3.45';
  #use constant DEBUG => 7;
  
  sub my_qr ($$) {
  
      # $1 is a pattern to compile and return.  Older perls compile any
      # syntactically valid property, even if it isn't legal.  To cope with
      # this, return an empty string unless the compiled pattern also
      # successfully matches $2, which the caller furnishes.
  
      my ($input_re, $should_match) = @_;
      # XXX could have a third parameter $shouldnt_match for extra safety
  
      my $use_utf8 = ($] le 5.006002) ? 'use utf8;' : "";
  
      my $re = eval "no warnings; $use_utf8 qr/$input_re/";
      #print STDERR  __LINE__, ": $input_re: $@\n" if $@;
      return "" if $@;
  
      my $matches = eval "no warnings; $use_utf8 '$should_match' =~ /$re/";
      #print STDERR  __LINE__, ": $input_re: $@\n" if $@;
      return "" if $@;
  
      #print STDERR  __LINE__, ": SUCCESS: $re\n" if $matches;
      return $re if $matches;
  
      #print STDERR  __LINE__, ": $re: didn't match\n";
      return "";
  }
  
  BEGIN {
    require Pod::Simple;
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
  }
  
  # Matches a character iff the character will have a different meaning
  # if we choose CP1252 vs UTF-8 if there is no =encoding line.
  # This is broken for early Perls on non-ASCII platforms.
  my $non_ascii_re = my_qr('[[:^ascii:]]', "\xB6");
  $non_ascii_re = qr/[\x80-\xFF]/ unless $non_ascii_re;
  
  # Use patterns understandable by Perl 5.6, if possible
  my $cs_re = do { no warnings; my_qr('\p{IsCs}', "\x{D800}") };
  my $cn_re = my_qr('\p{IsCn}', "\x{09E4}");  # <reserved> code point unlikely
                                              # to get assigned
  my $rare_blocks_re = my_qr('[\p{InIPAExtensions}\p{InSpacingModifierLetters}]',
                             "\x{250}");
  $rare_blocks_re = my_qr('[\x{0250}-\x{02FF}]', "\x{250}") unless $rare_blocks_re;
  
  my $script_run_re = eval 'no warnings "experimental::script_run";
                            qr/(*script_run: ^ .* $ )/x';
  my $latin_re = my_qr('[\p{IsLatin}\p{IsInherited}\p{IsCommon}]', "\x{100}");
  unless ($latin_re) {
      # This was machine generated to be the ranges of the union of the above
      # three properties, with things that were undefined by Unicode 4.1 filling
      # gaps.  That is the version in use when Perl advanced enough to
      # successfully compile and execute the above pattern.
      $latin_re = my_qr('[\x00-\x{02E9}\x{02EC}-\x{0374}\x{037E}\x{0385}\x{0387}\x{0485}\x{0486}\x{0589}\x{060C}\x{061B}\x{061F}\x{0640}\x{064B}-\x{0655}\x{0670}\x{06DD}\x{0951}-\x{0954}\x{0964}\x{0965}\x{0E3F}\x{10FB}\x{16EB}-\x{16ED}\x{1735}\x{1736}\x{1802}\x{1803}\x{1805}\x{1D00}-\x{1D25}\x{1D2C}-\x{1D5C}\x{1D62}-\x{1D65}\x{1D6B}-\x{1D77}\x{1D79}-\x{1DBE}\x{1DC0}-\x{1EF9}\x{2000}-\x{2125}\x{2127}-\x{27FF}\x{2900}-\x{2B13}\x{2E00}-\x{2E1D}\x{2FF0}-\x{3004}\x{3006}\x{3008}-\x{3020}\x{302A}-\x{302D}\x{3030}-\x{3037}\x{303C}-\x{303F}\x{3099}-\x{309C}\x{30A0}\x{30FB}\x{30FC}\x{3190}-\x{319F}\x{31C0}-\x{31CF}\x{3220}-\x{325F}\x{327F}-\x{32CF}\x{3358}-\x{33FF}\x{4DC0}-\x{4DFF}\x{A700}-\x{A716}\x{FB00}-\x{FB06}\x{FD3E}\x{FD3F}\x{FE00}-\x{FE6B}\x{FEFF}-\x{FF65}\x{FF70}\x{FF9E}\x{FF9F}\x{FFE0}-\x{FFFD}\x{10100}-\x{1013F}\x{1D000}-\x{1D1DD}\x{1D300}-\x{1D7FF}]', "\x{100}");
  }
  
  my $every_char_is_latin_re = my_qr("^(?:$latin_re)*\\z", "A");
  
  # Latin script code points not in the first release of Unicode
  my $later_latin_re = my_qr('[^\P{IsLatin}\p{IsAge=1.1}]', "\x{1F6}");
  
  # If this perl doesn't have the Deprecated property, there's only one code
  # point in it that we need be concerned with.
  my $deprecated_re = my_qr('\p{IsDeprecated}', "\x{149}");
  $deprecated_re = qr/\x{149}/ unless $deprecated_re;
  
  my $utf8_bom;
  if (($] ge 5.007_003)) {
    $utf8_bom = "\x{FEFF}";
    utf8::encode($utf8_bom);
  } else {
    $utf8_bom = "\xEF\xBB\xBF";   # No EBCDIC BOM detection for early Perls.
  }
  
  # This is used so that the 'content_seen' method doesn't return true on a
  # file that just happens to have a line that matches /^=[a-zA-z]/.  Only if
  # there is a valid =foo line will we return that content was seen.
  my $seen_legal_directive = 0;
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_line { shift->parse_lines(@_) } # alias
  
  # - - -  Turn back now!  Run away!  - - -
  
  sub parse_lines {             # Usage: $parser->parse_lines(@lines)
    # an undef means end-of-stream
    my $self = shift;
  
    my $code_handler = $self->{'code_handler'};
    my $cut_handler  = $self->{'cut_handler'};
    my $wl_handler   = $self->{'whiteline_handler'};
    $self->{'line_count'} ||= 0;
  
    my $scratch;
  
    DEBUG > 4 and
     print STDERR "# Parsing starting at line ", $self->{'line_count'}, ".\n";
  
    DEBUG > 5 and
     print STDERR "#  About to parse lines: ",
       join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
  
    my $paras = ($self->{'paras'} ||= []);
     # paragraph buffer.  Because we need to defer processing of =over
     # directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
     # to process this.
  
    $self->{'pod_para_count'} ||= 0;
  
    # An attempt to match the pod portions of a line.  This is not fool proof,
    # but is good enough to serve as part of the heuristic for guessing the pod
    # encoding if not specified.
    my $codes = join '', grep { / ^ [A-Za-z] $/x } sort keys %{$self->{accept_codes}};
    my $pod_chars_re = qr/ ^ = [A-Za-z]+ | [\Q$codes\E] < /x;
  
    my $line;
    foreach my $source_line (@_) {
      if( $self->{'source_dead'} ) {
        DEBUG > 4 and print STDERR "# Source is dead.\n";
        last;
      }
  
      unless( defined $source_line ) {
        DEBUG > 4 and print STDERR "# Undef-line seen.\n";
  
        push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
        push @$paras, $paras->[-1], $paras->[-1];
         # So that it definitely fills the buffer.
        $self->{'source_dead'} = 1;
        $self->_ponder_paragraph_buffer;
        next;
      }
  
  
      if( $self->{'line_count'}++ ) {
        ($line = $source_line) =~ tr/\n\r//d;
         # If we don't have two vars, we'll end up with that there
         # tr/// modding the (potentially read-only) original source line!
  
      } else {
        DEBUG > 2 and print STDERR "First line: [$source_line]\n";
  
        if( ($line = $source_line) =~ s/^$utf8_bom//s ) {
          DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
          $self->_handle_encoding_line( "=encoding utf8" );
          delete $self->{'_processed_encoding'};
          $line =~ tr/\n\r//d;
  
        } elsif( $line =~ s/^\xFE\xFF//s ) {
          DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } elsif( $line =~ s/^\xFF\xFE//s ) {
          DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } else {
          DEBUG > 2 and print STDERR "First line is BOM-less.\n";
          ($line = $source_line) =~ tr/\n\r//d;
        }
      }
  
      if(!$self->{'parse_characters'} && !$self->{'encoding'}
        && ($self->{'in_pod'} || $line =~ /^=/s)
        && $line =~ /$non_ascii_re/
      ) {
  
        my $encoding;
  
        # No =encoding line, and we are at the first pod line in the input that
        # contains a non-ascii byte, that is, one whose meaning varies depending
        # on whether the file is encoded in UTF-8 or CP1252, which are the two
        # possibilities permitted by the pod spec.  (ASCII is assumed if the
        # file only contains ASCII bytes.)  In order to process this line, we
        # need to figure out what encoding we will use for the file.
        #
        # Strictly speaking ISO 8859-1 (Latin 1) refers to the code points
        # 160-255, but it is used here, as it often colloquially is, to refer to
        # the complete set of code points 0-255, including ASCII (0-127), the C1
        # controls (128-159), and strict Latin 1 (160-255).
        #
        # CP1252 is effectively a superset of Latin 1, because it differs only
        # from colloquial 8859-1 in the C1 controls, which are very unlikely to
        # actually be present in 8859-1 files, so can be used for other purposes
        # without conflict.  CP 1252 uses most of them for graphic characters.
        #
        # Note that all ASCII-range bytes represent their corresponding code
        # points in both CP1252 and UTF-8.  In ASCII platform UTF-8, all other
        # code points require multiple (non-ASCII) bytes to represent.  (A
        # separate paragraph for EBCDIC is below.)  The multi-byte
        # representation is quite structured.  If we find an isolated byte that
        # would require multiple bytes to represent in UTF-8, we know that the
        # encoding is not UTF-8.  If we find a sequence of bytes that violates
        # the UTF-8 structure, we also can presume the encoding isn't UTF-8, and
        # hence must be 1252.
        #
        # But there are ambiguous cases where we could guess wrong.  If so, the
        # user will end up having to supply an =encoding line.  We use all
        # readily available information to improve our chances of guessing
        # right.  The odds of something not being UTF-8, but still passing a
        # UTF-8 validity test go down very rapidly with increasing length of the
        # sequence.  Therefore we look at all non-ascii sequences on the line.
        # If any of the sequences can't be UTF-8, we quit there and choose
        # CP1252.  If all could be UTF-8, we see if any of the code points
        # represented are unlikely to be in pod.  If so, we guess CP1252.  If
        # not, we check if the line is all in the same script; if not guess
        # CP1252; otherwise UTF-8.  For perls that don't have convenient script
        # run testing, see if there is both Latin and non-Latin.  If so, CP1252,
        # otherwise UTF-8.
        #
        # On EBCDIC platforms, the situation is somewhat different.  In
        # UTF-EBCDIC, not only do ASCII-range bytes represent their code points,
        # but so do the bytes that are for the C1 controls.  Recall that these
        # correspond to the unused portion of 8859-1 that 1252 mostly takes
        # over.  That means that there are fewer code points that are
        # represented by multi-bytes.  But, note that the these controls are
        # very unlikely to be in pod text.  So if we encounter one of them, it
        # means that it is quite likely CP1252 and not UTF-8.  The net result is
        # the same code below is used for both platforms.
        #
        # XXX probably if the line has E<foo> that evaluates to illegal CP1252,
        # then it is UTF-8.  But we haven't processed E<> yet.
  
        goto set_1252 if $] lt 5.006_000;    # No UTF-8 on very early perls
  
        my $copy;
  
        no warnings 'utf8';
  
        if ($] ge 5.007_003) {
          $copy = $line;
  
          # On perls that have this function, we can use it to easily see if the
          # sequence is valid UTF-8 or not; if valid it turns on the UTF-8 flag
          # needed below for script run detection
          goto set_1252 if ! utf8::decode($copy);
        }
        elsif (ord("A") != 65) {  # Early EBCDIC, assume UTF-8.  What's a windows
                                  # code page doing here anyway?
          goto set_utf8;
        }
        else { # ASCII, no decode(): do it ourselves using the fundamental
               # characteristics of UTF-8
          use if $] le 5.006002, 'utf8';
  
          my $char_ord;
          my $needed;         # How many continuation bytes to gobble up
  
          # Initialize the translated line with a dummy character that will be
          # deleted after everything else is done.  This dummy makes sure that
          # $copy will be in UTF-8.  Doing it now avoids the bugs in early perls
          # with upgrading in the middle
          $copy = chr(0x100);
  
          # Parse through the line
          for (my $i = 0; $i < length $line; $i++) {
            my $byte = substr($line, $i, 1);
  
            # ASCII bytes are trivially dealt with
            if ($byte !~ $non_ascii_re) {
              $copy .= $byte;
              next;
            }
  
            my $b_ord = ord $byte;
  
            # Now figure out what this code point would be if the input is
            # actually in UTF-8.  If, in the process, we discover that it isn't
            # well-formed UTF-8, we guess CP1252.
            #
            # Start the process.  If it is UTF-8, we are at the first, start
            # byte, of a multi-byte sequence.  We look at this byte to figure
            # out how many continuation bytes are needed, and to initialize the
            # code point accumulator with the data from this byte.
            #
            # Normally the minimum continuation byte is 0x80, but in certain
            # instances the minimum is a higher number.  So the code below
            # overrides this for those instances.
            my $min_cont = 0x80;
  
            if ($b_ord < 0xC2) { #  A start byte < C2 is malformed
              goto set_1252;
            }
            elsif ($b_ord <= 0xDF) {
              $needed = 1;
              $char_ord = $b_ord & 0x1F;
            }
            elsif ($b_ord <= 0xEF) {
              $min_cont = 0xA0 if $b_ord == 0xE0;
              $needed = 2;
              $char_ord = $b_ord & (0x1F >> 1);
            }
            elsif ($b_ord <= 0xF4) {
              $min_cont = 0x90 if $b_ord == 0xF0;
              $needed = 3;
              $char_ord = $b_ord & (0x1F >> 2);
            }
            else { # F4 is the highest start byte for legal Unicode; higher is
                   # unlikely to be in pod.
              goto set_1252;
            }
  
            # ? not enough continuation bytes available
            goto set_1252 if $i + $needed >= length $line;
  
            # Accumulate the ordinal of the character from the remaining
            # (continuation) bytes.
            while ($needed-- > 0) {
              my $cont = substr($line, ++$i, 1);
              $b_ord = ord $cont;
              goto set_1252 if $b_ord < $min_cont || $b_ord > 0xBF;
  
              # In all cases, any next continuation bytes all have the same
              # minimum legal value
              $min_cont = 0x80;
  
              # Accumulate this byte's contribution to the code point
              $char_ord <<= 6;
              $char_ord |= ($b_ord & 0x3F);
            }
  
            # Here, the sequence that formed this code point was valid UTF-8,
            # so add the completed character to the output
            $copy .= chr $char_ord;
          } # End of loop through line
  
          # Delete the dummy first character
          $copy = substr($copy, 1);
        }
  
        # Here, $copy is legal UTF-8.
  
        # If it can't be legal CP1252, no need to look further.  (These bytes
        # aren't valid in CP1252.)  This test could have been placed higher in
        # the code, but it seemed wrong to set the encoding to UTF-8 without
        # making sure that the very first instance is well-formed.  But what if
        # it isn't legal CP1252 either?  We have to choose one or the other, and
        # It seems safer to favor the single-byte encoding over the multi-byte.
        goto set_utf8 if ord("A") == 65 && $line =~ /[\x81\x8D\x8F\x90\x9D]/;
  
        # The C1 controls are not likely to appear in pod
        goto set_1252 if ord("A") == 65 && $copy =~ /[\x80-\x9F]/;
  
        # Nor are surrogates nor unassigned, nor deprecated.
        DEBUG > 8 and print STDERR __LINE__, ": $copy: surrogate\n" if $copy =~ $cs_re;
        goto set_1252 if $cs_re && $copy =~ $cs_re;
        DEBUG > 8 and print STDERR __LINE__, ": $copy: unassigned\n" if $cn_re && $copy =~ $cn_re;
        goto set_1252 if $cn_re && $copy =~ $cn_re;
        DEBUG > 8 and print STDERR __LINE__, ": $copy: deprecated\n" if $copy =~ $deprecated_re;
        goto set_1252 if $copy =~ $deprecated_re;
  
        # Nor are rare code points.  But this is hard to determine.  khw
        # believes that IPA characters and the modifier letters are unlikely to
        # be in pod (and certainly very unlikely to be the in the first line in
        # the pod containing non-ASCII)
        DEBUG > 8 and print STDERR __LINE__, ": $copy: rare\n" if $copy =~ $rare_blocks_re;
        goto set_1252 if $rare_blocks_re && $copy =~ $rare_blocks_re;
  
        # The first Unicode version included essentially every Latin character
        # in modern usage.  So, a Latin character not in the first release will
        # unlikely be in pod.
        DEBUG > 8 and print STDERR __LINE__, ": $copy: later_latin\n" if $later_latin_re && $copy =~ $later_latin_re;
        goto set_1252 if $later_latin_re && $copy =~ $later_latin_re;
  
        # On perls that handle script runs, if the UTF-8 interpretation yields
        # a single script, we guess UTF-8, otherwise just having a mixture of
        # scripts is suspicious, so guess CP1252.  We first strip off, as best
        # we can, the ASCII characters that look like they are pod directives,
        # as these would always show as mixed with non-Latin text.
        $copy =~ s/$pod_chars_re//g;
  
        if ($script_run_re) {
          goto set_utf8 if $copy =~ $script_run_re;
          DEBUG > 8 and print STDERR __LINE__, ":  not script run\n";
          goto set_1252;
        }
  
        # Even without script runs, but on recent enough perls and Unicodes, we
        # can check if there is a mixture of both Latin and non-Latin.  Again,
        # having a mixture of scripts is suspicious, so assume CP1252
  
        # If it's all non-Latin, there is no CP1252, as that is Latin
        # characters and punct, etc.
        DEBUG > 8 and print STDERR __LINE__, ": $copy: not latin\n" if $copy !~ $latin_re;
        goto set_utf8 if $copy !~ $latin_re;
  
        DEBUG > 8 and print STDERR __LINE__, ": $copy: all latin\n" if $copy =~ $every_char_is_latin_re;
        goto set_utf8 if $copy =~ $every_char_is_latin_re;
  
        DEBUG > 8 and print STDERR __LINE__, ": $copy: mixed\n";
  
       set_1252:
        DEBUG > 9 and print STDERR __LINE__, ": $copy: is 1252\n";
        $encoding = 'CP1252';
        goto done_set;
  
       set_utf8:
        DEBUG > 9 and print STDERR __LINE__, ": $copy: is UTF-8\n";
        $encoding = 'UTF-8';
  
       done_set:
        $self->_handle_encoding_line( "=encoding $encoding" );
        delete $self->{'_processed_encoding'};
        $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
        my ($word) = $line =~ /(\S*$non_ascii_re\S*)/;
  
        $self->whine(
          $self->{'line_count'},
          "Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
        );
      }
  
      DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";
  
      if(!$self->{'in_pod'}) {
        if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s) {
          if($1 eq 'cut') {
            $self->scream(
              $self->{'line_count'},
              "=cut found outside a pod block.  Skipping to next block."
            );
  
            ## Before there were errata sections in the world, it was
            ## least-pessimal to abort processing the file.  But now we can
            ## just barrel on thru (but still not start a pod block).
            #splice @_;
            #push @_, undef;
  
            next;
          } else {
            $self->{'in_pod'} = $self->{'start_of_pod_block'}
                              = $self->{'last_was_blank'}     = 1;
            # And fall thru to the pod-mode block further down
          }
        } else {
          DEBUG > 5 and print STDERR "# It's a code-line.\n";
          $code_handler->(map $_, $line, $self->{'line_count'}, $self)
           if $code_handler;
          # Note: this may cause code to be processed out of order relative
          #  to pods, but in order relative to cuts.
  
          # Note also that we haven't yet applied the transcoding to $line
          #  by time we call $code_handler!
  
          if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
            # That RE is from perlsyn, section "Plain Old Comments (Not!)",
            #$fname = $2 if defined $2;
            #DEBUG > 1 and defined $2 and print STDERR "# Setting fname to \"$fname\"\n";
            DEBUG > 1 and print STDERR "# Setting nextline to $1\n";
            $self->{'line_count'} = $1 - 1;
          }
  
          next;
        }
      }
  
      # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
      # Else we're in pod mode:
  
      # Apply any necessary transcoding:
      $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
      # HERE WE CATCH =encoding EARLY!
      if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
        next if $self->parse_characters;   # Ignore this line
        $line = $self->_handle_encoding_line( $line );
      }
  
      if($line =~ m/^=cut/s) {
        # here ends the pod block, and therefore the previous pod para
        DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";
        $self->{'in_pod'} = 0;
        # ++$self->{'pod_para_count'};
        $self->_ponder_paragraph_buffer();
         # by now it's safe to consider the previous paragraph as done.
        DEBUG > 6 and print STDERR "Processing any cut handler, line ${$self}{'line_count'}\n";
        $cut_handler->(map $_, $line, $self->{'line_count'}, $self)
         if $cut_handler;
  
        # TODO: add to docs: Note: this may cause cuts to be processed out
        #  of order relative to pods, but in order relative to code.
  
      } elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
        if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
          $wl_handler->(map $_, $line, $self->{'line_count'}, $self)
            if $wl_handler;
        }
  
        if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
          DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";
          push @{$paras->[-1]}, $line;
        }  # otherwise it's not interesting
  
        if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
          DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n";
        }
  
        $self->{'last_was_blank'} = 1;
  
      } elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
  
        if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(\s+|$)(.*)/s) {
          # THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
          my $new = [$1, {'start_line' => $self->{'line_count'}}, $3];
          $new->[1]{'~orig_spacer'} = $2 if $2 && $2 ne " ";
           # Note that in "=head1 foo", the WS is lost.
           # Example: ['=head1', {'start_line' => 123}, ' foo']
  
          ++$self->{'pod_para_count'};
  
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
  
          push @$paras, $new; # the new incipient paragraph
          DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
  
        } elsif($line =~ m/^\s/s) {
  
          if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
            DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";
            push @{$paras->[-1]}, $line;
          } else {
            ++$self->{'pod_para_count'};
            $self->_ponder_paragraph_buffer();
             # by now it's safe to consider the previous paragraph as done.
            DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";
            push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
          }
        } else {
          ++$self->{'pod_para_count'};
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
          push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
          DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
  
      } else {
        # It's a non-blank line /continuing/ the current para
        if(@$paras) {
          DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";
          push @{$paras->[-1]}, $line;
        } else {
          # Unexpected case!
          die "Continuing a paragraph but \@\$paras is empty?";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
      }
  
    } # ends the big while loop
  
    DEBUG > 1 and print STDERR (pretty(@$paras), "\n");
    return $self;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_encoding_line {
    my($self, $line) = @_;
  
    return if $self->parse_characters;
  
    # The point of this routine is to set $self->{'_transcoder'} as indicated.
  
    return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
    DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";
  
    my $e    = $1;
    my $orig = $e;
    push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
  
    my $enc_error;
  
    # Cf.   perldoc Encode   and   perldoc Encode::Supported
  
    require Pod::Simple::Transcode;
  
    if( $self->{'encoding'} ) {
      my $norm_current = $self->{'encoding'};
      my $norm_e = $e;
      foreach my $that ($norm_current, $norm_e) {
        $that =  lc($that);
        $that =~ s/[-_]//g;
      }
      if($norm_current eq $norm_e) {
        DEBUG > 1 and print STDERR "The '=encoding $orig' line is ",
         "redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
        $enc_error = '';
         # But that doesn't necessarily mean that the earlier one went okay
      } else {
        $enc_error = "Encoding is already set to " . $self->{'encoding'};
        DEBUG > 1 and print STDERR $enc_error;
      }
    } elsif (
      # OK, let's turn on the encoding
      do {
        DEBUG > 1 and print STDERR " Setting encoding to $e\n";
        $self->{'encoding'} = $e;
        1;
      }
      and $e eq 'HACKRAW'
    ) {
      DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n";
  
    } elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
  
      die($enc_error = "WHAT? _transcoder is already set?!")
       if $self->{'_transcoder'};   # should never happen
      require Pod::Simple::Transcode;
      $self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
      eval {
        my @x = ('', "abc", "123");
        $self->{'_transcoder'}->(@x);
      };
      $@ && die( $enc_error =
        "Really unexpected error setting up encoding $e: $@\nAborting"
      );
      $self->{'detected_encoding'} = $e;
  
    } else {
      my @supported = Pod::Simple::Transcode::->all_encodings;
  
      # Note unsupported, and complain
      DEBUG and print STDERR " Encoding [$e] is unsupported.",
        "\nSupporteds: @supported\n";
      my $suggestion = '';
  
      # Look for a near match:
      my $norm = lc($e);
      $norm =~ tr[-_][]d;
      my $n;
      foreach my $enc (@supported) {
        $n = lc($enc);
        $n =~ tr[-_][]d;
        next unless $n eq $norm;
        $suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
        last;
      }
      my $encmodver = Pod::Simple::Transcode::->encmodver;
      $enc_error = join '' =>
        "This document probably does not appear as it should, because its ",
        "\"=encoding $e\" line calls for an unsupported encoding.",
        $suggestion, "  [$encmodver\'s supported encodings are: @supported]"
      ;
  
      $self->scream( $self->{'line_count'}, $enc_error );
    }
    push @{ $self->{'encoding_command_statuses'} }, $enc_error;
    if (defined($self->{'_processed_encoding'})) {
      # Double declaration.
      $self->scream( $self->{'line_count'}, 'Cannot have multiple =encoding directives');
    }
    $self->{'_processed_encoding'} = $orig;
  
    return $line;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _handle_encoding_second_level {
    # By time this is called, the encoding (if well formed) will already
    #  have been acted on.
    my($self, $para) = @_;
    my @x = @$para;
    my $content = join ' ', splice @x, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";
  
    if (defined($self->{'_processed_encoding'})) {
      #if($content ne $self->{'_processed_encoding'}) {
      #  Could it happen?
      #}
      delete $self->{'_processed_encoding'};
      # It's already been handled.  Check for errors.
      if(! $self->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n";
      } elsif( $self->{'encoding_command_statuses'}[-1] ) {
        $self->whine( $para->[1]{'start_line'},
          sprintf "Couldn't do %s: %s",
            $self->{'encoding_command_reqs'  }[-1],
            $self->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n";
      }
  
    } else {
      # Otherwise it's a syntax error
      $self->whine( $para->[1]{'start_line'},
        "Invalid =encoding syntax: $content"
      );
    }
  
    return;
  }
  
  #~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
  
  {
  my $m = -321;   # magic line number
  
  sub _gen_errata {
    my $self = $_[0];
    # Return 0 or more fake-o paragraphs explaining the accumulated
    #  errors on this document.
  
    return() unless $self->{'errata'} and keys %{$self->{'errata'}};
  
    my @out;
  
    foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
      push @out,
        ['=item', {'start_line' => $m}, "Around line $line:"],
        map( ['~Para', {'start_line' => $m, '~cooked' => 1},
          #['~Top', {'start_line' => $m},
          $_
          #]
          ],
          @{$self->{'errata'}{$line}}
        )
      ;
    }
  
    # TODO: report of unknown entities? unrenderable characters?
  
    unshift @out,
      ['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
      ['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
       "Hey! ",
       ['B', {},
        'The above document had some coding errors, which are explained below:'
       ]
      ],
      ['=over',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    push @out,
      ['=back',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    DEBUG and print STDERR "\n<<\n", pretty(\@out), "\n>>\n\n";
  
    return @out;
  }
  
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  ##############################################################################
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##                         HERE IT BECOMES REALLY SCARY
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##############################################################################
  
  sub _ponder_paragraph_buffer {
  
    # Para-token types as found in the buffer.
    #   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
    #   =over, =back, =item
    #   and the null =pod (to be complained about if over one line)
    #
    # "~data" paragraphs are something we generate at this level, depending on
    # a currently open =over region
  
    # Events fired:  Begin and end for:
    #                   directivename (like head1 .. head4), item, extend,
    #                   for (from =begin...=end, =for),
    #                   over-bullet, over-number, over-text, over-block,
    #                   item-bullet, item-number, item-text,
    #                   Document,
    #                   Data, Para, Verbatim
    #                   B, C, longdirname (TODO -- wha?), etc. for all directives
    #
  
    my $self = $_[0];
    my $paras;
    return unless @{$paras = $self->{'paras'}};
    my $curr_open = ($self->{'curr_open'} ||= []);
  
    my $scratch;
  
    DEBUG > 10 and print STDERR "# Paragraph buffer: <<", pretty($paras), ">>\n";
  
    # We have something in our buffer.  So apparently the document has started.
    unless($self->{'doc_has_started'}) {
      $self->{'doc_has_started'} = 1;
  
      my $starting_contentless;
      $starting_contentless =
       (
         !@$curr_open
         and @$paras and ! grep $_->[0] ne '~end', @$paras
          # i.e., if the paras is all ~ends
       )
      ;
      DEBUG and print STDERR "# Starting ",
        $starting_contentless ? 'contentless' : 'contentful',
        " document\n"
      ;
  
      $self->_handle_element_start(
        ($scratch = 'Document'),
        {
          'start_line' => $paras->[0][1]{'start_line'},
          $starting_contentless ? ( 'contentless' => 1 ) : (),
        },
      );
    }
  
    my($para, $para_type);
    while(@$paras) {
  
      # If a directive, assume it's legal; subtract below if found not to be
      $seen_legal_directive++ if $paras->[0][0] =~ /^=/;
  
      last if      @$paras == 1
              and (    $paras->[0][0] eq '=over'
                   or  $paras->[0][0] eq '=item'
                   or ($paras->[0][0] eq '~Verbatim' and $self->{'in_pod'}));
      # Those're the three kinds of paragraphs that require lookahead.
      #   Actually, an "=item Foo" inside an <over type=text> region
      #   and any =item inside an <over type=block> region (rare)
      #   don't require any lookahead, but all others (bullets
      #   and numbers) do.
      # The verbatim is different from the other two, because those might be
      # like:
      #
      #   =item
      #   ...
      #   =cut
      #   ...
      #   =item
      #
      # The =cut here finishes the paragraph but doesn't terminate the =over
      # they should be in. (khw apologizes that he didn't comment at the time
      # why the 'in_pod' works, and no longer remembers why, and doesn't think
      # it is currently worth the effort to re-figure it out.)
  
  # TODO: whinge about many kinds of directives in non-resolving =for regions?
  # TODO: many?  like what?  =head1 etc?
  
      $para = shift @$paras;
      $para_type = $para->[0];
  
      DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",
        $self->_dump_curr_open(), ")\n";
  
      if($para_type eq '=for') {
        next if $self->_ponder_for($para,$curr_open,$paras);
  
      } elsif($para_type eq '=begin') {
        next if $self->_ponder_begin($para,$curr_open,$paras);
  
      } elsif($para_type eq '=end') {
        next if $self->_ponder_end($para,$curr_open,$paras);
  
      } elsif($para_type eq '~end') { # The virtual end-document signal
        next if $self->_ponder_doc_end($para,$curr_open,$paras);
      }
  
  
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      if(grep $_->[1]{'~ignore'}, @$curr_open) {
        DEBUG > 1 and
         print STDERR "Skipping $para_type paragraph because in ignore mode.\n";
        next;
      }
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
      if($para_type eq '=pod') {
        $self->_ponder_pod($para,$curr_open,$paras);
  
      } elsif($para_type eq '=over') {
        next if $self->_ponder_over($para,$curr_open,$paras);
  
      } elsif($para_type eq '=back') {
        next if $self->_ponder_back($para,$curr_open,$paras);
  
      } else {
  
        # All non-magical codes!!!
  
        # Here we start using $para_type for our own twisted purposes, to
        #  mean how it should get treated, not as what the element name
        #  should be.
  
        DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";
  
        my $i;
  
        # Enforce some =headN discipline
        if($para_type =~ m/^=head\d$/s
           and ! $self->{'accept_heads_anywhere'}
           and @$curr_open
           and $curr_open->[-1][0] eq '=over'
        ) {
          DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";
          $self->whine(
            $para->[1]{'start_line'},
            "You forgot a '=back' before '$para_type'"
          );
          unshift @$paras, ['=back', {}, ''], $para;   # close the =over
          next;
        }
  
  
        if($para_type eq '=item') {
  
          my $over;
          unless(@$curr_open and
                 $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
            $self->whine(
              $para->[1]{'start_line'},
              "'=item' outside of any '=over'"
            );
            unshift @$paras,
              ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
              $para
            ;
            next;
          }
  
  
          my $over_type = $over->[1]{'~type'};
  
          if(!$over_type) {
            # Shouldn't happen1
            die "Typeless over in stack, starting at line "
             . $over->[1]{'start_line'};
  
          } elsif($over_type eq 'block') {
            unless($curr_open->[-1][1]{'~bitched_about'}) {
              $curr_open->[-1][1]{'~bitched_about'} = 1;
              $self->whine(
                $curr_open->[-1][1]{'start_line'},
                "You can't have =items (as at line "
                . $para->[1]{'start_line'}
                . ") unless the first thing after the =over is an =item"
              );
            }
            # Just turn it into a paragraph and reconsider it
            $para->[0] = '~Para';
            unshift @$paras, $para;
            next;
  
          } elsif($over_type eq 'text') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
            if($item_type eq 'text') {
              # Nothing special needs doing for 'text'
            } elsif($item_type eq 'number' or $item_type eq 'bullet') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected text after =item, not a $item_type"
              );
              # Undo our clobbering:
              push @$para, $para->[1]{'~orig_content'};
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            # =item-text thingies don't need any assimilation, it seems.
  
          } elsif($over_type eq 'number') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
            my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
  
            if($item_type eq 'bullet') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              push @$para, $para->[1]{'~orig_content'};
                # restore the bullet, blocking the assimilation of next para
  
            } elsif($item_type eq 'text') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              # Text content will still be there and will block next ~Para
  
            } elsif($item_type ne 'number') {
              die "Unknown item type $item_type"; # should never happen
  
            } elsif($expected_value == $para->[1]{'number'}) {
              DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
  
            } else {
              DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
               " instead of the expected value of $expected_value\n";
              $self->whine(
                $para->[1]{'start_line'},
                "You have '=item " . $para->[1]{'number'} .
                "' instead of the expected '=item $expected_value'"
              );
              $para->[1]{'number'} = $expected_value;  # correcting!!
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
  
          } elsif($over_type eq 'bullet') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
            if($item_type eq 'bullet') {
              # as expected!
  
              if( $para->[1]{'~_freaky_para_hack'} ) {
                DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
                push @$para, $para->[1]{'~_freaky_para_hack'};
              }
  
            } elsif($item_type eq 'number') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
              push @$para, $para->[1]{'~orig_content'};
               # and block assimilation of the next paragraph
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } elsif($item_type eq 'text') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
               # But doesn't need processing.  But it'll block assimilation
               #  of the next para.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
          } else {
            die "Unhandled =over type \"$over_type\"?";
            # Shouldn't happen!
          }
  
          $para_type = 'Plain';
          $para->[0] .= '-' . $over_type;
          # Whew.  Now fall thru and process it.
  
  
        } elsif($para_type eq '=extend') {
          # Well, might as well implement it here.
          $self->_ponder_extend($para);
          next;  # and skip
        } elsif($para_type eq '=encoding') {
          # Not actually acted on here, but we catch errors here.
          $self->_handle_encoding_second_level($para);
          next unless $self->keep_encoding_directive;
          $para_type = 'Plain';
        } elsif($para_type eq '~Verbatim') {
          $para->[0] = 'Verbatim';
          $para_type = '?Verbatim';
        } elsif($para_type eq '~Para') {
          $para->[0] = 'Para';
          $para_type = '?Plain';
        } elsif($para_type eq 'Data') {
          $para->[0] = 'Data';
          $para_type = '?Data';
        } elsif( $para_type =~ s/^=//s
          and defined( $para_type = $self->{'accept_directives'}{$para_type} )
        ) {
          DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n";
        } else {
          # An unknown directive!
          $seen_legal_directive--;
          DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",
           $para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
          ;
          $self->whine(
            $para->[1]{'start_line'},
            "Unknown directive: $para->[0]"
          );
  
          # And maybe treat it as text instead of just letting it go?
          next;
        }
  
        if($para_type =~ s/^\?//s) {
          if(! @$curr_open) {  # usual case
            DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n";
          } else {
            my @fors = grep $_->[0] eq '=for', @$curr_open;
            DEBUG > 1 and print STDERR "Containing fors: ",
              join(',', map $_->[1]{'target'}, @fors), "\n";
  
            if(! @fors) {
              DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n";
  
            #} elsif(grep $_->[1]{'~resolve'}, @fors) {
            #} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
            } elsif( $fors[-1][1]{'~resolve'} ) {
              # Look to the immediately containing for
  
              if($para_type eq 'Data') {
                DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
                $para->[0] = 'Para';
                $para_type = 'Plain';
              } else {
                DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
              }
            } else {
              DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
              $para->[0] = $para_type = 'Data';
            }
          }
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if($para_type eq 'Plain') {
          $self->_ponder_Plain($para);
        } elsif($para_type eq 'Verbatim') {
          $self->_ponder_Verbatim($para);
        } elsif($para_type eq 'Data') {
          $self->_ponder_Data($para);
        } else {
          die "\$para type is $para_type -- how did that happen?";
          # Shouldn't happen.
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        $para->[0] =~ s/^[~=]//s;
  
        DEBUG and print STDERR "\n", pretty($para), "\n";
  
        # traverse the treelet (which might well be just one string scalar)
        $self->{'content_seen'} ||= 1 if   $seen_legal_directive
                                      && ! $self->{'~tried_gen_errata'};
        $self->_traverse_treelet_bit(@$para);
      }
    }
  
    return;
  }
  
  ###########################################################################
  # The sub-ponderers...
  
  
  
  sub _ponder_for {
    my ($self,$para,$curr_open,$paras) = @_;
  
    # Fake it out as a begin/end
    my $target;
  
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";
      return 1;
    }
  
    for(my $i = 2; $i < @$para; ++$i) {
      if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
        $target = $1;
        last;
      }
    }
    unless(defined $target) {
      $self->whine(
        $para->[1]{'start_line'},
        "=for without a target?"
      );
      return 1;
    }
    DEBUG > 1 and
     print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";
  
    $para->[0] = 'Data';
  
    unshift @$paras,
      ['=begin',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
      $para,
      ['=end',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
    ;
  
    return 1;
  }
  
  sub _ponder_begin {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "=begin without a target?"
      );
      DEBUG and print STDERR "Ignoring targetless =begin\n";
      return 1;
    }
  
    my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
    $para->[1]{'title'} = $title if ($title);
    $para->[1]{'target'} = $target;  # without any ':'
    $content = $target; # strip off the title
  
    $content =~ s/^:!/!:/s;
    my $neg;  # whether this is a negation-match
    $neg = 1        if $content =~ s/^!//s;
    my $to_resolve;  # whether to process formatting codes
    $to_resolve = 1 if $content =~ s/^://s;
  
    my $dont_ignore; # whether this target matches us
  
    foreach my $target_name (
      split(',', $content, -1),
      $neg ? () : '*'
    ) {
      DEBUG > 2 and
       print STDERR " Considering whether =begin $content matches $target_name\n";
      next unless $self->{'accept_targets'}{$target_name};
  
      DEBUG > 2 and
       print STDERR "  It DOES match the acceptable target $target_name!\n";
      $to_resolve = 1
        if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
      $dont_ignore = 1;
      $para->[1]{'target_matching'} = $target_name;
      last; # stop looking at other target names
    }
  
    if($neg) {
      if( $dont_ignore ) {
        $dont_ignore = '';
        delete $para->[1]{'target_matching'};
        DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n";
      } else {
        $dont_ignore = 1;
        $para->[1]{'target_matching'} = '!';
        DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n";
      }
    }
  
    $para->[0] = '=for';  # Just what we happen to call these, internally
    $para->[1]{'~really'} ||= '=begin';
    $para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
    $para->[1]{'~resolve'}  = $to_resolve || 0;
  
    DEBUG > 1 and print STDERR " Making note to ", $dont_ignore ? 'not ' : '',
      "ignore contents of this region\n";
    DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",
      ($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
    DEBUG > 1 and print STDERR " (Stack now: ", $self->_dump_curr_open(), ")\n";
  
    push @$curr_open, $para;
    if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n";
    } else {
      $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
      $self->_handle_element_start((my $scratch='for'), $para->[1]);
    }
  
    return 1;
  }
  
  sub _ponder_end {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    DEBUG and print STDERR "Ogling '=end $content' directive\n";
  
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=end' without a target?" . (
          ( @$curr_open and $curr_open->[-1][0] eq '=for' )
          ? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
          : ''
        )
      );
      DEBUG and print STDERR "Ignoring targetless =end\n";
      return 1;
    }
  
    unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
      $self->whine(
        $para->[1]{'start_line'},
        "'=end $content' is invalid.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
  
    unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content without matching =begin.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
  
    unless($content eq $curr_open->[-1][1]{'target'}) {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content doesn't match =begin "
        . $curr_open->[-1][1]{'target'}
        . ".  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
      return 1;
    }
  
    # Else it's okay to close...
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n";
      # And that may be because of this to-be-closed =for region, or some
      #  other one, but it doesn't matter.
    } else {
      $curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
        # what's that for?
  
      $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
      $self->_handle_element_end( my $scratch = 'for', $para->[1]);
    }
    DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
    pop @$curr_open;
  
    return 1;
  }
  
  sub _ponder_doc_end {
    my ($self,$para,$curr_open,$paras) = @_;
    if(@$curr_open) { # Deal with things left open
      DEBUG and print STDERR "Stack is nonempty at end-document: (",
        $self->_dump_curr_open(), ")\n";
  
      DEBUG > 9 and print STDERR "Stack: ", pretty($curr_open), "\n";
      unshift @$paras, $self->_closers_for_all_curr_open;
      # Make sure there is exactly one ~end in the parastack, at the end:
      @$paras = grep $_->[0] ne '~end', @$paras;
      push @$paras, $para, $para;
       # We need two -- once for the next cycle where we
       #  generate errata, and then another to be at the end
       #  when that loop back around to process the errata.
      return 1;
  
    } else {
      DEBUG and print STDERR "Okay, stack is empty now.\n";
    }
  
    # Try generating errata section, if applicable
    unless($self->{'~tried_gen_errata'}) {
      $self->{'~tried_gen_errata'} = 1;
      my @extras = $self->_gen_errata();
      if(@extras) {
        unshift @$paras, @extras;
        DEBUG and print STDERR "Generated errata... relooping...\n";
        return 1;  # I.e., loop around again to process these fake-o paragraphs
      }
    }
  
    splice @$paras; # Well, that's that for this paragraph buffer.
    DEBUG and print STDERR "Throwing end-document event.\n";
  
    $self->_handle_element_end( my $scratch = 'Document' );
    return 1; # Hasta la byebye
  }
  
  sub _ponder_pod {
    my ($self,$para,$curr_open,$paras) = @_;
    $self->whine(
      $para->[1]{'start_line'},
      "=pod directives shouldn't be over one line long!  Ignoring all "
       . (@$para - 2) . " lines of content"
    ) if @$para > 3;
  
    # Content ignored unless 'pod_handler' is set
    if (my $pod_handler = $self->{'pod_handler'}) {
        my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
        $line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
        $pod_handler->($line, $line_num, $self);
    }
  
    # The surrounding methods set content_seen, so let us remain consistent.
    # I do not know why it was not here before -- should it not be here?
    # $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
  
    return;
  }
  
  sub _ponder_over {
    my ($self,$para,$curr_open,$paras) = @_;
    return 1 unless @$paras;
    my $list_type;
  
    if($paras->[0][0] eq '=item') { # most common case
      $list_type = $self->_get_initial_item_type($paras->[0]);
  
    } elsif($paras->[0][0] eq '=back') {
      # Ignore empty lists by default
      if ($self->{'parse_empty_lists'}) {
        $list_type = 'empty';
      } else {
        shift @$paras;
        return 1;
      }
    } elsif($paras->[0][0] eq '~end') {
      $self->whine(
        $para->[1]{'start_line'},
        "=over is the last thing in the document?!"
      );
      return 1; # But feh, ignore it.
    } else {
      $list_type = 'block';
    }
    $para->[1]{'~type'} = $list_type;
    push @$curr_open, $para;
     # yes, we reuse the paragraph as a stack item
  
    my $content = join ' ', splice @$para, 2;
    $para->[1]{'~orig_content'} = $content;
    my $overness;
    if($content =~ m/^\s*$/s) {
      $para->[1]{'indent'} = 4;
    } elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
      no integer;
      $para->[1]{'indent'} = $1;
      if($1 == 0) {
        $self->whine(
          $para->[1]{'start_line'},
          "Can't have a 0 in =over $content"
        );
        $para->[1]{'indent'} = 4;
      }
    } else {
      $self->whine(
        $para->[1]{'start_line'},
        "=over should be: '=over' or '=over positive_number'"
      );
      $para->[1]{'indent'} = 4;
    }
    DEBUG > 1 and print STDERR "=over found of type $list_type\n";
  
    $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
    $self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
  
    return;
  }
  
  sub _ponder_back {
    my ($self,$para,$curr_open,$paras) = @_;
    # TODO: fire off </item-number> or </item-bullet> or </item-text> ??
  
    my $content = join ' ', splice @$para, 2;
    if($content =~ m/\S/) {
      $self->whine(
        $para->[1]{'start_line'},
        "=back doesn't take any parameters, but you said =back $content"
      );
    }
  
    if(@$curr_open and $curr_open->[-1][0] eq '=over') {
      DEBUG > 1 and print STDERR "=back happily closes matching =over\n";
      # Expected case: we're closing the most recently opened thing
      #my $over = pop @$curr_open;
      $self->{'content_seen'} ||= 1 unless $self->{'~tried_gen_errata'};
      $self->_handle_element_end( my $scratch =
        'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
      );
    } else {
      DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",
          join(', ', map $_->[0], @$curr_open), ").\n";
      $self->whine(
        $para->[1]{'start_line'},
        '=back without =over'
      );
      return 1; # and ignore it
    }
  }
  
  sub _ponder_item {
    my ($self,$para,$curr_open,$paras) = @_;
    my $over;
    unless(@$curr_open and
           $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=item' outside of any '=over'"
      );
      unshift @$paras,
        ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
        $para
      ;
      return 1;
    }
  
  
    my $over_type = $over->[1]{'~type'};
  
    if(!$over_type) {
      # Shouldn't happen1
      die "Typeless over in stack, starting at line "
       . $over->[1]{'start_line'};
  
    } elsif($over_type eq 'block') {
      unless($curr_open->[-1][1]{'~bitched_about'}) {
        $curr_open->[-1][1]{'~bitched_about'} = 1;
        $self->whine(
          $curr_open->[-1][1]{'start_line'},
          "You can't have =items (as at line "
          . $para->[1]{'start_line'}
          . ") unless the first thing after the =over is an =item"
        );
      }
      # Just turn it into a paragraph and reconsider it
      $para->[0] = '~Para';
      unshift @$paras, $para;
      return 1;
  
    } elsif($over_type eq 'text') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
      if($item_type eq 'text') {
        # Nothing special needs doing for 'text'
      } elsif($item_type eq 'number' or $item_type eq 'bullet') {
        $self->whine(
            $para->[1]{'start_line'},
            "Expected text after =item, not a $item_type"
        );
        # Undo our clobbering:
        push @$para, $para->[1]{'~orig_content'};
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      # =item-text thingies don't need any assimilation, it seems.
  
    } elsif($over_type eq 'number') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
      my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
  
      if($item_type eq 'bullet') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        push @$para, $para->[1]{'~orig_content'};
          # restore the bullet, blocking the assimilation of next para
  
      } elsif($item_type eq 'text') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        # Text content will still be there and will block next ~Para
  
      } elsif($item_type ne 'number') {
        die "Unknown item type $item_type"; # should never happen
  
      } elsif($expected_value == $para->[1]{'number'}) {
        DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
  
      } else {
        DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
         " instead of the expected value of $expected_value\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You have '=item " . $para->[1]{'number'} .
          "' instead of the expected '=item $expected_value'"
        );
        $para->[1]{'number'} = $expected_value;  # correcting!!
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
  
    } elsif($over_type eq 'bullet') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
  
      if($item_type eq 'bullet') {
        # as expected!
  
        if( $para->[1]{'~_freaky_para_hack'} ) {
          DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
          push @$para, $para->[1]{'~_freaky_para_hack'};
        }
  
      } elsif($item_type eq 'number') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
        push @$para, $para->[1]{'~orig_content'};
         # and block assimilation of the next paragraph
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } elsif($item_type eq 'text') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
         # But doesn't need processing.  But it'll block assimilation
         #  of the next para.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
    } else {
      die "Unhandled =over type \"$over_type\"?";
      # Shouldn't happen!
    }
    $para->[0] .= '-' . $over_type;
  
    return;
  }
  
  sub _ponder_Plain {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving plain treatment...\n";
    unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
      or $para->[1]{'~cooked'}
    ) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}
      )};
    }
    # Empty paragraphs don't need a treelet for any reason I can see.
    # And precooked paragraphs already have a treelet.
    return;
  }
  
  sub _ponder_Verbatim {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving verbatim treatment...\n";
  
    $para->[1]{'xml:space'} = 'preserve';
  
    unless ($self->{'_output_is_for_JustPod'}) {
      # Fix illegal settings for expand_verbatim_tabs()
      # This is because this module doesn't do input error checking, but khw
      # doesn't want to add yet another instance of that.
      my $tab_width = $self->expand_verbatim_tabs;
      $tab_width = $self->expand_verbatim_tabs(8)
          if ! defined $tab_width
          ||   $tab_width =~ /\D/;
  
      my $indent = $self->strip_verbatim_indent;
      if ($indent && ref $indent eq 'CODE') {
          my @shifted = (shift @{$para}, shift @{$para});
          $indent = $indent->($para);
          unshift @{$para}, @shifted;
      }
  
      for(my $i = 2; $i < @$para; $i++) {
        foreach my $line ($para->[$i]) { # just for aliasing
          # Strip indentation.
          $line =~ s/^\Q$indent// if $indent;
          next unless $tab_width;
  
              # This is commented out because of github issue #85, and the
              # current maintainers don't know why it was there in the first
              # place.
              #&& !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
          while( $line =~
            # Sort of adapted from Text::Tabs.
            s/^([^\t]*)(\t+)/$1.(" " x ((length($2)
                                         * $tab_width)
                                         -(length($1) % $tab_width)))/e
          ) {}
  
          # TODO: whinge about (or otherwise treat) unindented or overlong lines
  
        }
      }
    }
  
    # Now the VerbatimFormatted hoodoo...
    if( $self->{'accept_codes'} and
        $self->{'accept_codes'}{'VerbatimFormatted'}
    ) {
      while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
       # Kill any number of terminal newlines
      $self->_verbatim_format($para);
    } elsif ($self->{'codes_in_verbatim'}) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}, $para->[1]{'xml:space'}
      )};
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    } else {
      push @$para, join "\n", splice(@$para, 2) if @$para > 3;
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    }
    return;
  }
  
  sub _ponder_Data {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving data treatment...\n";
    $para->[1]{'xml:space'} = 'preserve';
    push @$para, join "\n", splice(@$para, 2) if @$para > 3;
    return;
  }
  
  
  
  
  ###########################################################################
  
  sub _traverse_treelet_bit {  # for use only by the routine above
    my($self, $name) = splice @_,0,2;
  
    my $scratch;
    $self->_handle_element_start(($scratch=$name), shift @_);
  
    while (@_) {
      my $x = shift;
      if (ref($x)) {
        &_traverse_treelet_bit($self, @$x);
      } else {
        $x .= shift while @_ && !ref($_[0]);
        $self->_handle_text($x);
      }
    }
  
    $self->_handle_element_end($scratch=$name);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _closers_for_all_curr_open {
    my $self = $_[0];
    my @closers;
    foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
      my @copy = @$still_open;
      $copy[1] = {%{ $copy[1] }};
      #$copy[1]{'start_line'} = -1;
      if($copy[0] eq '=for') {
        $copy[0] = '=end';
      } elsif($copy[0] eq '=over') {
        $self->whine(
          $still_open->[1]{start_line} ,
          "=over without closing =back"
        );
  
        $copy[0] = '=back';
      } else {
        die "I don't know how to auto-close an open $copy[0] region";
      }
  
      unless( @copy > 2 ) {
        push @copy, $copy[1]{'target'};
        $copy[-1] = '' unless defined $copy[-1];
         # since =over's don't have targets
      }
  
      $copy[1]{'fake-closer'} = 1;
  
      DEBUG and print STDERR "Queuing up fake-o event: ", pretty(\@copy), "\n";
      unshift @closers, \@copy;
    }
    return @closers;
  }
  
  #--------------------------------------------------------------------------
  
  sub _verbatim_format {
    my($it, $p) = @_;
  
    my $formatting;
  
    for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
      DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";
      $p->[$i] .= "\n";
       # Unlike with simple Verbatim blocks, we don't end up just doing
       # a join("\n", ...) on the contents, so we have to append a
       # newline to every line, and then nix the last one later.
    }
  
    if( DEBUG > 4 ) {
      print STDERR "<<\n";
      for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
        print STDERR "_verbatim_format $i: $p->[$i]";
      }
      print STDERR ">>\n";
    }
  
    for(my $i = $#$p; $i > 2; $i--) {
      # work backwards over the lines, except the first (#2)
  
      #next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
      #        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
       # look at a formatty line preceding a nonformatty one
      DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";
      if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
        DEBUG > 5 and print STDERR "  It's a formatty line.  ",
         "Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
  
        if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
          DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";
          next;
        } else {
          DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n";
        }
      } else {
        DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";
        next;
      }
  
      # A formatty line has to have #: in the first two columns, and uses
      # "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
      # Example:
      #   What do you want?  i like pie. [or whatever]
      # #:^^^^^^^^^^^^^^^^^              /////////////
  
  
      DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
  
      $formatting = '  ' . $1;
      $formatting =~ s/\s+$//s; # nix trailing whitespace
      unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
        splice @$p,$i,1; # remove this line
        $i--; # don't consider next line
        next;
      }
  
      if( length($formatting) >= length($p->[$i-1]) ) {
        $formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
      } else {
        $formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
      }
      # Make $formatting and the previous line be exactly the same length,
      # with $formatting having a " " as the last character.
  
      DEBUG > 4 and print STDERR "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
  
  
      my @new_line;
      while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
        #print STDERR "Format matches $1\n";
  
        if($2) {
          #print STDERR "SKIPPING <$2>\n";
          push @new_line,
            substr($p->[$i-1], pos($formatting)-length($1), length($1));
        } else {
          #print STDERR "SNARING $+\n";
          push @new_line, [
            (
              $3 ? 'VerbatimB'  :
              $4 ? 'VerbatimI'  :
              $5 ? 'VerbatimBI' : die("Should never get called")
            ), {},
            substr($p->[$i-1], pos($formatting)-length($1), length($1))
          ];
          #print STDERR "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
        }
      }
      my @nixed =
        splice @$p, $i-1, 2, @new_line; # replace myself and the next line
      DEBUG > 10 and print STDERR "Nixed count: ", scalar(@nixed), "\n";
  
      DEBUG > 6 and print STDERR "New version of the above line is these tokens (",
        scalar(@new_line), "):",
        map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
      $i--; # So the next line we scrutinize is the line before the one
            #  that we just went and formatted
    }
  
    $p->[0] = 'VerbatimFormatted';
  
    # Collapse adjacent text nodes, just for kicks.
    for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
      if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
        DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
        $p->[$i] .= splice @$p, $i+1, 1; # merge
        --$i;  # and back up
      }
    }
  
    # Now look for the last text token, and remove the terminal newline
    for( my $i = $#$p; $i >= 2; $i-- ) {
      # work backwards over the tokens, even the first
      if( !ref($p->[$i]) ) {
        if($p->[$i] =~ s/\n$//s) {
          DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
        } else {
          DEBUG > 5 and print STDERR
           "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
        }
        last; # we only want the next one
      }
    }
  
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  
  sub _treelet_from_formatting_codes {
    # Given a paragraph, returns a treelet.  Full of scary tokenizing code.
    #  Like [ '~Top', {'start_line' => $start_line},
    #            "I like ",
    #            [ 'B', {}, "pie" ],
    #            "!"
    #       ]
    # This illustrates the general format of a treelet.  It is an array:
    #     [0]       is a scalar indicating its type.  In the example above, the
    #               types are '~Top' and 'B'
    #     [1]       is a hash of various flags about it, possibly empty
    #     [2] - [N] are an ordered list of the subcomponents of the treelet.
    #               Scalars are literal text, refs are sub-treelets, to
    #               arbitrary levels.  Stringifying a treelet will recursively
    #               stringify the sub-treelets, concatentating everything
    #               together to form the exact text of the treelet.
  
    my($self, $para, $start_line, $preserve_space) = @_;
  
    my $treelet = ['~Top', {'start_line' => $start_line},];
  
    unless ($preserve_space || $self->{'preserve_whitespace'}) {
      $para =~ s/\s+/ /g; # collapse and trim all whitespace first.
      $para =~ s/ $//;
      $para =~ s/^ //;
    }
  
    # Only apparent problem the above code is that N<<  >> turns into
    # N<< >>.  But then, word wrapping does that too!  So don't do that!
  
  
    # As a Start-code is encountered, the number of opening bracket '<'
    # characters minus 1 is pushed onto @stack (so 0 means a single bracket,
    # etc).  When closing brackets are found in the text, at least this number
    # (plus the 1) will be required to mean the Start-code is terminated.  When
    # those are found, @stack is popped.
    my @stack;
  
    my @lineage = ($treelet);
    my $raw = ''; # raw content of L<> fcode before splitting/processing
      # XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
      # into just 1 ' '. Is this the regex's doing or 'raw's?  Answer is it's
      # the 'collapse and trim all whitespace first' lines just above.
    my $inL = 0;
  
    DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";
  
    # Here begins our frightening tokenizer RE.  The following regex matches
    # text in four main parts:
    #
    #  * Start-codes.  The first alternative matches C< or C<<, the latter
    #    followed by some whitespace.  $1 will hold the entire start code
    #    (including any space following a multiple-angle-bracket delimiter),
    #    and $2 will hold only the additional brackets past the first in a
    #    multiple-bracket delimiter.  length($2) + 1 will be the number of
    #    closing brackets we have to find.
    #
    #  * Closing brackets.  Match some amount of whitespace followed by
    #    multiple close brackets.  The logic to see if this closes anything
    #    is down below.  Note that in order to parse C<<  >> correctly, we
    #    have to use look-behind (?<=\s\s), since the match of the starting
    #    code will have consumed the whitespace.
    #
    #  * A single closing bracket, to close a simple code like C<>.
    #
    #  * Something that isn't a start or end code.  We have to be careful
    #    about accepting whitespace, since perlpodspec says that any whitespace
    #    before a multiple-bracket closing delimiter should be ignored.
    #
    while($para =~
      m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.  ($3 can be empty if the
          # construct is empty, like C<<  >>, and all the white-space has been
          # gobbled up already, considered to be space after the opening
          # bracket.  In this case we use look-behind to verify that there are
          # at least 2 spaces in a row before the ">".)
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo
    ) {
      DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";
      if(defined $1) {
        my $bracket_count;    # How many '<<<' in a row this has.  Needed for
                              # Pod::Simple::JustPod
        if(defined $2) {
          DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";
          $bracket_count = length($2) + 1;
          push @stack, $bracket_count; # length of the necessary complex
                                       # end-code string
        } else {
          DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";
          push @stack, 0;  # signal that we're looking for simple
          $bracket_count = 1;
        }
        my $code = substr($1,0,1);
        if ('L' eq $code) {
          if ($inL) {
              $raw .= $1;
              $self->scream( $start_line,
                             'Nested L<> are illegal.  Pretending inner one is '
                           . 'X<...> so can continue looking for other errors.');
              $code = "X";
          }
          else {
              $raw = ""; # reset raw content accumulator
              $inL = @stack;
          }
        } else {
          $raw .= $1 if $inL;
        }
        push @lineage, [ $code, {}, ];  # new node object
  
        # Tell Pod::Simple::JustPod how many brackets there were, but to save
        # space, not in the most usual case of there was just 1.  It can be
        # inferred by the absence of this element.  Similarly, if there is more
        # than one bracket, extract the white space between the final bracket
        # and the real beginning of the interior.  Save that if it isn't just a
        # single space
        if ($self->{'_output_is_for_JustPod'} && $bracket_count > 1) {
          $lineage[-1][1]{'~bracket_count'} = $bracket_count;
          my $lspacer = substr($1, 1 + $bracket_count);
          $lineage[-1][1]{'~lspacer'} = $lspacer if $lspacer ne " ";
        }
        push @{ $lineage[-2] }, $lineage[-1];
      } elsif(defined $4) {
        DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";
        # This is where it gets messy...
        if(! @stack) {
          # We saw " >>>>" but needed nothing.  This is ALL just stuff then.
          DEBUG > 4 and print STDERR " But it's really just stuff.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        } elsif(!$stack[-1]) {
          # We saw " >>>>" but needed only ">".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";
          push @{ $lineage[-1] }, $3; # That was a for-real space, too.
          pos($para) = pos($para) - length($4) + 1;
        } elsif($stack[-1] == length($4)) {
          # We found " >>>>", and it was exactly what we needed.  Commonest case.
          DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n";
        } elsif($stack[-1] < length($4)) {
          # We saw " >>>>" but needed only " >>".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";
          pos($para) = pos($para) - length($4) + $stack[-1];
        } else {
          # We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
          DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        }
        #print STDERR "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
  
        if ($3 ne " " && $self->{'_output_is_for_JustPod'}) {
          if ($3 ne "") {
            $lineage[-1][1]{'~rspacer'} = $3;
          }
          elsif ($lineage[-1][1]{'~lspacer'} eq "  ") {
  
            # Here we had something like C<<  >> which was a false positive
            delete $lineage[-1][1]{'~lspacer'};
          }
          else {
            $lineage[-1][1]{'~rspacer'}
                                  = substr($lineage[-1][1]{'~lspacer'}, -1, 1);
            chop $lineage[-1][1]{'~lspacer'};
          }
        }
  
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Keep the element from being childless
  
        if ($inL == @stack) {
          $lineage[-1][1]{'raw'} = $raw;
          $inL = 0;
        }
  
        pop @stack;
        pop @lineage;
  
        $raw .= $3.$4 if $inL;
  
      } elsif(defined $5) {
        DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";
  
        if(@stack and ! $stack[-1]) {
          # We're indeed expecting a simple end-code
          DEBUG > 4 and print STDERR " It's indeed an end-code.\n";
  
          if(length($5) == 2) { # There was a space there: " >"
            push @{ $lineage[-1] }, ' ';
          } elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
            push @{ $lineage[-1] }, ''; # keep it from being really childless
          }
  
          if ($inL == @stack) {
            $lineage[-1][1]{'raw'} = $raw;
            $inL = 0;
          }
  
          pop @stack;
          pop @lineage;
        } else {
          DEBUG > 4 and print STDERR " It's just stuff.\n";
          push @{ $lineage[-1] }, $5;
        }
  
        $raw .= $5 if $inL;
  
      } elsif(defined $6) {
        DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";
        push @{ $lineage[-1] }, $6;
        $raw .= $6 if $inL;
          # XXX does not capture multiplace whitespaces -- 'raw' ends up with
          #     at most 1 leading/trailing whitespace, why not all of it?
          #     Answer, because we deliberately trimmed it above
  
      } else {
        # should never ever ever ever happen
        DEBUG and print STDERR "AYYAYAAAAA at line ", __LINE__, "\n";
        die "SPORK 512512!";
      }
    }
  
    if(@stack) { # Uhoh, some sequences weren't closed.
      my $x= "...";
      while(@stack) {
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Hmmmmm!
  
        my $code         = (pop @lineage)->[0];
        my $ender_length =  pop @stack;
        if($ender_length) {
          --$ender_length;
          $x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
        } else {
          $x = $code . "<$x>";
        }
      }
      DEBUG > 1 and print STDERR "Unterminated $x sequence\n";
      $self->whine($start_line,
        "Unterminated $x sequence",
      );
    }
  
    return $treelet;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
    return stringify_lol($_[1]);
  }
  
  sub stringify_lol {  # function: stringify_lol($lol)
    my $string_form = '';
    _stringify_lol( $_[0] => \$string_form );
    return $string_form;
  }
  
  sub _stringify_lol {  # the real recursor
    my($lol, $to) = @_;
    for(my $i = 2; $i < @$lol; ++$i) {
      if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
        _stringify_lol( $lol->[$i], $to);  # recurse!
      } else {
        $$to .= $lol->[$i];
      }
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _dump_curr_open { # return a string representation of the stack
    my $curr_open = $_[0]{'curr_open'};
  
    return '[empty]' unless @$curr_open;
    return join '; ',
      map {;
             ($_->[0] eq '=for')
               ? ( ($_->[1]{'~really'} || '=over')
                 . ' ' . $_->[1]{'target'})
               : $_->[0]
          }
      @$curr_open
    ;
  }
  
  ###########################################################################
  my %pretty_form = (
    "\a" => '\a', # ding!
    "\b" => '\b', # BS
    "\e" => '\e', # ESC
    "\f" => '\f', # FF
    "\t" => '\t', # tab
    "\cm" => '\cm',
    "\cj" => '\cj',
    "\n" => '\n', # probably overrides one of either \cm or \cj
    '"' => '\"',
    '\\' => '\\\\',
    '$' => '\\$',
    '@' => '\\@',
    '%' => '\\%',
    '#' => '\\#',
  );
  
  sub pretty { # adopted from Class::Classless
    # Not the most brilliant routine, but passable.
    # Don't give it a cyclic data structure!
    my @stuff = @_; # copy
    my $x;
    my $out =
      # join ",\n" .
      join ", ",
      map {;
      if(!defined($_)) {
        "undef";
      } elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
        $x = "[ " . pretty(@$_) . " ]" ;
        $x;
      } elsif(ref($_) eq 'SCALAR') {
        $x = "\\" . pretty($$_) ;
        $x;
      } elsif(ref($_) eq 'HASH') {
        my $hr = $_;
        $x = "{" . join(", ",
          map(pretty($_) . '=>' . pretty($hr->{$_}),
              sort keys %$hr ) ) . "}" ;
        $x;
      } elsif(!length($_)) { q{''} # empty string
      } elsif(
        $_ eq '0' # very common case
        or(
           m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
           and $_ ne '-0' # the strange case that RE lets thru
        )
      ) { $_;
      } else {
          # Yes, explicitly name every character desired. There are shorcuts one
          # could make, but I (Karl Williamson) was afraid that some Perl
          # releases would have bugs in some of them. For example [A-Z] works
          # even on EBCDIC platforms to match exactly the 26 uppercase English
          # letters, but I don't know if it has always worked without bugs. It
          # seemed safest just to list the characters.
          # s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
          s<([^ !"#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
        qq{"$_"};
      }
    } @stuff;
    # $out =~ s/\n */ /g if length($out) < 75;
    return $out;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # A rather unsubtle method of blowing away all the state information
  # from a parser object so it can be reused. Provided as a utility for
  # backward compatibility in Pod::Man, etc. but not recommended for
  # general use.
  
  sub reinit {
    my $self = shift;
    foreach (qw(source_dead source_filename doc_has_started
  start_of_pod_block content_seen last_was_blank paras curr_open
  line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen
  Title)) {
  
      delete $self->{$_};
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  
  # A quite dimwitted pod2plaintext that need only know how to format whatever
  # text comes out of Pod::BlackBox's _gen_errata
  
  package Pod::Simple::Checker;
  use strict;
  use warnings;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  our $VERSION = '3.45';
  our @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 (); # was 2001.0131, but I don't think we need that
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub any_errata_seen {  # read-only accessor
    return $_[1]->{'Errata_seen'};
  }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    $new->{'Errata_seen'} = 0;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Errata_seen'} and $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  
  sub start_head1 {
    if($_[0]{'Errata_seen'}) {
      $_[0]{'Thispara'} = '';
    } else {
      if($_[1]{'errata'}) { # start of errata!
        $_[0]{'Errata_seen'} = 1;
        $_[0]{'Thispara'} = $_[0]{'source_filename'} ?
          "$_[0]{'source_filename'} -- " : ''
      }
    }
  }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = '* ' }
  sub start_item_number { $_[0]{'Thispara'} = "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  
  sub emit_par {
    return unless $_[0]{'Errata_seen'};
    my($self, $tweak_indent) = splice(@_,0,2);
    my $length = 2 * $self->{'Indent'} + ($tweak_indent||0);
    my $indent = ' ' x ($length > 0 ? $length : 0);
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
     # 'Negative repeat count does nothing' since 5.22
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    local $Text::Wrap::wrap = 'overflow';
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out,
      #"\n"
    ;
    $self->{'Thispara'} = '';
  
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    return unless $_[0]{'Errata_seen'};
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
  
    $self->{'Thispara'} =~ s/^/$i/mg;
  
    print { $self->{'output_fh'} }   '',
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Checker -- check the Pod syntax of a document
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Checker -e \
     "exit Pod::Simple::Checker->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for checking the syntactic validity of Pod.
  It works by basically acting like a simple-minded version of
  L<Pod::Simple::Text> that formats only the "Pod Errors" section
  (if Pod::Simple even generates one for the given document).
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Checker>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  package Pod::Simple::Debug;
  use strict;
  our $VERSION = '3.45';
  
  sub import {
    my($value,$variable);
  
    if(@_ == 2) {
      $value = $_[1];
    } elsif(@_ == 3) {
      ($variable, $value) = @_[1,2];
  
      ($variable, $value) = ($value, $variable)
         if     defined $value    and ref($value)    eq 'SCALAR'
        and not(defined $variable and ref($variable) eq 'SCALAR')
      ; # tolerate getting it backwards
  
      unless( defined $variable and ref($variable) eq 'SCALAR') {
        require Carp;
        Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                  . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
      }
    } else {
      require Carp;
      Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined &Pod::Simple::DEBUG ) {
      require Carp;
      Carp::croak("It's too late to call Pod::Simple::Debug -- "
                . "Pod::Simple has already loaded\nAborting");
    }
  
    $value = 0 unless defined $value;
  
    unless($value =~ m/^-?\d+$/) {
      require Carp;
      Carp::croak( "$value isn't a numeric value."
              . "\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined $variable ) {
      # make a not-really-constant
      *Pod::Simple::DEBUG = sub () { $$variable } ;
      $$variable = $value;
      print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n";
    } else {
      *Pod::Simple::DEBUG = eval " sub () { $value } ";
      print STDERR "# Starting Pod::Simple::DEBUG = $value\n";
    }
  
    require Pod::Simple;
    return;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Debug -- put Pod::Simple into trace/debug mode
  
  =head1 SYNOPSIS
  
   use Pod::Simple::Debug (5);  # or some integer
  
  Or:
  
   my $debuglevel;
   use Pod::Simple::Debug (\$debuglevel, 0);
   ...some stuff that uses Pod::Simple to do stuff, but which
    you don't want debug output from...
  
   $debug_level = 4;
   ...some stuff that uses Pod::Simple to do stuff, but which
    you DO want debug output from...
  
   $debug_level = 0;
  
  =head1 DESCRIPTION
  
  This is an internal module for controlling the debug level (a.k.a. trace
  level) of Pod::Simple.  This is of interest only to Pod::Simple
  developers.
  
  
  =head1 CAVEATS
  
  Note that you should load this module I<before> loading Pod::Simple (or
  any Pod::Simple-based class).  If you try loading Pod::Simple::Debug
  after &Pod::Simple::DEBUG is already defined, Pod::Simple::Debug will
  throw a fatal error to the effect that
  "It's too late to call Pod::Simple::Debug".
  
  Note that the C<use Pod::Simple::Debug (\$x, I<somenum>)> mode will make
  Pod::Simple (et al) run rather slower, since &Pod::Simple::DEBUG won't
  be a constant sub anymore, and so Pod::Simple (et al) won't compile with
  constant-folding.
  
  
  =head1 GUTS
  
  Doing this:
  
    use Pod::Simple::Debug (5);  # or some integer
  
  is basically equivalent to:
  
    BEGIN { sub Pod::Simple::DEBUG () {5} }  # or some integer
    use Pod::Simple ();
  
  And this:
  
    use Pod::Simple::Debug (\$debug_level,0);  # or some integer
  
  is basically equivalent to this:
  
    my $debug_level;
    BEGIN { $debug_level = 0 }
    BEGIN { sub Pod::Simple::DEBUG () { $debug_level }
    use Pod::Simple ();
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  The article "Constants in Perl", in I<The Perl Journal> issue
  21.  See L<http://interglacial.com/tpj/21/>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  use warnings;
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  package Pod::Simple::DumpAsText;
  use strict;
  our $VERSION = '3.45';
  use Pod::Simple ();
  BEGIN { our @ISA = ('Pod::Simple')}
  
  use Carp ();
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
  
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "++", $_[1], "\n";
    $_[0]{'indent'}++;
    while(($key,$value) = each %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _perly_escape($key);
        _perly_escape($value);
        printf $fh qq{%s \\ "%s" => "%s"\n},
          '  ' x ($_[0]{'indent'} || 0), $key, $value;
      }
    }
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
  
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _perly_escape($text);
      $text =~  # A not-totally-brilliant wrapping algorithm:
        s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx     # => line-break here
      ;
  
      print {$_[0]{'output_fh'}} $indent, '* "', $text, "\"\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "--", $_[1], "\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _perly_escape {
    foreach my $x (@_) {
      $x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;
      # Escape things very cautiously:
      $x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg;
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsText -- dump Pod-parsing events as text
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsText -e \
     "exit Pod::Simple::DumpAsText->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for dumping, as text, the events gotten from parsing a Pod
  document.  This class is of interest to people writing Pod formatters
  based on Pod::Simple. It is useful for seeing exactly what events you
  get out of some Pod that you feed in.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML>
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  use warnings;
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  package Pod::Simple::DumpAsXML;
  use strict;
  our $VERSION = '3.45';
  use Pod::Simple ();
  BEGIN {our @ISA = ('Pod::Simple')}
  
  use Carp ();
  use Text::Wrap qw(wrap);
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
  
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "<", $_[1];
  
    foreach my $key (sort keys %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _xml_escape($value = $_[2]{$key});
        print $fh ' ', $key, '="', $value, '"';
      }
    }
  
  
    print $fh ">\n";
    $_[0]{'indent'}++;
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _xml_escape($text);
      local $Text::Wrap::huge = 'overflow';
      $text = wrap('', $indent, $text);
      print {$_[0]{'output_fh'}} $indent, $text, "\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "</", $_[1], ">\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsXML -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsXML -e \
     "exit Pod::Simple::DumpAsXML->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::DumpAsXML is a subclass of L<Pod::Simple> that parses Pod
  and turns it into indented and wrapped XML.  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  Pod::Simple::DumpAsXML inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::XMLOutStream> is rather like this class.
  Pod::Simple::XMLOutStream's output is space-padded in a way
  that's better for sending to an XML processor (that is, it has
  no ignorable whitespace). But
  Pod::Simple::DumpAsXML's output is much more human-readable, being
  (more-or-less) one token per line, with line-wrapping.
  
  L<Pod::Simple::DumpAsText> is rather like this class,
  except that it doesn't dump with XML syntax.  Try them and see
  which one you like best!
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>
  
  The older libraries L<Pod::PXML>, L<Pod::XML>, L<Pod::SAX>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  use warnings;
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  package Pod::Simple::HTML;
  use strict;
  use warnings;
  use Pod::Simple::PullParser ();
  our @ISA = ('Pod::Simple::PullParser');
  our $VERSION = '3.45';
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  our $Doctype_decl ||= '';  # No.  Just No.  Don't even ask me for it.
   # qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   #    "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  our $Content_decl ||=
   q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};
  
  our $HTML_EXTENSION;
  $HTML_EXTENSION = '.html' unless defined $HTML_EXTENSION;
  our $Computerese;
  $Computerese =  "" unless defined $Computerese;
  our $LamePad;
  $LamePad = '' unless defined $LamePad;
  
  our $Linearization_Limit;
  $Linearization_Limit = 120 unless defined $Linearization_Limit;
   # headings/items longer than that won't get an <a name="...">
  our $Perldoc_URL_Prefix;
  $Perldoc_URL_Prefix  = 'https://metacpan.org/pod/'
   unless defined $Perldoc_URL_Prefix;
  our $Perldoc_URL_Postfix;
  $Perldoc_URL_Postfix = ''
   unless defined $Perldoc_URL_Postfix;
  
  
  our $Man_URL_Prefix  = 'http://man.he.net/man';
  our $Man_URL_Postfix = '';
  
  our $Title_Prefix;
  $Title_Prefix  = '' unless defined $Title_Prefix;
  our $Title_Postfix;
  $Title_Postfix = '' unless defined $Title_Postfix;
  our %ToIndex = map {; $_ => 1 } qw(head1 head2 head3 head4 ); # item-text
    # 'item-text' stuff in the index doesn't quite work, and may
    # not be a good idea anyhow.
  
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
     # In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
     #  to put before the "Foo%3a%3aBar".
     # (for singleton mode only?)
   'perldoc_url_postfix',
     # what to put after "Foo%3a%3aBar" in the URL.  Normally "".
  
   'man_url_prefix',
     # In turning L<crontab(5)> into http://whatever/man/1/crontab, what
     #  to put before the "1/crontab".
   'man_url_postfix',
     #  what to put after the "1/crontab" in the URL. Normally "".
  
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
  
   'title_prefix',  'title_postfix',
    # What to put before and after the title in the head.
    # Should already be &-escaped
  
   'html_h_level',
  
   'html_header_before_title',
   'html_header_after_title',
   'html_footer',
   'top_anchor',
  
   'index', # whether to add an index at the top of each page
      # (actually it's a table-of-contents, but we'll call it an index,
      #  out of apparently longstanding habit)
  
   'html_css', # URL of CSS file to point to
   'html_javascript', # URL of Javascript file to point to
  
   'force_title',   # should already be &-escaped
   'default_title', # should already be &-escaped
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  my @_to_accept;
  
  our %Tagmap = (
    'Verbatim'  => "\n<pre$Computerese>",
    '/Verbatim' => "</pre>\n",
    'VerbatimFormatted'  => "\n<pre$Computerese>",
    '/VerbatimFormatted' => "</pre>\n",
    'VerbatimB'  => "<b>",
    '/VerbatimB' => "</b>",
    'VerbatimI'  => "<i>",
    '/VerbatimI' => "</i>",
    'VerbatimBI'  => "<b><i>",
    '/VerbatimBI' => "</i></b>",
  
  
    'Data'  => "\n",
    '/Data' => "\n",
  
    'head1' => "\n<h1>",  # And also stick in an <a name="...">
    'head2' => "\n<h2>",  #  ''
    'head3' => "\n<h3>",  #  ''
    'head4' => "\n<h4>",  #  ''
    'head5' => "\n<h5>",  #  ''
    'head6' => "\n<h6>",  #  ''
    '/head1' => "</a></h1>\n",
    '/head2' => "</a></h2>\n",
    '/head3' => "</a></h3>\n",
    '/head4' => "</a></h4>\n",
    '/head5' => "</a></h5>\n",
    '/head6' => "</a></h6>\n",
  
    'X'  => "<!--\n\tINDEX: ",
    '/X' => "\n-->",
  
    changes(qw(
      Para=p
      B=b I=i
      over-bullet=ul
      over-number=ol
      over-text=dl
      over-block=blockquote
      item-bullet=li
      item-number=li
      item-text=dt
    )),
    changes2(
      map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
      qw[
        sample=samp
        definition=dfn
        keyboard=kbd
        variable=var
        citation=cite
        abbreviation=abbr
        acronym=acronym
        subscript=sub
        superscript=sup
        big=big
        small=small
        underline=u
        strikethrough=s
        preformat=pre
        teletype=tt
      ]  # no point in providing a way to get <q>...</q>, I think
    ),
  
    '/item-bullet' => "</li>$LamePad\n",
    '/item-number' => "</li>$LamePad\n",
    '/item-text'   => "</a></dt>$LamePad\n",
    'item-body'    => "\n<dd>",
    '/item-body'   => "</dd>\n",
  
  
    'B'      =>  "<b>",                  '/B'     =>  "</b>",
    'I'      =>  "<i>",                  '/I'     =>  "</i>",
    'F'      =>  "<em$Computerese>",     '/F'     =>  "</em>",
    'C'      =>  "<code$Computerese>",   '/C'     =>  "</code>",
    'L'  =>  "<a href='YOU_SHOULD_NEVER_SEE_THIS'>", # ideally never used!
    '/L' =>  "</a>",
  );
  
  sub changes {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "\n<$2>", "/$1", => "</$2>\n" ) : die "Funky $_"
    } @_;
  }
  sub changes2 {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "<$2>", "/$1", => "</$2>" ) : die "Funky $_"
    } @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub go { Pod::Simple::HTML->parse_from_file(@ARGV); exit 0 }
   # Just so we can run from the command line.  No options.
   #  For that, use perldoc!
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $new = shift->SUPER::new(@_);
    #$new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'html', 'HTML' );
    $new->accept_codes('VerbatimFormatted');
    $new->accept_codes(@_to_accept);
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
  
    $new->perldoc_url_prefix(  $Perldoc_URL_Prefix  );
    $new->perldoc_url_postfix( $Perldoc_URL_Postfix );
    $new->man_url_prefix(  $Man_URL_Prefix  );
    $new->man_url_postfix( $Man_URL_Postfix );
    $new->title_prefix(  $Title_Prefix  );
    $new->title_postfix( $Title_Postfix );
  
    $new->html_header_before_title(
     qq[$Doctype_decl<html><head><title>]
    );
    $new->html_header_after_title( join "\n" =>
      "</title>",
      $Content_decl,
      "</head>\n<body class='pod'>",
      $new->version_tag_comment,
      "<!-- start doc -->\n",
    );
    $new->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
    $new->top_anchor( "<a name='___top' class='dummyTopAnchor' ></a>\n" );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    return $new;
  }
  
  sub __adjust_html_h_levels {
    my ($self) = @_;
    my $Tagmap = $self->{'Tagmap'};
  
    my $add = $self->html_h_level;
    return unless defined $add;
    return if ($self->{'Adjusted_html_h_levels'}||0) == $add;
  
    $add -= 1;
    for (1 .. 6) {
      $Tagmap->{"head$_"}  =~ s/$_/$_ + $add/e;
      $Tagmap->{"/head$_"} =~ s/$_/$_ + $add/e;
    }
  }
  
  sub batch_mode_page_object_init {
    my($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    DEBUG and print STDERR "Initting $self\n  for $module\n",
      "  in $infile\n  out $outfile\n  depth $depth\n";
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub do_beginning {
    my $self = $_[0];
  
    my $title;
  
    if(defined $self->force_title) {
      $title = $self->force_title;
      DEBUG and print STDERR "Forcing title to be $title\n";
    } else {
      # Actually try looking for the title in the document:
      $title = $self->get_short_title();
      unless($self->content_seen) {
        DEBUG and print STDERR "No content seen in search for title.\n";
        return;
      }
      $self->{'Title'} = $title;
  
      if(defined $title and $title =~ m/\S/) {
        $title = $self->title_prefix . esc($title) . $self->title_postfix;
      } else {
        $title = $self->default_title;
        $title = '' unless defined $title;
        DEBUG and print STDERR "Title defaults to $title\n";
      }
    }
  
  
    my $after = $self->html_header_after_title  || '';
    if($self->html_css) {
      my $link =
      $self->html_css =~ m/</
       ? $self->html_css # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],
        $self->html_css,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
    $self->_add_top_anchor(\$after);
  
    if($self->html_javascript) {
      my $link =
      $self->html_javascript =~ m/</
       ? $self->html_javascript # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<script type="text/javascript" src="%s"></script>\n],
        $self->html_javascript,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
  
    print {$self->{'output_fh'}}
      $self->html_header_before_title || '',
      $title, # already escaped
      $after,
    ;
  
    DEBUG and print STDERR "Returning from do_beginning...\n";
    return 1;
  }
  
  sub _add_top_anchor {
    my($self, $text_r) = @_;
    unless($$text_r and $$text_r =~ m/name=['"]___top['"]/) { # a hack
      $$text_r .= $self->top_anchor || '';
    }
    return;
  }
  
  sub version_tag_comment {
    my $self = shift;
    return sprintf
     "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",
     esc(
      ref($self), $self->VERSION(), $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime($ENV{SOURCE_DATE_EPOCH} || time)),
     ), $self->_modnote(),
    ;
  }
  
  sub _modnote {
    my $class = ref($_[0]) || $_[0];
    return join "\n   " => grep m/\S/, split "\n",
  
  qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  };
  
  }
  
  sub do_end {
    my $self = $_[0];
    print {$self->{'output_fh'}}  $self->html_footer || '';
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Normally this would just be a call to _do_middle_main_loop -- but we
  #  have to do some elaborate things to emit all the content and then
  #  summarize it and output it /before/ the content that it's a summary of.
  
  sub do_middle {
    my $self = $_[0];
    return $self->_do_middle_main_loop unless $self->index;
  
    if( $self->output_string ) {
      # An efficiency hack
      my $out = $self->output_string; #it's a reference to it
      my $sneakytag = "\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";
      $$out .= $sneakytag;
      $self->_do_middle_main_loop;
      $sneakytag = quotemeta($sneakytag);
      my $index = $self->index_as_html();
      if( $$out =~ s/$sneakytag/$index/s ) {
        # Expected case
        DEBUG and print STDERR "Inserted ", length($index), " bytes of index HTML into $out.\n";
      } else {
        DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n";
        # I don't think this should ever happen.
      }
      return 1;
    }
  
    unless( $self->output_fh ) {
      require Carp;
      Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.");
    }
  
    # If we get here, we're outputting to a FH.  So we need to do some magic.
    # Namely, divert all content to a string, which we output after the index.
    my $fh = $self->output_fh;
    my $content = '';
    {
      # Our horrible bait and switch:
      $self->output_string( \$content );
      $self->_do_middle_main_loop;
      $self->abandon_output_string();
      $self->output_fh($fh);
    }
    print $fh $self->index_as_html();
    print $fh $content;
  
    return 1;
  }
  
  ###########################################################################
  
  sub index_as_html {
    my $self = $_[0];
    # This is meant to be called AFTER the input document has been parsed!
  
    my $points = $self->{'PSHTML_index_points'} || [];
  
    @$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];
     # There's no point in having a 0-item or 1-item index, I dare say.
  
    my(@out) = qq{\n<div class='indexgroup'>};
    my $level = 0;
  
    my( $target_level, $previous_tagname, $tagname, $text, $anchorname, $indent);
    foreach my $p (@$points, ['head0', '(end)']) {
      ($tagname, $text) = @$p;
      $anchorname = $self->section_escape($text);
      if( $tagname =~ m{^head(\d+)$} ) {
        $target_level = 0 + $1;
      } else {  # must be some kinda list item
        if($previous_tagname =~ m{^head\d+$} ) {
          $target_level = $level + 1;
        } else {
          $target_level = $level;  # no change needed
        }
      }
  
      # Get to target_level by opening or closing ULs
      while($level > $target_level)
       { --$level; push @out, ("  " x $level) . "</ul>"; }
      while($level < $target_level)
       { ++$level; push @out, ("  " x ($level-1))
         . "<ul   class='indexList indexList$level'>"; }
  
      $previous_tagname = $tagname;
      next unless $level;
  
      $indent = '  '  x $level;
      push @out, sprintf
        "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",
        $indent, $level, esc($anchorname), esc($text)
      ;
    }
    push @out, "</div>\n";
    return join "\n", @out;
  }
  
  ###########################################################################
  
  sub _do_middle_main_loop {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    my $tagmap = $self->{'Tagmap'};
  
    $self->__adjust_html_h_levels;
  
    my($token, $type, $tagname, $linkto, $linktype);
    my @stack;
    my $dont_wrap = 0;
  
    while($token = $self->get_token) {
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if( ($type = $token->type) eq 'start' ) {
        if(($tagname = $token->tagname) eq 'L') {
          $linktype = $token->attr('type') || 'insane';
  
          $linkto = $self->do_link($token);
  
          if(defined $linkto and length $linkto) {
            esc($linkto);
              #   (Yes, SGML-escaping applies on top of %-escaping!
              #   But it's rarely noticeable in practice.)
            print $fh qq{<a href="$linkto" class="podlink$linktype"\n>};
          } else {
            print $fh "<a>"; # Yes, an 'a' element with no attributes!
          }
  
        } elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s) {
          print $fh $tagmap->{$tagname} || next;
  
          my @to_unget;
          while(1) {
            push @to_unget, $self->get_token;
            last if $to_unget[-1]->is_end
                and $to_unget[-1]->tagname eq $tagname;
  
            # TODO: support for X<...>'s found in here?  (maybe hack into linearize_tokens)
          }
  
          my $name = $self->linearize_tokens(@to_unget);
          $name = $self->do_section($name, $token) if defined $name;
  
          print $fh "<a ";
          if ($tagname =~ m/^head\d$/s) {
              print $fh "class='u'", $self->index
                  ? " href='#___top' title='click to go to top of document'\n"
                  : "\n";
          }
  
          if(defined $name) {
            my $esc = esc(  $self->section_name_tidy( $name ) );
            print $fh qq[name="$esc"];
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens as \"$name\".\n";
            push @{ $self->{'PSHTML_index_points'} }, [$tagname, $name]
             if $ToIndex{ $tagname };
              # Obviously, this discards all formatting codes (saving
              #  just their content), but ahwell.
  
          } else {  # ludicrously long, so nevermind
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens, but it was too long, so nevermind.\n";
          }
          print $fh "\n>";
          $self->unget_token(@to_unget);
  
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          # The parser sometimes preserves newlines and sometimes doesn't!
          (my $text = $next->text) =~ s/\n\z//;
          print $fh $text, "\n";
          next;
  
        } else {
          if( $tagname =~ m/^over-/s ) {
            push @stack, '';
          } elsif( $tagname =~ m/^item-/s and @stack and $stack[-1] ) {
            print $fh $stack[-1];
            $stack[-1] = '';
          }
          print $fh $tagmap->{$tagname} || next;
          ++$dont_wrap if $tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted"
            or $tagname eq 'X';
        }
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'end' ) {
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          if( my $end = pop @stack ) {
            print $fh $end;
          }
        } elsif( $tagname =~ m/^item-/s and @stack) {
          $stack[-1] = $tagmap->{"/$tagname"};
          if( $tagname eq 'item-text' and defined(my $next = $self->get_token) ) {
            $self->unget_token($next);
            if( $next->type eq 'start' ) {
              print $fh $tagmap->{"/item-text"},$tagmap->{"item-body"};
              $stack[-1] = $tagmap->{"/item-body"};
            }
          }
          next;
        }
        print $fh $tagmap->{"/$tagname"} || next;
        --$dont_wrap if $tagname eq 'Verbatim' or $tagname eq 'X';
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'text' ) {
        esc($type = $token->text);  # reuse $type, why not
        $type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless $dont_wrap;
        print $fh $type;
      }
  
    }
    return 1;
  }
  
  ###########################################################################
  #
  
  sub do_section {
    my($self, $name, $token) = @_;
    return $name;
  }
  
  sub do_link {
    my($self, $token) = @_;
    my $type = $token->attr('type');
    if(!defined $type) {
      $self->whine("Typeless L!?", $token->attr('start_line'));
    } elsif( $type eq 'pod') { return $self->do_pod_link($token);
    } elsif( $type eq 'url') { return $self->do_url_link($token);
    } elsif( $type eq 'man') { return $self->do_man_link($token);
    } else {
      $self->whine("L of unknown type $type!?", $token->attr('start_line'));
    }
    return 'FNORG'; # should never get called
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub do_url_link { return $_[1]->attr('to') }
  
  sub do_man_link {
    my ($self, $link) = @_;
    my $to = $link->attr('to');
    my $frag = $link->attr('section');
  
    return undef unless defined $to and length $to; # should never happen
  
    $frag = $self->section_escape($frag)
     if defined $frag and length($frag .= ''); # (stringify)
  
    DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";
  
    return $self->resolve_man_page_link($to, $frag);
  }
  
  
  sub do_pod_link {
    # And now things get really messy...
    my($self, $link) = @_;
    my $to = $link->attr('to');
    my $section = $link->attr('section');
    return undef unless(  # should never happen
      (defined $to and length $to) or
      (defined $section and length $section)
    );
  
    $section = $self->section_escape($section)
     if defined $section and length($section .= ''); # (stringify)
  
    DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",
     $to || "(nil)",  $section || "(nil)";
  
    {
      # An early hack:
      my $complete_url = $self->resolve_pod_link_by_table($to, $section);
      if( $complete_url ) {
        DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",
          $complete_url, "\n  (Returning that.)\n";
        return $complete_url;
      } else {
        DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)",
         " didn't return anything interesting.\n";
      }
    }
  
    if(defined $to and length $to) {
      # Give this routine first hack again
      my $there = $self->resolve_pod_link_by_table($to);
      if(defined $there and length $there) {
        DEBUG > 1
         and print STDERR "resolve_pod_link_by_table(T) gives $there\n";
      } else {
        $there =
          $self->resolve_pod_page_link($to, $section);
           # (I pass it the section value, but I don't see a
           #  particular reason it'd use it.)
        DEBUG > 1 and print STDERR "resolve_pod_page_link gives ", $there || "(nil)", "\n";
        unless( defined $there and length $there ) {
          DEBUG and print STDERR "Can't resolve $to\n";
          return undef;
        }
        # resolve_pod_page_link returning undef is how it
        #  can signal that it gives up on making a link
      }
      $to = $there;
    }
  
    #DEBUG and print STDERR "So far [", $to||'nil', "] [", $section||'nil', "]\n";
  
    my $out = (defined $to and length $to) ? $to : '';
    $out .= "#" . $section if defined $section and length $section;
  
    unless(length $out) { # sanity check
      DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",
       $to || "(nil)",  $section || "(nil)";
      return undef;
    }
  
    DEBUG and print STDERR "Resolved to $out\n";
    return $out;
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub section_escape {
    my($self, $section) = @_;
    return $self->section_url_escape(
      $self->section_name_tidy($section)
    );
  }
  
  sub section_name_tidy {
    my($self, $section) = @_;
    $section =~ s/^\s+//;
    $section =~ s/\s+$//;
    $section =~ tr/ /_/;
    if ($] ge 5.006) {
      $section =~ s/[[:cntrl:][:^ascii:]]//g; # drop crazy characters
    } elsif ('A' eq chr(65)) { # But not on early EBCDIC
      $section =~ tr/\x00-\x1F\x80-\x9F//d;
    }
    $section = $self->unicode_escape_url($section);
    $section = '_' unless length $section;
    return $section;
  }
  
  sub section_url_escape  { shift->general_url_escape(@_) }
  sub pagepath_url_escape { shift->general_url_escape(@_) }
  sub manpage_url_escape  { shift->general_url_escape(@_) }
  
  sub general_url_escape {
    my($self, $string) = @_;
  
    $string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;
       # express Unicode things as urlencode(utf(orig)).
  
    # A pretty conservative escaping, behoovey even for query components
    #  of a URL (see RFC 2396)
  
    if ($] ge 5.007_003) {
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg;
    } else { # Is broken for non-ASCII platforms on early perls
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg;
    }
     # Yes, stipulate the list without a range, so that this can work right on
     #  all charsets that this module happens to run under.
  
    return $string;
  }
  
  #--------------------------------------------------------------------------
  #
  # Oh look, a yawning portal to Hell!  Let's play touch football right by it!
  #
  
  sub resolve_pod_page_link {
    # resolve_pod_page_link must return a properly escaped URL
    my $self = shift;
    return $self->batch_mode()
     ? $self->resolve_pod_page_link_batch_mode(@_)
     : $self->resolve_pod_page_link_singleton_mode(@_)
    ;
  }
  
  sub resolve_pod_page_link_singleton_mode {
    my($self, $it) = @_;
    return undef unless defined $it and length $it;
    my $url = $self->pagepath_url_escape($it);
  
    $url =~ s{::$}{}s; # probably never comes up anyway
    $url =~ s{::}{/}g unless $self->perldoc_url_prefix =~ m/\?/s; # sane DWIM?
  
    return undef unless length $url;
    return $self->perldoc_url_prefix . $url . $self->perldoc_url_postfix;
  }
  
  sub resolve_pod_page_link_batch_mode {
    my($self, $to) = @_;
    DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";
    my @path = grep length($_), split m/::/s, $to, -1;
    unless( @path ) { # sanity
      DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";
      return undef;
    }
    $self->batch_mode_rectify_path(\@path);
    my $out = join('/', map $self->pagepath_url_escape($_), @path)
      . $HTML_EXTENSION;
    DEBUG > 1 and print STDERR " => $out\n";
    return $out;
  }
  
  sub batch_mode_rectify_path {
    my($self, $pathbits) = @_;
    my $level = $self->batch_mode_current_level;
    $level--; # how many levels up to go to get to the root
    if($level < 1) {
      unshift @$pathbits, '.'; # just to be pretty
    } else {
      unshift @$pathbits, ('..') x $level;
    }
    return;
  }
  
  sub resolve_man_page_link {
    my ($self, $to, $frag) = @_;
    my ($page, $section) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
  
    return undef unless defined $page and length $page;
    $section ||= 1;
  
    return $self->man_url_prefix . "$section/"
        . $self->manpage_url_escape($page)
        . $self->man_url_postfix;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub resolve_pod_link_by_table {
    # A crazy hack to allow specifying custom L<foo> => URL mappings
  
    return unless $_[0]->{'podhtml_LOT'};  # An optimizy shortcut
  
    my($self, $to, $section) = @_;
  
    # TODO: add a method that actually populates podhtml_LOT from a file?
  
    if(defined $section) {
      $to = '' unless defined $to and length $to;
      return $self->{'podhtml_LOT'}{"$to#$section"}; # quite possibly undef!
    } else {
      return $self->{'podhtml_LOT'}{$to};            # quite possibly undef!
    }
    return;
  }
  
  ###########################################################################
  
  sub linearize_tokens {  # self, tokens
    my $self = shift;
    my $out = '';
  
    my $t;
    while($t = shift @_) {
      if(!ref $t or !UNIVERSAL::can($t, 'is_text')) {
        $out .= $t; # a string, or some insane thing
      } elsif($t->is_text) {
        $out .= $t->text;
      } elsif($t->is_start and $t->tag eq 'X') {
        # Ignore until the end of this X<...> sequence:
        my $x_open = 1;
        while($x_open) {
          next if( ($t = shift @_)->is_text );
          if(   $t->is_start and $t->tag eq 'X') { ++$x_open }
          elsif($t->is_end   and $t->tag eq 'X') { --$x_open }
        }
      }
    }
    return undef if length $out > $Linearization_Limit;
    return $out;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub unicode_escape_url {
    my($self, $string) = @_;
    $string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;
      #  Turn char 1234 into "(1234)"
    return $string;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub esc { # a function.
    if(defined wantarray) {
      if(wantarray) {
        @_ = splice @_; # break aliasing
      } else {
        my $x = shift;
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
        }
        return $x;
      }
    }
    foreach my $x (@_) {
      # Escape things very cautiously:
      if (defined $x) {
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg
        }
      }
      # Leave out "- so that "--" won't make it thru in X-generated comments
      #  with text in them.
  
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::HTML - convert Pod to HTML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go thingy.pod
  
  
  =head1 DESCRIPTION
  
  This class is for making an HTML rendering of a Pod document.
  
  This is a subclass of L<Pod::Simple::PullParser> and inherits all its
  methods (and options).
  
  Note that if you want to do a batch conversion of a lot of Pod
  documents to HTML, you should see the module L<Pod::Simple::HTMLBatch>.
  
  
  
  =head1 CALLING FROM THE COMMAND LINE
  
  TODO
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go Thing.pod Thing.html
  
  
  
  =head1 CALLING FROM PERL
  
  =head2 Minimal code
  
    use Pod::Simple::HTML;
    my $p = Pod::Simple::HTML->new;
    $p->output_string(\my $html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  =head2 More detailed example
  
    use Pod::Simple::HTML;
  
  Set the content type:
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
    my $p = Pod::Simple::HTML->new;
  
  Include a single javascript source:
  
    $p->html_javascript('http://abc.com/a.js');
  
  Or insert multiple javascript source in the header
  (or for that matter include anything, thought this is not recommended)
  
    $p->html_javascript('
        <script type="text/javascript" src="http://abc.com/b.js"></script>
        <script type="text/javascript" src="http://abc.com/c.js"></script>');
  
  Include a single css source in the header:
  
    $p->html_css('/style.css');
  
  or insert multiple css sources:
  
    $p->html_css('
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://remote.server.com/jquery.css">
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="/style.css">');
  
  Tell the parser where should the output go. In this case it will be placed in the $html variable:
  
    my $html;
    $p->output_string(\$html);
  
  Parse and process a file with pod in it:
  
    $p->parse_file('path/to/Module/Name.pm');
  
  =head1 METHODS
  
  TODO
  all (most?) accessorized methods
  
  The following variables need to be set B<before> the call to the ->new constructor.
  
  Set the string that is included before the opening <html> tag:
  
    $Pod::Simple::HTML::Doctype_decl = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  Set the content-type in the HTML head: (defaults to ISO-8859-1)
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
  Set the value that will be embedded in the opening tags of F, C tags and verbatim text.
  F maps to <em>, C maps to <code>, Verbatim text maps to <pre> (Computerese defaults to "")
  
    $Pod::Simple::HTML::Computerese =  ' class="some_class_name';
  
  =head2 html_css
  
  =head2 html_javascript
  
  =head2 title_prefix
  
  =head2 title_postfix
  
  =head2 html_header_before_title
  
  This includes everything before the <title> opening tag including the Document type
  and including the opening <title> tag. The following call will set it to be a simple HTML
  file:
  
    $p->html_header_before_title('<html><head><title>');
  
  =head2 top_anchor
  
  By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML.
  You can change it by calling
  
    $p->top_anchor('<a name="zz" >');
  
  =head2 html_h_level
  
  Normally =head1 will become <h1>, =head2 will become <h2> etc.
  Using the html_h_level method will change these levels setting the h level
  of =head1 tags:
  
    $p->html_h_level(3);
  
  Will make sure that =head1 will become <h3> and =head2 will become <h4> etc...
  
  
  =head2 index
  
  Set it to some true value if you want to have an index (in reality a table of contents)
  to be added at the top of the generated HTML.
  
    $p->index(1);
  
  =head2 html_header_after_title
  
  Includes the closing tag of </title> and through the rest of the head
  till the opening of the body
  
    $p->html_header_after_title('</title>...</head><body id="my_id">');
  
  =head2 html_footer
  
  The very end of the document:
  
    $p->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
  
  =head1 SUBCLASSING
  
  Can use any of the methods described above but for further customization
  one needs to override some of the methods:
  
    package My::Pod;
    use strict;
    use warnings;
  
    use base 'Pod::Simple::HTML';
  
    # needs to return a URL string such
    # http://some.other.com/page.html
    # #anchor_in_the_same_file
    # /internal/ref.html
    sub do_pod_link {
      # My::Pod object and Pod::Simple::PullParserStartToken object
      my ($self, $link) = @_;
  
      say $link->tagname;          # will be L for links
      say $link->attr('to');       #
      say $link->attr('type');     # will be 'pod' always
      say $link->attr('section');
  
      # Links local to our web site
      if ($link->tagname eq 'L' and $link->attr('type') eq 'pod') {
        my $to = $link->attr('to');
        if ($to =~ /^Padre::/) {
            $to =~ s{::}{/}g;
            return "/docs/Padre/$to.html";
        }
      }
  
      # all other links are generated by the parent class
      my $ret = $self->SUPER::do_pod_link($link);
      return $ret;
    }
  
    1;
  
  Meanwhile in script.pl:
  
    use My::Pod;
  
    my $p = My::Pod->new;
  
    my $html;
    $p->output_string(\$html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die;
    print $out $html;
  
  TODO
  
  maybe override do_beginning do_end
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>
  
  TODO: a corpus of sample Pod input and HTML output?  Or common
  idioms?
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  package Pod::Simple::HTMLBatch;
  use strict;
  our $VERSION = '3.45';
  our @ISA = ();  # Yup, we're NOT a subclass of Pod::Simple::HTML!
  
  # TODO: nocontents stylesheets. Strike some of the color variations?
  
  use Pod::Simple::HTML ();
  BEGIN {*esc = \&Pod::Simple::HTML::esc }
  use File::Spec ();
  
  use Pod::Simple::Search;
  our $SEARCH_CLASS ||= 'Pod::Simple::Search';
  
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  our $SLEEPY;
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
  # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  our $HTML_RENDER_CLASS ||= "Pod::Simple::HTML";
  our $HTML_EXTENSION;
  
  #
  # Methods beginning with "_" are particularly internal and possibly ugly.
  #
  
  Pod::Simple::_accessorize( __PACKAGE__,
   'verbose', # how verbose to be during batch conversion
   'html_render_class', # what class to use to render
   'search_class', # what to use to search for POD documents
   'contents_file', # If set, should be the name of a file (in current directory)
                    # to write the list of all modules to
   'index', # will set $htmlpage->index(...) to this (true or false)
   'progress', # progress object
   'contents_page_start',  'contents_page_end',
  
   'css_flurry', '_css_wad', 'javascript_flurry', '_javascript_wad',
   'no_contents_links', # set to true to suppress automatic adding of << links.
   '_contents',
  );
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Just so we can run from the command line more easily
  sub go {
    @ARGV == 2 or die sprintf(
      "Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",
      __PACKAGE__, __PACKAGE__,
    );
  
    if(defined($ARGV[1]) and length($ARGV[1])) {
      my $d = $ARGV[1];
      -e $d or die "I see no output directory named \"$d\"\nAborting";
      -d $d or die "But \"$d\" isn't a directory!\nAborting";
      -w $d or die "Directory \"$d\" isn't writeable!\nAborting";
    }
  
    __PACKAGE__->batch_convert(@ARGV);
  }
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  
  sub new {
    my $new = bless {}, ref($_[0]) || $_[0];
    $new->html_render_class($HTML_RENDER_CLASS);
    $new->search_class($SEARCH_CLASS);
    $new->verbose(1 + DEBUG);
    $new->_contents([]);
  
    $new->index(1);
  
    $new->       _css_wad([]);         $new->css_flurry(1);
    $new->_javascript_wad([]);  $new->javascript_flurry(1);
  
    $new->contents_file(
      'index' . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION)
    );
  
    $new->contents_page_start( join "\n", grep $_,
      $Pod::Simple::HTML::Doctype_decl,
      "<html><head>",
      "<title>Perl Documentation</title>",
      $Pod::Simple::HTML::Content_decl,
      "</head>",
      "\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n"
    ); # override if you need a different title
  
  
    $new->contents_page_end( sprintf(
      "\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT.</p>\n\n</body></html>\n",
      esc(
        ref($new),
        eval {$new->VERSION} || $VERSION,
        $], scalar(gmtime($ENV{SOURCE_DATE_EPOCH} || time)),
    )));
  
    return $new;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub muse {
    my $self = shift;
    if($self->verbose) {
      print 'T+', int(time() - $self->{'_batch_start_time'}), "s: ", @_, "\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub batch_convert {
    my($self, $dirs, $outdir) = @_;
    $self ||= __PACKAGE__; # tolerate being called as an optionless function
    $self = $self->new unless ref $self; # tolerate being used as a class method
  
    if(!defined($dirs)  or  $dirs eq ''  or  $dirs eq '@INC' ) {
      $dirs = '';
    } elsif(ref $dirs) {
      # OK, it's an explicit set of dirs to scan, specified as an arrayref.
    } else {
      # OK, it's an explicit set of dirs to scan, specified as a
      #  string like "/thing:/also:/whatever/perl" (":"-delim, as usual)
      #  or, under MSWin, like "c:/thing;d:/also;c:/whatever/perl" (";"-delim!)
      require Config;
      my $ps = quotemeta( $Config::Config{'path_sep'} || ":" );
      $dirs = [ grep length($_), split qr/$ps/, $dirs ];
    }
  
    $outdir = $self->filespecsys->curdir
     unless defined $outdir and length $outdir;
  
    $self->_batch_convert_main($dirs, $outdir);
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _batch_convert_main {
    my($self, $dirs, $outdir) = @_;
    # $dirs is either false, or an arrayref.
    # $outdir is a pathspec.
  
    $self->{'_batch_start_time'} ||= time();
  
    $self->muse( "= ", scalar(localtime) );
    $self->muse( "Starting batch conversion to \"$outdir\"" );
  
    my $progress = $self->progress;
    if(!$progress and $self->verbose > 0 and $self->verbose() <= 5) {
      require Pod::Simple::Progress;
      $progress = Pod::Simple::Progress->new(
          ($self->verbose  < 2) ? () # Default omission-delay
        : ($self->verbose == 2) ? 1  # Reduce the omission-delay
                                : 0  # Eliminate the omission-delay
      );
      $self->progress($progress);
    }
  
    if($dirs) {
      $self->muse(scalar(@$dirs), " dirs to scan: @$dirs");
    } else {
      $self->muse("Scanning \@INC.  This could take a minute or two.");
    }
    my $mod2path = $self->find_all_pods($dirs ? $dirs : ());
    $self->muse("Done scanning.");
  
    my $total = keys %$mod2path;
    unless($total) {
      $self->muse("No pod found.  Aborting batch conversion.\n");
      return $self;
    }
  
    $progress and $progress->goal($total);
    $self->muse("Now converting pod files to HTML.",
      ($total > 25) ? "  This will take a while more." : ()
    );
  
    $self->_spray_css(        $outdir );
    $self->_spray_javascript( $outdir );
  
    $self->_do_all_batch_conversions($mod2path, $outdir);
  
    $progress and $progress->done(sprintf (
      "Done converting %d files.",  $self->{"__batch_conv_page_count"}
    ));
    return $self->_batch_convert_finish($outdir);
    return $self;
  }
  
  
  sub _do_all_batch_conversions {
    my($self, $mod2path, $outdir) = @_;
    $self->{"__batch_conv_page_count"} = 0;
  
    foreach my $module (sort {lc($a) cmp lc($b)} keys %$mod2path) {
      $self->_do_one_batch_conversion($module, $mod2path, $outdir);
      sleep($SLEEPY - 1) if $SLEEPY;
    }
  
    return;
  }
  
  sub _batch_convert_finish {
    my($self, $outdir) = @_;
    $self->write_contents_file($outdir);
    $self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");
    $self->muse( "= ", scalar(localtime) );
    $self->progress and $self->progress->done("All done!");
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _do_one_batch_conversion {
    my($self, $module, $mod2path, $outdir, $outfile) = @_;
  
    my $retval;
    my $total    = scalar keys %$mod2path;
    my $infile   = $mod2path->{$module};
    my @namelets = grep m/\S/, split "::", $module;
          # this can stick around in the contents LoL
    my $depth    = scalar @namelets;
    die "Contentless thingie?! $module $infile" unless @namelets; #sanity
  
    $outfile  ||= do {
      my @n = @namelets;
      $n[-1] .= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;
      $self->filespecsys->catfile( $outdir, @n );
    };
  
    my $progress = $self->progress;
  
    my $page = $self->html_render_class->new;
    if(DEBUG > 5) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: ",
        ref($page), " render ($depth) $module => $outfile");
    } elsif(DEBUG > 2) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: $module => $outfile")
    }
  
    # Give each class a chance to init the converter:
    $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_init');
    # Init for the index (TOC), too.
    $self->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_init');
  
    # Now get busy...
    $self->makepath($outdir => \@namelets);
  
    $progress and $progress->reach($self->{"__batch_conv_page_count"}, "Rendering $module");
  
    if( $retval = $page->parse_from_file($infile, $outfile) ) {
      ++ $self->{"__batch_conv_page_count"} ;
      $self->note_for_contents_file( \@namelets, $infile, $outfile );
    } else {
      $self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.");
    }
  
    $page->batch_mode_page_object_kill($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_kill');
    # The following isn't a typo.  Note that it switches $self and $page.
    $self->batch_mode_page_object_kill($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_kill');
  
    DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",
       $outfile, -s $outfile, $infile, -s $infile
    ;
  
    undef($page);
    return $retval;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub filespecsys { $_[0]{'_filespecsys'} || 'File::Spec' }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub note_for_contents_file {
    my($self, $namelets, $infile, $outfile) = @_;
  
    # I think the infile and outfile parts are never used. -- SMB
    # But it's handy to have them around for debugging.
  
    if( $self->contents_file ) {
      my $c = $self->_contents();
      push @$c,
       [ join("::", @$namelets), $infile, $outfile, $namelets ]
       #            0               1         2         3
      ;
      DEBUG > 3 and print STDERR "Noting @$c[-1]\n";
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub write_contents_file {
    my($self, $outdir) = @_;
    my $outfile  = $self->_contents_filespec($outdir) || return;
  
    $self->muse("Preparing list of modules for ToC");
  
    my($toplevel,           # maps  toplevelbit => [all submodules]
       $toplevel_form_freq, # ends up being  'foo' => 'Foo'
      ) = $self->_prep_contents_breakdown;
  
    my $Contents = eval { $self->_wopen($outfile) };
    if( $Contents ) {
      $self->muse( "Writing contents file $outfile" );
    } else {
      warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";
      return;
    }
  
    $self->_write_contents_start(  $Contents, $outfile, );
    $self->_write_contents_middle( $Contents, $outfile, $toplevel, $toplevel_form_freq );
    $self->_write_contents_end(    $Contents, $outfile, );
    return $outfile;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_start {
    my($self, $Contents, $outfile) = @_;
    my $starter = $self->contents_page_start || '';
  
    {
      my $css_wad = $self->_css_wad_to_markup(1);
      if( $css_wad ) {
        $starter =~ s{(</head>)}{\n$css_wad\n$1}i;  # otherwise nevermind
      }
  
      my $javascript_wad = $self->_javascript_wad_to_markup(1);
      if( $javascript_wad ) {
        $starter =~ s{(</head>)}{\n$javascript_wad\n$1}i;   # otherwise nevermind
      }
    }
  
    unless(print $Contents $starter, "<dl class='superindex'>\n" ) {
      warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Contents);
      return 0;
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_middle {
    my($self, $Contents, $outfile, $toplevel2submodules, $toplevel_form_freq) = @_;
  
    foreach my $t (sort keys %$toplevel2submodules) {
      my @downlines = sort {$a->[-1] cmp $b->[-1]}
                            @{ $toplevel2submodules->{$t} };
  
      printf $Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],
        esc( $t, $toplevel_form_freq->{$t} )
      ;
  
      my($path, $name);
      foreach my $e (@downlines) {
        $name = $e->[0];
        $path = join( "/", '.', esc( @{$e->[3]} ) )
          . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);
        print $Contents qq{  <a href="$path">}, esc($name), "</a>&nbsp;&nbsp;\n";
      }
      print $Contents "</dd>\n\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_end {
    my($self, $Contents, $outfile) = @_;
    unless(
      print $Contents "</dl>\n",
        $self->contents_page_end || '',
    ) {
      warn "Couldn't write to $outfile: $!";
    }
    close($Contents) or warn "Couldn't close $outfile: $!";
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _prep_contents_breakdown {
    my($self) = @_;
    my $contents = $self->_contents;
    my %toplevel; # maps  lctoplevelbit => [all submodules]
    my %toplevel_form_freq; # ends up being  'foo' => 'Foo'
                                 # (mapping anycase forms to most freq form)
  
    foreach my $entry (@$contents) {
      my $toplevel =
        $entry->[0] =~ m/^perl\w*$/ ? 'perl_core_docs'
            # group all the perlwhatever docs together
        : $entry->[3][0] # normal case
      ;
      ++$toplevel_form_freq{ lc $toplevel }{ $toplevel };
      push @{ $toplevel{ lc $toplevel } }, $entry;
      push @$entry, lc($entry->[0]); # add a sort-order key to the end
    }
  
    foreach my $toplevel (sort keys %toplevel) {
      my $fgroup = $toplevel_form_freq{$toplevel};
      $toplevel_form_freq{$toplevel} =
      (
        sort { $fgroup->{$b} <=> $fgroup->{$a}  or  $a cmp $b }
          keys %$fgroup
        # This hash is extremely unlikely to have more than 4 members, so this
        # sort isn't so very wasteful
      )[0];
    }
  
    return(\%toplevel, \%toplevel_form_freq) if wantarray;
    return \%toplevel;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _contents_filespec {
    my($self, $outdir) = @_;
    my $outfile = $self->contents_file;
    return unless $outfile;
    return $self->filespecsys->catfile( $outdir, $outfile );
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub makepath {
    my($self, $outdir, $namelets) = @_;
    return unless @$namelets > 1;
    for my $i (0 .. ($#$namelets - 1)) {
      my $dir = $self->filespecsys->catdir( $outdir, @$namelets[0 .. $i] );
      if(-e $dir) {
        die "$dir exists but not as a directory!?" unless -d $dir;
        next;
      }
      DEBUG > 3 and print STDERR "  Making $dir\n";
      mkdir $dir, 0777
       or die "Can't mkdir $dir: $!\nAborting"
      ;
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub batch_mode_page_object_init {
    my $self = shift;
    my($page, $module, $infile, $outfile, $depth) = @_;
  
    # TODO: any further options to percolate onto this new object here?
  
    $page->default_title($module);
    $page->index( $self->index );
  
    $page->html_css(        $self->       _css_wad_to_markup($depth) );
    $page->html_javascript( $self->_javascript_wad_to_markup($depth) );
  
    $self->add_header_backlink($page, $module, $infile, $outfile, $depth);
    $self->add_footer_backlink($page, $module, $infile, $outfile, $depth);
  
  
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub add_header_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_header_after_title( join '',
      $page->html_header_after_title || '',
  
      qq[<p class="backlinktop"><b><a name="___top" href="],
      $self->url_up_to_contents($depth),
      qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub add_footer_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_footer( join '',
      qq[<p class="backlinkbottom"><b><a name="___bottom" href="],
      $self->url_up_to_contents($depth),
      qq[" title="All Documents">&lt;&lt;</a></b></p>\n],
  
      $page->html_footer || '',
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub url_up_to_contents {
    my($self, $depth) = @_;
    --$depth;
    return join '/', ('..') x $depth, esc($self->contents_file);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub find_all_pods {
    my($self, $dirs) = @_;
    # You can override find_all_pods in a subclass if you want to
    #  do extra filtering or whatnot.  But for the moment, we just
    #  pass to modnames2paths:
    return $self->modnames2paths($dirs);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub modnames2paths { # return a hashref mapping modulenames => paths
    my($self, $dirs) = @_;
  
    my $m2p;
    {
      my $search = $self->search_class->new;
      DEBUG and print STDERR "Searching via $search\n";
      $search->verbose(1) if DEBUG > 10;
      $search->progress( $self->progress->copy->goal(0) ) if $self->progress;
      $search->shadows(0);  # don't bother noting shadowed files
      $search->inc(     $dirs ? 0      :  1 );
      $search->survey(  $dirs ? @$dirs : () );
      $m2p = $search->name2path;
      die "What, no name2path?!" unless $m2p;
    }
  
    $self->muse("That's odd... no modules found!") unless keys %$m2p;
    if( DEBUG > 4 ) {
      print STDERR "Modules found (name => path):\n";
      foreach my $m (sort {lc($a) cmp lc($b)} keys %$m2p) {
        print STDERR "  $m  $$m2p{$m}\n";
      }
      print STDERR "(total ",     scalar(keys %$m2p), ")\n\n";
    } elsif( DEBUG ) {
      print STDERR      "Found ", scalar(keys %$m2p), " modules.\n";
    }
    $self->muse( "Found ", scalar(keys %$m2p), " modules." );
  
    # return the Foo::Bar => /whatever/Foo/Bar.pod|pm hashref
    return $m2p;
  }
  
  #===========================================================================
  
  sub _wopen {
    # this is abstracted out so that the daemon class can override it
    my($self, $outpath) = @_;
    require Symbol;
    my $out_fh = Symbol::gensym();
    DEBUG > 5 and print STDERR "Write-opening to $outpath\n";
    return $out_fh if open($out_fh, "> $outpath");
    require Carp;
    Carp::croak("Can't write-open $outpath: $!");
  }
  
  #==========================================================================
  
  sub add_css {
    my($self, $url, $is_default, $name, $content_type, $media, $_code) = @_;
    return unless $url;
    unless($name) {
      # cook up a reasonable name based on the URL
      $name = $url;
      if( $name !~ m/\?/ and $name =~ m{([^/]+)$}s ) {
        $name = $1;
        $name =~ s/\.css//i;
      }
    }
    $media        ||= 'all';
    $content_type ||= 'text/css';
  
    my $bunch = [$url, $name, $content_type, $media, $_code];
    if($is_default) { unshift @{ $self->_css_wad }, $bunch }
    else            { push    @{ $self->_css_wad }, $bunch }
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _spray_css {
    my($self, $outdir) = @_;
  
    return unless $self->css_flurry();
    $self->_gen_css_wad();
  
    my $lol = $self->_css_wad;
    foreach my $chunk (@$lol) {
      my $url = $chunk->[0];
      my $outfile;
      if( ref($chunk->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.css$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";
        # Requires no further attention.
        next;
      }
  
      #$self->muse( "Writing autogenerated CSS file $outfile" );
      my $Cssout = $self->_wopen($outfile);
      print $Cssout ${$chunk->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Cssout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _css_wad_to_markup {
    my($self, $depth) = @_;
  
    my @css  = @{ $self->_css_wad || return '' };
    return '' unless @css;
  
    my $rel = 'stylesheet';
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $chunk (@css) {
      next unless $chunk and @$chunk;
  
      my( $url1, $url2, $title, $type, $media) = (
        $self->_maybe_uplink( $chunk->[0], $uplink ),
        esc(grep !ref($_), @$chunk)
      );
  
      $out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};
  
      $rel = 'alternate stylesheet'; # alternates = all non-first iterations
    }
    return $out;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _maybe_uplink {
    # if the given URL looks relative, return the given uplink string --
    # otherwise return emptystring
    my($self, $url, $uplink) = @_;
    ($url =~ m{^\./} or $url !~ m{[/\:]} )
      ? $uplink
      : ''
      # qualify it, if/as needed
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _gen_css_wad {
    my $self = $_[0];
    my $css_template = $self->_css_template;
    foreach my $variation (
  
     # Commented out for sake of concision:
     #
     #  011n=black_with_red_on_white
     #  001n=black_with_yellow_on_white
     #  101n=black_with_green_on_white
     #  110=white_with_yellow_on_black
     #  010=white_with_green_on_black
     #  011=white_with_blue_on_black
     #  100=white_with_red_on_black
      '110n=blkbluw',  # black_with_blue_on_white
      '010n=blkmagw',  # black_with_magenta_on_white
      '100n=blkcynw',  # black_with_cyan_on_white
      '101=whtprpk',   # white_with_purple_on_black
      '001=whtnavk',   # white_with_navy_blue_on_black
      '010a=grygrnk',  # grey_with_green_on_black
      '010b=whtgrng',  # white_with_green_on_grey
      '101an=blkgrng', # black_with_green_on_grey
      '101bn=grygrnw', # grey_with_green_on_white
    ) {
  
      my $outname = $variation;
      my($flipmode, @swap) = ( ($4 || ''), $1,$2,$3)
        if $outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;
      @swap = () if '010' eq join '', @swap; # 010 is a swop-no-op!
  
      my $this_css =
        "/* This file is autogenerated.  Do not edit.  $variation */\n\n"
        . $css_template;
  
      # Only look at three-digitty colors, for now at least.
      if( $flipmode =~ m/n/ ) {
        $this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;
        $this_css =~ s/\bthin\b/medium/g;
      }
      $this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg   if @swap;
  
      if(   $flipmode =~ m/a/)
         { $this_css =~ s/#fff\b/#999/gi } # black -> dark grey
      elsif($flipmode =~ m/b/)
         { $this_css =~ s/#000\b/#666/gi } # white -> light grey
  
      my $name = $outname;
      $name =~ tr/-_/  /;
      $self->add_css( "_$outname.css", 0, $name, 0, 0, \$this_css);
    }
  
    # Now a few indexless variations:
    for (my ($outfile, $variation) = each %{{
        blkbluw => 'black_with_blue_on_white',
        whtpurk => 'white_with_purple_on_black',
        whtgrng => 'white_with_green_on_grey',
        grygrnw => 'grey_with_green_on_white',
    }}) {
      my $this_css = join "\n",
        "/* This file is autogenerated.  Do not edit.  $outfile */\n",
        "\@import url(\"./_$variation.css\");",
        ".indexgroup { display: none; }",
        "\n",
      ;
      my $name = $outfile;
      $name =~ tr/-_/  /;
      $self->add_css( "_$outfile.css", 0, $name, 0, 0, \$this_css);
    }
  
    return;
  }
  
  sub _color_negate {
    my $x = lc $_[0];
    $x =~ tr[0123456789abcdef]
            [fedcba9876543210];
    return $x;
  }
  
  #===========================================================================
  
  sub add_javascript {
    my($self, $url, $content_type, $_code) = @_;
    return unless $url;
    push  @{ $self->_javascript_wad }, [
      $url, $content_type || 'text/javascript', $_code
    ];
    return;
  }
  
  sub _spray_javascript {
    my($self, $outdir) = @_;
    return unless $self->javascript_flurry();
    $self->_gen_javascript_wad();
  
    my $lol = $self->_javascript_wad;
    foreach my $script (@$lol) {
      my $url = $script->[0];
      my $outfile;
  
      if( ref($script->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.js$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";
        next;
      }
  
      #$self->muse( "Writing JavaScript file $outfile" );
      my $Jsout = $self->_wopen($outfile);
  
      print $Jsout ${$script->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Jsout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  sub _gen_javascript_wad {
    my $self = $_[0];
    my $js_code = $self->_javascript || return;
    $self->add_javascript( "_podly.js", 0, \$js_code);
    return;
  }
  
  sub _javascript_wad_to_markup {
    my($self, $depth) = @_;
  
    my @scripts  = @{ $self->_javascript_wad || return '' };
    return '' unless @scripts;
  
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $s (@scripts) {
      next unless $s and @$s;
  
      my( $url1, $url2, $type, $media) = (
        $self->_maybe_uplink( $s->[0], $uplink ),
        esc(grep !ref($_), @$s)
      );
  
      $out .= qq{<script type="$type" src="$url1$url2"></script>\n};
    }
    return $out;
  }
  
  #===========================================================================
  
  our $CSS = <<'EOCSS';
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3,
    body.pod h4, body.pod h5, body.pod h6  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
  
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
    body.pod h5  { border-top-color: #010; }
    body.pod h6  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h5 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h6 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
  
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
  
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
  
  }
  
  /* The End */
  
  EOCSS
  
  #==========================================================================
  
  our $JAVASCRIPT = <<'EOJAVASCRIPT';
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
  
  sub _css_template { return $CSS }
  sub _javascript   { return $JAVASCRIPT }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  1;
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::HTMLBatch - convert several Pod files to several HTML files
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTMLBatch -e 'Pod::Simple::HTMLBatch::go' in out
  
  
  =head1 DESCRIPTION
  
  This module is used for running batch-conversions of a lot of HTML
  documents
  
  This class is NOT a subclass of Pod::Simple::HTML
  (nor of bad old Pod::Html) -- although it uses
  Pod::Simple::HTML for doing the conversion of each document.
  
  The normal use of this class is like so:
  
    use Pod::Simple::HTMLBatch;
    my $batchconv = Pod::Simple::HTMLBatch->new;
    $batchconv->some_option( some_value );
    $batchconv->some_other_option( some_other_value );
    $batchconv->batch_convert( \@search_dirs, $output_dir );
  
  =head2 FROM THE COMMAND LINE
  
  Note that this class also provides
  (but does not export) the function Pod::Simple::HTMLBatch::go.
  This is basically just a shortcut for C<<
  Pod::Simple::HTMLBatch->batch_convert(@ARGV) >>.
  It's meant to be handy for calling from the command line.
  
  However, the shortcut requires that you specify exactly two command-line
  arguments, C<indirs> and C<outdir>.
  
  Example:
  
    % mkdir out_html
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go @INC out_html
        (to convert the pod from Perl's @INC
         files under the directory ./out_html)
  
  (Note that the command line there contains a literal atsign-I-N-C.  This
  is handled as a special case by batch_convert, in order to save you having
  to enter the odd-looking "" as the first command-line parameter when you
  mean "just use whatever's in @INC".)
  
  Example:
  
    % mkdir ../seekrut
    % chmod og-rx ../seekrut
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go . ../seekrut
        (to convert the pod under the current dir into HTML
         files under the directory ./seekrut)
  
  Example:
  
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go happydocs .
        (to convert all pod from happydocs into the current directory)
  
  
  
  =head1 MAIN METHODS
  
  =over
  
  =item $batchconv = Pod::Simple::HTMLBatch->new;
  
  This creates a new batch converter.  The method doesn't take parameters.
  To change the converter's attributes, use the L<"/ACCESSOR METHODS">
  below.
  
  =item $batchconv->batch_convert( I<indirs>, I<outdir> );
  
  This searches the directories given in I<indirs> and writes
  HTML files for each of these to a corresponding directory
  in I<outdir>.  The directory I<outdir> must exist.
  
  =item $batchconv->batch_convert( undef    , ...);
  
  =item $batchconv->batch_convert( q{@INC}, ...);
  
  These two values for I<indirs> specify that the normal Perl @INC
  
  =item $batchconv->batch_convert( \@dirs , ...);
  
  This specifies that the input directories are the items in
  the arrayref C<\@dirs>.
  
  =item $batchconv->batch_convert( "somedir" , ...);
  
  This specifies that the director "somedir" is the input.
  (This can be an absolute or relative path, it doesn't matter.)
  
  A common value you might want would be just "." for the current
  directory:
  
       $batchconv->batch_convert( "." , ...);
  
  
  =item $batchconv->batch_convert( 'somedir:someother:also' , ...);
  
  This specifies that you want the dirs "somedir", "someother", and "also"
  scanned, just as if you'd passed the arrayref
  C<[qw( somedir someother also)]>.  Note that a ":"-separator is normal
  under Unix, but Under MSWin, you'll need C<'somedir;someother;also'>
  instead, since the pathsep on MSWin is ";" instead of ":".  (And
  I<that> is because ":" often comes up in paths, like
  C<"c:/perl/lib">.)
  
  (Exactly what separator character should be used, is gotten from
  C<$Config::Config{'path_sep'}>, via the L<Config> module.)
  
  =item $batchconv->batch_convert( ... , undef );
  
  This specifies that you want the HTML output to go into the current
  directory.
  
  (Note that a missing or undefined value means a different thing in
  the first slot than in the second.  That's so that C<batch_convert()>
  with no arguments (or undef arguments) means "go from @INC, into
  the current directory.)
  
  =item $batchconv->batch_convert( ... , 'somedir' );
  
  This specifies that you want the HTML output to go into the
  directory 'somedir'.
  (This can be an absolute or relative path, it doesn't matter.)
  
  =back
  
  
  Note that you can also call C<batch_convert> as a class method,
  like so:
  
    Pod::Simple::HTMLBatch->batch_convert( ... );
  
  That is just short for this:
  
    Pod::Simple::HTMLBatch-> new-> batch_convert(...);
  
  That is, it runs a conversion with default options, for
  whatever inputdirs and output dir you specify.
  
  
  =head2 ACCESSOR METHODS
  
  The following are all accessor methods -- that is, they don't do anything
  on their own, but just alter the contents of the conversion object,
  which comprises the options for this particular batch conversion.
  
  We show the "put" form of the accessors below (i.e., the syntax you use
  for setting the accessor to a specific value).  But you can also
  call each method with no parameters to get its current value.  For
  example, C<< $self->contents_file() >> returns the current value of
  the contents_file attribute.
  
  =over
  
  
  =item $batchconv->verbose( I<nonnegative_integer> );
  
  This controls how verbose to be during batch conversion, as far as
  notes to STDOUT (or whatever is C<select>'d) about how the conversion
  is going.  If 0, no progress information is printed.
  If 1 (the default value), some progress information is printed.
  Higher values print more information.
  
  
  =item $batchconv->index( I<true-or-false> );
  
  This controls whether or not each HTML page is liable to have a little
  table of contents at the top (which we call an "index" for historical
  reasons).  This is true by default.
  
  
  =item $batchconv->contents_file( I<filename> );
  
  If set, should be the name of a file (in the output directory)
  to write the HTML index to.  The default value is "index.html".
  If you set this to a false value, no contents file will be written.
  
  =item $batchconv->contents_page_start( I<HTML_string> );
  
  This specifies what string should be put at the beginning of
  the contents page.
  The default is a string more or less like this:
  
    <html>
    <head><title>Perl Documentation</title></head>
    <body class='contentspage'>
    <h1>Perl Documentation</h1>
  
  =item $batchconv->contents_page_end( I<HTML_string> );
  
  This specifies what string should be put at the end of the contents page.
  The default is a string more or less like this:
  
    <p class='contentsfooty'>Generated by
    Pod::Simple::HTMLBatch v3.01 under Perl v5.008
    <br >At Fri May 14 22:26:42 2004 GMT,
    which is Fri May 14 14:26:42 2004 local time.</p>
  
  
  
  =item $batchconv->add_css( $url );
  
  TODO
  
  =item $batchconv->add_javascript( $url );
  
  TODO
  
  =item $batchconv->css_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate some CSS files in the
  output directory, and set our HTML files to use those.
  TODO: continue
  
  =item $batchconv->javascript_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate a JavaScript in the
  output directory, and set our HTML files to use it.  Currently,
  the JavaScript is used only to get the browser to remember what
  stylesheet it prefers.
  TODO: continue
  
  =item $batchconv->no_contents_links( I<true-or-false> );
  
  TODO
  
  =item $batchconv->html_render_class( I<classname> );
  
  This sets what class is used for rendering the files.
  The default is "Pod::Simple::HTML".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::HTML, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =item $batchconv->search_class( I<classname> );
  
  This sets what class is used for searching for the files.
  The default is "Pod::Simple::Search".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::Search, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =back
  
  
  
  
  =head1 NOTES ON CUSTOMIZATION
  
  TODO
  
    call add_css($someurl) to add stylesheet as alternate
    call add_css($someurl,1) to add as primary stylesheet
  
    call add_javascript
  
    subclass Pod::Simple::HTML and set $batchconv->html_render_class to
      that classname
    and maybe override
      $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
    or maybe override
      $batchconv->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
    subclass Pod::Simple::Search and set $batchconv->search_class to
      that classname
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>, L<perlpod>, L<perlpodspec>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  use warnings;
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  package Pod::Simple::HTMLLegacy;
  use strict;
  use warnings;
  
  use Getopt::Long;
  
  our $VERSION = "5.01";
  
  #--------------------------------------------------------------------------
  #
  # This class is meant to thinly emulate bad old Pod::Html
  #
  # TODO: some basic docs
  
  sub pod2html {
    my @args = (@_);
  
    my( $verbose, $infile, $outfile, $title );
    my $index = 1;
  
    {
      my($help);
  
      my($netscape); # dummy
      local @ARGV = @args;
      GetOptions(
        "help"       => \$help,
        "verbose!"   => \$verbose,
        "infile=s"   => \$infile,
        "outfile=s"  => \$outfile,
        "title=s"    => \$title,
        "index!"     => \$index,
  
        "netscape!"   => \$netscape,
      ) or return bad_opts(@args);
      bad_opts(@args) if @ARGV; # it should be all switches!
      return help_message() if $help;
    }
  
    for($infile, $outfile) { $_ = undef unless defined and length }
  
    if($verbose) {
      warn sprintf "%s version %s\n", __PACKAGE__, $VERSION;
      warn "OK, processed args [@args] ...\n";
      warn sprintf
        " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",
        map defined($_) ? $_ : "(nil)",
         $verbose,     $index,     $infile,     $outfile,     $title,
      ;
      *Pod::Simple::HTML::DEBUG = sub(){1};
    }
    require Pod::Simple::HTML;
    Pod::Simple::HTML->VERSION(3);
  
    die "No such input file as $infile\n"
     if defined $infile and ! -e $infile;
  
  
    my $pod = Pod::Simple::HTML->new;
    $pod->force_title($title) if defined $title;
    $pod->index($index);
    return $pod->parse_from_file($infile, $outfile);
  }
  
  #--------------------------------------------------------------------------
  
  sub bad_opts     { die _help_message();         }
  sub help_message { print STDOUT _help_message() }
  
  #--------------------------------------------------------------------------
  
  sub _help_message {
  
    join '',
  
  "[", __PACKAGE__, " version ", $VERSION, qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~;
  
  }
  
  1;
  __END__
  
  OVER the underpass! UNDER the overpass! Around the FUTURE and BEYOND REPAIR!!
  
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/JustPod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_JUSTPOD';
  package Pod::Simple::JustPod;
  # ABSTRACT: Pod::Simple formatter that extracts POD from a file containing
  #           other things as well
  use strict;
  use warnings;
  
  use Pod::Simple::Methody ();
  our @ISA = ('Pod::Simple::Methody');
  
  sub new {
    my $self = shift;
    my $new  = $self->SUPER::new(@_);
  
    $new->accept_targets('*');
    $new->keep_encoding_directive(1);
    $new->preserve_whitespace(1);
    $new->complain_stderr(1);
    $new->_output_is_for_JustPod(1);
  
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub check_that_all_is_closed {
  
    # Actually checks that the things we depend on being balanced in fact are,
    # so that we can continue in spit of pod errors
  
    my $self = shift;
    while ($self->{inL}) {
      $self->end_L(@_);
    }
    while ($self->{fcode_end} && @{$self->{fcode_end}}) {
      $self->_end_fcode(@_);
    }
  }
  
  sub handle_text {
  
    # Add text to the output buffer.  This is skipped if within a L<>, as we use
    # the 'raw' attribute of that tag instead.
  
    $_[0]{buffer} .= $_[1] unless $_[0]{inL} ;
  }
  
  sub spacer {
  
    # Prints the white space following things like =head1.  This is normally a
    # blank, unless BlackBox has told us otherwise.
  
    my ($self, $arg) = @_;
    return unless $arg;
  
    my $spacer = ($arg->{'~orig_spacer'})
                  ? $arg->{'~orig_spacer'}
                  : " ";
    $self->handle_text($spacer);
  }
  
  sub _generic_start {
  
    # Called from tags like =head1, etc.
  
    my ($self, $text, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text($text);
    $self->spacer($arg);
  }
  
  sub start_Document    { shift->_generic_start("=pod\n\n"); }
  sub start_head1       { shift->_generic_start('=head1', @_); }
  sub start_head2       { shift->_generic_start('=head2', @_); }
  sub start_head3       { shift->_generic_start('=head3', @_); }
  sub start_head4       { shift->_generic_start('=head4', @_); }
  sub start_head5       { shift->_generic_start('=head5', @_); }
  sub start_head6       { shift->_generic_start('=head6', @_); }
  sub start_encoding    { shift->_generic_start('=encoding', @_); }
  # sub start_Para
  # sub start_Verbatim
  
  sub start_item_bullet { # Handle =item *
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text('=item');
  
    # It can be that they said simply '=item', and it is inferred that it is to
    # be a bullet.
    if (! $arg->{'~orig_content'}) {
      $self->handle_text("\n\n");
    }
    else {
      $self->spacer($arg);
      if ($arg->{'~_freaky_para_hack'}) {
  
          # See Message Id <87y3gtcwa2.fsf@hope.eyrie.org>
          my $item_text = $arg->{'~orig_content'};
          my $trailing = quotemeta $arg->{'~_freaky_para_hack'};
          $item_text =~ s/$trailing$//;
          $self->handle_text($item_text);
      }
      else {
          $self->handle_text("*\n\n");
      }
    }
  }
  
  sub start_item_number {     # Handle '=item 2'
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text("=item");
    $self->spacer($arg);
    $self->handle_text("$arg->{'~orig_content'}\n\n");
  }
  
  sub start_item_text {   # Handle '=item foo bar baz'
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text('=item');
    $self->spacer($arg);
  }
  
  sub _end_item {
    my $self = shift;
    $self->check_that_all_is_closed();
    $self->emit;
  }
  
  *end_item_bullet = *_end_item;
  *end_item_number = *_end_item;
  *end_item_text   = *_end_item;
  
  sub _start_over  {  # Handle =over
    my ($self, $arg) = @_;
    $self->check_that_all_is_closed();
    $self->handle_text("=over");
  
    # The =over amount is optional
    if ($arg->{'~orig_content'}) {
      $self->spacer($arg);
      $self->handle_text("$arg->{'~orig_content'}");
    }
    $self->handle_text("\n\n");
  }
  
  *start_over_bullet = *_start_over;
  *start_over_number = *_start_over;
  *start_over_text   = *_start_over;
  *start_over_block  = *_start_over;
  
  sub _end_over  {
    my $self = shift;
    $self->check_that_all_is_closed();
    $self->handle_text('=back');
    $self->emit;
  }
  
  *end_over_bullet = *_end_over;
  *end_over_number = *_end_over;
  *end_over_text   = *_end_over;
  *end_over_block  = *_end_over;
  
  sub end_Document    {
    my $self = shift;
    $self->emit;        # Make sure buffer gets flushed
    print {$self->{'output_fh'} } "=cut\n"
  }
  
  sub _end_generic  {
    my $self = shift;
    $self->check_that_all_is_closed();
    $self->emit;
  }
  
  *end_head1    = *_end_generic;
  *end_head2    = *_end_generic;
  *end_head3    = *_end_generic;
  *end_head4    = *_end_generic;
  *end_head5    = *_end_generic;
  *end_head6    = *_end_generic;
  *end_encoding = *_end_generic;
  *end_Para     = *_end_generic;
  *end_Verbatim = *_end_generic;
  
  sub _start_fcode {
    my ($type, $self, $flags) = @_;
  
    # How many brackets is set by BlackBox unless the count is 1
    my $bracket_count = (exists $flags->{'~bracket_count'})
                         ? $flags->{'~bracket_count'}
                         : 1;
    $self->handle_text($type . ( "<" x $bracket_count));
  
    my $rspacer = "";
    if ($bracket_count > 1) {
      my $lspacer = (exists $flags->{'~lspacer'})
                    ? $flags->{'~lspacer'}
                    : " ";
      $self->handle_text($lspacer);
  
      $rspacer = (exists $flags->{'~rspacer'})
                    ? $flags->{'~rspacer'}
                    : " ";
    }
  
    # BlackBox doesn't output things for for the ending code callbacks, so save
    # what we need.
    push @{$self->{'fcode_end'}}, [ $bracket_count, $rspacer ];
  }
  
  sub start_B { _start_fcode('B', @_); }
  sub start_C { _start_fcode('C', @_); }
  sub start_E { _start_fcode('E', @_); }
  sub start_F { _start_fcode('F', @_); }
  sub start_I { _start_fcode('I', @_); }
  sub start_S { _start_fcode('S', @_); }
  sub start_X { _start_fcode('X', @_); }
  sub start_Z { _start_fcode('Z', @_); }
  
  sub _end_fcode {
      my $self = shift;
      my $fcode_end = pop @{$self->{'fcode_end'}};
      my $bracket_count = 1;
      my $rspacer = "";
  
      if (! defined $fcode_end) { # If BlackBox is working, this shouldn't
                                  # happen, but verify
        $self->whine($self->{line_count}, "Extra '>'");
      }
      else {
        $bracket_count = $fcode_end->[0];
        $rspacer = $fcode_end->[1];
      }
  
      $self->handle_text($rspacer) if $bracket_count > 1;
      $self->handle_text(">" x $bracket_count);
  }
  
  *end_B   = *_end_fcode;
  *end_C   = *_end_fcode;
  *end_E   = *_end_fcode;
  *end_F   = *_end_fcode;
  *end_I   = *_end_fcode;
  *end_S   = *_end_fcode;
  *end_X   = *_end_fcode;
  *end_Z   = *_end_fcode;
  
  sub start_L {
      _start_fcode('L', @_);
      $_[0]->handle_text($_[1]->{raw});
      $_[0]->{inL}++
  }
  
  sub end_L {
    my $self = shift;
    $self->{inL}--;
    if ($self->{inL} < 0) {   # If BlackBox is working, this shouldn't
                              # happen, but verify
      $self->whine($self->{line_count}, "Extra '>' ending L<>");
      $self->{inL} = 0;
    }
  
    $self->_end_fcode(@_);
  }
  
  sub emit {
    my $self = shift;
  
    if ($self->{buffer} ne "") {
      print { $self->{'output_fh'} } "",$self->{buffer} ,"\n\n";
  
      $self->{buffer} = "";
    }
  
    return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::JustPod -- just the Pod, the whole Pod, and nothing but the Pod
  
  =head1 SYNOPSIS
  
   my $infile  = "mixed_code_and_pod.pm";
   my $outfile = "just_the_pod.pod";
   open my $fh, ">$outfile" or die "Can't write to $outfile: $!";
  
   my $parser = Pod::Simple::JustPod->new();
   $parser->output_fh($fh);
   $parser->parse_file($infile);
   close $fh or die "Can't close $outfile: $!";
  
  =head1 DESCRIPTION
  
  This class returns a copy of its input, translated into Perl's internal
  encoding (UTF-8), and with all the non-Pod lines removed.
  
  This is a subclass of L<Pod::Simple::Methody> and inherits all its methods.
  And since, that in turn is a subclass of L<Pod::Simple>, you can use any of
  its methods.  This means you can output to a string instead of a file, or
  you can parse from an array.
  
  This class strives to return the Pod lines of the input completely unchanged,
  except for any necessary translation into Perl's internal encoding, and it makes
  no effort to return trailing spaces on lines; these likely will be stripped.
  If the input pod is well-formed with no warnings nor errors generated, the
  extracted pod should generate the same documentation when formatted by a Pod
  formatter as the original file does.
  
  By default, warnings are output to STDERR
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Methody>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  L<mailto:pod-people@perl.org> mail list. Send an empty email to
  L<mailto:pod-people-subscribe@perl.org> to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/theory/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/theory/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  L<mailto:<bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  Pod::Simple::JustPod was developed by John SJ Anderson
  C<genehack@genehack.org>, with contributions from Karl Williamson
  C<khw@cpan.org>.
  
  =cut
POD_SIMPLE_JUSTPOD

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  package Pod::Simple::LinkSection;
    # Based somewhat dimly on Array::Autojoin
  
  use strict;
  use warnings;
  use Pod::Simple::BlackBox;
  our $VERSION = '3.45';
  
  use overload( # So it'll stringify nice
    '""'   => \&Pod::Simple::BlackBox::stringify_lol,
    'bool' => \&Pod::Simple::BlackBox::stringify_lol,
    # '.='   => \&tack_on,  # grudgingly support
  
    'fallback' => 1,         # turn on cleverness
  );
  
  sub tack_on {
    $_[0] = ['', {}, "$_[0]" ];
    return $_[0][2] .= $_[1];
  }
  
  sub as_string {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  sub stringify {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  
  sub new {
    my $class = shift;
    $class = ref($class) || $class;
    my $new;
    if(@_ == 1) {
      if (!ref($_[0] || '')) { # most common case: one bare string
        return bless ['', {}, $_[0] ], $class;
      } elsif( ref($_[0] || '') eq 'ARRAY') {
        $new = [ @{ $_[0] } ];
      } else {
        Carp::croak( "$class new() doesn't know to clone $new" );
      }
    } else { # misc stuff
      $new = [ '', {}, @_ ];
    }
  
    # By now it's a treelet:  [ 'foo', {}, ... ]
    foreach my $x (@$new) {
      if(ref($x || '') eq 'ARRAY') {
        $x = $class->new($x); # recurse
      } elsif(ref($x || '') eq 'HASH') {
        $x = { %$x };
      }
       # otherwise leave it.
    }
  
    return bless $new, $class;
  }
  
  # Not much in this class is likely to be link-section specific --
  # but it just so happens that link-sections are about the only treelets
  # that are exposed to the user.
  
  1;
  
  __END__
  
  # TODO: let it be an option whether a given subclass even wants little treelets?
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::LinkSection -- represent "section" attributes of L codes
  
  =head1 SYNOPSIS
  
   # a long story
  
  =head1 DESCRIPTION
  
  This class is not of interest to general users.
  
  Pod::Simple uses this class for representing the value of the
  "section" attribute of "L" start-element events.  Most applications
  can just use the normal stringification of objects of this class;
  they stringify to just the text content of the section,
  such as "foo" for
  C<< LZ<><Stuff/foo> >>, and "bar" for
  C<< LZ<><Stuff/bIZ<><ar>> >>.
  
  However, anyone particularly interested in getting the full value of
  the treelet, can just traverse the content of the treeleet
  @$treelet_object.  To wit:
  
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper($_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = bless( [
                     '',
                     {},
                     'b',
                     bless( [
                              'I',
                              {},
                              'ar'
                            ], 'Pod::Simple::LinkSection' ),
                     'baz'
                   ], 'Pod::Simple::LinkSection' );
  
  But stringify it and you get just the text content:
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper( '' . $_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = 'barbaz';
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  package Pod::Simple::Methody;
  use strict;
  use warnings;
  use Pod::Simple ();
  our $VERSION = '3.45';
  our @ISA = ('Pod::Simple');
  
  # Yes, we could use named variables, but I want this to be impose
  # as little an additional performance hit as possible.
  
  sub _handle_element_start {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'start_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  sub _handle_text {
    ( $_[0]->can( 'handle_text' )
      || return
    )->(
      @_
    );
  }
  
  sub _handle_element_end {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'end_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Methody -- turn Pod::Simple events into method calls
  
  =head1 SYNOPSIS
  
   require 5;
   use strict;
   package SomePodFormatter;
   use base qw(Pod::Simple::Methody);
  
   sub handle_text {
     my($self, $text) = @_;
     ...
   }
  
   sub start_head1 {
     my($self, $attrs) = @_;
     ...
   }
   sub end_head1 {
     my($self) = @_;
     ...
   }
  
  ...and start_/end_ methods for whatever other events you want to catch.
  
  =head1 DESCRIPTION
  
  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  This class (which is very small -- read the source) overrides
  Pod::Simple's _handle_element_start, _handle_text, and
  _handle_element_end methods so that parser events are turned into method
  calls. (Otherwise, this is a subclass of L<Pod::Simple> and inherits all
  its methods.)
  
  You can use this class as the base class for a Pod formatter/processor.
  
  =head1 METHOD CALLING
  
  When Pod::Simple sees a "=head1 Hi there", for example, it basically does
  this:
  
    $parser->_handle_element_start( "head1", \%attributes );
    $parser->_handle_text( "Hi there" );
    $parser->_handle_element_end( "head1" );
  
  But if you subclass Pod::Simple::Methody, it will instead do this
  when it sees a "=head1 Hi there":
  
    $parser->start_head1( \%attributes ) if $parser->can('start_head1');
    $parser->handle_text( "Hi there" )   if $parser->can('handle_text');
    $parser->end_head1()                 if $parser->can('end_head1');
  
  If Pod::Simple sends an event where the element name has a dash,
  period, or colon, the corresponding method name will have a underscore
  in its place.  For example, "foo.bar:baz" becomes start_foo_bar_baz
  and end_foo_bar_baz.
  
  See the source for Pod::Simple::Text for an example of using this class.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  package Pod::Simple::Progress;
  use strict;
  use warnings;
  
  our $VERSION = '3.45';
  
  # Objects of this class are used for noting progress of an
  #  operation every so often.  Messages delivered more often than that
  #  are suppressed.
  #
  # There's actually nothing in here that's specific to Pod processing;
  #  but it's ad-hoc enough that I'm not willing to give it a name that
  #  implies that it's generally useful, like "IO::Progress" or something.
  #
  # -- sburke
  #
  #--------------------------------------------------------------------------
  
  sub new {
    my($class,$delay) = @_;
    my $self = bless {'quiet_until' => 1},  ref($class) || $class;
    $self->to(*STDOUT{IO});
    $self->delay(defined($delay) ? $delay : 5);
    return $self;
  }
  
  sub copy {
    my $orig = shift;
    bless {%$orig, 'quiet_until' => 1}, ref($orig);
  }
  #--------------------------------------------------------------------------
  
  sub reach {
    my($self, $point, $note) = @_;
    if( (my $now = time) >= $self->{'quiet_until'}) {
      my $goal;
      my    $to = $self->{'to'};
      print $to join('',
        ($self->{'quiet_until'} == 1) ? () : '... ',
        (defined $point) ? (
          '#',
          ($goal = $self->{'goal'}) ? (
            ' ' x (length($goal) - length($point)),
            $point, '/', $goal,
          ) : $point,
          $note ? ': ' : (),
        ) : (),
        $note || '',
        "\n"
      );
      $self->{'quiet_until'} = $now + $self->{'delay'};
    }
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub done {
    my($self, $note) = @_;
    $self->{'quiet_until'} = 1;
    return $self->reach( undef, $note );
  }
  
  #--------------------------------------------------------------------------
  # Simple accessors:
  
  sub delay {
    return $_[0]{'delay'} if @_ == 1; $_[0]{'delay'} = $_[1]; return $_[0] }
  sub goal {
    return $_[0]{'goal' } if @_ == 1; $_[0]{'goal' } = $_[1]; return $_[0] }
  sub to   {
    return $_[0]{'to'   } if @_ == 1; $_[0]{'to'   } = $_[1]; return $_[0] }
  
  #--------------------------------------------------------------------------
  
  unless(caller) { # Simple self-test:
    my $p = __PACKAGE__->new->goal(5);
    $p->reach(1, "Primus!");
    sleep 1;
    $p->reach(2, "Secundus!");
    sleep 3;
    $p->reach(3, "Tertius!");
    sleep 5;
    $p->reach(4);
    $p->reach(5, "Quintus!");
    sleep 1;
    $p->done("All done");
  }
  
  #--------------------------------------------------------------------------
  1;
  __END__
  
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  package Pod::Simple::PullParser;
  use strict;
  our $VERSION = '3.45';
  use Pod::Simple ();
  BEGIN {our @ISA = ('Pod::Simple')}
  
  use Carp ();
  
  use Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserTextToken;
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  __PACKAGE__->_accessorize(
    'source_fh',         # the filehandle we're reading from
    'source_scalar_ref', # the scalarref we're reading from
    'source_arrayref',   # the arrayref we're reading from
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  And here is how we implement a pull-parser on top of a push-parser...
  
  sub filter {
    my($self, $source) = @_;
    $self = $self->new unless ref $self;
  
    $source = *STDIN{IO} unless defined $source;
    $self->set_source($source);
    $self->output_fh(*STDOUT{IO});
  
    $self->run; # define run() in a subclass if you want to use filter()!
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub parse_string_document {
    my $this = shift;
    $this->set_source(\ $_[0]);
    $this->run;
  }
  
  sub parse_file {
    my($this, $filename) = @_;
    $this->set_source($filename);
    $this->run;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #  In case anyone tries to use them:
  
  sub run {
    use Carp ();
    if( __PACKAGE__ eq (ref($_[0]) || $_[0])) { # I'm not being subclassed!
      Carp::croak "You can call run() only on subclasses of "
       . __PACKAGE__;
    } else {
      Carp::croak join '',
        "You can't call run() because ",
        ref($_[0]) || $_[0], " didn't define a run() method";
    }
  }
  
  sub parse_lines {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_lines";
  }
  
  sub parse_line {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_line";
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(@_);
    die "Couldn't construct for $class" unless $self;
  
    $self->{'token_buffer'} ||= [];
    $self->{'start_token_class'} ||= 'Pod::Simple::PullParserStartToken';
    $self->{'text_token_class'}  ||= 'Pod::Simple::PullParserTextToken';
    $self->{'end_token_class'}   ||= 'Pod::Simple::PullParserEndToken';
  
    DEBUG > 1 and print STDERR "New pullparser object: $self\n";
  
    return $self;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_token {
    my $self = shift;
    DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";
    DEBUG > 2 and print STDERR " Items in token-buffer (",
     scalar( @{ $self->{'token_buffer'} } ) ,
     ") :\n", map(
       "    " . $_->dump . "\n", @{ $self->{'token_buffer'} }
     ),
     @{ $self->{'token_buffer'} } ? '' : '       (no tokens)',
     "\n"
    ;
  
    until( @{ $self->{'token_buffer'} } ) {
      DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";
      if($self->{'source_dead'}) {
        DEBUG and print STDERR "$self 's source is dead.\n";
        push @{ $self->{'token_buffer'} }, undef;
      } elsif(exists $self->{'source_fh'}) {
        my @lines;
        my $fh = $self->{'source_fh'}
         || Carp::croak('You have to call set_source before you can call get_token');
  
        DEBUG and print STDERR "$self 's source is filehandle $fh.\n";
        # Read those many lines at a time
        for(my $i = Pod::Simple::MANY_LINES; $i--;) {
          DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";
          local $/ = $Pod::Simple::NL;
          push @lines, scalar(<$fh>); # readline
          DEBUG > 3 and print STDERR "  Line is: ",
            defined($lines[-1]) ? $lines[-1] : "<undef>\n";
          unless( defined $lines[-1] ) {
            DEBUG and print STDERR "That's it for that source fh!  Killing.\n";
            delete $self->{'source_fh'}; # so it can be GC'd
            last;
          }
           # but pass thru the undef, which will set source_dead to true
  
          # TODO: look to see if $lines[-1] is =encoding, and if so,
          # do horribly magic things
  
        }
  
        if(DEBUG > 8) {
          print STDERR "* I've gotten ", scalar(@lines), " lines:\n";
          foreach my $l (@lines) {
            if(defined $l) {
              print STDERR "  line {$l}\n";
            } else {
              print STDERR "  line undef\n";
            }
          }
          print STDERR "* end of ", scalar(@lines), " lines\n";
        }
  
        $self->SUPER::parse_lines(@lines);
  
      } elsif(exists $self->{'source_arrayref'}) {
        DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",
         scalar(@{$self->{'source_arrayref'}}), " items left in it.\n";
  
        DEBUG > 3 and print STDERR "  Fetching ", Pod::Simple::MANY_LINES, " lines.\n";
        $self->SUPER::parse_lines(
          splice @{ $self->{'source_arrayref'} },
          0,
          Pod::Simple::MANY_LINES
        );
        unless( @{ $self->{'source_arrayref'} } ) {
          DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_arrayref'}; # so it can be GC'd
        }
         # to make sure that an undef is always sent to signal end-of-stream
  
      } elsif(exists $self->{'source_scalar_ref'}) {
  
        DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",
          length(${ $self->{'source_scalar_ref'} }) -
          (pos(${ $self->{'source_scalar_ref'} }) || 0),
          " characters left to parse.\n";
  
        DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";
        if( ${ $self->{'source_scalar_ref'} } =~
          m/([^\n\r]*)((?:\r?\n)?)/g
        ) {
          #print(">> $1\n"),
          $self->SUPER::parse_lines($1)
           if length($1) or length($2)
            or pos(     ${ $self->{'source_scalar_ref'} })
             != length( ${ $self->{'source_scalar_ref'} });
           # I.e., unless it's a zero-length "empty line" at the very
           #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
        } else { # that's the end.  Byebye
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_scalar_ref'};
          DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n";
        }
  
  
      } else {
        die "What source??";
      }
    }
    DEBUG and print STDERR "get_token about to return ",
     Pod::Simple::pretty( @{$self->{'token_buffer'}}
       ? $self->{'token_buffer'}[-1] : undef
     ), "\n";
    return shift @{$self->{'token_buffer'}}; # that's an undef if empty
  }
  
  sub unget_token {
    my $self = shift;
    DEBUG and print STDERR "Ungetting ", scalar(@_), " tokens: ",
     @_ ? "@_\n" : "().\n";
    foreach my $t (@_) {
      Carp::croak "Can't unget that, because it's not a token -- it's undef!"
       unless defined $t;
      Carp::croak "Can't unget $t, because it's not a token -- it's a string!"
       unless ref $t;
      Carp::croak "Can't unget $t, because it's not a token object!"
       unless UNIVERSAL::can($t, 'type');
    }
  
    unshift @{$self->{'token_buffer'}}, @_;
    DEBUG > 1 and print STDERR "Token buffer now has ",
     scalar(@{$self->{'token_buffer'}}), " items in it.\n";
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # $self->{'source_filename'} = $source;
  
  sub set_source {
    my $self = shift @_;
    return $self->{'source_fh'} unless @_;
    Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")
        if $self->{'source_fh'} || $self->{'source_scalar_ref'} || $self->{'source_arrayref'};
    my $handle;
    if(!defined $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } elsif(ref(\( $_[0] )) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is glob $_[0]\n";
      # and fall thru
    } elsif(ref( $_[0] ) eq 'SCALAR') {
      $self->{'source_scalar_ref'} = $_[0];
      DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";
      return;
    } elsif(ref( $_[0] ) eq 'ARRAY') {
      $self->{'source_arrayref'} = $_[0];
      DEBUG and print STDERR "$self 's source is array ref $_[0]\n";
      return;
    } elsif(ref $_[0]) {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n";
    } elsif(!length $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } else {  # It's a filename!
      DEBUG and print STDERR "$self 's source is filename $_[0]\n";
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$_[0]") || Carp::croak "Can't open $_[0]: $!";
        $handle = *PODSOURCE{IO};
      }
      $self->{'source_filename'} = $_[0];
      DEBUG and print STDERR "  Its name is $_[0].\n";
  
      # TODO: file-discipline things here!
    }
  
    $self->{'source_fh'} = $handle;
    DEBUG and print STDERR "  Its handle is $handle\n";
    return 1;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_title_short {  shift->get_short_title(@_)  } # alias
  
  sub get_short_title {
    my $title = shift->get_title(@_);
    $title = $1 if $title =~ m/^(\S{1,60})\s+--?\s+./s;
      # turn "Foo::Bar -- bars for your foo" into "Foo::Bar"
    return $title;
  }
  
  sub get_title       { shift->_get_titled_section(
    'NAME', max_token => 50, desperate => 1, @_)
  }
  sub get_version     { shift->_get_titled_section(
     'VERSION',
      max_token => 400,
      accept_verbatim => 1,
      max_content_length => 3_000,
     @_,
    );
  }
  sub get_description { shift->_get_titled_section(
     'DESCRIPTION',
      max_token => 400,
      max_content_length => 3_000,
     @_,
  ) }
  
  sub get_authors     { shift->get_author(@_) }  # a harmless alias
  
  sub get_author      {
    my $this = shift;
    # Max_token is so high because these are
    #  typically at the end of the document:
    $this->_get_titled_section('AUTHOR' , max_token => 10_000, @_) ||
    $this->_get_titled_section('AUTHORS', max_token => 10_000, @_);
  }
  
  #--------------------------------------------------------------------------
  
  sub _get_titled_section {
    # Based on a get_title originally contributed by Graham Barr
    my($self, $titlename, %options) = (@_);
  
    my $max_token            = delete $options{'max_token'};
    my $desperate_for_title  = delete $options{'desperate'};
    my $accept_verbatim      = delete $options{'accept_verbatim'};
    my $max_content_length   = delete $options{'max_content_length'};
    my $nocase               = delete $options{'nocase'};
    $max_content_length = 120 unless defined $max_content_length;
  
    Carp::croak( "Unknown " . ((1 == keys %options) ? "option: " : "options: ")
      . join " ", map "[$_]", sort keys %options
    )
     if keys %options;
  
    my %content_containers;
    $content_containers{'Para'} = 1;
    if($accept_verbatim) {
      $content_containers{'Verbatim'} = 1;
      $content_containers{'VerbatimFormatted'} = 1;
    }
  
    my $token_count = 0;
    my $title;
    my @to_unget;
    my $state = 0;
    my $depth = 0;
  
    Carp::croak "What kind of titlename is \"$titlename\"?!" unless
     defined $titlename and $titlename =~ m/^[A-Z ]{1,60}$/s; #sanity
    my $titlename_re = quotemeta($titlename);
  
    my $head1_text_content;
    my $para_text_content;
    my $skipX;
  
    while(
      ++$token_count <= ($max_token || 1_000_000)
      and defined(my $token = $self->get_token)
    ) {
      push @to_unget, $token;
  
      if ($state == 0) { # seeking =head1
        if( $token->is_start and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found head1.  Seeking content...\n";
          ++$state;
          $head1_text_content = '';
        }
      }
  
      elsif($state == 1) { # accumulating text until end of head1
        if( $token->is_text ) {
            unless ($skipX) {
              DEBUG and print STDERR "   Adding \"", $token->text, "\" to head1-content.\n";
              $head1_text_content .= $token->text;
            }
        } elsif( $token->is_tagname('X') ) {
            # We're going to want to ignore X<> stuff.
            $skipX = $token->is_start;
            DEBUG and print STDERR +($skipX ? 'Start' : 'End'), 'ing ignoring of X<> tag';
        } elsif( $token->is_end and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found end of head1.  Considering content...\n";
          $head1_text_content = uc $head1_text_content if $nocase;
          if($head1_text_content eq $titlename
            or $head1_text_content =~ m/\($titlename_re\)/s
            # We accept "=head1 Nomen Modularis (NAME)" for sake of i18n
          ) {
            DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";
            ++$state;
          } elsif(
            $desperate_for_title
             # if we're so desperate we'll take the first
             #  =head1's content as a title
            and $head1_text_content =~ m/\S/
            and $head1_text_content !~ m/^[ A-Z]+$/s
            and $head1_text_content !~
              m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx
              # avoid accepting things like =head1 Thingy Thongy (DESCRIPTION)
            and ($max_content_length
              ? (length($head1_text_content) <= $max_content_length) # sanity
              : 1)
          ) {
            # Looks good; trim it
            ($title = $head1_text_content) =~ s/\s+$//;
            DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";
            last;
          } else {
            --$state;
            DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n",
              "\n  Dropping back to seeking-head1-content mode...\n";
          }
        }
      }
  
      elsif($state == 2) {
        # seeking start of para (which must immediately follow)
        if($token->is_start and $content_containers{ $token->tagname }) {
          DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";
          $para_text_content = '';
          ++$state;
        } else {
          DEBUG and print
           "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";
          $state = 0;
        }
      }
  
      elsif($state == 3) {
        # accumulating text until end of Para
        if( $token->is_text ) {
          DEBUG and print STDERR "   Adding \"", $token->text, "\" to para-content.\n";
          $para_text_content .= $token->text;
          # and keep looking
  
        } elsif( $token->is_end and $content_containers{ $token->tagname } ) {
          DEBUG and print STDERR "  Found end of Para.  Considering content: ",
            $para_text_content, "\n";
  
          if( $para_text_content =~ m/\S/
            and ($max_content_length
             ? (length($para_text_content) <= $max_content_length)
             : 1)
          ) {
            # Some minimal sanity constraints, I think.
            DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";
            $title = $para_text_content;
            last;
          } else {
            DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";
            undef $title;
            last;
          }
        }
      }
  
      else {
        die "IMPOSSIBLE STATE $state!\n";  # should never happen
      }
  
    }
  
    # Put it all back!
    $self->unget_token(@to_unget);
  
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
  
    return '' unless defined $title;
    $title =~ s/^\s+//;
    return $title;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  Methods that actually do work at parse-time:
  
  sub _handle_element_start {
    my $self = shift;   # leaving ($element_name, $attr_hash_r)
    DEBUG > 2 and print STDERR "++ $_[0] (", map("<$_> ", %{$_[1]}), ")\n";
  
    push @{ $self->{'token_buffer'} },
         $self->{'start_token_class'}->new(@_);
    return;
  }
  
  sub _handle_text {
    my $self = shift;   # leaving ($text)
    DEBUG > 2 and print STDERR "== $_[0]\n";
    push @{ $self->{'token_buffer'} },
         $self->{'text_token_class'}->new(@_);
    return;
  }
  
  sub _handle_element_end {
    my $self = shift;   # leaving ($element_name);
    DEBUG > 2 and print STDERR "-- $_[0]\n";
    push @{ $self->{'token_buffer'} },
         $self->{'end_token_class'}->new(@_);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParser -- a pull-parser interface to parsing Pod
  
  =head1 SYNOPSIS
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( "whatever.pod" );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( $some_filehandle_object );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \$document_source );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \@document_lines );
   $parser->run;
  
  And elsewhere:
  
   require 5;
   package SomePodProcessor;
   use strict;
   use base qw(Pod::Simple::PullParser);
  
   sub run {
     my $self = shift;
    Token:
     while(my $token = $self->get_token) {
       ...process each token...
     }
   }
  
  =head1 DESCRIPTION
  
  This class is for using Pod::Simple to build a Pod processor -- but
  one that uses an interface based on a stream of token objects,
  instead of based on events.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  A subclass of Pod::Simple::PullParser should define a C<run> method
  that calls C<< $token = $parser->get_token >> to pull tokens.
  
  See the source for Pod::Simple::RTF for an example of a formatter
  that uses Pod::Simple::PullParser.
  
  =head1 METHODS
  
  =over
  
  =item my $token = $parser->get_token
  
  This returns the next token object (which will be of a subclass of
  L<Pod::Simple::PullParserToken>), or undef if the parser-stream has hit
  the end of the document.
  
  =item $parser->unget_token( $token )
  
  =item $parser->unget_token( $token1, $token2, ... )
  
  This restores the token object(s) to the front of the parser stream.
  
  =back
  
  The source has to be set before you can parse anything.  The lowest-level
  way is to call C<set_source>:
  
  =over
  
  =item $parser->set_source( $filename )
  
  =item $parser->set_source( $filehandle_object )
  
  =item $parser->set_source( \$document_source )
  
  =item $parser->set_source( \@document_lines )
  
  =back
  
  Or you can call these methods, which Pod::Simple::PullParser has defined
  to work just like Pod::Simple's same-named methods:
  
  =over
  
  =item $parser->parse_file(...)
  
  =item $parser->parse_string_document(...)
  
  =item $parser->filter(...)
  
  =item $parser->parse_from_file(...)
  
  =back
  
  For those to work, the Pod-processing subclass of
  Pod::Simple::PullParser has to have defined a $parser->run method --
  so it is advised that all Pod::Simple::PullParser subclasses do so.
  See the Synopsis above, or the source for Pod::Simple::RTF.
  
  Authors of formatter subclasses might find these methods useful to
  call on a parser object that you haven't started pulling tokens
  from yet:
  
  =over
  
  =item my $title_string = $parser->get_title
  
  This tries to get the title string out of $parser, by getting some tokens,
  and scanning them for the title, and then ungetting them so that you can
  process the token-stream from the beginning.
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  $parser->get_title on that document will return "Hoo::Boy::Wowza --
  Stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_title(nocase => 1);
  
  In cases where get_title can't find the title, it will return empty-string
  ("").
  
  =item my $title_string = $parser->get_short_title
  
  This is just like get_title, except that it returns just the modulename, if
  the title seems to be of the form "SomeModuleName -- description".
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return
  "Hoo::Boy::Wowza".
  
  But if the document starts out:
  
    =head1 NAME
  
    Hooboy, stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return "Hooboy,
  stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_short_title(nocase => 1);
  
  If the title can't be found, then get_short_title returns empty-string
  ("").
  
  =item $author_name   = $parser->get_author
  
  This works like get_title except that it returns the contents of the
  "=head1 AUTHOR\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Author\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_author(nocase => 1);
  
  (This method tolerates "AUTHORS" instead of "AUTHOR" too.)
  
  =item $description_name = $parser->get_description
  
  This works like get_title except that it returns the contents of the
  "=head1 DESCRIPTION\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Description\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_description(nocase => 1);
  
  =item $version_block = $parser->get_version
  
  This works like get_title except that it returns the contents of
  the "=head1 VERSION\n\n[BIG BLOCK]\n" block.  Note that this does NOT
  return the module's C<$VERSION>!! To recognize a
  "=head1 Version\n\n[BIG BLOCK]\n" section, pass the C<nocase> option:
  
    $parser->get_version(nocase => 1);
  
  =back
  
  =head1 NOTE
  
  You don't actually I<have> to define a C<run> method.  If you're
  writing a Pod-formatter class, you should define a C<run> just so
  that users can call C<parse_file> etc, but you don't I<have> to.
  
  And if you're not writing a formatter class, but are instead just
  writing a program that does something simple with a Pod::PullParser
  object (and not an object of a subclass), then there's no reason to
  bother subclassing to add a C<run> method.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<Pod::Simple::PullParserToken> -- and its subclasses
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<HTML::TokeParser>, which inspired this.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  
  JUNK:
  
  sub _old_get_title {  # some witchery in here
    my $self = $_[0];
    my $title;
    my @to_unget;
  
    while(1) {
      push @to_unget, $self->get_token;
      unless(defined $to_unget[-1]) { # whoops, short doc!
        pop @to_unget;
        last;
      }
  
      DEBUG and print STDERR "-Got token ", $to_unget[-1]->dump, "\n";
  
      (DEBUG and print STDERR "Too much in the buffer.\n"),
       last if @to_unget > 25; # sanity
  
      my $pattern = '';
      if( #$to_unget[-1]->type eq 'end'
          #and $to_unget[-1]->tagname eq 'Para'
          #and
          ($pattern = join('',
           map {;
              ($_->type eq 'start') ? ("<" . $_->tagname .">")
            : ($_->type eq 'end'  ) ? ("</". $_->tagname .">")
            : ($_->type eq 'text' ) ? ($_->text =~ m<^([A-Z]+)$>s ? $1 : 'X')
            : "BLORP"
           } @to_unget
         )) =~ m{<head1>NAME</head1><Para>(X|</?[BCIFLS]>)+</Para>$}s
      ) {
        # Whee, it fits the pattern
        DEBUG and print STDERR "Seems to match =head1 NAME pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname eq 'Para';
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
  
      } elsif ($pattern =~ m{<head(\d)>(.+)</head\d>$}
        and !( $1 eq '1' and $2 eq 'NAME' )
      ) {
        # Well, it fits a fallback pattern
        DEBUG and print STDERR "Seems to match NAMEless pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname =~ m/^head\d$/s;
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
  
      } else {
        DEBUG and $pattern and print STDERR "Leading pattern: $pattern\n";
      }
    }
  
    # Put it all back:
    $self->unget_token(@to_unget);
  
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
  
    return '' unless defined $title;
    return $title;
  }
  
  use warnings;
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  package Pod::Simple::PullParserEndToken;
  use strict;
  use warnings;
  use Pod::Simple::PullParserToken ();
  our @ISA = ('Pod::Simple::PullParserToken');
  our $VERSION = '3.45';
  
  sub new {  # Class->new(tagname);
    my $class = shift;
    return bless ['end', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  # shortcut:
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this end-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this end-token object.
  You probably won't need to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserEndToken->new( I<tagname> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  package Pod::Simple::PullParserStartToken;
  use strict;
  use warnings;
  use Pod::Simple::PullParserToken ();
  our @ISA = ('Pod::Simple::PullParserToken');
  our $VERSION = '3.45';
  
  sub new {  # Class->new(tagname, optional_attrhash);
    my $class = shift;
    return bless ['start', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname   { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  
  sub attr_hash { $_[0][2] ||= {} }
  
  sub attr      {
    if(@_ == 2) {      # Reading: $token->attr('attrname')
      ${$_[0][2] || return undef}{ $_[1] };
    } elsif(@_ > 2) {  # Writing: $token->attr('attrname', 'newval')
      ${$_[0][2] ||= {}}{ $_[1] } = $_[2];
    } else {
      require Carp;
      Carp::croak(
        'usage: $object->attr("val") or $object->attr("key", "newval")');
      return undef;
    }
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser> object, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this start-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this start-token object.
  You probably won't need
  to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =item $token->attr(I<attrname>)
  
  This returns the value of the I<attrname> attribute for this start-token
  object, or undef.
  
  For example, parsing a LZ<><Foo/"Bar"> link will produce a start-token
  with a "to" attribute with the value "Foo", a "type" attribute with the
  value "pod", and a "section" attribute with the value "Bar".
  
  =item $token->attr(I<attrname>, I<newvalue>)
  
  This sets the I<attrname> attribute for this start-token object to
  I<newvalue>.  You probably won't need to do this.
  
  =item $token->attr_hash
  
  This returns the hashref that is the attribute set for this start-token.
  This is useful if (for example) you want to ask what all the attributes
  are -- you can just do C<< keys %{$token->attr_hash} >>
  
  =back
  
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserStartToken->new( I<tagname>, I<attrhash> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  package Pod::Simple::PullParserTextToken;
  use strict;
  use warnings;
  use Pod::Simple::PullParserToken ();
  our @ISA = ('Pod::Simple::PullParserToken');
  our $VERSION = '3.45';
  
  sub new {  # Class->new(text);
    my $class = shift;
    return bless ['text', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub text { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  
  sub text_r { \ $_[0][1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->text
  
  This returns the text that this token holds.  For example, parsing
  CZ<><foo> will return a C start-token, a text-token, and a C end-token.  And
  if you want to get the "foo" out of the text-token, call C<< $token->text >>
  
  =item $token->text(I<somestring>)
  
  This changes the string that this token holds.  You probably won't need
  to do this.
  
  =item $token->text_r()
  
  This returns a scalar reference to the string that this token holds.
  This can be useful if you don't want to memory-copy the potentially
  large text value (well, as large as a paragraph or a verbatim block)
  as calling $token->text would do.
  
  Or, if you want to alter the value, you can even do things like this:
  
    for ( ${  $token->text_r  } ) {  # Aliases it with $_ !!
  
      s/ The / the /g; # just for example
  
      if( 'A' eq chr(65) ) {  # (if in an ASCII world)
        tr/\xA0/ /;
        tr/\xAD//d;
      }
  
      ...or however you want to alter the value...
      (Note that starting with Perl v5.8, you can use, e.g.,
  
          my $nbsp = chr utf8::unicode_to_native(0xA0);
          s/$nbsp/ /g;
  
      to handle the above regardless if it's an ASCII world or not)
    }
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserTextToken->new( I<text> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  package Pod::Simple::PullParserToken;
   # Base class for tokens gotten from Pod::Simple::PullParser's $parser->get_token
  our @ISA = ();
  our $VERSION = '3.45';
  use strict;
  
  sub new {  # Class->new('type', stuff...);  ## Overridden in derived classes anyway
    my $class = shift;
    return bless [@_], ref($class) || $class;
  }
  
  sub type { $_[0][0] }  # Can't change the type of an object
  sub dump { Pod::Simple::pretty( [ @{ $_[0] } ] ) }
  
  sub is_start { $_[0][0] eq 'start' }
  sub is_end   { $_[0][0] eq 'end'   }
  sub is_text  { $_[0][0] eq 'text'  }
  
  1;
  __END__
  
  sub dump { '[' . _esc( @{ $_[0] } ) . ']' }
  
  # JUNK:
  
  sub _esc {
    return '' unless @_;
    my @out;
    foreach my $in (@_) {
      push @out, '"' . $in . '"';
      $out[-1] =~ s/([^- \:\:\.\,\'\>\<\"\/\=\?\+\|\[\]\{\}\_a-zA-Z0-9_\`\~\!\#\%\^\&\*\(\)])/
        sprintf( (ord($1) < 256) ? "\\x%02X" : "\\x{%X}", ord($1))
      /eg;
    }
    return join ', ', @out;
  }
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  Given a $parser that's an object of class Pod::Simple::PullParser
  (or a subclass)...
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      if($token->is_start) {
        ...access $token->tagname, $token->attr, etc...
  
      } elsif($token->is_text) {
        ...access $token->text, $token->text_r, etc...
  
      } elsif($token->is_end) {
        ...access $token->tagname...
  
      }
    }
  
  (Also see L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you should
  get an object of a subclass of Pod::Simple::PullParserToken.
  
  Subclasses will add methods, and will also inherit these methods:
  
  =over
  
  =item $token->type
  
  This returns the type of the token.  This will be either the string
  "start", the string "text", or the string "end".
  
  Once you know what the type of an object is, you then know what
  subclass it belongs to, and therefore what methods it supports.
  
  Yes, you could probably do the same thing with code like
  $token->isa('Pod::Simple::PullParserEndToken'), but that's not so
  pretty as using just $token->type, or even the following shortcuts:
  
  =item $token->is_start
  
  This is a shortcut for C<< $token->type() eq "start" >>
  
  =item $token->is_text
  
  This is a shortcut for C<< $token->type() eq "text" >>
  
  =item $token->is_end
  
  This is a shortcut for C<< $token->type() eq "end" >>
  
  =item $token->dump
  
  This returns a handy stringified value of this object.  This
  is useful for debugging, as in:
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      ...
    }
  
  =back
  
  =head1 SEE ALSO
  
  My subclasses:
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<Pod::Simple::PullParser> and L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  use warnings;
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  package Pod::Simple::RTF;
  use strict;
  use warnings;
  
  #sub DEBUG () {4};
  #sub Pod::Simple::DEBUG () {4};
  #sub Pod::Simple::PullParser::DEBUG () {4};
  
  our $VERSION = '3.45';
  use Pod::Simple::PullParser ();
  our @ISA;
  BEGIN {@ISA = ('Pod::Simple::PullParser')}
  
  use Carp ();
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub to_uni ($) {    # Convert native code point to Unicode
      my $x = shift;
  
      # Broken for early EBCDICs
      $x = chr utf8::native_to_unicode(ord $x) if $] ge 5.007_003
                                               && ord("A") != 65;
      return $x;
  }
  
  # We escape out 'F' so that we can send RTF files thru the mail without the
  # slightest worry that paragraphs beginning with "From" will get munged.
  # We also escape '\', '{', '}', and '_'
  my $map_to_self = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEGHIJKLMNOPQRSTUVWXYZ[]^`abcdefghijklmnopqrstuvwxyz|~';
  
  our $WRAP;
  $WRAP = 1 unless defined $WRAP;
  our %Escape = (
  
    # Start with every character mapping to its hex equivalent
    map( (chr($_) => sprintf("\\'%02x", $_)), 0 .. 0xFF),
  
    # Override most ASCII printables with themselves (or on non-ASCII platforms,
    # their ASCII values.  This is because the output is UTF-16, which is always
    # based on Unicode code points)
    map( (   substr($map_to_self, $_, 1)
          => to_uni(substr($map_to_self, $_, 1))), 0 .. length($map_to_self) - 1),
  
    # And some refinements:
    "\r"  => "\n",
    "\cj"  => "\n",
    "\n"   => "\n\\line ",
  
    "\t"   => "\\tab ",     # Tabs (altho theoretically raw \t's are okay)
    "\f"   => "\n\\page\n", # Formfeed
    "-"    => "\\_",        # Turn plaintext '-' into a non-breaking hyphen
    $Pod::Simple::nbsp => "\\~",        # Latin-1 non-breaking space
    $Pod::Simple::shy => "\\-",        # Latin-1 soft (optional) hyphen
  
    # CRAZY HACKS:
    "\n" => "\\line\n",
    "\r" => "\n",
    "\cb" => "{\n\\cs21\\lang1024\\noproof ",  # \\cf1
    "\cc" => "}",
  );
  
  # Generate a string of all the characters in %Escape that don't map to
  # themselves.  First, one without the hyphen, then one with.
  my $escaped_sans_hyphen = "";
  $escaped_sans_hyphen .= $_ for grep { $_ ne $Escape{$_} && $_ ne '-' }
                                                              sort keys %Escape;
  my $escaped = "-$escaped_sans_hyphen";
  
  # Then convert to patterns
  $escaped_sans_hyphen = qr/[\Q$escaped_sans_hyphen \E]/;
  $escaped= qr/[\Q$escaped\E]/;
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _openclose {
   return map {;
     m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";
     ( $1,  "{\\$2\n",   "/$1",  "}" );
   } @_;
  }
  
  my @_to_accept;
  
  our %Tagmap = (
   # 'foo=bar' means ('foo' => '{\bar'."\n", '/foo' => '}')
   _openclose(
    'B=cs18\b',
    'I=cs16\i',
    'C=cs19\f1\lang1024\noproof',
    'F=cs17\i\lang1024\noproof',
  
    'VerbatimI=cs26\i',
    'VerbatimB=cs27\b',
    'VerbatimBI=cs28\b\i',
  
    map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
     qw[
         underline=ul         smallcaps=scaps  shadow=shad
         superscript=super    subscript=sub    strikethrough=strike
         outline=outl         emboss=embo      engrave=impr
         dotted-underline=uld          dash-underline=uldash
         dot-dash-underline=uldashd    dot-dot-dash-underline=uldashdd
         double-underline=uldb         thick-underline=ulth
         word-underline=ulw            wave-underline=ulwave
     ]
     # But no double-strikethrough, because MSWord can't agree with the
     #  RTF spec on whether it's supposed to be \strikedl or \striked1 (!!!)
   ),
  
   # Bit of a hack here:
   'L=pod' => '{\cs22\i'."\n",
   'L=url' => '{\cs23\i'."\n",
   'L=man' => '{\cs24\i'."\n",
   '/L' => '}',
  
   'Data'  => "\n",
   '/Data' => "\n",
  
   'Verbatim'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/Verbatim' => "\n\\par}\n",
   'VerbatimFormatted'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/VerbatimFormatted' => "\n\\par}\n",
   'Para'    => "\n{\\pard\\li#rtfindent#\\sa180\n",
   '/Para'   => "\n\\par}\n",
   'head1'   => "\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",
   '/head1'  => "\n}\\par}\n",
   'head2'   => "\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",
   '/head2'  => "\n}\\par}\n",
   'head3'   => "\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",
   '/head3'  => "\n}\\par}\n",
   'head4'   => "\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",
   '/head4'  => "\n}\\par}\n",
     # wordpad borks on \tc\tcl1, or I'd put that in =head1 and =head2
  
   'item-bullet'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-bullet' => "\n\\par}\n",
   'item-number'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-number' => "\n\\par}\n",
   'item-text'    => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-text'   => "\n\\par}\n",
  
   # we don't need any styles for over-* and /over-*
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub new {
    my $new = shift->SUPER::new(@_);
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'rtf', 'RTF' );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    $new->accept_codes(@_to_accept);
    $new->accept_codes('VerbatimFormatted');
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
    $new->doc_lang(
      (  $ENV{'RTFDEFLANG'} || '') =~ m/^(\d{1,10})$/s ? $1
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1)
                                        # yes, tolerate hex!
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^([a-fA-F0-9]{4})$/s ? hex($1)
                                        # yes, tolerate even more hex!
      : '1033'
    );
  
    $new->head1_halfpoint_size(32);
    $new->head2_halfpoint_size(28);
    $new->head3_halfpoint_size(25);
    $new->head4_halfpoint_size(22);
    $new->codeblock_halfpoint_size(18);
    $new->header_halfpoint_size(17);
    $new->normal_halfpoint_size(25);
  
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  __PACKAGE__->_accessorize(
   'doc_lang',
   'head1_halfpoint_size',
   'head2_halfpoint_size',
   'head3_halfpoint_size',
   'head4_halfpoint_size',
   'codeblock_halfpoint_size',
   'header_halfpoint_size',
   'normal_halfpoint_size',
   'no_proofing_exemptions',
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  # Match something like an identifier.  Prefer XID if available, then plain ID,
  # then just ASCII
  my $id_re = Pod::Simple::BlackBox::my_qr('[\'_\p{XIDS}][\'\p{XIDC}]+', "ab");
  $id_re    = Pod::Simple::BlackBox::my_qr('[\'_\p{IDS}][\'\p{IDC}]+', "ab")
                                                                    unless $id_re;
  $id_re = qr/['_a-zA-Z]['a-zA-Z0-9_]+/ unless $id_re;
  
  sub do_middle {      # the main work
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
  
    my($token, $type, $tagname, $scratch);
    my @stack;
    my @indent_stack;
    $self->{'rtfindent'} = 0 unless defined $self->{'rtfindent'};
  
    while($token = $self->get_token) {
  
      if( ($type = $token->type) eq 'text' ) {
        if( $self->{'rtfverbatim'} ) {
          DEBUG > 1 and print STDERR "  $type " , $token->text, " in verbatim!\n";
          rtf_esc(0, $scratch = $token->text); # 0 => Don't escape hyphen
          print $fh $scratch;
          next;
        }
  
        DEBUG > 1 and print STDERR "  $type " , $token->text, "\n";
  
        $scratch = $token->text;
        $scratch =~ tr/\t\cb\cc/ /d;
  
        $self->{'no_proofing_exemptions'} or $scratch =~
         s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             ${id_re}[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg
        ;
  
        rtf_esc(1, $scratch);     # 1 => escape hyphen
        $scratch =~
           s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx     # and put a NL before those spaces
          if $WRAP;
          # This may wrap at well past the 65th column, but not past the 120th.
  
        print $fh $scratch;
  
      } elsif( $type eq 'start' ) {
        DEBUG > 1 and print STDERR "  +$type ",$token->tagname,
          " (", map("<$_> ", %{$token->attr_hash}), ")\n";
  
        if( ($tagname = $token->tagname) eq 'Verbatim'
            or $tagname eq 'VerbatimFormatted'
        ) {
          ++$self->{'rtfverbatim'};
          my $next = $self->get_token;
          next unless defined $next;
          my $line_count = 1;
          if($next->type eq 'text') {
            my $t = $next->text_r;
            while( $$t =~ m/$/mg ) {
              last if  ++$line_count  > 15; # no point in counting further
            }
            DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n";
          }
          $self->unget_token($next);
          $self->{'rtfkeep'} = ($line_count > 15) ? '' : '\keepn' ;
  
        } elsif( $tagname =~ m/^item-/s ) {
          my @to_unget;
          my $text_count_here = 0;
          $self->{'rtfitemkeepn'} = '';
          # Some heuristics to stop item-*'s functioning as subheadings
          #  from getting split from the things they're subheadings for.
          #
          # It's not terribly pretty, but it really does make things pretty.
          #
          while(1) {
            push @to_unget, $self->get_token;
            pop(@to_unget), last unless defined $to_unget[-1];
             # Erroneously used to be "unshift" instead of pop!  Adds instead
             # of removes, and operates on the beginning instead of the end!
  
            if($to_unget[-1]->type eq 'text') {
              if( ($text_count_here += length ${$to_unget[-1]->text_r}) > 150 ){
                DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";
                last;
              }
            } elsif (@to_unget > 1 and
              $to_unget[-2]->type eq 'end' and
              $to_unget[-2]->tagname =~ m/^item-/s
            ) {
              # Bail out here, after setting rtfitemkeepn yea or nay.
              $self->{'rtfitemkeepn'} = '\keepn' if
                $to_unget[-1]->type eq 'start' and
                $to_unget[-1]->tagname eq 'Para';
  
              DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",
                $to_unget[-1]->type,
                $to_unget[-1]->can('tagname') ? $to_unget[-1]->tagname : '',
                $self->{'rtfitemkeepn'} ? "gets" : "doesn't get";
              last;
            } elsif (@to_unget > 40) {
              DEBUG > 1 and print STDERR "    item-* now has too many tokens (",
                scalar(@to_unget),
                (DEBUG > 4) ? (q<: >, map($_->dump, @to_unget)) : (),
                ") to be keepn'd.\n";
              last; # give up
            }
            # else keep while'ing along
          }
          # Now put it aaaaall back...
          $self->unget_token(@to_unget);
  
        } elsif( $tagname =~ m/^over-/s ) {
          push @stack, $1;
          push @indent_stack,
           int($token->attr('indent') * 4 * $self->normal_halfpoint_size);
          DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} += $indent_stack[-1];
  
        } elsif ($tagname eq 'L') {
          $tagname .= '=' . ($token->attr('type') || 'pod');
  
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          printf $fh "\n" . $next->text . "\n";
          next;
        }
  
        defined($scratch = $self->{'Tagmap'}{$tagname}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
  
        if ($tagname eq 'item-number') {
          print $fh $token->attr('number'), ". \n";
        } elsif ($tagname eq 'item-bullet') {
          print $fh "\\'", ord("_"), "\n";
          #for funky testing: print $fh '', rtf_esc(1, "\x{4E4B}\x{9053}");
        }
  
      } elsif( $type eq 'end' ) {
        DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} -= pop @indent_stack;
          pop @stack;
        } elsif( $tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted') {
          --$self->{'rtfverbatim'};
        }
        defined($scratch = $self->{'Tagmap'}{"/$tagname"}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
      }
    }
    return 1;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub do_beginning {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh join '',
      $self->doc_init,
      $self->font_table,
      $self->stylesheet,
      $self->color_table,
      $self->doc_info,
      $self->doc_start,
      "\n"
    ;
  }
  
  sub do_end {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh '}'; # that should do it
  }
  
  ###########################################################################
  
  sub stylesheet {
    return sprintf <<'END',
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  
     $_[0]->codeblock_halfpoint_size(),
     $_[0]->head1_halfpoint_size(),
     $_[0]->head2_halfpoint_size(),
     $_[0]->head3_halfpoint_size(),
     $_[0]->head4_halfpoint_size(),
    ;
  }
  
  ###########################################################################
  # Override these as necessary for further customization
  
  sub font_table {
    return <<'END';  # text font, code font, heading font
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  }
  
  sub doc_init {
     return <<'END';
  {\rtf1\ansi\deff0
  
  END
  }
  
  sub color_table {
     return <<'END';
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  }
  
  
  sub doc_info {
     my $self = $_[0];
  
     my $class = ref($self) || $self;
  
     my $tag = __PACKAGE__ . ' ' . $VERSION;
  
     unless($class eq __PACKAGE__) {
       $tag = " ($tag)";
       $tag = " v" . $self->VERSION . $tag   if   defined $self->VERSION;
       $tag = $class . $tag;
     }
  
     return sprintf <<'END',
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  
    # None of the following things should need escaping, I dare say!
      $tag,
      $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime($ENV{SOURCE_DATE_EPOCH} || time)),
    ;
  }
  
  sub doc_start {
    my $self = $_[0];
    my $title = $self->get_short_title();
    DEBUG and print STDERR "Short Title: <$title>\n";
    $title .= ' ' if length $title;
  
    $title =~ s/ *$/ /s;
    $title =~ s/^ //s;
    $title =~ s/ $/, /s;
     # make sure it ends in a comma and a space, unless it's 0-length
  
    my $is_obviously_module_name;
    $is_obviously_module_name = 1
     if $title =~ m/^\S+$/s and $title =~ m/::/s;
      # catches the most common case, at least
  
    DEBUG and print STDERR "Title0: <$title>\n";
    $title = rtf_esc(1, $title);  # 1 => escape hyphen
    DEBUG and print STDERR "Title1: <$title>\n";
    $title = '\lang1024\noproof ' . $title
     if $is_obviously_module_name;
  
    return sprintf <<'END',
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
      ($self->doc_lang) x 2,
      $self->header_halfpoint_size,
      $title,
      $self->normal_halfpoint_size,
    ;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #-------------------------------------------------------------------------
  
  use integer;
  
  my $question_mark_code_points =
          Pod::Simple::BlackBox::my_qr('([^\x00-\x{D7FF}\x{E000}-\x{10FFFF}])',
                                       "\x{110000}");
  my $plane0 =
          Pod::Simple::BlackBox::my_qr('([\x{100}-\x{FFFF}])', "\x{100}");
  my $other_unicode =
          Pod::Simple::BlackBox::my_qr('([\x{10000}-\x{10FFFF}])', "\x{10000}");
  
  sub esc_uni($) {
      use if $] le 5.006002, 'utf8';
  
      my $x = shift;
  
      # The output is expected to be UTF-16.  Surrogates and above-Unicode get
      # mapped to '?'
      $x =~ s/$question_mark_code_points/?/g if $question_mark_code_points;
  
      # Non-surrogate Plane 0 characters get mapped to their code points.  But
      # the standard calls for a 16bit SIGNED value.
      $x =~ s/$plane0/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg
                                                                      if $plane0;
  
      # Use surrogate pairs for the rest
      $x =~ s/$other_unicode/'\\uc1\\u' . ((ord($1) >> 10) + 0xD7C0 - 65536) . '\\u' . (((ord$1) & 0x03FF) + 0xDC00 - 65536) . '?'/eg if $other_unicode;
  
      return $x;
  }
  
  sub rtf_esc ($$) {
    # The parameter is true if we should escape hyphens
    my $escape_re = ((shift) ? $escaped : $escaped_sans_hyphen);
  
    # When false, it doesn't change "-" to hard-hyphen.
    #  We don't want to change the "-" to hard-hyphen, because we want to
    #  be able to paste this into a file and run it without there being
    #  dire screaming about the mysterious hard-hyphen character (which
    #  looks just like a normal dash character).
    # XXX The comments used to claim that when false it didn't apply computerese
    #     style-smarts, but khw didn't see this actually
  
    my $x; # scratch
    if(!defined wantarray) { # void context: alter in-place!
      for(@_) {
        s/($escape_re)/$Escape{$1}/g;  # ESCAPER
        $_ = esc_uni($_);
      }
      return;
    } elsif(wantarray) {  # return an array
      return map {; ($x = $_) =~
        s/($escape_re)/$Escape{$1}/g;  # ESCAPER
        $x = esc_uni($x);
        $x;
      } @_;
    } else { # return a single scalar
      ($x = ((@_ == 1) ? $_[0] : join '', @_)
      ) =~ s/($escape_re)/$Escape{$1}/g;  # ESCAPER
               # Escape \, {, }, -, control chars, and 7f-ff.
      $x = esc_uni($x);
      return $x;
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::RTF -- format Pod as RTF
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::RTF -e \
     "exit Pod::Simple::RTF->filter(shift)->any_errata_seen" \
     thingy.pod > thingy.rtf
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as RTF, good for
  viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 FORMAT CONTROL ATTRIBUTES
  
  You can set these attributes on the parser object before you
  call C<parse_file> (or a similar method) on it:
  
  =over
  
  =item $parser->head1_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head2_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head3_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head4_halfpoint_size( I<halfpoint_integer> );
  
  These methods set the size (in half-points, like 52 for 26-point)
  that these heading levels will appear as.
  
  =item $parser->codeblock_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 21 for 10.5-point)
  that codeblocks ("verbatim sections") will appear as.
  
  =item $parser->header_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 15 for 7.5-point)
  that the header on each page will appear in.  The header
  is usually just "I<modulename> p. I<pagenumber>".
  
  =item $parser->normal_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 26 for 13-point)
  that normal paragraphic text will appear in.
  
  =item $parser->no_proofing_exemptions( I<true_or_false> );
  
  Set this value to true if you don't want the formatter to try
  putting a hidden code on all Perl symbols (as best as it can
  notice them) that labels them as being not in English, and
  so not worth spellchecking.
  
  =item $parser->doc_lang( I<microsoft_decimal_language_code> )
  
  This sets the language code to tag this document as being in. By
  default, it is currently the value of the environment variable
  C<RTFDEFLANG>, or if that's not set, then the value
  1033 (for US English).
  
  Setting this appropriately is useful if you want to use the RTF
  to spellcheck, and/or if you want it to hyphenate right.
  
  Here are some notable values:
  
    1033  US English
    2057  UK English
    3081  Australia English
    4105  Canada English
    1034  Spain Spanish
    2058  Mexico Spanish
    1031  Germany German
    1036  France French
    3084  Canada French
    1035  Finnish
    1044  Norwegian (Bokmal)
    2068  Norwegian (Nynorsk)
  
  =back
  
  If you are particularly interested in customizing this module's output
  even more, see the source and/or write to me.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<RTF::Writer>, L<RTF::Cookbook>, L<RTF::Document>,
  L<RTF::Generator>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  package Pod::Simple::Search;
  use strict;
  use warnings;
  
  our $VERSION = '3.45';   ## Current version of this package
  
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG; }   # set DEBUG level
  use Carp ();
  
  our $SLEEPY;
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
    # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  our $MAX_VERSION_WITHIN ||= 60;
  
  #############################################################################
  
  #use diagnostics;
  use File::Spec ();
  use File::Basename qw( basename dirname );
  use Config ();
  use Cwd qw( cwd );
  
  #==========================================================================
  __PACKAGE__->_accessorize(  # Make my dumb accessor methods
   'callback', 'progress', 'dir_prefix', 'inc', 'laborious', 'limit_glob',
   'limit_re', 'shadows', 'verbose', 'name2path', 'path2name', 'recurse',
   'ciseen', 'is_case_insensitive'
  );
  #==========================================================================
  
  sub new {
    my $class = shift;
    my $self = bless {}, ref($class) || $class;
    $self->init;
    return $self;
  }
  
  sub init {
    my $self = shift;
    $self->inc(1);
    $self->recurse(1);
    $self->verbose(DEBUG);
    $self->is_case_insensitive(-e uc __FILE__ && -e lc __FILE__);
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub survey {
    my($self, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    $self->_expand_inc( \@search_dirs );
  
    $self->{'_scan_count'} = 0;
    $self->{'_dirs_visited'} = {};
    $self->path2name( {} );
    $self->name2path( {} );
    $self->ciseen( {} );
    $self->limit_re( $self->_limit_glob_to_limit_re ) if $self->{'limit_glob'};
    my $cwd = cwd();
    my $verbose  = $self->verbose;
    local $_; # don't clobber the caller's $_ !
  
    foreach my $try (@search_dirs) {
      unless( File::Spec->file_name_is_absolute($try) ) {
        # make path absolute
        $try = File::Spec->catfile( $cwd ,$try);
      }
      # simplify path
      $try =  File::Spec->canonpath($try);
  
      my $start_in;
      my $modname_prefix;
      if($self->{'dir_prefix'}) {
        $start_in = File::Spec->catdir(
          $try,
          grep length($_), split '[\\/:]+', $self->{'dir_prefix'}
        );
        $modname_prefix = [grep length($_), split m{[:/\\]}, $self->{'dir_prefix'}];
        $verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ",
          "giving $start_in (= @$modname_prefix)\n";
      } else {
        $start_in = $try;
      }
  
      if( $self->{'_dirs_visited'}{$start_in} ) {
        $verbose and print "Directory '$start_in' already seen, skipping.\n";
        next;
      } else {
        $self->{'_dirs_visited'}{$start_in} = 1;
      }
  
      unless(-e $start_in) {
        $verbose and print "Skipping non-existent $start_in\n";
        next;
      }
  
      my $closure = $self->_make_search_callback;
  
      if(-d $start_in) {
        # Normal case:
        $verbose and print "Beginning excursion under $start_in\n";
        $self->_recurse_dir( $start_in, $closure, $modname_prefix );
        $verbose and print "Back from excursion under $start_in\n\n";
  
      } elsif(-f _) {
        # A excursion consisting of just one file!
        $_ = basename($start_in);
        $verbose and print "Pondering $start_in ($_)\n";
        $closure->($start_in, $_, 0, []);
  
      } else {
        $verbose and print "Skipping mysterious $start_in\n";
      }
    }
    $self->progress and $self->progress->done(
     "Noted $$self{'_scan_count'} Pod files total");
    $self->ciseen( {} );
  
    return unless defined wantarray; # void
    return $self->name2path unless wantarray; # scalar
    return $self->name2path, $self->path2name; # list
  }
  
  #==========================================================================
  sub _make_search_callback {
    my $self = $_[0];
  
    # Put the options in variables, for easy access
    my( $laborious, $verbose, $shadows, $limit_re, $callback, $progress,
        $path2name, $name2path, $recurse, $ciseen, $is_case_insensitive) =
      map scalar($self->$_()),
       qw(laborious verbose shadows limit_re callback progress
          path2name name2path recurse ciseen is_case_insensitive);
    my ($seen, $remember, $files_for);
    if ($is_case_insensitive) {
        $seen      = sub { $ciseen->{ lc $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $ciseen->{ lc $_[0] } = $_[1]; };
        $files_for = sub { my $n = lc $_[0]; grep { lc $path2name->{$_} eq $n } %{ $path2name } };
    } else {
        $seen      = sub { $name2path->{ $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $_[1] };
        $files_for = sub { my $n = $_[0]; grep { $path2name->{$_} eq $n } %{ $path2name } };
    }
  
    my($file, $shortname, $isdir, $modname_bits);
    return sub {
      ($file, $shortname, $isdir, $modname_bits) = @_;
  
      if($isdir) { # this never gets called on the startdir itself, just subdirs
  
        unless( $recurse ) {
          $verbose and print "Not recursing into '$file' as per requested.\n";
          return 'PRUNE';
        }
  
        if( $self->{'_dirs_visited'}{$file} ) {
          $verbose and print "Directory '$file' already seen, skipping.\n";
          return 'PRUNE';
        }
  
        print "Looking in dir $file\n" if $verbose;
  
        unless ($laborious) { # $laborious overrides pruning
          if( m/^(\d+\.[\d_]{3,})\z/s
               and do { my $x = $1; $x =~ tr/_//d; $x != $] }
             ) {
            $verbose and print "Perl $] version mismatch on $_, skipping.\n";
            return 'PRUNE';
          }
  
          if( m/^([A-Za-z][a-zA-Z0-9_]*)\z/s ) {
            $verbose and print "$_ is a well-named module subdir.  Looking....\n";
          } else {
            $verbose and print "$_ is a fishy directory name.  Skipping.\n";
            return 'PRUNE';
          }
        } # end unless $laborious
  
        $self->{'_dirs_visited'}{$file} = 1;
        return; # (not pruning);
      }
  
      # Make sure it's a file even worth even considering
      if($laborious) {
        unless(
          m/\.(pod|pm|plx?)\z/i || -x _ and -T _
           # Note that the cheapest operation (the RE) is run first.
        ) {
          $verbose > 1 and print " Brushing off uninteresting $file\n";
          return;
        }
      } else {
        unless( m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is ) {
          $verbose > 1 and print " Brushing off oddly-named $file\n";
          return;
        }
      }
  
      $verbose and print "Considering item $file\n";
      my $name = $self->_path2modname( $file, $shortname, $modname_bits );
      $verbose > 0.01 and print " Nominating $file as $name\n";
  
      if($limit_re and $name !~ m/$limit_re/i) {
        $verbose and print "Shunning $name as not matching $limit_re\n";
        return;
      }
  
      if( !$shadows and $seen->($name) ) {
        $verbose and print "Not worth considering $file ",
          "-- already saw $name as ",
          join(' ', $files_for->($name)), "\n";
        return;
      }
  
      # Put off until as late as possible the expense of
      #  actually reading the file:
      $progress and $progress->reach($self->{'_scan_count'}, "Scanning $file");
      return unless $self->contains_pod( $file );
      ++ $self->{'_scan_count'};
  
      # Or finally take note of it:
      if ( my $prev = $seen->($name)  ) {
        $verbose and print
         "Duplicate POD found (shadowing?): $name ($file)\n",
         "    Already seen in ", join(' ', $files_for->($name)), "\n";
      } else {
        $remember->($name, $file); # Noting just the first occurrence
      }
      $verbose and print "  Noting $name = $file\n";
      if( $callback ) {
        local $_ = $_; # insulate from changes, just in case
        $callback->($file, $name);
      }
      $path2name->{$file} = $name;
      return;
    }
  }
  
  #==========================================================================
  
  sub _path2modname {
    my($self, $file, $shortname, $modname_bits) = @_;
  
    # this code simplifies the POD name for Perl modules:
    # * remove "site_perl"
    # * remove e.g. "i586-linux" (from 'archname')
    # * remove e.g. 5.00503
    # * remove pod/ if followed by perl*.pod (e.g. in pod/perlfunc.pod)
    # * dig into the file for case-preserved name if not already mixed case
  
    my @m = @$modname_bits;
    my $x;
    my $verbose = $self->verbose;
  
    # Shaving off leading naughty-bits
    while(@m
      and defined($x = lc( $m[0] ))
      and(  $x eq 'site_perl'
         or($x =~ m/^pods?$/ and @m == 1 and $shortname =~ m{^perl.*\.pod$}s )
         or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?}  # if looks like a vernum
         or $x eq lc( $Config::Config{'archname'} )
    )) { shift @m }
  
    my $name = join '::', @m, $shortname;
    $self->_simplify_base($name);
  
    # On VMS, case-preserved document names can't be constructed from
    # filenames, so try to extract them from the "=head1 NAME" tag in the
    # file instead.
    if ($^O eq 'VMS' && ($name eq lc($name) || $name eq uc($name))) {
        open PODFILE, "<$file" or die "_path2modname: Can't open $file: $!";
        my $in_pod = 0;
        my $in_name = 0;
        my $line;
        while ($line = <PODFILE>) {
          chomp $line;
          $in_pod = 1 if ($line =~ m/^=\w/);
          $in_pod = 0 if ($line =~ m/^=cut/);
          next unless $in_pod;         # skip non-pod text
          next if ($line =~ m/^\s*\z/);           # and blank lines
          next if ($in_pod && ($line =~ m/^X</)); # and commands
          if ($in_name) {
            if ($line =~ m/(\w+::)?(\w+)/) {
              # substitute case-preserved version of name
              my $podname = $2;
              my $prefix = $1 || '';
              $verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";
              unless ($name =~ s/$prefix$podname/$prefix$podname/i) {
                $verbose and print "Attempting case restore of '$name' from '$podname'\n";
                $name =~ s/$podname/$podname/i;
              }
              last;
            }
          }
          $in_name = 1 if ($line =~ m/^=head1 NAME/);
      }
      close PODFILE;
    }
  
    return $name;
  }
  
  #==========================================================================
  
  sub _recurse_dir {
    my($self, $startdir, $callback, $modname_bits) = @_;
  
    my $maxdepth = $self->{'fs_recursion_maxdepth'} || 10;
    my $verbose = $self->verbose;
  
    my $here_string = File::Spec->curdir;
    my $up_string   = File::Spec->updir;
    $modname_bits ||= [];
  
    my $recursor;
    $recursor = sub {
      my($dir_long, $dir_bare) = @_;
      if( @$modname_bits >= 10 ) {
        $verbose and print "Too deep! [@$modname_bits]\n";
        return;
      }
  
      unless(-d $dir_long) {
        $verbose > 2 and print "But it's not a dir! $dir_long\n";
        return;
      }
      unless( opendir(INDIR, $dir_long) ) {
        $verbose > 2 and print "Can't opendir $dir_long : $!\n";
        closedir(INDIR);
        return
      }
  
      # Load all items; put no extension before .pod before .pm before .plx?.
      my @items = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] || $b->[2] cmp $a->[2] }
        map {
          (my $t = $_) =~ s/[.]p(m|lx?|od)\z//;
          [$_, $t, lc($1 || 'z') ]
        } readdir(INDIR);
      closedir(INDIR);
  
      push @$modname_bits, $dir_bare unless $dir_bare eq '';
  
      my $i_full;
      foreach my $i (@items) {
        next if $i eq $here_string or $i eq $up_string or $i eq '';
        $i_full = File::Spec->catfile( $dir_long, $i );
  
        if(!-r $i_full) {
          $verbose and print "Skipping unreadable $i_full\n";
  
        } elsif(-f $i_full) {
          $_ = $i;
          $callback->(          $i_full, $i, 0, $modname_bits );
  
        } elsif(-d _) {
          $i =~ s/\.DIR\z//i if $^O eq 'VMS';
          $_ = $i;
          my $rv = $callback->( $i_full, $i, 1, $modname_bits ) || '';
  
          if($rv eq 'PRUNE') {
            $verbose > 1 and print "OK, pruning";
          } else {
            # Otherwise, recurse into it
            $recursor->( File::Spec->catdir($dir_long, $i) , $i);
          }
        } else {
          $verbose > 1 and print "Skipping oddity $i_full\n";
        }
      }
      pop @$modname_bits;
      return;
    };;
  
    local $_;
    $recursor->($startdir, '');
  
    undef $recursor;  # allow it to be GC'd
  
    return;
  }
  
  
  #==========================================================================
  
  sub run {
    # A function, useful in one-liners
  
    my $self = __PACKAGE__->new;
    $self->limit_glob($ARGV[0]) if @ARGV;
    $self->callback( sub {
      my($file, $name) = @_;
      my $version = '';
  
      # Yes, I know we won't catch the version in like a File/Thing.pm
      #  if we see File/Thing.pod first.  That's just the way the
      #  cookie crumbles.  -- SMB
  
      if($file =~ m/\.pod$/i) {
        # Don't bother looking for $VERSION in .pod files
        DEBUG and print "Not looking for \$VERSION in .pod $file\n";
      } elsif( !open(INPOD, $file) ) {
        DEBUG and print "Couldn't open $file: $!\n";
        close(INPOD);
      } else {
        # Sane case: file is readable
        my $lines = 0;
        while(<INPOD>) {
          last if $lines++ > $MAX_VERSION_WITHIN; # some degree of sanity
          if( s/^\s*\$VERSION\s*=\s*//s and m/\d/ ) {
            DEBUG and print "Found version line (#$lines): $_";
            s/\s*\#.*//s;
            s/\;\s*$//s;
            s/\s+$//s;
            s/\t+/ /s; # nix tabs
            # Optimize the most common cases:
            $_ = "v$1"
              if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s
               # like in $VERSION = "3.14159";
               or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s
               # like in sprintf("%d.%02d", q$Revision: 4.13 $ =~ /(\d+)\.(\d+)/);
            ;
  
            # Like in sprintf("%d.%s", map {s/_//g; $_} q$Name: release-0_55-public $ =~ /-(\d+)_([\d_]+)/)
            $_ = sprintf("v%d.%s",
              map {s/_//g; $_}
                $1 =~ m/-(\d+)_([\d_]+)/) # snare just the numeric part
             if m{\$Name:\s*([^\$]+)\$}s
            ;
            $version = $_;
            DEBUG and print "Noting $version as version\n";
            last;
          }
        }
        close(INPOD);
      }
      print "$name\t$version\t$file\n";
      return;
      # End of callback!
    });
  
    $self->survey;
  }
  
  #==========================================================================
  
  sub simplify_name {
    my($self, $str) = @_;
  
    # Remove all path components
    #                             XXX Why not just use basename()? -- SMB
  
    if ($^O eq 'MacOS') { $str =~ s{^.*:+}{}s }
    else                { $str =~ s{^.*/+}{}s }
  
    $self->_simplify_base($str);
    return $str;
  }
  
  #==========================================================================
  
  sub _simplify_base {   # Internal method only
  
    # strip Perl's own extensions
    $_[1] =~ s/\.(pod|pm|plx?)\z//i;
  
    # strip meaningless extensions on Win32 and OS/2
    $_[1] =~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;
  
    # strip meaningless extensions on VMS
    $_[1] =~ s/\.(com)\z//i if $^O eq 'VMS';
  
    return;
  }
  
  #==========================================================================
  
  sub _expand_inc {
    my($self, $search_dirs) = @_;
  
    return unless $self->{'inc'};
    my %seen = map { File::Spec->rel2abs($_) => 1 } @{ $search_dirs };
  
    if ($^O eq 'MacOS') {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } $self->_mac_whammy(@INC);
    # Any other OSs need custom handling here?
    } else {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } @INC;
    }
  
    $self->{'laborious'} = 0;   # Since inc said to use INC
    return;
  }
  
  #==========================================================================
  
  sub _mac_whammy { # Tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
    my @them;
    (undef,@them) = @_;
    for $_ (@them) {
      if ( $_ eq '.' ) {
        $_ = ':';
      } elsif ( $_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e ) {
        $_ = ':'. $_;
      } else {
        $_ =~ s|^\./|:|;
      }
    }
    return @them;
  }
  
  #==========================================================================
  
  sub _limit_glob_to_limit_re {
    my $self = $_[0];
    my $limit_glob = $self->{'limit_glob'} || return;
  
    my $limit_re = '^' . quotemeta($limit_glob) . '$';
    $limit_re =~ s/\\\?/./g;    # glob "?" => "."
    $limit_re =~ s/\\\*/.*?/g;  # glob "*" => ".*?"
    $limit_re =~ s/\.\*\?\$$//s; # final glob "*" => ".*?$" => ""
  
    $self->{'verbose'} and print "Turning limit_glob $limit_glob into re $limit_re\n";
  
    # A common optimization:
    if(!exists($self->{'dir_prefix'})
      and $limit_glob =~ m/^(?:\w+\:\:)+/s  # like "File::*" or "File::Thing*"
      # Optimize for sane and common cases (but not things like "*::File")
    ) {
      $self->{'dir_prefix'} = join "::", $limit_glob =~ m/^(?:\w+::)+/sg;
      $self->{'verbose'} and print " and setting dir_prefix to $self->{'dir_prefix'}\n";
    }
  
    return $limit_re;
  }
  
  #==========================================================================
  
  # contribution mostly from Tim Jenness <t.jenness@jach.hawaii.edu>
  
  sub _actual_filenames {
      my $dir = shift;
      my $fn = lc shift;
      opendir my ($dh), $dir or return;
      return map { File::Spec->catdir($dir, $_) }
          grep { lc $_  eq $fn } readdir $dh;
  }
  
  sub find {
    my($self, $pod, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    # Check usage
    Carp::carp 'Usage: \$self->find($podname, ...)'
     unless defined $pod and length $pod;
  
    my $verbose = $self->verbose;
  
    # Split on :: and then join the name together using File::Spec
    my @parts = split /::/, $pod;
    $verbose and print "Chomping {$pod} => {@parts}\n";
  
    #@search_dirs = File::Spec->curdir unless @search_dirs;
  
    $self->_expand_inc(\@search_dirs);
    # Add location of binaries such as pod2text:
    push @search_dirs, $Config::Config{'scriptdir'} if $self->inc;
  
    my %seen_dir;
    while (my $dir = shift @search_dirs ) {
      next unless defined $dir and length $dir;
      next if $seen_dir{$dir};
      $seen_dir{$dir} = 1;
      unless(-d $dir) {
        print "Directory $dir does not exist\n" if $verbose;
      }
  
      print "Looking in directory $dir\n" if $verbose;
      my $fullname = File::Spec->catfile( $dir, @parts );
      print "Filename is now $fullname\n" if $verbose;
  
      foreach my $ext ('', '.pod', '.pm', '.pl') {   # possible extensions
        my $fullext = $fullname . $ext;
        if ( -f $fullext and $self->contains_pod($fullext) ) {
          print "FOUND: $fullext\n" if $verbose;
          if (@parts > 1 && lc $parts[0] eq 'pod' && $self->is_case_insensitive() && $ext eq '.pod') {
            # Well, this file could be for a program (perldoc) but we actually
            # want a module (Pod::Perldoc). So see if there is a .pm with the
            # proper casing.
            my $subdir = dirname $fullext;
            unless (grep { $fullext eq $_  } _actual_filenames $subdir, "$parts[-1].pod") {
              print "# Looking for alternate spelling in $subdir\n" if $verbose;
              # Try the .pm file.
              my $pm = $fullname . '.pm';
              if ( -f $pm and $self->contains_pod($pm) ) {
                # Prefer the .pm if its case matches.
                if (grep { $pm eq $_  } _actual_filenames $subdir, "$parts[-1].pm") {
                  print "FOUND: $fullext\n" if $verbose;
                  return $pm;
                }
              }
            }
          }
          return $fullext;
        }
      }
  
      # Case-insensitively Look for ./pod directories and slip them in.
      for my $subdir ( _actual_filenames($dir, 'pods'), _actual_filenames($dir, 'pod') ) {
        if (-d $subdir) {
          $verbose and print "Noticing $subdir and looking there...\n";
          unshift @search_dirs, $subdir;
        }
      }
    }
  
    return undef;
  }
  
  #==========================================================================
  
  sub contains_pod {
    my($self, $file) = @_;
    my $verbose = $self->{'verbose'};
  
    # check for one line of POD
    $verbose > 1 and print " Scanning $file for pod...\n";
    unless( open(MAYBEPOD,"<$file") ) {
      print "Error: $file is unreadable: $!\n";
      return undef;
    }
  
    sleep($SLEEPY - 1) if $SLEEPY;
     # avoid totally hogging the processor on OSs with poor process control
  
    local $_;
    while( <MAYBEPOD> ) {
      if(m/^=(head\d|pod|over|item)\b/s) {
        close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
        chomp;
        $verbose > 1 and print "  Found some pod ($_) in $file\n";
        return 1;
      }
    }
    close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
    $verbose > 1 and print "  No POD in $file, skipping.\n";
    return 0;
  }
  
  #==========================================================================
  
  sub _accessorize {  # A simple-minded method-maker
    shift;
    no strict 'refs';
    foreach my $attrname (@_) {
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
  
        # Read access:
        return $_[0]->{$attrname} if @_ == 1;
  
        # Write access:
        $_[0]->{$attrname} = $_[1];
        return $_[0]; # RETURNS MYSELF!
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  #==========================================================================
  sub _state_as_string {
    my $self = $_[0];
    return '' unless ref $self;
    my @out = "{\n  # State of $self ...\n";
    foreach my $k (sort keys %$self) {
      push @out, "  ", _esc($k), " => ", _esc($self->{$k}), ",\n";
    }
    push @out, "}\n";
    my $x = join '', @out;
    $x =~ s/^/#/mg;
    return $x;
  }
  
  sub _esc {
    my $in = $_[0];
    return 'undef' unless defined $in;
    $in =~
      s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;
    return qq{"$in"};
  }
  
  #==========================================================================
  
  run() unless caller;  # run if "perl whatever/Search.pm"
  
  1;
  
  #==========================================================================
  
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::Search - find POD documents in directory trees
  
  =head1 SYNOPSIS
  
    use Pod::Simple::Search;
    my $name2path = Pod::Simple::Search->new->limit_glob('LWP::*')->survey;
    print "Looky see what I found: ",
      join(' ', sort keys %$name2path), "\n";
  
    print "LWPUA docs = ",
      Pod::Simple::Search->new->find('LWP::UserAgent') || "?",
      "\n";
  
  =head1 DESCRIPTION
  
  B<Pod::Simple::Search> is a class that you use for running searches
  for Pod files.  An object of this class has several attributes
  (mostly options for controlling search options), and some methods
  for searching based on those attributes.
  
  The way to use this class is to make a new object of this class,
  set any options, and then call one of the search options
  (probably C<survey> or C<find>).  The sections below discuss the
  syntaxes for doing all that.
  
  
  =head1 CONSTRUCTOR
  
  This class provides the one constructor, called C<new>.
  It takes no parameters:
  
    use Pod::Simple::Search;
    my $search = Pod::Simple::Search->new;
  
  =head1 ACCESSORS
  
  This class defines several methods for setting (and, occasionally,
  reading) the contents of an object. With two exceptions (discussed at
  the end of this section), these attributes are just for controlling the
  way searches are carried out.
  
  Note that each of these return C<$self> when you call them as
  C<< $self->I<whatever(value)> >>.  That's so that you can chain
  together set-attribute calls like this:
  
    my $name2path =
      Pod::Simple::Search->new
      -> inc(0) -> verbose(1) -> callback(\&blab)
      ->survey(@there);
  
  ...which works exactly as if you'd done this:
  
    my $search = Pod::Simple::Search->new;
    $search->inc(0);
    $search->verbose(1);
    $search->callback(\&blab);
    my $name2path = $search->survey(@there);
  
  =over
  
  =item $search->inc( I<true-or-false> );
  
  This attribute, if set to a true value, means that searches should
  implicitly add perl's I<@INC> paths. This
  automatically considers paths specified in the C<PERL5LIB> environment
  as this is prepended to I<@INC> by the Perl interpreter itself.
  This attribute's default value is B<TRUE>.  If you want to search
  only specific directories, set $self->inc(0) before calling
  $inc->survey or $inc->find.
  
  
  =item $search->verbose( I<nonnegative-number> );
  
  This attribute, if set to a nonzero positive value, will make searches output
  (via C<warn>) notes about what they're doing as they do it.
  This option may be useful for debugging a pod-related module.
  This attribute's default value is zero, meaning that no C<warn> messages
  are produced.  (Setting verbose to 1 turns on some messages, and setting
  it to 2 turns on even more messages, i.e., makes the following search(es)
  even more verbose than 1 would make them.)
  
  =item $search->limit_glob( I<some-glob-string> );
  
  This option means that you want to limit the results just to items whose
  podnames match the given glob/wildcard expression. For example, you
  might limit your search to just "LWP::*", to search only for modules
  starting with "LWP::*" (but not including the module "LWP" itself); or
  you might limit your search to "LW*" to see only modules whose (full)
  names begin with "LW"; or you might search for "*Find*" to search for
  all modules with "Find" somewhere in their full name. (You can also use
  "?" in a glob expression; so "DB?" will match "DBI" and "DBD".)
  
  
  =item $search->callback( I<\&some_routine> );
  
  This attribute means that every time this search sees a matching
  Pod file, it should call this callback routine.  The routine is called
  with two parameters: the current file's filespec, and its pod name.
  (For example: C<("/etc/perljunk/File/Crunk.pm", "File::Crunk")> would
  be in C<@_>.)
  
  The callback routine's return value is not used for anything.
  
  This attribute's default value is false, meaning that no callback
  is called.
  
  =item $search->laborious( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Search will
  apply Perl-specific heuristics to find the correct module PODs quickly.
  This attribute's default value is false.  You won't normally need
  to set this to true.
  
  Specifically: Turning on this option will disable the heuristics for
  seeing only files with Perl-like extensions, omitting subdirectories
  that are numeric but do I<not> match the current Perl interpreter's
  version ID, suppressing F<site_perl> as a module hierarchy name, etc.
  
  =item $search->recurse( I<true-or-false> );
  
  Unless you set this attribute to a false value, Pod::Search will
  recurse into subdirectories of the search directories.
  
  =item $search->shadows( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Simple::Search will
  consider only the first file of a given modulename as it looks thru the
  specified directories; that is, with this option off, if
  Pod::Simple::Search has seen a C<somepathdir/Foo/Bar.pm> already in this
  search, then it won't bother looking at a C<somelaterpathdir/Foo/Bar.pm>
  later on in that search, because that file is merely a "shadow". But if
  you turn on C<< $self->shadows(1) >>, then these "shadow" files are
  inspected too, and are noted in the pathname2podname return hash.
  
  This attribute's default value is false; and normally you won't
  need to turn it on.
  
  =item $search->is_case_insensitive( I<true-or-false> );
  
  Pod::Simple::Search will by default internally make an assumption
  based on the underlying filesystem where the class file is found
  whether it is case insensitive or not.
  
  If it is determined to be case insensitive, during survey() it may
  skip pod files/modules that happen to be equal to names it's already
  seen, ignoring case.
  
  However, it's possible to have distinct files in different directories
  that intentionally has the same name, just differing in case, that should
  be reported. Hence, you may force the behavior by setting this to true
  or false.
  
  =item $search->limit_re( I<some-regxp> );
  
  Setting this attribute (to a value that's a regexp) means that you want
  to limit the results just to items whose podnames match the given
  regexp. Normally this option is not needed, and the more efficient
  C<limit_glob> attribute is used instead.
  
  =item $search->dir_prefix( I<some-string-value> );
  
  Setting this attribute to a string value means that the searches should
  begin in the specified subdirectory name (like "Pod" or "File::Find",
  also expressible as "File/Find"). For example, the search option
  C<< $search->limit_glob("File::Find::R*") >>
  is the same as the combination of the search options
  C<< $search->limit_re("^File::Find::R") -> dir_prefix("File::Find") >>.
  
  Normally you don't need to know about the C<dir_prefix> option, but I
  include it in case it might prove useful for someone somewhere.
  
  (Implementationally, searching with limit_glob ends up setting limit_re
  and usually dir_prefix.)
  
  
  =item $search->progress( I<some-progress-object> );
  
  If you set a value for this attribute, the value is expected
  to be an object (probably of a class that you define) that has a
  C<reach> method and a C<done> method.  This is meant for reporting
  progress during the search, if you don't want to use a simple
  callback.
  
  Normally you don't need to know about the C<progress> option, but I
  include it in case it might prove useful for someone somewhere.
  
  While a search is in progress, the progress object's C<reach> and
  C<done> methods are called like this:
  
    # Every time a file is being scanned for pod:
    $progress->reach($count, "Scanning $file");   ++$count;
  
    # And then at the end of the search:
    $progress->done("Noted $count Pod files total");
  
  Internally, we often set this to an object of class
  Pod::Simple::Progress.  That class is probably undocumented,
  but you may wish to look at its source.
  
  
  =item $name2path = $self->name2path;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =item $path2name = $self->path2name;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =back
  
  =head1 MAIN SEARCH METHODS
  
  Once you've actually set any options you want (if any), you can go
  ahead and use the following methods to search for Pod files
  in particular ways.
  
  
  =head2 C<< $search->survey( @directories ) >>
  
  The method C<survey> searches for POD documents in a given set of
  files and/or directories.  This runs the search according to the various
  options set by the accessors above.  (For example, if the C<inc> attribute
  is on, as it is by default, then the perl @INC directories are implicitly
  added to the list of directories (if any) that you specify.)
  
  The return value of C<survey> is two hashes:
  
  =over
  
  =item C<name2path>
  
  A hash that maps from each pod-name to the filespec (like
  "Stuff::Thing" => "/whatever/plib/Stuff/Thing.pm")
  
  =item C<path2name>
  
  A hash that maps from each Pod filespec to its pod-name (like
  "/whatever/plib/Stuff/Thing.pm" => "Stuff::Thing")
  
  =back
  
  Besides saving these hashes as the hashref attributes
  C<name2path> and C<path2name>, calling this function also returns
  these hashrefs.  In list context, the return value of
  C<< $search->survey >> is the list C<(\%name2path, \%path2name)>.
  In scalar context, the return value is C<\%name2path>.
  Or you can just call this in void context.
  
  Regardless of calling context, calling C<survey> saves
  its results in its C<name2path> and C<path2name> attributes.
  
  E.g., when searching in F<$HOME/perl5lib>, the file
  F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
  whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
  I<Myclass::Subclass>. The name information can be used for POD
  translators.
  
  Only text files containing at least one valid POD command are found.
  
  In verbose mode, a warning is printed if shadows are found (i.e., more
  than one POD file with the same POD name is found, e.g. F<CPAN.pm> in
  different directories).  This usually indicates duplicate occurrences of
  modules in the I<@INC> search path, which is occasionally inadvertent
  (but is often simply a case of a user's path dir having a more recent
  version than the system's general path dirs in general.)
  
  The options to this argument is a list of either directories that are
  searched recursively, or files.  (Usually you wouldn't specify files,
  but just dirs.)  Or you can just specify an empty-list, as in
  $name2path; with the C<inc> option on, as it is by default.
  
  The POD names of files are the plain basenames with any Perl-like
  extension (.pm, .pl, .pod) stripped, and path separators replaced by
  C<::>'s.
  
  Calling Pod::Simple::Search->search(...) is short for
  Pod::Simple::Search->new->search(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $search->simplify_name( $str ) >>
  
  The method B<simplify_name> is equivalent to B<basename>, but also
  strips Perl-like extensions (.pm, .pl, .pod) and extensions like
  F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.
  
  
  =head2 C<< $search->find( $pod ) >>
  
  =head2 C<< $search->find( $pod, @search_dirs ) >>
  
  Returns the location of a Pod file, given a Pod/module/script name
  (like "Foo::Bar" or "perlvar" or "perldoc"), and an idea of
  what files/directories to look in.
  It searches according to the various options set by the accessors above.
  (For example, if the C<inc> attribute is on, as it is by default, then
  the perl @INC directories are implicitly added to the list of
  directories (if any) that you specify.)
  
  This returns the full path of the first occurrence to the file.
  Package names (eg 'A::B') are automatically converted to directory
  names in the selected directory.  Additionally, '.pm', '.pl' and '.pod'
  are automatically appended to the search as required.
  (So, for example, under Unix, "A::B" is converted to "somedir/A/B.pm",
  "somedir/A/B.pod", or "somedir/A/B.pl", as appropriate.)
  
  If no such Pod file is found, this method returns undef.
  
  If any of the given search directories contains a F<pod/> subdirectory,
  then it is searched.  (That's how we manage to find F<perlfunc>,
  for example, which is usually in F<pod/perlfunc> in most Perl dists.)
  
  The C<verbose> and C<inc> attributes influence the behavior of this
  search; notably, C<inc>, if true, adds @INC I<and also
  $Config::Config{'scriptdir'}> to the list of directories to search.
  
  It is common to simply say C<< $filename = Pod::Simple::Search-> new
  ->find("perlvar") >> so that just the @INC (well, and scriptdir)
  directories are searched.  (This happens because the C<inc>
  attribute is true by default.)
  
  Calling Pod::Simple::Search->find(...) is short for
  Pod::Simple::Search->new->find(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $self->contains_pod( $file ) >>
  
  Returns true if the supplied filename (not POD module) contains some Pod
  documentation.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org> with code borrowed
  from Marek Rouchal's L<Pod::Find>, which in turn heavily borrowed code from
  Nick Ing-Simmons' C<PodToHtml>.
  
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  package Pod::Simple::SimpleTree;
  use strict;
  use warnings;
  use Carp ();
  use Pod::Simple ();
  our $VERSION = '3.45';
  BEGIN {
    our @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  __PACKAGE__->_accessorize(
    'root',   # root of the tree
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start { # self, tagname, attrhash
    DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";
    my $x = [$_[1], $_[2]];
    if($_[0]{'_currpos'}) {
      push    @{ $_[0]{'_currpos'}[0] }, $x; # insert in parent's child-list
      unshift @{ $_[0]{'_currpos'} },    $x; # prefix to stack
    } else {
      DEBUG and print STDERR " And oo, it gets to be root!\n";
      $_[0]{'_currpos'} = [   $_[0]{'root'} = $x   ];
        # first event!  set to stack, and set as root.
    }
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_element_end { # self, tagname
    DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";
    shift @{$_[0]{'_currpos'}};
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_text { # self, text
    DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";
    push @{ $_[0]{'_currpos'}[0] }, $_[1];
    return;
  }
  
  
  # A bit of evil from the black box...  please avert your eyes, kind souls.
  sub _traverse_treelet_bit {
    DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";
    my $self = shift;
    push @{ $self->{'_currpos'}[0] }, [@_];
    return;
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::SimpleTree -- parse Pod into a simple parse tree
  
  =head1 SYNOPSIS
  
    % cat ptest.pod
  
    =head1 PIE
  
    I like B<pie>!
  
    % perl -MPod::Simple::SimpleTree -MData::Dumper -e \
       "print Dumper(Pod::Simple::SimpleTree->new->parse_file(shift)->root)" \
       ptest.pod
  
    $VAR1 = [
              'Document',
              { 'start_line' => 1 },
              [
                'head1',
                { 'start_line' => 1 },
                'PIE'
              ],
              [
                'Para',
                { 'start_line' => 3 },
                'I like ',
                [
                  'B',
                  {},
                  'pie'
                ],
                '!'
              ]
            ];
  
  =head1 DESCRIPTION
  
  This class is of interest to people writing a Pod processor/formatter.
  
  This class takes Pod and parses it, returning a parse tree made just
  of arrayrefs, and hashrefs, and strings.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  This class is inspired by XML::Parser's "Tree" parsing-style, although
  it doesn't use exactly the same LoL format.
  
  =head1 METHODS
  
  At the end of the parse, call C<< $parser->root >> to get the
  tree's top node.
  
  =head1 Tree Contents
  
  Every element node in the parse tree is represented by an arrayref of
  the form: C<[ I<elementname>, \%attributes, I<...subnodes...> ]>.
  See the example tree dump in the Synopsis, above.
  
  Every text node in the tree is represented by a simple (non-ref)
  string scalar.  So you can test C<ref($node)> to see whether you have
  an element node or just a text node.
  
  The top node in the tree is C<[ 'Document', \%attributes,
  I<...subnodes...> ]>
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<perllol>
  
  L<The "Tree" subsubsection in XML::Parser|XML::Parser/"Tree">
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  package Pod::Simple::Text;
  use strict;
  use warnings;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  our $VERSION = '3.45';
  our @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  our $FREAKYMODE;
  
  use Text::Wrap 98.112902 ();
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_target_as_text(qw( text plaintext plain ));
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  sub start_head1 {  $_[0]{'Thispara'} = '' }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = $FREAKYMODE ? '' : '* ' }
  sub start_item_number { $_[0]{'Thispara'} = $FREAKYMODE ? '' : "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  sub start_L         { $_[0]{'Link'} = $_[1] if $_[1]->{type} eq 'url' }
  sub end_L           {
      if (my $link = delete $_[0]{'Link'}) {
          # Append the URL to the output unless it's already present.
          $_[0]{'Thispara'} .= " <$link->{to}>"
              unless $_[0]{'Thispara'} =~ /\b\Q$link->{to}/;
      }
  }
  
  sub emit_par {
    my($self, $tweak_indent) = splice(@_,0,2);
    my $indent = ' ' x ( 2 * $self->{'Indent'} + 4 + ($tweak_indent||0) );
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    local $Text::Wrap::huge = 'overflow';
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out, "\n";
    $self->{'Thispara'} = '';
  
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    #my $i = ' ' x (4 + $self->{'Indent'});
  
    $self->{'Thispara'} =~ s/^/$i/mg;
  
    print { $self->{'output_fh'} }   '',
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Text -- format Pod as plaintext
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Text -e \
     "exit Pod::Simple::Text->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as
  wrapped plaintext.
  
  Its wrapping is done by L<Text::Wrap>, so you can change
  C<$Text::Wrap::columns> as you like.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::TextContent>, L<Pod::Text>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  package Pod::Simple::TextContent;
  use strict;
  use warnings;
  use Carp ();
  use Pod::Simple ();
  our $VERSION = '3.45';
  our @ISA = ('Pod::Simple');
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  sub _handle_text {
    $_[1] =~ s/$Pod::Simple::shy//g;
    $_[1] =~ s/$Pod::Simple::nbsp/ /g;
    print {$_[0]{'output_fh'}} $_[1];
    return;
  }
  
  sub _handle_element_end {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::TextContent -- get the text content of Pod
  
  =head1 SYNOPSIS
  
   TODO
  
    perl -MPod::Simple::TextContent -e \
     "exit Pod::Simple::TextContent->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is that parses Pod and dumps just the text content.  It is
  mainly meant for use by the Pod::Simple test suite, but you may find
  some other use for it.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  package Pod::Simple::TiedOutFH;
  use strict;
  use warnings;
  use Symbol ('gensym');
  use Carp ();
  our $VERSION = '3.45';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_on { # some horrible frightening things are encapsulated in here
    my $class = shift;
    $class = ref($class) || $class;
  
    Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;
  
    my $x = (defined($_[0]) and ref($_[0]))
      ? $_[0]
      : ( \( $_[0] ) )[0]
    ;
    $$x = '' unless defined $$x;
  
    #Pod::Simple::DEBUG and print STDERR "New $class handle on $x = \"$$x\"\n";
  
    my $new = gensym();
    tie *$new, $class, $x;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub TIEHANDLE {  # Ties to just a scalar ref
    my($class, $scalar_ref) = @_;
    $$scalar_ref = '' unless defined $$scalar_ref;
    return bless \$scalar_ref,  ref($class) || $class;
  }
  
  sub PRINT {
    my $it = shift;
    foreach my $x (@_) { $$$it .= $x }
  
    #Pod::Simple::DEBUG > 10 and print STDERR " appended to $$it = \"$$$it\"\n";
  
    return 1;
  }
  
  sub FETCH {
    return ${$_[0]};
  }
  
  sub PRINTF {
    my $it = shift;
    my $format = shift;
    $$$it .= sprintf $format, @_;
    return 1;
  }
  
  sub FILENO { ${ $_[0] } + 100 } # just to produce SOME number
  
  sub CLOSE { 1 }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  Chole
  
   * 1 large red onion
   * 2 tomatillos
   * 4 or 5 roma tomatoes (optionally with the pulp discarded)
   * 1 tablespoons chopped ginger root (or more, to taste)
   * 2 tablespoons canola oil (or vegetable oil)
  
   * 1 tablespoon garam masala
   * 1/2 teaspoon red chili powder, or to taste
   * Salt, to taste (probably quite a bit)
   * 2 (15-ounce) cans chick peas or garbanzo beans, drained and rinsed
   * juice of one smallish lime
   * a dash of balsamic vinegar (to taste)
   * cooked rice, preferably long-grain white rice (whether plain,
      basmati rice, jasmine rice, or even a mild pilaf)
  
  In a blender or food processor, puree the onions, tomatoes, tomatillos,
  and ginger root.  You can even do it with a Braun hand "mixer", if you
  chop things finer to start with, and work at it.
  
  In a saucepan set over moderate heat, warm the oil until hot.
  
  Add the puree and the balsamic vinegar, and cook, stirring occasionally,
  for 20 to 40 minutes. (Cooking it longer will make it sweeter.)
  
  Add the Garam Masala, chili powder, and cook, stirring occasionally, for
  5 minutes.
  
  Add the salt and chick peas and cook, stirring, until heated through.
  
  Stir in the lime juice, and optionally one or two teaspoons of tahini.
  You can let it simmer longer, depending on how much softer you want the
  garbanzos to get.
  
  Serve over rice, like a curry.
  
  Yields 5 to 7 servings.
  
  
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  package Pod::Simple::Transcode;
  use strict;
  our $VERSION = '3.45';
  
  BEGIN {
    if(defined &DEBUG) {;} # Okay
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG; }
    else { *DEBUG = sub () {0}; }
  }
  
  our @ISA;
  foreach my $class (
    'Pod::Simple::TranscodeSmart',
    'Pod::Simple::TranscodeDumb',
    '',
  ) {
    $class or die "Couldn't load any encoding classes";
    DEBUG and print STDERR "About to try loading $class...\n";
    eval "require $class;";
    if($@) {
      DEBUG and print STDERR "Couldn't load $class: $@\n";
    } else {
      DEBUG and print STDERR "OK, loaded $class.\n";
      @ISA = ($class);
      last;
    }
  }
  
  sub _blorp { return; } # just to avoid any "empty class" warning
  
  1;
  __END__
  
  
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  package Pod::Simple::TranscodeDumb;
  use strict;
  our $VERSION = '3.45';
  # This module basically pretends it knows how to transcode, except
  #  only for null-transcodings!  We use this when Encode isn't
  #  available.
  
  our %Supported = (
    'ascii'       => 1,
    'ascii-ctrl'  => 1,
    'iso-8859-1'  => 1,
    'cp1252'      => 1,
    'null'        => 1,
    'latin1'      => 1,
    'latin-1'     => 1,
    %Supported,
  );
  
  sub is_dumb  {1}
  sub is_smart {0}
  
  sub all_encodings {
    return sort keys %Supported;
  }
  
  sub encoding_is_available {
    return exists $Supported{lc $_[1]};
  }
  
  sub encmodver {
    return __PACKAGE__ . " v" .($VERSION || '?');
  }
  
  sub make_transcoder {
      my ($e) = $_[1];
      die "WHAT ENCODING!?!?" unless $e;
      # No-op for all but CP1252.
      return sub {;} if $e !~ /^cp-?1252$/i;
  
      # Replace CP1252 nerbles with their ASCII equivalents.
      return sub {
          # Copied from Encode::ZapCP1252.
          my %ascii_for = (
              # http://en.wikipedia.org/wiki/Windows-1252
              "\x80" => 'e',    # EURO SIGN
              "\x82" => ',',    # SINGLE LOW-9 QUOTATION MARK
              "\x83" => 'f',    # LATIN SMALL LETTER F WITH HOOK
              "\x84" => ',,',   # DOUBLE LOW-9 QUOTATION MARK
              "\x85" => '...',  # HORIZONTAL ELLIPSIS
              "\x86" => '+',    # DAGGER
              "\x87" => '++',   # DOUBLE DAGGER
              "\x88" => '^',    # MODIFIER LETTER CIRCUMFLEX ACCENT
              "\x89" => '%',    # PER MILLE SIGN
              "\x8a" => 'S',    # LATIN CAPITAL LETTER S WITH CARON
              "\x8b" => '<',    # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
              "\x8c" => 'OE',   # LATIN CAPITAL LIGATURE OE
              "\x8e" => 'Z',    # LATIN CAPITAL LETTER Z WITH CARON
              "\x91" => "'",    # LEFT SINGLE QUOTATION MARK
              "\x92" => "'",    # RIGHT SINGLE QUOTATION MARK
              "\x93" => '"',    # LEFT DOUBLE QUOTATION MARK
              "\x94" => '"',    # RIGHT DOUBLE QUOTATION MARK
              "\x95" => '*',    # BULLET
              "\x96" => '-',    # EN DASH
              "\x97" => '--',   # EM DASH
              "\x98" => '~',    # SMALL TILDE
              "\x99" => '(tm)', # TRADE MARK SIGN
              "\x9a" => 's',    # LATIN SMALL LETTER S WITH CARON
              "\x9b" => '>',    # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
              "\x9c" => 'oe',   # LATIN SMALL LIGATURE OE
              "\x9e" => 'z',    # LATIN SMALL LETTER Z WITH CARON
              "\x9f" => 'Y',    # LATIN CAPITAL LETTER Y WITH DIAERESIS
          );
  
          s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_;
    };
  }
  
  
  1;
  
  
  use warnings;
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  use 5.008;
  ## Anything before 5.8.0 is GIMPY!
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeSmart;
  use strict;
  use warnings;
  use Pod::Simple;
  use Encode;
  our $VERSION = '3.45';
  
  sub is_dumb  {0}
  sub is_smart {1}
  
  sub all_encodings {
    return Encode::->encodings(':all');
  }
  
  sub encoding_is_available {
    return Encode::resolve_alias($_[1]);
  }
  
  sub encmodver {
    return "Encode.pm v" .($Encode::VERSION || '?');
  }
  
  sub make_transcoder {
    my $e = Encode::find_encoding($_[1]);
    die "WHAT ENCODING!?!?" unless $e;
    my $x;
    return sub {
      foreach $x (@_) {
        $x = $e->decode($x) unless Encode::is_utf8($x);
      }
      return;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  =pod
  
  =head1 NAME
  
  Pod::Simple::XHTML -- format Pod as validating XHTML
  
  =head1 SYNOPSIS
  
    use Pod::Simple::XHTML;
  
    my $parser = Pod::Simple::XHTML->new();
  
    ...
  
    $parser->parse_file('path/to/file.pod');
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as XHTML
  validating HTML.
  
  This is a subclass of L<Pod::Simple::Methody> and inherits all its
  methods. The implementation is entirely different than
  L<Pod::Simple::HTML>, but it largely preserves the same interface.
  
  =head2 Minimal code
  
    use Pod::Simple::XHTML;
    my $psx = Pod::Simple::XHTML->new;
    $psx->output_string(\my $html);
    $psx->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  You can also control the character encoding and entities. For example, if
  you're sure that the POD is properly encoded (using the C<=encoding> command),
  you can prevent high-bit characters from being encoded as HTML entities and
  declare the output character set as UTF-8 before parsing, like so:
  
    $psx->html_charset('UTF-8');
  use warnings;
    $psx->html_encode_chars(q{&<>'"});
  
  =cut
  
  package Pod::Simple::XHTML;
  use strict;
  our $VERSION = '3.45';
  use Pod::Simple::Methody ();
  our @ISA = ('Pod::Simple::Methody');
  
  our $HAS_HTML_ENTITIES;
  BEGIN {
    $HAS_HTML_ENTITIES = eval "require HTML::Entities; 1";
  }
  
  my %entities = (
    q{>} => 'gt',
    q{<} => 'lt',
    q{'} => '#39',
    q{"} => 'quot',
    q{&} => 'amp',
  );
  
  sub encode_entities {
    my $self = shift;
    my $ents = $self->html_encode_chars;
    return HTML::Entities::encode_entities( $_[0], $ents ) if $HAS_HTML_ENTITIES;
    if (defined $ents) {
        $ents =~ s,(?<!\\)([]/]),\\$1,g;
        $ents =~ s,(?<!\\)\\\z,\\\\,;
    } else {
        $ents = join '', keys %entities;
    }
    my $str = $_[0];
    $str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;
    return $str;
  }
  
  my %entity_to_char = reverse %entities;
  my ($entity_re) = map qr{$_}, join '|', map quotemeta, sort keys %entity_to_char;
  
  sub decode_entities {
    my ($self, $string) = @_;
    return HTML::Entities::decode_entities( $string ) if $HAS_HTML_ENTITIES;
  
    $string =~ s{&(?:($entity_re)|#x([0123456789abcdefABCDEF]+)|#([0123456789]+));}{
        defined $1 ? $entity_to_char{$1}
      : defined $2 ? chr(hex($2))
      : defined $3 ? chr($3)
      : die;
    }ge;
  
    return $string;
  }
  
  sub encode_url {
    my ($self, $string) = @_;
  
    $string =~ s{([^-_.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZZ0123456789])}{
      sprintf('%%%02X', ord($1))
    }eg;
  
    return $string;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 METHODS
  
  Pod::Simple::XHTML offers a number of methods that modify the format of
  the HTML output. Call these after creating the parser object, but before
  the call to C<parse_file>:
  
    my $parser = Pod::PseudoPod::HTML->new();
    $parser->set_optional_param("value");
    $parser->parse_file($file);
  
  =head2 perldoc_url_prefix
  
  In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
  to put before the "Foo%3a%3aBar". The default value is
  "https://metacpan.org/pod/".
  
  =head2 perldoc_url_postfix
  
  What to put after "Foo%3a%3aBar" in the URL. This option is not set by
  default.
  
  =head2 man_url_prefix
  
  In turning C<< L<crontab(5)> >> into http://whatever/man/1/crontab, what
  to put before the "1/crontab". The default value is
  "http://man.he.net/man".
  
  =head2 man_url_postfix
  
  What to put after "1/crontab" in the URL. This option is not set by default.
  
  =head2 title_prefix, title_postfix
  
  What to put before and after the title in the head. The values should
  already be &-escaped.
  
  =head2 html_css
  
    $parser->html_css('path/to/style.css');
  
  The URL or relative path of a CSS file to include. This option is not
  set by default.
  
  =head2 html_javascript
  
  The URL or relative path of a JavaScript file to pull in. This option is
  not set by default.
  
  =head2 html_doctype
  
  A document type tag for the file. This option is not set by default.
  
  =head2 html_charset
  
  The character set to declare in the Content-Type meta tag created by default
  for C<html_header_tags>. Note that this option will be ignored if the value of
  C<html_header_tags> is changed. Defaults to "ISO-8859-1".
  
  =head2 html_header_tags
  
  Additional arbitrary HTML tags for the header of the document. The
  default value is just a content type header tag:
  
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  
  Add additional meta tags here, or blocks of inline CSS or JavaScript
  (wrapped in the appropriate tags).
  
  =head3 html_encode_chars
  
  A string containing all characters that should be encoded as HTML entities,
  specified using the regular expression character class syntax (what you find
  within brackets in regular expressions). This value will be passed as the
  second argument to the C<encode_entities> function of L<HTML::Entities>. If
  L<HTML::Entities> is not installed, then any characters other than C<&<>"'>
  will be encoded numerically.
  
  =head2 html_h_level
  
  This is the level of HTML "Hn" element to which a Pod "head1" corresponds.  For
  example, if C<html_h_level> is set to 2, a head1 will produce an H2, a head2
  will produce an H3, and so on.
  
  =head2 default_title
  
  Set a default title for the page if no title can be determined from the
  content. The value of this string should already be &-escaped.
  
  =head2 force_title
  
  Force a title for the page (don't try to determine it from the content).
  The value of this string should already be &-escaped.
  
  =head2 html_header, html_footer
  
  Set the HTML output at the beginning and end of each file. The default
  header includes a title, a doctype tag (if C<html_doctype> is set), a
  content tag (customized by C<html_header_tags>), a tag for a CSS file
  (if C<html_css> is set), and a tag for a Javascript file (if
  C<html_javascript> is set). The default footer simply closes the C<html>
  and C<body> tags.
  
  The options listed above customize parts of the default header, but
  setting C<html_header> or C<html_footer> completely overrides the
  built-in header or footer. These may be useful if you want to use
  template tags instead of literal HTML headers and footers or are
  integrating converted POD pages in a larger website.
  
  If you want no headers or footers output in the HTML, set these options
  to the empty string.
  
  =head2 index
  
  Whether to add a table-of-contents at the top of each page (called an
  index for the sake of tradition).
  
  =head2 anchor_items
  
  Whether to anchor every definition C<=item> directive. This needs to be
  enabled if you want to be able to link to specific C<=item> directives, which
  are output as C<< <dt> >> elements. Disabled by default.
  
  =head2 backlink
  
  Whether to turn every =head1 directive into a link pointing to the top
  of the page (specifically, the opening body tag).
  
  =cut
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
   'perldoc_url_postfix',
   'man_url_prefix',
   'man_url_postfix',
   'title_prefix',  'title_postfix',
   'html_css',
   'html_javascript',
   'html_doctype',
   'html_charset',
   'html_encode_chars',
   'html_h_level',
   'title', # Used internally for the title extracted from the content
   'default_title',
   'force_title',
   'html_header',
   'html_footer',
   'index',
   'anchor_items',
   'backlink',
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 SUBCLASSING
  
  If the standard options aren't enough, you may want to subclass
  Pod::Simple::XHMTL. These are the most likely candidates for methods
  you'll want to override when subclassing.
  
  =cut
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->perldoc_url_prefix('https://metacpan.org/pod/');
    $new->man_url_prefix('http://man.he.net/man');
    $new->html_charset('ISO-8859-1');
    $new->nix_X_codes(1);
    $new->{'scratch'} = '';
    $new->{'to_index'} = [];
    $new->{'output'} = [];
    $new->{'saved'} = [];
    $new->{'ids'} = { '_podtop_' => 1 }; # used in <body>
    $new->{'in_li'} = [];
  
    $new->{'__region_targets'}  = [];
    $new->{'__literal_targets'} = {};
    $new->accept_targets_as_html( 'html', 'HTML' );
  
    return $new;
  }
  
  sub html_header_tags {
      my $self = shift;
      return $self->{html_header_tags} = shift if @_;
      return $self->{html_header_tags}
          ||= '<meta http-equiv="Content-Type" content="text/html; charset='
              . $self->html_charset . '" />';
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head2 handle_text
  
  This method handles the body of text within any element: it's the body
  of a paragraph, or everything between a "=begin" tag and the
  corresponding "=end" tag, or the text within an L entity, etc. You would
  want to override this if you are adding a custom element type that does
  more than just display formatted text. Perhaps adding a way to generate
  HTML tables from an extended version of POD.
  
  So, let's say you want to add a custom element called 'foo'. In your
  subclass's C<new> method, after calling C<SUPER::new> you'd call:
  
    $new->accept_targets_as_text( 'foo' );
  
  Then override the C<start_for> method in the subclass to check for when
  "$flags->{'target'}" is equal to 'foo' and set a flag that marks that
  you're in a foo block (maybe "$self->{'in_foo'} = 1"). Then override the
  C<handle_text> method to check for the flag, and pass $text to your
  custom subroutine to construct the HTML output for 'foo' elements,
  something like:
  
    sub handle_text {
        my ($self, $text) = @_;
        if ($self->{'in_foo'}) {
            $self->{'scratch'} .= build_foo_html($text);
            return;
        }
        $self->SUPER::handle_text($text);
    }
  
  =head2 handle_code
  
  This method handles the body of text that is marked up to be code.
  You might for instance override this to plug in a syntax highlighter.
  The base implementation just escapes the text.
  
  The callback methods C<start_code> and C<end_code> emits the C<code> tags
  before and after C<handle_code> is invoked, so you might want to override these
  together with C<handle_code> if this wrapping isn't suitable.
  
  Note that the code might be broken into multiple segments if there are
  nested formatting codes inside a C<< CE<lt>...> >> sequence.  In between the
  calls to C<handle_code> other markup tags might have been emitted in that
  case.  The same is true for verbatim sections if the C<codes_in_verbatim>
  option is turned on.
  
  =head2 accept_targets_as_html
  
  This method behaves like C<accept_targets_as_text>, but also marks the region
  as one whose content should be emitted literally, without HTML entity escaping
  or wrapping in a C<div> element.
  
  =cut
  
  sub __in_literal_xhtml_region {
      return unless @{ $_[0]{__region_targets} };
      my $target = $_[0]{__region_targets}[-1];
      return $_[0]{__literal_targets}{ $target };
  }
  
  sub accept_targets_as_html {
      my ($self, @targets) = @_;
      $self->accept_targets(@targets);
      $self->{__literal_targets}{$_} = 1 for @targets;
  }
  
  sub handle_text {
      # escape special characters in HTML (<, >, &, etc)
      my $text = $_[1];
      my $html;
      if ($_[0]->__in_literal_xhtml_region) {
          $html = $text;
          $text =~ s{<[^>]+?>}{}g;
          $text = $_[0]->decode_entities($text);
      }
      else {
          $html = $_[0]->encode_entities($text);
      }
  
      if ($_[0]{'in_code'} && @{$_[0]{'in_code'}}) {
          # Intentionally use the raw text in $_[1], even if we're not in a
          # literal xhtml region, since handle_code calls encode_entities.
          $_[0]->handle_code( $_[1], $_[0]{'in_code'}[-1] );
      } else {
          if ($_[0]->{in_for}) {
              my $newlines = $_[0]->__in_literal_xhtml_region ? "\n\n" : '';
              if ($_[0]->{started_for}) {
                  if ($html =~ /\S/) {
                      delete $_[0]->{started_for};
                      $_[0]{'scratch'} .= $html . $newlines;
                  }
                  # Otherwise, append nothing until we have something to append.
              } else {
                  # The parser sometimes preserves newlines and sometimes doesn't!
                  $html =~ s/\n\z//;
                  $_[0]{'scratch'} .= $html . $newlines;
              }
          } else {
              # Just plain text.
              $_[0]{'scratch'} .= $html;
          }
      }
  
      $_[0]{hhtml} .= $html if $_[0]{'in_head'};
      $_[0]{htext} .= $text if $_[0]{'in_head'};
      $_[0]{itext} .= $text if $_[0]{'in_item_text'};
  }
  
  sub start_code {
      $_[0]{'scratch'} .= '<code>';
  }
  
  sub end_code {
      $_[0]{'scratch'} .= '</code>';
  }
  
  sub handle_code {
      $_[0]{'scratch'} .= $_[0]->encode_entities( $_[1] );
  }
  
  sub start_Para {
      $_[0]{'scratch'} .= '<p>';
  }
  
  sub start_Verbatim {
      $_[0]{'scratch'} = '<pre>';
      push(@{$_[0]{'in_code'}}, 'Verbatim');
      $_[0]->start_code($_[0]{'in_code'}[-1]);
  }
  
  sub start_head1 {  $_[0]{'in_head'} = 1; $_[0]{htext} = $_[0]{hhtml} = ''; }
  sub start_head2 {  $_[0]{'in_head'} = 2; $_[0]{htext} = $_[0]{hhtml} = ''; }
  sub start_head3 {  $_[0]{'in_head'} = 3; $_[0]{htext} = $_[0]{hhtml} = ''; }
  sub start_head4 {  $_[0]{'in_head'} = 4; $_[0]{htext} = $_[0]{hhtml} = ''; }
  sub start_head5 {  $_[0]{'in_head'} = 5; $_[0]{htext} = $_[0]{hhtml} = ''; }
  sub start_head6 {  $_[0]{'in_head'} = 6; $_[0]{htext} = $_[0]{hhtml} = ''; }
  
  sub start_item_number {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_bullet {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_text   {
      $_[0]{'in_item_text'} = 1; $_[0]{itext} = '';
      # see end_item_text
  }
  
  sub start_over_bullet { $_[0]{'scratch'} = '<ul>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_block  { $_[0]{'scratch'} = '<ul>'; $_[0]->emit }
  sub start_over_number { $_[0]{'scratch'} = '<ol>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_text   {
      $_[0]{'scratch'} = '<dl>';
      $_[0]{'dl_level'}++;
      $_[0]{'in_dd'} ||= [];
      $_[0]->emit
  }
  
  sub end_over_block  { $_[0]{'scratch'} .= '</ul>'; $_[0]->emit }
  
  sub end_over_number   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ol>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_bullet   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ul>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_text   {
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
      $_[0]{'scratch'} .= '</dl>';
      $_[0]{'dl_level'}--;
      $_[0]->emit;
  }
  
  # . . . . . Now the actual formatters:
  
  sub end_Para     { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_Verbatim {
      $_[0]->end_code(pop(@{$_[0]->{'in_code'}}));
      $_[0]{'scratch'} .= '</pre>';
      $_[0]->emit;
  }
  
  sub _end_head {
      my $h = delete $_[0]{in_head};
  
      my $add = $_[0]->html_h_level;
      $add = 1 unless defined $add;
      $h += $add - 1;
  
      my $id = $_[0]->idify(delete $_[0]{htext});
      my $text = $_[0]{scratch};
      my $head = qq{<h$h id="} . $_[0]->encode_entities($id) . qq{">$text</h$h>};
      $_[0]{'scratch'} = $_[0]->backlink && ($h - $add == 0)
                           # backlinks enabled && =head1
                           ? qq{<a href="#_podtop_">$head</a>}
                           : $head;
      $_[0]->emit;
      push @{ $_[0]{'to_index'} }, [$h, $id, delete $_[0]{'hhtml'}];
  }
  
  sub end_head1       { shift->_end_head(@_); }
  sub end_head2       { shift->_end_head(@_); }
  sub end_head3       { shift->_end_head(@_); }
  sub end_head4       { shift->_end_head(@_); }
  sub end_head5       { shift->_end_head(@_); }
  sub end_head6       { shift->_end_head(@_); }
  
  sub end_item_bullet { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_item_number { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  
  sub end_item_text   {
      # idify and anchor =item content if wanted
      my $dt_id = $_[0]{'anchor_items'}
                   ? ' id="'. $_[0]->encode_entities($_[0]->idify($_[0]{'itext'})) .'"'
                   : '';
  
      # reset scratch
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = '';
  
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
  
      $_[0]{'scratch'} .= qq{<dt$dt_id>$text</dt>\n<dd>};
      $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 1;
      $_[0]->emit;
  }
  
  # This handles =begin and =for blocks of all kinds.
  sub start_for {
    my ($self, $flags) = @_;
  
    push @{ $self->{__region_targets} }, $flags->{target_matching};
    $self->{started_for} = 1;
    $self->{in_for} = 1;
  
    unless ($self->__in_literal_xhtml_region) {
      $self->{scratch} .= '<div';
      $self->{scratch} .= qq( class="$flags->{target}") if $flags->{target};
      $self->{scratch} .= ">\n\n";
    }
  }
  
  sub end_for {
    my ($self) = @_;
    delete $self->{started_for};
    delete $self->{in_for};
  
    if ($self->__in_literal_xhtml_region) {
      # Remove trailine newlines.
      $self->{'scratch'} =~ s/\s+\z//s;
    } else {
      $self->{'scratch'} .= '</div>';
    }
  
    pop @{ $self->{__region_targets} };
    $self->emit;
  }
  
  sub start_Document {
    my ($self) = @_;
    if (defined $self->html_header) {
      $self->{'scratch'} .= $self->html_header;
      $self->emit unless $self->html_header eq "";
    } else {
      my ($doctype, $title, $metatags, $bodyid);
      $doctype = $self->html_doctype || '';
      $title = $self->force_title || $self->title || $self->default_title || '';
      $metatags = $self->html_header_tags || '';
      if (my $css = $self->html_css) {
          if ($css !~ /<link/) {
              # this is required to be compatible with Pod::Simple::BatchHTML
              $metatags .= '<link rel="stylesheet" href="'
                  . $self->encode_entities($css) . '" type="text/css" />';
          } else {
              $metatags .= $css;
          }
      }
      if ($self->html_javascript) {
        $metatags .= qq{\n<script type="text/javascript" src="} .
                      $self->html_javascript . '"></script>';
      }
      $bodyid = $self->backlink ? ' id="_podtop_"' : '';
      $self->{'scratch'} .= <<"HTML";
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
      $self->emit;
    }
  }
  
  sub build_index {
      my ($self, $to_index) = @_;
  
      my @out;
      my $level  = 0;
      my $indent = -1;
      my $space  = '';
      my $id     = ' id="index"';
  
      for my $h (@{ $to_index }, [0]) {
          my $target_level = $h->[0];
          # Get to target_level by opening or closing ULs
          if ($level == $target_level) {
              $out[-1] .= '</li>';
          } elsif ($level > $target_level) {
              $out[-1] .= '</li>' if $out[-1] =~ /^\s+<li>/;
              while ($level > $target_level) {
                  --$level;
                  push @out, ('  ' x --$indent) . '</li>' if @out && $out[-1] =~ m{^\s+<\/ul};
                  push @out, ('  ' x --$indent) . '</ul>';
              }
              push @out, ('  ' x --$indent) . '</li>' if $level;
          } else {
              while ($level < $target_level) {
                  ++$level;
                  push @out, ('  ' x ++$indent) . '<li>' if @out && $out[-1]=~ /^\s*<ul/;
                  push @out, ('  ' x ++$indent) . "<ul$id>";
                  $id = '';
              }
              ++$indent;
          }
  
          next unless $level;
          $space = '  '  x $indent;
          my $fragment = $self->encode_entities($self->encode_url($h->[1]));
          push @out, sprintf '%s<li><a href="#%s">%s</a>',
              $space, $fragment, $h->[2];
      }
  
      return join "\n", @out;
  }
  
  sub end_Document   {
    my ($self) = @_;
    my $to_index = $self->{'to_index'};
    if ($self->index && @{ $to_index } ) {
        my $index = $self->build_index($to_index);
  
        # Splice the index in between the HTML headers and the first element.
        my $offset = defined $self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;
        splice @{ $self->{'output'} }, $offset, 0, $index;
    }
  
    if (defined $self->html_footer) {
      $self->{'scratch'} .= $self->html_footer;
      $self->emit unless $self->html_footer eq "";
    } else {
      $self->{'scratch'} .= "</body>\n</html>";
      $self->emit;
    }
  
    if ($self->index) {
        print {$self->{'output_fh'}} join ("\n\n", @{ $self->{'output'} }), "\n\n";
        @{$self->{'output'}} = ();
    }
  
  }
  
  # Handling code tags
  sub start_B { $_[0]{'scratch'} .= '<b>' }
  sub end_B   { $_[0]{'scratch'} .= '</b>' }
  
  sub start_C { push(@{$_[0]{'in_code'}}, 'C'); $_[0]->start_code($_[0]{'in_code'}[-1]); }
  sub end_C   { $_[0]->end_code(pop(@{$_[0]{'in_code'}})); }
  
  sub start_F { $_[0]{'scratch'} .= '<i>' }
  sub end_F   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_I { $_[0]{'scratch'} .= '<i>' }
  sub end_I   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_L {
    my ($self, $flags) = @_;
      my ($type, $to, $section) = @{$flags}{'type', 'to', 'section'};
      my $url = $self->encode_entities(
          $type eq 'url' ? $to
              : $type eq 'pod' ? $self->resolve_pod_page_link($to, $section)
              : $type eq 'man' ? $self->resolve_man_page_link($to, $section)
              :                  undef
      );
  
      # If it's an unknown type, use an attribute-less <a> like HTML.pm.
      $self->{'scratch'} .= '<a' . ($url ? ' href="'. $url . '">' : '>');
  }
  
  sub end_L   { $_[0]{'scratch'} .= '</a>' }
  
  sub start_S { $_[0]{'scratch'} .= '<span style="white-space: nowrap;">' }
  sub end_S   { $_[0]{'scratch'} .= '</span>' }
  
  sub emit {
    my($self) = @_;
    if ($self->index) {
        push @{ $self->{'output'} }, $self->{'scratch'};
    } else {
        print {$self->{'output_fh'}} $self->{'scratch'}, "\n\n";
    }
    $self->{'scratch'} = '';
    return;
  }
  
  =head2 resolve_pod_page_link
  
    my $url = $pod->resolve_pod_page_link('Net::Ping', 'INSTALL');
    my $url = $pod->resolve_pod_page_link('perlpodspec');
    my $url = $pod->resolve_pod_page_link(undef, 'SYNOPSIS');
  
  Resolves a POD link target (typically a module or POD file name) and section
  name to a URL. The resulting link will be returned for the above examples as:
  
    https://metacpan.org/pod/Net::Ping#INSTALL
    https://metacpan.org/pod/perlpodspec
    #SYNOPSIS
  
  Note that when there is only a section argument the URL will simply be a link
  to a section in the current document.
  
  =cut
  
  sub resolve_pod_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to || defined $section;
      if (defined $section) {
          my $id = $self->idify($section, 1);
          $section = '#' . $self->encode_url($id);
          return $section unless defined $to;
      } else {
          $section = ''
      }
  
      return ($self->perldoc_url_prefix || '')
          . $to . $section
          . ($self->perldoc_url_postfix || '');
  }
  
  =head2 resolve_man_page_link
  
    my $url = $pod->resolve_man_page_link('crontab(5)', 'EXAMPLE CRON FILE');
    my $url = $pod->resolve_man_page_link('crontab');
  
  Resolves a man page link target and numeric section to a URL. The resulting
  link will be returned for the above examples as:
  
      http://man.he.net/man5/crontab
      http://man.he.net/man1/crontab
  
  Note that the first argument is required. The section number will be parsed
  from it, and if it's missing will default to 1. The second argument is
  currently ignored, as L<man.he.net|http://man.he.net> does not currently
  include linkable IDs or anchor names in its pages. Subclass to link to a
  different man page HTTP server.
  
  =cut
  
  sub resolve_man_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to;
      my ($page, $part) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
      return undef unless $page;
      return ($self->man_url_prefix || '')
          . ($part || 1) . "/" . $self->encode_entities($page)
          . ($self->man_url_postfix || '');
  
  }
  
  =head2 idify
  
    my $id   = $pod->idify($text);
    my $hash = $pod->idify($text, 1);
  
  This method turns an arbitrary string into a valid XHTML ID attribute value.
  The rules enforced, following
  L<http://webdesign.about.com/od/htmltags/a/aa031707.htm>, are:
  
  =over
  
  =item *
  
  The id must start with a letter (a-z or A-Z)
  
  =item *
  
  All subsequent characters can be letters, numbers (0-9), hyphens (-),
  underscores (_), colons (:), and periods (.).
  
  =item *
  
  The final character can't be a hyphen, colon, or period. URLs ending with these
  characters, while allowed by XHTML, can be awkward to extract from plain text.
  
  =item *
  
  Each id must be unique within the document.
  
  =back
  
  In addition, the returned value will be unique within the context of the
  Pod::Simple::XHTML object unless a second argument is passed a true value. ID
  attributes should always be unique within a single XHTML document, but pass
  the true value if you are creating not an ID but a URL hash to point to
  an ID (i.e., if you need to put the "#foo" in C<< <a href="#foo">foo</a> >>.
  
  =cut
  
  sub idify {
      my ($self, $t, $not_unique) = @_;
      for ($t) {
          s/[<>&'"]//g;            # Strip HTML special characters
          s/^\s+//; s/\s+$//;      # Strip white space.
          s/^([^a-zA-Z]+)$/pod$1/; # Prepend "pod" if no valid chars.
          s/^[^a-zA-Z]+//;         # First char must be a letter.
          s/[^-a-zA-Z0-9_:.]+/-/g; # All other chars must be valid.
          s/[-:.]+$//;             # Strip trailing punctuation.
      }
      return $t if $not_unique;
      my $i = '';
      $i++ while $self->{ids}{"$t$i"}++;
      return "$t$i";
  }
  
  =head2 batch_mode_page_object_init
  
    $pod->batch_mode_page_object_init($batchconvobj, $module, $infile, $outfile, $depth);
  
  Called by L<Pod::Simple::HTMLBatch> so that the class has a chance to
  initialize the converter. Internally it sets the C<batch_mode> property to
  true and sets C<batch_mode_current_level()>, but Pod::Simple::XHTML does not
  currently use those features. Subclasses might, though.
  
  =cut
  
  sub batch_mode_page_object_init {
    my ($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub html_header_after_title {
  }
  
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2003-2005 Allison Randal.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simpele::XHTML was created by Allison Randal <allison@perl.org>.
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  package Pod::Simple::XMLOutStream;
  use strict;
  use warnings;
  use Carp ();
  use Pod::Simple ();
  our $VERSION = '3.45';
  BEGIN {
    our @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  our $ATTR_PAD;
  $ATTR_PAD = "\n" unless defined $ATTR_PAD;
   # Don't mess with this unless you know what you're doing.
  
  our $SORT_ATTRS;
  $SORT_ATTRS = 0 unless defined $SORT_ATTRS;
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->keep_encoding_directive(1);
    #$new->accept_codes('VerbatimFormatted');
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    print $fh "<", $_[1];
    if($SORT_ATTRS) {
      foreach my $key (sort keys %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value = $_[2]{$key});
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    } else { # faster
      while(($key,$value) = each %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value);
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    }
    print $fh ">";
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $text = $_[1];
      _xml_escape($text);
      print {$_[0]{'output_fh'}} $text;
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}} "</", $_[1], ">";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::XMLOutStream -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::XMLOutStream -e \
     "exit Pod::Simple::XMLOutStream->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::XMLOutStream is a subclass of L<Pod::Simple> that parses
  Pod and turns it into XML.
  
  Pod::Simple::XMLOutStream inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML> is rather like this class; see its
  documentation for a discussion of the differences.
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>, L<Pod::SAX>
  
  L<Pod::Simple::Subclassing>
  
  The older (and possibly obsolete) libraries L<Pod::PXML>, L<Pod::XML>
  
  
  =head1 ABOUT EXTENDING POD
  
  TODO: An example or two of =extend, then point to Pod::Simple::Subclassing
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<https://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  # Convert POD data to formatted text.
  #
  # This module converts POD to formatted text.  It replaces the old Pod::Text
  # module that came with versions of Perl prior to 5.6.0 and attempts to match
  # its output except for some specific circumstances where other decisions
  # seemed to produce better output.  It uses Pod::Parser and is designed to be
  # very easy to subclass.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Carp qw(carp croak);
  use Encode qw(encode);
  use Exporter ();
  use Pod::Simple ();
  
  our @ISA = qw(Pod::Simple Exporter);
  our $VERSION = '5.01';
  
  # We have to export pod2text for backward compatibility.
  our @EXPORT = qw(pod2text);
  
  # Ensure that $Pod::Simple::nbsp and $Pod::Simple::shy are available.  Code
  # taken from Pod::Simple 3.32, but was only added in 3.30.
  my ($NBSP, $SHY);
  if ($Pod::Simple::VERSION ge 3.30) {
      $NBSP = $Pod::Simple::nbsp;
      $SHY  = $Pod::Simple::shy;
  } else {
      $NBSP = chr utf8::unicode_to_native(0xA0);
      $SHY  = chr utf8::unicode_to_native(0xAD);
  }
  
  # Import the ASCII constant from Pod::Simple.  This is true iff we're in an
  # ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
  # generally only false for EBCDIC.
  BEGIN { *ASCII = \&Pod::Simple::ASCII }
  
  ##############################################################################
  # Initialization
  ##############################################################################
  
  # This function handles code blocks.  It's registered as a callback to
  # Pod::Simple and therefore doesn't work as a regular method call, but all it
  # does is call output_code with the line.
  sub handle_code {
      my ($line, $number, $parser) = @_;
      $parser->output_code ($line . "\n");
  }
  
  # Initialize the object and set various Pod::Simple options that we need.
  # Here, we also process any additional options passed to the constructor or
  # set up defaults if none were given.  Note that all internal object keys are
  # in all-caps, reserving all lower-case object keys for Pod::Simple and user
  # arguments.
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new;
  
      # Tell Pod::Simple to keep whitespace whenever possible.
      if ($self->can ('preserve_whitespace')) {
          $self->preserve_whitespace (1);
      } else {
          $self->fullstop_space_harden (1);
      }
  
      # The =for and =begin targets that we accept.
      $self->accept_targets (qw/text TEXT/);
  
      # Ensure that contiguous blocks of code are merged together.  Otherwise,
      # some of the guesswork heuristics don't work right.
      $self->merge_text (1);
  
      # Pod::Simple doesn't do anything useful with our arguments, but we want
      # to put them in our object as hash keys and values.  This could cause
      # problems if we ever clash with Pod::Simple's own internal class
      # variables.
      my %opts = @_;
      my @opts = map { ("opt_$_", $opts{$_}) } keys %opts;
      %$self = (%$self, @opts);
  
      # Backwards-compatibility support for the stderr option.
      if ($$self{opt_stderr} and not $$self{opt_errors}) {
          $$self{opt_errors} = 'stderr';
      }
      delete $$self{opt_stderr};
  
      # Backwards-compatibility support for the utf8 option.
      if ($$self{opt_utf8} && !$$self{opt_encoding}) {
          $$self{opt_encoding} = 'UTF-8';
      }
      delete $$self{opt_utf8};
  
      # Validate the errors parameter and act on it.
      $$self{opt_errors} //= 'pod';
      if ($$self{opt_errors} eq 'stderr' || $$self{opt_errors} eq 'die') {
          $self->no_errata_section (1);
          $self->complain_stderr (1);
          if ($$self{opt_errors} eq 'die') {
              $$self{complain_die} = 1;
          }
      } elsif ($$self{opt_errors} eq 'pod') {
          $self->no_errata_section (0);
          $self->complain_stderr (0);
      } elsif ($$self{opt_errors} eq 'none') {
          $self->no_errata_section (1);
          $self->no_whining (1);
      } else {
          croak (qq(Invalid errors setting: "$$self{errors}"));
      }
      delete $$self{errors};
  
      # Initialize various things from our parameters.
      $$self{opt_alt}      //= 0;
      $$self{opt_indent}   //= 4;
      $$self{opt_margin}   //= 0;
      $$self{opt_loose}    //= 0;
      $$self{opt_sentence} //= 0;
      $$self{opt_width}    //= 76;
  
      # Figure out what quotes we'll be using for C<> text.
      $$self{opt_quotes} ||= '"';
      if ($$self{opt_quotes} eq 'none') {
          $$self{LQUOTE} = $$self{RQUOTE} = '';
      } elsif (length ($$self{opt_quotes}) == 1) {
          $$self{LQUOTE} = $$self{RQUOTE} = $$self{opt_quotes};
      } elsif (length ($$self{opt_quotes}) % 2 == 0) {
          my $length = length ($$self{opt_quotes}) / 2;
          $$self{LQUOTE} = substr ($$self{opt_quotes}, 0, $length);
          $$self{RQUOTE} = substr ($$self{opt_quotes}, $length);
      } else {
          croak qq(Invalid quote specification "$$self{opt_quotes}");
      }
  
      # Configure guesswork based on options.
      my $guesswork = $self->{opt_guesswork} || q{};
      my %guesswork = map { $_ => 1 } split(m{,}xms, $guesswork);
      if (!%guesswork || $guesswork{all}) {
          $$self{GUESSWORK} = {quoting => 1};
      } elsif ($guesswork{none}) {
          $$self{GUESSWORK} = {};
      } else {
          $$self{GUESSWORK} = {%guesswork};
      }
  
      # If requested, do something with the non-POD text.
      $self->code_handler (\&handle_code) if $$self{opt_code};
  
      # Return the created object.
      return $self;
  }
  
  ##############################################################################
  # Core parsing
  ##############################################################################
  
  # This is the glue that connects the code below with Pod::Simple itself.  The
  # goal is to convert the event stream coming from the POD parser into method
  # calls to handlers once the complete content of a tag has been seen.  Each
  # paragraph or POD command will have textual content associated with it, and
  # as soon as all of a paragraph or POD command has been seen, that content
  # will be passed in to the corresponding method for handling that type of
  # object.  The exceptions are handlers for lists, which have opening tag
  # handlers and closing tag handlers that will be called right away.
  #
  # The internal hash key PENDING is used to store the contents of a tag until
  # all of it has been seen.  It holds a stack of open tags, each one
  # represented by a tuple of the attributes hash for the tag and the contents
  # of the tag.
  
  # Add a block of text to the contents of the current node, formatting it
  # according to the current formatting instructions as we do.
  sub _handle_text {
      my ($self, $text) = @_;
      my $tag = $$self{PENDING}[-1];
      $$tag[1] .= $text;
  }
  
  # Given an element name, get the corresponding method name.
  sub method_for_element {
      my ($self, $element) = @_;
      $element =~ tr/-/_/;
      $element =~ tr/A-Z/a-z/;
      $element =~ tr/_a-z0-9//cd;
      return $element;
  }
  
  # Handle the start of a new element.  If cmd_element is defined, assume that
  # we need to collect the entire tree for this element before passing it to the
  # element method, and create a new tree into which we'll collect blocks of
  # text and nested elements.  Otherwise, if start_element is defined, call it.
  sub _handle_element_start {
      my ($self, $element, $attrs) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, we need to accumulate the contents of the
      # tag before calling it.
      if ($self->can ("cmd_$method")) {
          push (@{ $$self{PENDING} }, [ $attrs, '' ]);
      } elsif ($self->can ("start_$method")) {
          my $method = 'start_' . $method;
          $self->$method ($attrs, '');
      }
  }
  
  # Handle the end of an element.  If we had a cmd_ method for this element,
  # this is where we pass along the text that we've accumulated.  Otherwise, if
  # we have an end_ method for the element, call that.
  sub _handle_element_end {
      my ($self, $element) = @_;
      my $method = $self->method_for_element ($element);
  
      # If we have a command handler, pull off the pending text and pass it to
      # the handler along with the saved attribute hash.
      if ($self->can ("cmd_$method")) {
          my $tag = pop @{ $$self{PENDING} };
          my $method = 'cmd_' . $method;
          my $text = $self->$method (@$tag);
          if (defined $text) {
              if (@{ $$self{PENDING} } > 1) {
                  $$self{PENDING}[-1][1] .= $text;
              } else {
                  $self->output ($text);
              }
          }
      } elsif ($self->can ("end_$method")) {
          my $method = 'end_' . $method;
          $self->$method ();
      }
  }
  
  ##############################################################################
  # Output formatting
  ##############################################################################
  
  # Wrap a line, indenting by the current left margin.  We can't use Text::Wrap
  # because it plays games with tabs.  We can't use formline, even though we'd
  # really like to, because it screws up non-printing characters.  So we have to
  # do the wrapping ourselves.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
      while (length > $width) {
          if (s/^([^\n]{0,$width})[ \t\n]+// || s/^([^\n]{$width})//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  # Reformat a paragraph of text for the current margin.  Takes the text to
  # reformat and returns the formatted text.
  sub reformat {
      my $self = shift;
      local $_ = shift;
  
      # If we're trying to preserve two spaces after sentences, do some munging
      # to support that.  Otherwise, smash all repeated whitespace.  Be careful
      # not to use \s here, which in Unicode input may match non-breaking spaces
      # that we don't want to smash.
      if ($$self{opt_sentence}) {
          s/ +$//mg;
          s/\.\n/. \n/g;
          s/\n/ /g;
          s/   +/  /g;
      } else {
          s/[ \t\n]+/ /g;
      }
      return $self->wrap ($_);
  }
  
  # Output text to the output device.  Replace non-breaking spaces with spaces
  # and soft hyphens with nothing, and then determine the output encoding.
  sub output {
      my ($self, @text) = @_;
      my $text = join ('', @text);
      if ($NBSP) {
          $text =~ s/$NBSP/ /g;
      }
      if ($SHY) {
          $text =~ s/$SHY//g;
      }
  
      # The logic used here is described in the POD documentation.  Prefer the
      # configured encoding, then the pass-through option of using the same
      # encoding as the input, and then UTF-8, but commit to an encoding for the
      # document.
      #
      # ENCODE says whether to encode or not and is turned off if there is a
      # PerlIO encoding layer (in start_document).  ENCODING is the encoding
      # that we previously committed to and is cleared at the start of each
      # document.
      if ($$self{ENCODE}) {
          my $encoding = $$self{ENCODING};
          if (!$encoding) {
              $encoding = $self->encoding();
              if (!$encoding && ASCII && $text =~ /[^\x00-\x7F]/) {
                  $encoding = 'UTF-8';
              }
              if ($encoding) {
                  $$self{ENCODING} = $encoding;
              }
          }
          if ($encoding) {
              my $check = sub {
                  my ($char) = @_;
                  my $display = '"\x{' . hex($char) . '}"';
                  my $error = "$display does not map to $$self{ENCODING}";
                  $self->whine ($self->line_count(), $error);
                  return Encode::encode ($$self{ENCODING}, chr($char));
              };
              print { $$self{output_fh} } encode ($encoding, $text, $check);
          } else {
              print { $$self{output_fh} } $text;
          }
      } else {
          print { $$self{output_fh} } $text;
      }
  }
  
  # Output a block of code (something that isn't part of the POD text).  Called
  # by preprocess_paragraph only if we were given the code option.  Exists here
  # only so that it can be overridden by subclasses.
  sub output_code { $_[0]->output ($_[1]) }
  
  ##############################################################################
  # Document initialization
  ##############################################################################
  
  # Set up various things that have to be initialized on a per-document basis.
  sub start_document {
      my ($self, $attrs) = @_;
      if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
          $$self{CONTENTLESS} = 1;
      } else {
          delete $$self{CONTENTLESS};
      }
      my $margin = $$self{opt_indent} + $$self{opt_margin};
  
      # Initialize a few per-document variables.
      $$self{INDENTS} = [];       # Stack of indentations.
      $$self{MARGIN}  = $margin;  # Default left margin.
      $$self{PENDING} = [[]];     # Pending output.
  
      # We have to redo encoding handling for each document.  Check whether the
      # output file handle already has a PerlIO encoding layer set and, if so,
      # disable encoding.
      $$self{ENCODE} = 1;
      eval {
          my @options = (output => 1, details => 1);
          my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
          if ($flag && ($flag & PerlIO::F_UTF8 ())) {
              $$self{ENCODE} = 0;
          }
      };
      $$self{ENCODING} = $$self{opt_encoding};
  
      return '';
  }
  
  # Handle the end of the document.  The only thing we do is handle dying on POD
  # errors, since Pod::Parser currently doesn't.
  sub end_document {
      my ($self) = @_;
      if ($$self{complain_die} && $self->errors_seen) {
          croak ("POD document had syntax errors");
      }
  }
  
  ##############################################################################
  # Text blocks
  ##############################################################################
  
  # Intended for subclasses to override, this method returns text with any
  # non-printing formatting codes stripped out so that length() correctly
  # returns the length of the text.  For basic Pod::Text, it does nothing.
  sub strip_format {
      my ($self, $string) = @_;
      return $string;
  }
  
  # This method is called whenever an =item command is complete (in other words,
  # we've seen its associated paragraph or know for certain that it doesn't have
  # one).  It gets the paragraph associated with the item as an argument.  If
  # that argument is empty, just output the item tag; if it contains a newline,
  # output the item tag followed by the newline.  Otherwise, see if there's
  # enough room for us to output the item tag in the margin of the text or if we
  # have to put it on a separate line.
  sub item {
      my ($self, $text) = @_;
      my $tag = $$self{ITEM};
      unless (defined $tag) {
          carp "Item called without tag";
          return;
      }
      undef $$self{ITEM};
  
      # Calculate the indentation and margin.  $fits is set to true if the tag
      # will fit into the margin of the paragraph given our indentation level.
      my $indent = $$self{INDENTS}[-1] // $$self{opt_indent};
      my $margin = ' ' x $$self{opt_margin};
      my $tag_length = length ($self->strip_format ($tag));
      my $fits = ($$self{MARGIN} - $indent >= $tag_length + 1);
  
      # If the tag doesn't fit, or if we have no associated text, print out the
      # tag separately.  Otherwise, put the tag in the margin of the paragraph.
      if (!$text || $text =~ /^\s+$/ || !$fits) {
          my $realindent = $$self{MARGIN};
          $$self{MARGIN} = $indent;
          my $output = $self->reformat ($tag);
          $output =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
          $output =~ s/\n*$/\n/;
  
          # If the text is just whitespace, we have an empty item paragraph;
          # this can result from =over/=item/=back without any intermixed
          # paragraphs.  Insert some whitespace to keep the =item from merging
          # into the next paragraph.
          $output .= "\n" if $text && $text =~ /^\s*$/;
  
          $self->output ($output);
          $$self{MARGIN} = $realindent;
          $self->output ($self->reformat ($text)) if ($text && $text =~ /\S/);
      } else {
          my $space = ' ' x $indent;
          $space =~ s/^$margin /$margin:/ if $$self{opt_alt};
          $text = $self->reformat ($text);
          $text =~ s/^$margin /$margin:/ if ($$self{opt_alt} && $indent > 0);
          my $tagspace = ' ' x $tag_length;
          $text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";
          $self->output ($text);
      }
  }
  
  # Handle a basic block of text.  The only tricky thing here is that if there
  # is a pending item tag, we need to format this as an item paragraph.
  sub cmd_para {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$/\n/;
      if (defined $$self{ITEM}) {
          $self->item ($text . "\n");
      } else {
          $self->output ($self->reformat ($text . "\n"));
      }
      return '';
  }
  
  # Handle a verbatim paragraph.  Just print it out, but indent it according to
  # our margin.
  sub cmd_verbatim {
      my ($self, $attrs, $text) = @_;
      $self->item if defined $$self{ITEM};
      return if $text =~ /^\s*$/;
      $text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;
      $text =~ s/\s*$/\n\n/;
      $self->output ($text);
      return '';
  }
  
  # Handle literal text (produced by =for and similar constructs).  Just output
  # it with the minimum of changes.
  sub cmd_data {
      my ($self, $attrs, $text) = @_;
      $text =~ s/^\n+//;
      $text =~ s/\n{0,2}$/\n/;
      $self->output ($text);
      return '';
  }
  
  ##############################################################################
  # Headings
  ##############################################################################
  
  # The common code for handling all headers.  Takes the header text, the
  # indentation, and the surrounding marker for the alt formatting method.
  sub heading {
      my ($self, $text, $indent, $marker) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $text =~ s/\s+$//;
      if ($$self{opt_alt}) {
          my $closemark = reverse (split (//, $marker));
          my $margin = ' ' x $$self{opt_margin};
          $self->output ("\n" . "$margin$marker $text $closemark" . "\n\n");
      } else {
          $text .= "\n" if $$self{opt_loose};
          my $margin = ' ' x ($$self{opt_margin} + $indent);
          $self->output ($margin . $text . "\n");
      }
      return '';
  }
  
  # First level heading.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, 0, '====');
  }
  
  # Second level heading.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} / 2, '==  ');
  }
  
  # Third level heading.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} * 2 / 3 + 0.5, '=   ');
  }
  
  # Fourth level heading.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $self->heading ($text, $$self{opt_indent} * 3 / 4 + 0.5, '-   ');
  }
  
  ##############################################################################
  # List handling
  ##############################################################################
  
  # Handle the beginning of an =over block.  Takes the type of the block as the
  # first argument, and then the attr hash.  This is called by the handlers for
  # the four different types of lists (bullet, number, text, and block).
  sub over_common_start {
      my ($self, $attrs) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
  
      # Find the indentation level.
      my $indent = $$attrs{indent};
      unless (defined ($indent) && $indent =~ /^\s*[-+]?\d{1,4}\s*$/) {
          $indent = $$self{opt_indent};
      }
  
      # Add this to our stack of indents and increase our current margin.
      push (@{ $$self{INDENTS} }, $$self{MARGIN});
      $$self{MARGIN} += ($indent + 0);
      return '';
  }
  
  # End an =over block.  Takes no options other than the class pointer.  Output
  # any pending items and then pop one level of indentation.
  sub over_common_end {
      my ($self) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $$self{MARGIN} = pop @{ $$self{INDENTS} };
      return '';
  }
  
  # Dispatch the start and end calls as appropriate.
  sub start_over_bullet { $_[0]->over_common_start ($_[1]) }
  sub start_over_number { $_[0]->over_common_start ($_[1]) }
  sub start_over_text   { $_[0]->over_common_start ($_[1]) }
  sub start_over_block  { $_[0]->over_common_start ($_[1]) }
  sub end_over_bullet { $_[0]->over_common_end }
  sub end_over_number { $_[0]->over_common_end }
  sub end_over_text   { $_[0]->over_common_end }
  sub end_over_block  { $_[0]->over_common_end }
  
  # The common handler for all item commands.  Takes the type of the item, the
  # attributes, and then the text of the item.
  sub item_common {
      my ($self, $type, $attrs, $text) = @_;
      $self->item if defined $$self{ITEM};
  
      # Clean up the text.  We want to end up with two variables, one ($text)
      # which contains any body text after taking out the item portion, and
      # another ($item) which contains the actual item text.  Note the use of
      # the internal Pod::Simple attribute here; that's a potential land mine.
      $text =~ s/\s+$//;
      my ($item, $index);
      if ($type eq 'bullet') {
          $item = '*';
      } elsif ($type eq 'number') {
          $item = $$attrs{'~orig_content'};
      } else {
          $item = $text;
          $item =~ s/\s*\n\s*/ /g;
          $text = '';
      }
      $$self{ITEM} = $item;
  
      # If body text for this item was included, go ahead and output that now.
      if ($text) {
          $text =~ s/\s*$/\n/;
          $self->item ($text);
      }
      return '';
  }
  
  # Dispatch the item commands to the appropriate place.
  sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
  sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
  sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
  sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }
  
  ##############################################################################
  # Formatting codes
  ##############################################################################
  
  # The simple ones.
  sub cmd_b { return $_[0]{alt} ? "``$_[2]''" : $_[2] }
  sub cmd_f { return $_[0]{alt} ? "\"$_[2]\"" : $_[2] }
  sub cmd_i { return '*' . $_[2] . '*' }
  sub cmd_x { return '' }
  
  # Convert all internal whitespace to $NBSP.
  sub cmd_s {
      my ($self, $attrs, $text) = @_;
      $text =~ s{ \s }{$NBSP}xmsg;
      return $text;
  }
  
  # Apply a whole bunch of messy heuristics to not quote things that don't
  # benefit from being quoted.  These originally come from Barrie Slaymaker and
  # largely duplicate code in Pod::Man.
  sub cmd_c {
      my ($self, $attrs, $text) = @_;
  
      # A regex that matches the portion of a variable reference that's the
      # array or hash index, separated out just because we want to use it in
      # several places in the following regex.
      my $index = '(?: \[[^]]+\] | \{[^}]+\} )?';
  
      # Check for things that we don't want to quote, and if we find any of
      # them, return the string with just a font change and no quoting.
      #
      # Traditionally, Pod::Text has not quoted Perl variables, functions,
      # numbers, or hex constants, but this is not always desirable.  Make this
      # optional on the quoting guesswork flag.
      my $extra = qr{(?!)}xms;    # never matches
      if ($$self{GUESSWORK}{quoting}) {
          $extra = qr{
               \$+ [\#^]? \S $index            # special ($^F, $")
             | [\$\@%&*]+ \#? [:\'\w]+ $index  # plain var or func
             | [\$\@%&*]* [:\'\w]+
               (?: -> )? \(\s*[^\s,\)]*\s*\)   # 0/1-arg func call
             | [+-]? ( \d[\d.]* | \.\d+ )
               (?: [eE][+-]?\d+ )?             # a number
             | 0x [a-fA-F\d]+                  # a hex constant
           }xms;
      }
      $text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                  # already quoted
         | \` .* \'                            # `quoted'
         | $extra
        )
        \s*\z
       }xms and return $text;
  
      # If we didn't return, go ahead and quote the text.
      return $$self{opt_alt}
          ? "``$text''"
          : "$$self{LQUOTE}$text$$self{RQUOTE}";
  }
  
  # Links reduce to the text that we're given, wrapped in angle brackets if it's
  # a URL.
  sub cmd_l {
      my ($self, $attrs, $text) = @_;
      if ($$attrs{type} eq 'url') {
          if (not defined($$attrs{to}) or $$attrs{to} eq $text) {
              return "<$text>";
          } elsif ($$self{opt_nourls}) {
              return $text;
          } else {
              return "$text <$$attrs{to}>";
          }
      } else {
          return $text;
      }
  }
  
  ##############################################################################
  # Backwards compatibility
  ##############################################################################
  
  # The old Pod::Text module did everything in a pod2text() function.  This
  # tries to provide the same interface for legacy applications.
  sub pod2text {
      my @args;
  
      # This is really ugly; I hate doing option parsing in the middle of a
      # module.  But the old Pod::Text module supported passing flags to its
      # entry function, so handle -a and -<number>.
      while ($_[0] =~ /^-/) {
          my $flag = shift;
          if    ($flag eq '-a')       { push (@args, alt => 1)    }
          elsif ($flag =~ /^-(\d+)$/) { push (@args, width => $1) }
          else {
              unshift (@_, $flag);
              last;
          }
      }
  
      # Now that we know what arguments we're using, create the parser.
      my $parser = Pod::Text->new (@args);
  
      # If two arguments were given, the second argument is going to be a file
      # handle.  That means we want to call parse_from_filehandle(), which means
      # we need to turn the first argument into a file handle.  Magic open will
      # handle the <&STDIN case automagically.
      if (defined $_[1]) {
          my @fhs = @_;
          local *IN;
          unless (open (IN, $fhs[0])) {
              croak ("Can't open $fhs[0] for reading: $!\n");
              return;
          }
          $fhs[0] = \*IN;
          $parser->output_fh ($fhs[1]);
          my $retval = $parser->parse_file ($fhs[0]);
          my $fh = $parser->output_fh ();
          close $fh;
          return $retval;
      } else {
          $parser->output_fh (\*STDOUT);
          return $parser->parse_file (@_);
      }
  }
  
  # Reset the underlying Pod::Simple object between calls to parse_from_file so
  # that the same object can be reused to convert multiple pages.
  sub parse_from_file {
      my $self = shift;
      $self->reinit;
  
      # Fake the old cutting option to Pod::Parser.  This fiddles with internal
      # Pod::Simple state and is quite ugly; we need a better approach.
      if (ref ($_[0]) eq 'HASH') {
          my $opts = shift @_;
          if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
              $$self{in_pod} = 1;
              $$self{last_was_blank} = 1;
          }
      }
  
      # Do the work.
      my $retval = $self->Pod::Simple::parse_from_file (@_);
  
      # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
      # close the file descriptor if we had to open one, but we can't easily
      # figure this out.
      my $fh = $self->output_fh ();
      my $oldfh = select $fh;
      my $oldflush = $|;
      $| = 1;
      print $fh '';
      $| = $oldflush;
      select $oldfh;
      return $retval;
  }
  
  # Pod::Simple failed to provide this backward compatibility function, so
  # implement it ourselves.  File handles are one of the inputs that
  # parse_from_file supports.
  sub parse_from_filehandle {
      my $self = shift;
      $self->parse_from_file (@_);
  }
  
  # Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
  # ourself unless it was already set by the caller, since our documentation has
  # always said that this should work.
  sub parse_file {
      my ($self, $in) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_file ($in);
  }
  
  # Do the same for parse_lines, just to be polite.  Pod::Simple's man page
  # implies that the caller is responsible for setting this, but I don't see any
  # reason not to set a default.
  sub parse_lines {
      my ($self, @lines) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_lines (@lines);
  }
  
  # Likewise for parse_string_document.
  sub parse_string_document {
      my ($self, $doc) = @_;
      unless (defined $$self{output_fh}) {
          $self->output_fh (\*STDOUT);
      }
      return $self->SUPER::parse_string_document ($doc);
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  alt stderr Allbery Sean Burke's Christiansen UTF-8 pre-Unicode utf8 nourls
  parsers EBCDIC autodetecting superset unrepresentable FH NNN
  
  =head1 NAME
  
  Pod::Text - Convert POD data to formatted text
  
  =head1 SYNOPSIS
  
      use Pod::Text;
      my $parser = Pod::Text->new (sentence => 1, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text is a module that can convert documentation in the POD format (the
  preferred language for documenting Perl) into formatted text.  It uses no
  special formatting controls or codes, and its output is therefore suitable for
  nearly any device.
  
  =head2 Encoding
  
  Pod::Text uses the following logic to choose an output encoding, in order:
  
  =over 4
  
  =item 1.
  
  If a PerlIO encoding layer is set on the output file handle, do not do any
  output encoding and will instead rely on the PerlIO encoding layer.
  
  =item 2.
  
  If the C<encoding> or C<utf8> options are set, use the output encoding
  specified by those options.
  
  =item 3.
  
  If the input encoding of the POD source file was explicitly specified (using
  C<=encoding>) or automatically detected by Pod::Simple, use that as the output
  encoding as well.
  
  =item 4.
  
  Otherwise, if running on a non-EBCDIC system, use UTF-8 as the output
  encoding.  Since this is a superset of ASCII, this will result in ASCII output
  unless the POD input contains non-ASCII characters without declaring or
  autodetecting an encoding (usually via EZ<><> escapes).
  
  =item 5.
  
  Otherwise, for EBCDIC systems, output without doing any encoding and hope
  this works.
  
  =back
  
  One caveat: Pod::Text has to commit to an output encoding the first time it
  outputs a non-ASCII character, and then has to stick with it for consistency.
  However, C<=encoding> commands don't have to be at the beginning of a POD
  document.  If someone uses a non-ASCII character early in a document with an
  escape, such as EZ<><0xEF>, and then puts C<=encoding iso-8859-1> later,
  ideally Pod::Text would follow rule 3 and output the entire document as ISO
  8859-1.  Instead, it will commit to UTF-8 following rule 4 as soon as it sees
  that escape, and then stick with that encoding for the rest of the document.
  
  Unfortunately, there's no universally good choice for an output encoding.
  Each choice will be incorrect in some circumstances.  This approach was chosen
  primarily for backwards compatibility.  Callers should consider forcing the
  output encoding via C<encoding> if they have any knowledge about what encoding
  the user may expect.
  
  In particular, consider importing the L<Encode::Locale> module, if available,
  and setting C<encoding> to C<locale> to use an output encoding appropriate to
  the user's locale.  But be aware that if the user is not using locales or is
  using a locale of C<C>, Encode::Locale will set the output encoding to
  US-ASCII.  This will cause all non-ASCII characters will be replaced with C<?>
  and produce a flurry of warnings about unsupported characters, which may or
  may not be what you want.
  
  =head1 CLASS METHODS
  
  =over 4
  
  =item new(ARGS)
  
  Create a new Pod::Text object.  ARGS should be a list of key/value pairs,
  where the keys are chosen from the following.  Each option is annotated with
  the version of Pod::Text in which that option was added with its current
  meaning.
  
  =over 4
  
  =item alt
  
  [2.00] If set to a true value, selects an alternate output format that, among
  other things, uses a different heading style and marks C<=item> entries with a
  colon in the left margin.  Defaults to false.
  
  =item code
  
  [2.13] If set to a true value, the non-POD parts of the input file will be
  included in the output.  Useful for viewing code documented with POD blocks
  with the POD rendered and the code left intact.
  
  =item encoding
  
  [5.00] Specifies the encoding of the output.  The value must be an encoding
  recognized by the L<Encode> module (see L<Encode::Supported>).  If the output
  contains characters that cannot be represented in this encoding, that is an
  error that will be reported as configured by the C<errors> option.  If error
  handling is other than C<die>, the unrepresentable character will be replaced
  with the Encode substitution character (normally C<?>).
  
  If the output file handle has a PerlIO encoding layer set, this parameter will
  be ignored and no encoding will be done by Pod::Man.  It will instead rely on
  the encoding layer to make whatever output encoding transformations are
  desired.
  
  WARNING: The input encoding of the POD source is independent from the output
  encoding, and setting this option does not affect the interpretation of the
  POD input.  Unless your POD source is US-ASCII, its encoding should be
  declared with the C<=encoding> command in the source, as near to the top of
  the file as possible.  If this is not done, Pod::Simple will will attempt to
  guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will
  produce warnings.  See L<perlpod(1)> for more information.
  
  =item errors
  
  [3.17] How to report errors.  C<die> says to throw an exception on any POD
  formatting error.  C<stderr> says to report errors on standard error, but not
  to throw an exception.  C<pod> says to include a POD ERRORS section in the
  resulting documentation summarizing the errors.  C<none> ignores POD errors
  entirely, as much as possible.
  
  The default is C<pod>.
  
  =item guesswork
  
  [5.01] By default, Pod::Text applies some default formatting rules based on
  guesswork and regular expressions that are intended to make writing Perl
  documentation easier and require less explicit markup.  These rules may not
  always be appropriate, particularly for documentation that isn't about Perl.
  This option allows turning all or some of it off.
  
  The special value C<all> enables all guesswork.  This is also the default for
  backward compatibility reasons.  The special value C<none> disables all
  guesswork.  Otherwise, the value of this option should be a comma-separated
  list of one or more of the following keywords:
  
  =over 4
  
  =item quoting
  
  If no guesswork is enabled, any text enclosed in CZ<><> is surrounded by
  double quotes in nroff (terminal) output unless the contents are already
  quoted.  When this guesswork is enabled, quote marks will also be suppressed
  for Perl variables, function names, function calls, numbers, and hex
  constants.
  
  =back
  
  Any unknown guesswork name is silently ignored (for potential future
  compatibility), so be careful about spelling.
  
  =item indent
  
  [2.00] The number of spaces to indent regular text, and the default
  indentation for C<=over> blocks.  Defaults to 4.
  
  =item loose
  
  [2.00] If set to a true value, a blank line is printed after a C<=head1>
  heading.  If set to false (the default), no blank line is printed after
  C<=head1>, although one is still printed after C<=head2>.  This is the default
  because it's the expected formatting for manual pages; if you're formatting
  arbitrary text documents, setting this to true may result in more pleasing
  output.
  
  =item margin
  
  [2.21] The width of the left margin in spaces.  Defaults to 0.  This is the
  margin for all text, including headings, not the amount by which regular text
  is indented; for the latter, see the I<indent> option.  To set the right
  margin, see the I<width> option.
  
  =item nourls
  
  [3.17] Normally, LZ<><> formatting codes with a URL but anchor text are
  formatted to show both the anchor text and the URL.  In other words:
  
      L<foo|http://example.com/>
  
  is formatted as:
  
      foo <http://example.com/>
  
  This option, if set to a true value, suppresses the URL when anchor text is
  given, so this example would be formatted as just C<foo>.  This can produce
  less cluttered output in cases where the URLs are not particularly important.
  
  =item quotes
  
  [4.00] Sets the quote marks used to surround CE<lt>> text.  If the value is a
  single character, it is used as both the left and right quote.  Otherwise, it
  is split in half, and the first half of the string is used as the left quote
  and the second is used as the right quote.
  
  This may also be set to the special value C<none>, in which case no quote
  marks are added around CE<lt>> text.
  
  =item sentence
  
  [3.00] If set to a true value, Pod::Text will assume that each sentence ends
  in two spaces, and will try to preserve that spacing.  If set to false, all
  consecutive whitespace in non-verbatim paragraphs is compressed into a single
  space.  Defaults to false.
  
  =item stderr
  
  [3.10] Send error messages about invalid POD to standard error instead of
  appending a POD ERRORS section to the generated output.  This is equivalent to
  setting C<errors> to C<stderr> if C<errors> is not already set.  It is
  supported for backward compatibility.
  
  =item utf8
  
  [3.12] If this option is set to a true value, the output encoding is set to
  UTF-8.  This is equivalent to setting C<encoding> to C<UTF-8> if C<encoding>
  is not already set.  It is supported for backward compatibility.
  
  =item width
  
  [2.00] The column at which to wrap text on the right-hand side.  Defaults to
  76.
  
  =back
  
  =back
  
  =head1 INSTANCE METHODS
  
  As a derived class from Pod::Simple, Pod::Text supports the same methods and
  interfaces.  See L<Pod::Simple> for all the details.  This section summarizes
  the most-frequently-used methods and the ones added by Pod::Text.
  
  =over 4
  
  =item output_fh(FH)
  
  Direct the output from parse_file(), parse_lines(), or parse_string_document()
  to the file handle FH instead of C<STDOUT>.
  
  =item output_string(REF)
  
  Direct the output from parse_file(), parse_lines(), or parse_string_document()
  to the scalar variable pointed to by REF, rather than C<STDOUT>.  For example:
  
      my $man = Pod::Man->new();
      my $output;
      $man->output_string(\$output);
      $man->parse_file('/some/input/file');
  
  Be aware that the output in that variable will already be encoded (see
  L</Encoding>).
  
  =item parse_file(PATH)
  
  Read the POD source from PATH and format it.  By default, the output is sent
  to C<STDOUT>, but this can be changed with the output_fh() or output_string()
  methods.
  
  =item parse_from_file(INPUT, OUTPUT)
  
  =item parse_from_filehandle(FH, OUTPUT)
  
  Read the POD source from INPUT, format it, and output the results to OUTPUT.
  
  parse_from_filehandle() is provided for backward compatibility with older
  versions of Pod::Man.  parse_from_file() should be used instead.
  
  =item parse_lines(LINES[, ...[, undef]])
  
  Parse the provided lines as POD source, writing the output to either C<STDOUT>
  or the file handle set with the output_fh() or output_string() methods.  This
  method can be called repeatedly to provide more input lines.  An explicit
  C<undef> should be passed to indicate the end of input.
  
  This method expects raw bytes, not decoded characters.
  
  =item parse_string_document(INPUT)
  
  Parse the provided scalar variable as POD source, writing the output to either
  C<STDOUT> or the file handle set with the output_fh() or output_string()
  methods.
  
  This method expects raw bytes, not decoded characters.
  
  =back
  
  =head1 FUNCTIONS
  
  Pod::Text exports one function for backward compatibility with older versions.
  This function is deprecated; instead, use the object-oriented interface
  described above.
  
  =over 4
  
  =item pod2text([[-a,] [-NNN,]] INPUT[, OUTPUT])
  
  Convert the POD source from INPUT to text and write it to OUTPUT.  If OUTPUT
  is not given, defaults to C<STDOUT>.  INPUT can be any expression supported as
  the second argument to two-argument open().
  
  If C<-a> is given as an initial argument, pass the C<alt> option to the
  Pod::Text constructor.  This enables alternative formatting.
  
  If C<-NNN> is given as an initial argument, pass the C<width> option to the
  Pod::Text constructor with the number C<NNN> as its argument.  This sets the
  wrap line width to NNN.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bizarre space in item
  
  =item Item called without tag
  
  (W) Something has gone wrong in internal C<=item> processing.  These
  messages indicate a bug in Pod::Text; you should never see them.
  
  =item Can't open %s for reading: %s
  
  (F) Pod::Text was invoked via the compatibility mode pod2text() interface
  and the input file it was given could not be opened.
  
  =item Invalid errors setting "%s"
  
  (F) The C<errors> parameter to the constructor was set to an unknown value.
  
  =item Invalid quote specification "%s"
  
  (F) The quote specification given (the C<quotes> option to the
  constructor) was invalid.  A quote specification must be either one
  character long or an even number (greater than one) characters long.
  
  =item POD document had syntax errors
  
  (F) The POD document being formatted had syntax errors and the C<errors>
  option was set to C<die>.
  
  =back
  
  =head1 COMPATIBILITY
  
  Pod::Text 2.03 (based on L<Pod::Parser>) was the first version of this module
  included with Perl, in Perl 5.6.0.  Earlier versions of Perl had a different
  Pod::Text module, with a different API.
  
  The current API based on L<Pod::Simple> was added in Pod::Text 3.00.
  Pod::Text 3.01 was included in Perl 5.9.3, the first version of Perl to
  incorporate those changes.  This is the first version that correctly supports
  all modern POD syntax.  The parse_from_filehandle() method was re-added for
  backward compatibility in Pod::Text 3.07, included in Perl 5.9.4.
  
  Pod::Text 3.12, included in Perl 5.10.1, first implemented the current
  practice of attempting to match the default output encoding with the input
  encoding of the POD source, unless overridden by the C<utf8> option or (added
  later) the C<encoding> option.
  
  Support for anchor text in LZ<><> links of type URL was added in Pod::Text
  3.14, included in Perl 5.11.5.
  
  parse_lines(), parse_string_document(), and parse_file() set a default output
  file handle of C<STDOUT> if one was not already set as of Pod::Text 3.18,
  included in Perl 5.19.5.
  
  Pod::Text 4.00, included in Perl 5.23.7, aligned the module version and the
  version of the podlators distribution.  All modules included in podlators, and
  the podlators distribution itself, share the same version number from this
  point forward.
  
  Pod::Text 4.09, included in Perl 5.25.7, fixed a serious bug on EBCDIC
  systems, present in all versions back to 3.00, that would cause opening
  brackets to disappear.
  
  Pod::Text 5.00 now defaults, on non-EBCDIC systems, to UTF-8 encoding if it
  sees a non-ASCII character in the input and the input encoding is not
  specified.  It also commits to an encoding with the first non-ASCII character
  and does not change the output encoding if the input encoding changes.  The
  L<Encode> module is now used for all output encoding rather than PerlIO
  layers, which fixes earlier problems with output to scalars.
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>, based I<very> heavily on the original Pod::Text
  by Tom Christiansen <tchrist@mox.perl.com> and its conversion to Pod::Parser
  by Brad Appleton <bradapp@enteract.com>.  Sean Burke's initial conversion of
  Pod::Man to use Pod::Simple provided much-needed guidance on how to use
  Pod::Simple.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999-2002, 2004, 2006, 2008-2009, 2012-2016, 2018-2019, 2022 Russ
  Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Encode::Locale>, L<Encode::Supproted>, L<Pod::Simple>,
  L<Pod::Text::Termcap>, L<perlpod(1)>, L<pod2text(1)>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  # Convert POD data to formatted color ASCII text
  #
  # This is just a basic proof of concept.  It should later be modified to make
  # better use of color, take options changing what colors are used for what
  # text, and the like.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Color;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Pod::Text ();
  use Term::ANSIColor qw(color colored);
  
  our @ISA = qw(Pod::Text);
  our $VERSION = '5.01';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # Make level one headings bold.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      local $Term::ANSIColor::EACHLINE = "\n";
      $self->SUPER::cmd_head1 ($attrs, colored ($text, 'bold'));
  }
  
  # Make level two headings bold.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head2 ($attrs, colored ($text, 'bold'));
  }
  
  # Fix the various formatting codes.
  sub cmd_b { return colored ($_[2], 'bold')   }
  sub cmd_f { return colored ($_[2], 'cyan')   }
  sub cmd_i { return colored ($_[2], 'yellow') }
  
  # Analyze a single line and return any formatting codes in effect at the end
  # of that line.
  sub end_format {
      my ($self, $line) = @_;
      my $reset = color ('reset');
      my $current;
      while ($line =~ /(\e\[[\d;]+m)/g) {
          my $code = $1;
          if ($code eq $reset) {
              undef $current;
          } else {
              $current .= $code;
          }
      }
      return $current;
  }
  
  # Output any included code in green.
  sub output_code {
      my ($self, $code) = @_;
      local $Term::ANSIColor::EACHLINE = "\n";
      $code = colored ($code, 'green');
      $self->output ($code);
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.  We will eventually want to use colorstrip() from Term::ANSIColor,
  # but it's fairly new so avoid the tight dependency.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/\e\[[\d;]*m//g;
      return $text;
  }
  
  # We unfortunately have to override the wrapping code here, since the normal
  # wrapping code gets really confused by all the escape sequences.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
  
      # $codes matches a single special sequence.  $char matches any number of
      # special sequences preceding a single character other than a newline.
      # $shortchar matches some sequence of $char ending in codes followed by
      # whitespace or the end of the string.  $longchar matches exactly $width
      # $chars, used when we have to truncate and hard wrap.
      my $code = '(?:\e\[[\d;]+m)';
      my $char = "(?>$code*[^\\n])";
      my $shortchar = '^(' . $char . "{0,$width}(?>$code*)" . ')(?:\s+|\z)';
      my $longchar = '^(' . $char . "{$width})";
      while (length > $width) {
          if (s/$shortchar// || s/$longchar//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
  
      # less -R always resets terminal attributes at the end of each line, so we
      # need to clear attributes at the end of lines and then set them again at
      # the start of the next line.  This requires a second pass through the
      # wrapped string, accumulating any attributes we see, remembering them,
      # and then inserting the appropriate sequences at the newline.
      if ($output =~ /\n/) {
          my @lines = split (/\n/, $output);
          my $start_format;
          for my $line (@lines) {
              if ($start_format && $line =~ /\S/) {
                  $line =~ s/^(\s*)(\S)/$1$start_format$2/;
              }
              $start_format = $self->end_format ($line);
              if ($start_format) {
                  $line .= color ('reset');
              }
          }
          $output = join ("\n", @lines);
      }
  
      # Fix up trailing whitespace and return the results.
      $output =~ s/\s+$/\n\n/;
      $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  Allbery
  
  =head1 NAME
  
  Pod::Text::Color - Convert POD data to formatted color ASCII text
  
  =head1 SYNOPSIS
  
      use Pod::Text::Color;
      my $parser = Pod::Text::Color->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Color is a simple subclass of Pod::Text that highlights output
  text using ANSI color escape sequences.  Apart from the color, it in all
  ways functions like Pod::Text.  See L<Pod::Text> for details and available
  options.
  
  Term::ANSIColor is used to get colors and therefore must be installed to use
  this module.
  
  =head1 COMPATIBILITY
  
  Pod::Text::Color 0.05 (based on L<Pod::Parser>) was the first version of this
  module included with Perl, in Perl 5.6.0.
  
  The current API based on L<Pod::Simple> was added in Pod::Text::Color 2.00.
  Pod::Text::Color 2.01 was included in Perl 5.9.3, the first version of Perl to
  incorporate those changes.
  
  Several problems with wrapping and line length were fixed as recently as
  Pod::Text::Color 4.11, included in Perl 5.29.1.
  
  This module inherits its API and most behavior from Pod::Text, so the details
  in L<Pod::Text/COMPATIBILITY> also apply.  Pod::Text and Pod::Text::Color have
  had the same module version since 4.00, included in Perl 5.23.7.  (They
  unfortunately diverge in confusing ways prior to that.)
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2001, 2004, 2006, 2008, 2009, 2018-2019, 2022 Russ Allbery
  <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  # Convert POD data to formatted overstrike text
  #
  # This was written because the output from:
  #
  #     pod2text Text.pm > plain.txt; less plain.txt
  #
  # is not as rich as the output from
  #
  #     pod2man Text.pm | nroff -man > fancy.txt; less fancy.txt
  #
  # and because both Pod::Text::Color and Pod::Text::Termcap are not device
  # independent.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Overstrike;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Pod::Text ();
  
  our @ISA = qw(Pod::Text);
  our $VERSION = '5.01';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # Make level one headings bold, overriding any existing formatting.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/$1\b$1/g;
      return $self->SUPER::cmd_head1 ($attrs, $text);
  }
  
  # Make level two headings bold, overriding any existing formatting.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/$1\b$1/g;
      return $self->SUPER::cmd_head2 ($attrs, $text);
  }
  
  # Make level three headings underscored, overriding any existing formatting.
  sub cmd_head3 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/_\b$1/g;
      return $self->SUPER::cmd_head3 ($attrs, $text);
  }
  
  # Level four headings look like level three headings.
  sub cmd_head4 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $text = $self->strip_format ($text);
      $text =~ s/(.)/_\b$1/g;
      return $self->SUPER::cmd_head4 ($attrs, $text);
  }
  
  # The common code for handling all headers.  We have to override to avoid
  # interpolating twice and because we don't want to honor alt.
  sub heading {
      my ($self, $text, $indent, $marker) = @_;
      $self->item ("\n\n") if defined $$self{ITEM};
      $text .= "\n" if $$self{opt_loose};
      my $margin = ' ' x ($$self{opt_margin} + $indent);
      $self->output ($margin . $text . "\n");
      return '';
  }
  
  # Fix the various formatting codes.
  sub cmd_b { local $_ = $_[0]->strip_format ($_[2]); s/(.)/$1\b$1/g; $_ }
  sub cmd_f { local $_ = $_[0]->strip_format ($_[2]); s/(.)/_\b$1/g; $_ }
  sub cmd_i { local $_ = $_[0]->strip_format ($_[2]); s/(.)/_\b$1/g; $_ }
  
  # Output any included code in bold.
  sub output_code {
      my ($self, $code) = @_;
      $code =~ s/(.)/$1\b$1/g;
      $self->output ($code);
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/(.)[\b]\1/$1/g;
      $text =~ s/_[\b]//g;
      return $text;
  }
  
  # We unfortunately have to override the wrapping code here, since the normal
  # wrapping code gets really confused by all the backspaces.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
      while (length > $width) {
          # This regex represents a single character, that's possibly underlined
          # or in bold (in which case, it's three characters; the character, a
          # backspace, and a character).  Use [^\n] rather than . to protect
          # against odd settings of $*.
          my $char = '(?:[^\n][\b])?[^\n]';
          if (s/^((?>$char){0,$width})(?:\Z|\s+)//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  overstrike overstruck Overstruck Allbery terminal's
  
  =head1 NAME
  
  Pod::Text::Overstrike - Convert POD data to formatted overstrike text
  
  =head1 SYNOPSIS
  
      use Pod::Text::Overstrike;
      my $parser = Pod::Text::Overstrike->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights
  output text using overstrike sequences, in a manner similar to nroff.
  Characters in bold text are overstruck (character, backspace, character)
  and characters in underlined text are converted to overstruck underscores
  (underscore, backspace, character).  This format was originally designed
  for hard-copy terminals and/or line printers, yet is readable on soft-copy
  (CRT) terminals.
  
  Overstruck text is best viewed by page-at-a-time programs that take
  advantage of the terminal's B<stand-out> and I<underline> capabilities, such
  as the less program on Unix.
  
  Apart from the overstrike, it in all ways functions like Pod::Text.  See
  L<Pod::Text> for details and available options.
  
  =head1 BUGS
  
  Currently, the outermost formatting instruction wins, so for example
  underlined text inside a region of bold text is displayed as simply bold.
  There may be some better approach possible.
  
  =head1 COMPATIBILITY
  
  Pod::Text::Overstrike 1.01 (based on L<Pod::Parser>) was the first version of
  this module included with Perl, in Perl 5.6.1.
  
  The current API based on L<Pod::Simple> was added in Pod::Text::Overstrike
  2.00, included in Perl 5.9.3.
  
  Several problems with wrapping and line length were fixed as recently as
  Pod::Text::Overstrike 2.04, included in Perl 5.11.5.
  
  This module inherits its API and most behavior from Pod::Text, so the details
  in L<Pod::Text/COMPATIBILITY> also apply.  Pod::Text and Pod::Text::Overstrike
  have had the same module version since 4.00, included in Perl 5.23.7.  (They
  unfortunately diverge in confusing ways prior to that.)
  
  =head1 AUTHOR
  
  Originally written by Joe Smith <Joe.Smith@inwap.com>, using the framework
  created by Russ Allbery <rra@cpan.org>.  Subsequently updated by Russ Allbery.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2000 by Joe Smith <Joe.Smith@inwap.com>
  
  Copyright 2001, 2004, 2008, 2014, 2018-2019, 2022 by Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  # Convert POD data to ASCII text with format escapes.
  #
  # This is a simple subclass of Pod::Text that overrides a few key methods to
  # output the right termcap escape sequences for formatted text on the current
  # terminal type.
  #
  # SPDX-License-Identifier: GPL-1.0-or-later OR Artistic-1.0-Perl
  
  ##############################################################################
  # Modules and declarations
  ##############################################################################
  
  package Pod::Text::Termcap;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Pod::Text ();
  use POSIX ();
  use Term::Cap;
  
  our @ISA = qw(Pod::Text);
  our $VERSION = '5.01';
  
  ##############################################################################
  # Overrides
  ##############################################################################
  
  # In the initialization method, grab our terminal characteristics as well as
  # do all the stuff we normally do.
  sub new {
      my ($self, %args) = @_;
      my ($ospeed, $term, $termios);
  
      # Fall back on a hard-coded terminal speed if POSIX::Termios isn't
      # available (such as on VMS).
      eval { $termios = POSIX::Termios->new };
      if ($@) {
          $ospeed = 9600;
      } else {
          $termios->getattr;
          $ospeed = $termios->getospeed || 9600;
      }
  
      # Get data from Term::Cap if possible.
      my ($bold, $undl, $norm, $width);
      eval {
          my $term = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
          $bold = $term->Tputs('md');
          $undl = $term->Tputs('us');
          $norm = $term->Tputs('me');
          if (defined $$term{_co}) {
              $width = $$term{_co};
              $width =~ s/^\#//;
          }
      };
  
      # Figure out the terminal width before calling the Pod::Text constructor,
      # since it will otherwise force 76 characters.  Pod::Text::Termcap has
      # historically used 2 characters less than the width of the screen, while
      # the other Pod::Text classes have used 76.  This is weirdly inconsistent,
      # but there's probably no good reason to change it now.
      unless (defined $args{width}) {
          $args{width} = $ENV{COLUMNS} || $width || 80;
          $args{width} -= 2;
      }
  
      # Initialize Pod::Text.
      $self = $self->SUPER::new (%args);
  
      # If we were unable to get any of the formatting sequences, don't attempt
      # that type of formatting.  This will do weird things if bold or underline
      # were available but normal wasn't, but hopefully that will never happen.
      $$self{BOLD} = $bold || q{};
      $$self{UNDL} = $undl || q{};
      $$self{NORM} = $norm || q{};
  
      return $self;
  }
  
  # Make level one headings bold.
  sub cmd_head1 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head1 ($attrs, "$$self{BOLD}$text$$self{NORM}");
  }
  
  # Make level two headings bold.
  sub cmd_head2 {
      my ($self, $attrs, $text) = @_;
      $text =~ s/\s+$//;
      $self->SUPER::cmd_head2 ($attrs, "$$self{BOLD}$text$$self{NORM}");
  }
  
  # Fix up B<> and I<>.  Note that we intentionally don't do F<>.
  sub cmd_b { my $self = shift; return "$$self{BOLD}$_[1]$$self{NORM}" }
  sub cmd_i { my $self = shift; return "$$self{UNDL}$_[1]$$self{NORM}" }
  
  # Return a regex that matches a formatting sequence.  This will only be valid
  # if we were able to get at least some termcap information.
  sub format_regex {
      my ($self) = @_;
      my @codes = ($self->{BOLD}, $self->{UNDL}, $self->{NORM});
      return join(q{|}, map { $_ eq q{} ? () : "\Q$_\E" } @codes);
  }
  
  # Analyze a single line and return any formatting codes in effect at the end
  # of that line.
  sub end_format {
      my ($self, $line) = @_;
      my $pattern = "(" . $self->format_regex() . ")";
      my $current;
      while ($line =~ /$pattern/g) {
          my $code = $1;
          if ($code eq $$self{NORM}) {
              undef $current;
          } else {
              $current .= $code;
          }
      }
      return $current;
  }
  
  # Output any included code in bold.
  sub output_code {
      my ($self, $code) = @_;
      $self->output ($$self{BOLD} . $code . $$self{NORM});
  }
  
  # Strip all of the formatting from a provided string, returning the stripped
  # version.
  sub strip_format {
      my ($self, $text) = @_;
      $text =~ s/\Q$$self{BOLD}//g;
      $text =~ s/\Q$$self{UNDL}//g;
      $text =~ s/\Q$$self{NORM}//g;
      return $text;
  }
  
  # Override the wrapping code to ignore the special sequences.
  sub wrap {
      my $self = shift;
      local $_ = shift;
      my $output = '';
      my $spaces = ' ' x $$self{MARGIN};
      my $width = $$self{opt_width} - $$self{MARGIN};
  
      # If we were unable to find any termcap sequences, use Pod::Text wrapping.
      if ($self->{BOLD} eq q{} && $self->{UNDL} eq q{} && $self->{NORM} eq q{}) {
          return $self->SUPER::wrap($_);
      }
  
      # $code matches a single special sequence.  $char matches any number of
      # special sequences preceding a single character other than a newline.
      # $shortchar matches some sequence of $char ending in codes followed by
      # whitespace or the end of the string.  $longchar matches exactly $width
      # $chars, used when we have to truncate and hard wrap.
      my $code = "(?:" . $self->format_regex() . ")";
      my $char = "(?>$code*[^\\n])";
      my $shortchar = '^(' . $char . "{0,$width}(?>$code*)" . ')(?:\s+|\z)';
      my $longchar = '^(' . $char . "{$width})";
      while (length > $width) {
          if (s/$shortchar// || s/$longchar//) {
              $output .= $spaces . $1 . "\n";
          } else {
              last;
          }
      }
      $output .= $spaces . $_;
  
      # less -R always resets terminal attributes at the end of each line, so we
      # need to clear attributes at the end of lines and then set them again at
      # the start of the next line.  This requires a second pass through the
      # wrapped string, accumulating any attributes we see, remembering them,
      # and then inserting the appropriate sequences at the newline.
      if ($output =~ /\n/) {
          my @lines = split (/\n/, $output);
          my $start_format;
          for my $line (@lines) {
              if ($start_format && $line =~ /\S/) {
                  $line =~ s/^(\s*)(\S)/$1$start_format$2/;
              }
              $start_format = $self->end_format ($line);
              if ($start_format) {
                  $line .= $$self{NORM};
              }
          }
          $output = join ("\n", @lines);
      }
  
      # Fix up trailing whitespace and return the results.
      $output =~ s/\s+$/\n\n/;
      return $output;
  }
  
  ##############################################################################
  # Module return value and documentation
  ##############################################################################
  
  1;
  __END__
  
  =for stopwords
  ECMA-48 VT100 Allbery Solaris TERMPATH unformatted
  
  =head1 NAME
  
  Pod::Text::Termcap - Convert POD data to ASCII text with format escapes
  
  =head1 SYNOPSIS
  
      use Pod::Text::Termcap;
      my $parser = Pod::Text::Termcap->new (sentence => 0, width => 78);
  
      # Read POD from STDIN and write to STDOUT.
      $parser->parse_from_filehandle;
  
      # Read POD from file.pod and write to file.txt.
      $parser->parse_from_file ('file.pod', 'file.txt');
  
  =head1 DESCRIPTION
  
  Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output
  text using the correct termcap escape sequences for the current terminal.
  Apart from the format codes, it in all ways functions like Pod::Text.  See
  L<Pod::Text> for details and available options.
  
  This module uses L<Term::Cap> to find the correct terminal settings.  See the
  documentation of that module for how it finds terminal database information
  and how to override that behavior if necessary.  If unable to find control
  strings for bold and underscore formatting, that formatting is skipped,
  resulting in the same output as Pod::Text.
  
  =head1 COMPATIBILITY
  
  Pod::Text::Termcap 0.04 (based on L<Pod::Parser>) was the first version of
  this module included with Perl, in Perl 5.6.0.
  
  The current API based on L<Pod::Simple> was added in Pod::Text::Termcap 2.00.
  Pod::Text::Termcap 2.01 was included in Perl 5.9.3, the first version of Perl
  to incorporate those changes.
  
  Several problems with wrapping and line length were fixed as recently as
  Pod::Text::Termcap 4.11, included in Perl 5.29.1.
  
  Pod::Text::Termcap 4.13 stopped setting the TERMPATH environment variable
  during module load.  It also stopped falling back on VT100 escape sequences if
  Term::Cap was not able to find usable escape sequences, instead producing
  unformatted output for better results on dumb terminals.  The next version to
  be incorporated into Perl, 4.14, was included in Perl 5.31.8.
  
  This module inherits its API and most behavior from Pod::Text, so the details
  in L<Pod::Text/COMPATIBILITY> also apply.  Pod::Text and Pod::Text::Termcap
  have had the same module version since 4.00, included in Perl 5.23.7.  (They
  unfortunately diverge in confusing ways prior to that.)
  
  =head1 AUTHOR
  
  Russ Allbery <rra@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1999, 2001-2002, 2004, 2006, 2008-2009, 2014-2015, 2018-2019, 2022
  Russ Allbery <rra@cpan.org>
  
  This program is free software; you may redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Pod::Text>, L<Pod::Simple>, L<Term::Cap>
  
  The current version of this module is always available from its web site at
  L<https://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
  Perl core distribution as of 5.6.0.
  
  =cut
  
  # Local Variables:
  # copyright-at-end-flag: t
  # End:
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  #############################################################################
  # Pod/Usage.pm -- print usage messages for the running script.
  #
  # Copyright (c) 1996-2000 by Bradford Appleton. All rights reserved.
  # Copyright (c) 2001-2016 by Marek Rouchal.
  # This file is part of "Pod-Usage". Pod-Usage is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Usage;
  
  use strict;
  require  5.006;    ## requires this Perl version or later
  
  use Carp;
  use Config;
  use Exporter;
  use File::Spec;
  
  our $VERSION = '2.03';
  
  our @EXPORT = qw(&pod2usage);
  our @ISA;
  BEGIN {
      $Pod::Usage::Formatter ||= 'Pod::Text';
      eval "require $Pod::Usage::Formatter";
      die $@ if $@;
      @ISA = ( $Pod::Usage::Formatter );
  }
  
  our $MAX_HEADING_LEVEL = 3;
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------
  ## Function definitions begin here
  ##---------------------------------
  
  sub pod2usage {
      local($_) = shift;
      my %opts;
      ## Collect arguments
      if (@_ > 0) {
          ## Too many arguments - assume that this is a hash and
          ## the user forgot to pass a reference to it.
          %opts = ($_, @_);
      }
      elsif (!defined $_) {
        $_ = '';
      }
      elsif (ref $_) {
          ## User passed a ref to a hash
          %opts = %{$_}  if (ref($_) eq 'HASH');
      }
      elsif (/^[-+]?\d+$/) {
          ## User passed in the exit value to use
          $opts{'-exitval'} =  $_;
      }
      else {
          ## User passed in a message to print before issuing usage.
          $_  and  $opts{'-message'} = $_;
      }
  
      ## Need this for backward compatibility since we formerly used
      ## options that were all uppercase words rather than ones that
      ## looked like Unix command-line options.
      ## to be uppercase keywords)
      %opts = map {
          my ($key, $val) = ($_, $opts{$_});
          $key =~ s/^(?=\w)/-/;
          $key =~ /^-msg/i   and  $key = '-message';
          $key =~ /^-exit/i  and  $key = '-exitval';
          lc($key) => $val;
      } (keys %opts);
  
      ## Now determine default -exitval and -verbose values to use
      if ((! defined $opts{'-exitval'}) && (! defined $opts{'-verbose'})) {
          $opts{'-exitval'} = 2;
          $opts{'-verbose'} = 0;
      }
      elsif (! defined $opts{'-exitval'}) {
          $opts{'-exitval'} = ($opts{'-verbose'} > 0) ? 1 : 2;
      }
      elsif (! defined $opts{'-verbose'}) {
          $opts{'-verbose'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                               $opts{'-exitval'} < 2);
      }
  
      ## Default the output file
      $opts{'-output'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                          $opts{'-exitval'} < 2) ? \*STDOUT : \*STDERR
              unless (defined $opts{'-output'});
      ## Default the input file
      $opts{'-input'} = $0  unless (defined $opts{'-input'});
  
      ## Look up input file in path if it doesn't exist.
      unless ((ref $opts{'-input'}) || (-e $opts{'-input'})) {
          my $basename = $opts{'-input'};
          my $pathsep = ($^O =~ /^(?:dos|os2|MSWin32)$/i) ? ';'
                              : (($^O eq 'MacOS' || $^O eq 'VMS') ? ',' :  ':');
          my $pathspec = $opts{'-pathlist'} || $ENV{PATH} || $ENV{PERL5LIB};
  
          my @paths = (ref $pathspec) ? @$pathspec : split($pathsep, $pathspec);
          for my $dirname (@paths) {
              $_ = length($dirname) ? File::Spec->catfile($dirname, $basename) : $basename;
              last if (-e $_) && ($opts{'-input'} = $_);
          }
      }
  
      ## Now create a pod reader and constrain it to the desired sections.
      my $parser = Pod::Usage->new(USAGE_OPTIONS => \%opts);
      if ($opts{'-verbose'} == 0) {
          $parser->select('(?:SYNOPSIS|USAGE)\s*');
      }
      elsif ($opts{'-verbose'} == 1) {
          my $opt_re = '(?i)' .
                       '(?:OPTIONS|ARGUMENTS)' .
                       '(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';
          $parser->select( '(?:SYNOPSIS|USAGE)\s*', $opt_re, "DESCRIPTION/$opt_re" );
      }
      elsif ($opts{'-verbose'} >= 2 && $opts{'-verbose'} != 99) {
          $parser->select('.*');
      }
      elsif ($opts{'-verbose'} == 99) {
          my $sections = $opts{'-sections'};
          $parser->select( (ref $sections) ? @$sections : $sections );
          $opts{'-verbose'} = 1;
      }
  
      ## Check for perldoc
      my $progpath = $opts{'-perldoc'} ? $opts{'-perldoc'} :
          File::Spec->catfile($Config{scriptdirexp} || $Config{scriptdir},
              'perldoc');
  
      my $version = sprintf("%vd",$^V);
      if ($Config{versiononly} and $Config{startperl} =~ /\Q$version\E$/ ) {
        $progpath .= $version;
      }
      $opts{'-noperldoc'} = 1 unless -e $progpath;
  
      ## Now translate the pod document and then exit with the desired status
      if (      !$opts{'-noperldoc'}
           and  $opts{'-verbose'} >= 2
           and  !ref($opts{'-input'})
           and  $opts{'-output'} == \*STDOUT )
      {
         ## spit out the entire PODs. Might as well invoke perldoc
         print { $opts{'-output'} } ($opts{'-message'}, "\n") if($opts{'-message'});
         if(defined $opts{-input} && $opts{-input} =~ /^\s*(\S.*?)\s*$/) {
           # the perldocs back to 5.005 should all have -F
  	 # without -F there are warnings in -T scripts
  	 my $f = $1;
           my @perldoc_cmd = ($progpath);
  	 if ($opts{'-perldocopt'}) {
             $opts{'-perldocopt'} =~ s/^\s+|\s+$//g;
  	   push @perldoc_cmd, split(/\s+/, $opts{'-perldocopt'});
  	 }
  	 push @perldoc_cmd, ('-F', $f);
           unshift @perldoc_cmd, $opts{'-perlcmd'} if $opts{'-perlcmd'};
           system(@perldoc_cmd);
           # RT16091: fall back to more if perldoc failed
           if($?) {
             # RT131844: prefer PAGER env
             my $pager = $ENV{PAGER} || $Config{pager};
             if(defined($pager) && length($pager)) {
               my $cmd = $pager . ' ' . ($^O =~ /win/i ? qq("$f") : quotemeta($f));
               system($cmd);
             } else {
               # the most humble fallback; should work (at least) on *nix and Win
               system('more', $f);
             }
           }
         } else {
           croak "Unspecified input file or insecure argument.\n";
         }
      }
      else {
         $parser->parse_from_file($opts{'-input'}, $opts{'-output'});
      }
  
      exit($opts{'-exitval'})  unless (lc($opts{'-exitval'}) eq 'noexit');
  }
  
  ##---------------------------------------------------------------------------
  
  ##-------------------------------
  ## Method definitions begin here
  ##-------------------------------
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      if ($self->can('initialize')) {
          $self->initialize();
      } else {
          # pass through options to Pod::Text
          my %opts;
         	for (qw(alt code indent loose margin quotes sentence stderr utf8 width)) {
              my $val = $params{USAGE_OPTIONS}{"-$_"};
              $opts{$_} = $val if defined $val;
          }
          $self = $self->SUPER::new(%opts);
          %$self = (%$self, %params);
      }
      return $self;
  }
  
  # This subroutine was copied in whole-cloth from Pod::Select 1.60 in order to
  # allow the ejection of Pod::Select from the core without breaking Pod::Usage.
  # -- rjbs, 2013-03-18
  sub _compile_section_spec {
      my ($section_spec) = @_;
      my (@regexs, $negated);
  
      ## Compile the spec into a list of regexs
      local $_ = $section_spec;
      s{\\\\}{\001}g;  ## handle escaped backward slashes
      s{\\/}{\002}g;   ## handle escaped forward slashes
  
      ## Parse the regexs for the heading titles
      @regexs = split(/\//, $_, $MAX_HEADING_LEVEL);
  
      ## Set default regex for ommitted levels
      for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
          $regexs[$i]  = '.*'  unless ((defined $regexs[$i])
                                       && (length $regexs[$i]));
      }
      ## Modify the regexs as needed and validate their syntax
      my $bad_regexs = 0;
      for (@regexs) {
          $_ .= '.+'  if ($_ eq '!');
          s{\001}{\\\\}g;       ## restore escaped backward slashes
          s{\002}{\\/}g;        ## restore escaped forward slashes
          $negated = s/^\!//;   ## check for negation
          eval "m{$_}";         ## check regex syntax
          if ($@) {
              ++$bad_regexs;
              carp qq{Bad regular expression /$_/ in "$section_spec": $@\n};
          }
          else {
              ## Add the forward and rear anchors (and put the negator back)
              $_ = '^' . $_  unless (/^\^/);
              $_ = $_ . '$'  unless (/\$$/);
              $_ = '!' . $_  if ($negated);
          }
      }
      return  (! $bad_regexs) ? [ @regexs ] : undef;
  }
  
  sub select {
      my ($self, @sections) = @_;
      if ($ISA[0]->can('select')) {
          $self->SUPER::select(@sections);
      } else {
          # we're using Pod::Simple - need to mimic the behavior of Pod::Select
          my $add = ($sections[0] eq '+') ? shift(@sections) : '';
          ## Reset the set of sections to use
          unless (@sections) {
            delete $self->{USAGE_SELECT} unless ($add);
            return;
          }
          $self->{USAGE_SELECT} = []
            unless ($add && $self->{USAGE_SELECT});
          my $sref = $self->{USAGE_SELECT};
          ## Compile each spec
          for my $spec (@sections) {
            my $cs = _compile_section_spec($spec);
            if ( defined $cs ) {
              ## Store them in our sections array
              push(@$sref, $cs);
            } else {
              carp qq{Ignoring section spec "$spec"!\n};
            }
          }
      }
  }
  
  # Override Pod::Text->seq_i to return just "arg", not "*arg*".
  sub seq_i { return $_[1] }
  # Override Pod::Text->cmd_i to return just "arg", not "*arg*".
  # newer version based on Pod::Simple
  sub cmd_i {
   my $self = shift;
   # RT121489: highlighting should be there with Termcap
   return $self->SUPER::cmd_i(@_) if $self->isa('Pod::Text::Termcap');
   return $_[1];
  }
  
  # This overrides the Pod::Text method to do something very akin to what
  # Pod::Select did as well as the work done below by preprocess_paragraph.
  # Note that the below is very, very specific to Pod::Text and Pod::Simple.
  sub _handle_element_end {
      my ($self, $element) = @_;
      if ($element eq 'head1') {
          $self->{USAGE_HEADINGS} = [ $$self{PENDING}[-1][1] ];
          if ($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              $$self{PENDING}[-1][1] =~ s/^\s*SYNOPSIS\s*$/USAGE/;
          }
      } elsif ($element =~ /^head(\d+)$/ && $1) { # avoid 0
          my $idx = $1 - 1;
          $self->{USAGE_HEADINGS} = [] unless($self->{USAGE_HEADINGS});
          $self->{USAGE_HEADINGS}->[$idx] = $$self{PENDING}[-1][1];
          # we have to get rid of the lower headings
          splice(@{$self->{USAGE_HEADINGS}},$idx+1);
      }
      if ($element =~ /^head\d+$/) {
          $$self{USAGE_SKIPPING} = 1;
          if (!$$self{USAGE_SELECT} || !@{ $$self{USAGE_SELECT} }) {
              $$self{USAGE_SKIPPING} = 0;
          } else {
              my @headings = @{$$self{USAGE_HEADINGS}};
              for my $section_spec ( @{$$self{USAGE_SELECT}} ) {
                  my $match = 1;
                  for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
                      $headings[$i] = '' unless defined $headings[$i];
                      my $regex   = $section_spec->[$i];
                      my $negated = ($regex =~ s/^\!//);
                      $match  &= ($negated ? ($headings[$i] !~ /${regex}/)
                                           : ($headings[$i] =~ /${regex}/));
                      last unless ($match);
                  } # end heading levels
                  if ($match) {
                    $$self{USAGE_SKIPPING} = 0;
                    last;
                  }
              } # end sections
          }
  
          # Try to do some lowercasing instead of all-caps in headings, and use
          # a colon to end all headings.
          if($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              local $_ = $$self{PENDING}[-1][1];
              s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
              s/\s*$/:/  unless (/:\s*$/);
              $_ .= "\n";
              $$self{PENDING}[-1][1] = $_;
          }
      }
      if ($$self{USAGE_SKIPPING} && $element !~ m/^over-|^[BCFILSZ]$/) {
          pop @{ $$self{PENDING} };
      } else {
          $self->SUPER::_handle_element_end($element);
      }
  }
  
  # required for Pod::Simple API
  sub start_document {
      my $self = shift;
      $self->SUPER::start_document();
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_fh();
      print $out_fh "$msg\n";
  }
  
  # required for old Pod::Parser API
  sub begin_pod {
      my $self = shift;
      $self->SUPER::begin_pod();  ## Have to call superclass
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_handle();
      print $out_fh "$msg\n";
  }
  
  sub preprocess_paragraph {
      my $self = shift;
      local $_ = shift;
      my $line = shift;
      ## See if this is a heading and we aren't printing the entire manpage.
      if (($self->{USAGE_OPTIONS}->{-verbose} < 2) && /^=head/) {
          ## Change the title of the SYNOPSIS section to USAGE
          s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;
          ## Try to do some lowercasing instead of all-caps in headings
          s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
          ## Use a colon to end all headings
          s/\s*$/:/  unless (/:\s*$/);
          $_ .= "\n";
      }
      return  $self->SUPER::preprocess_paragraph($_);
  }
  
  1; # keep require happy
  
  __END__
  
  =for stopwords pod2usage verboseness downcased MSWin32 Marek Rouchal Christiansen ATOOMIC rjbs McDougall
  
  =head1 NAME
  
  Pod::Usage - extracts POD documentation and shows usage information
  
  =head1 SYNOPSIS
  
    use Pod::Usage;
  
    my $message_text  = "This text precedes the usage message.";
    my $exit_status   = 2;          ## The exit status to use
    my $verbose_level = 0;          ## The verbose level to use
    my $filehandle    = \*STDERR;   ## The filehandle to write to
  
    pod2usage($message_text);
  
    pod2usage($exit_status);
  
    pod2usage( { -message => $message_text ,
                 -exitval => $exit_status  ,
                 -verbose => $verbose_level,
                 -output  => $filehandle } );
  
    pod2usage(   -msg     => $message_text ,
                 -exitval => $exit_status  ,
                 -verbose => $verbose_level,
                 -output  => $filehandle );
  
    pod2usage(   -verbose => 2,
                 -noperldoc => 1  );
  
    pod2usage(   -verbose => 2,
                 -perlcmd => $path_to_perl,
                 -perldoc => $path_to_perldoc,
                 -perldocopt => $perldoc_options );
  
  =head1 ARGUMENTS
  
  B<pod2usage> should be given either a single argument, or a list of
  arguments corresponding to an associative array (a "hash"). When a single
  argument is given, it should correspond to exactly one of the following:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the usage message
  
  =item *
  
  A numeric value corresponding to the desired exit status
  
  =item *
  
  A reference to a hash
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message> I<string>
  
  =item C<-msg> I<string>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval> I<value>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string C<NOEXIT> to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-verbose> I<value>
  
  The desired level of "verboseness" to use when printing the usage message.
  If the value is 0, then only the "SYNOPSIS" and/or "USAGE" sections of the
  pod documentation are printed. If the value is 1, then the "SYNOPSIS" and/or
  "USAGE" sections, along with any section entitled "OPTIONS", "ARGUMENTS", or
  "OPTIONS AND ARGUMENTS" is printed. If the corresponding value is 2 or more
  then the entire manpage is printed, using L<perldoc> if available; otherwise
  L<Pod::Text> is used for the formatting. For better readability, the
  all-capital headings are downcased, e.g. C<SYNOPSIS> =E<gt> C<Synopsis>.
  
  The special verbosity level 99 requires to also specify the -sections
  parameter; then these sections are extracted and printed.
  
  =item C<-sections> I<spec>
  
  There are two ways to specify the selection. Either a string (scalar)
  representing a selection regexp for sections to be printed when -verbose
  is set to 99, e.g.
  
    "NAME|SYNOPSIS|DESCRIPTION|VERSION"
  
  With the above regexp all content following (and including) any of the
  given C<=head1> headings will be shown. It is possible to restrict the
  output to particular subsections only, e.g.:
  
    "DESCRIPTION/Algorithm"
  
  This will output only the C<=head2 Algorithm> heading and content within
  the C<=head1 DESCRIPTION> section. The regexp binding is stronger than the
  section separator, such that e.g.:
  
    "DESCRIPTION|OPTIONS|ENVIRONMENT/Caveats"
  
  will print any C<=head2 Caveats> section (only) within any of the three
  C<=head1> sections.
  
  Alternatively, an array reference of section specifications can be used:
  
    pod2usage(-verbose => 99, -sections => [
      qw(DESCRIPTION DESCRIPTION/Introduction) ] );
  
  This will print only the content of C<=head1 DESCRIPTION> and the
  C<=head2 Introduction> sections, but no other C<=head2>, and no other
  C<=head1> either.
  
  =item C<-output> I<handle>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =item C<-input> I<handle>
  
  A reference to a filehandle, or the pathname of a file from which the
  invoking script's pod documentation should be read.  It defaults to the
  file indicated by C<$0> (C<$PROGRAM_NAME> for users of F<English.pm>).
  
  If you are calling B<pod2usage()> from a module and want to display
  that module's POD, you can use this:
  
    use Pod::Find qw(pod_where);
    pod2usage( -input => pod_where({-inc => 1}, __PACKAGE__) );
  
  =item C<-pathlist> I<string>
  
  A list of directory paths. If the input file does not exist, then it
  will be searched for in the given directory list (in the order the
  directories appear in the list). It defaults to the list of directories
  implied by C<$ENV{PATH}>. The list may be specified either by a reference
  to an array, or by a string of directory paths which use the same path
  separator as C<$ENV{PATH}> on your system (e.g., C<:> for Unix, C<;> for
  MSWin32 and DOS).
  
  =item C<-noperldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  This does not work well e.g. if the script was packed with L<PAR>. This option
  suppresses the external call to L<perldoc> and uses the simple text formatter
  (L<Pod::Text>) to output the POD.
  
  =item C<-perlcmd>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case of special or unusual Perl installations,
  this option may be used to supply the path to a L<perl> executable
  which should run L<perldoc>.
  
  =item C<-perldoc> I<path-to-perldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case L<perldoc> is not installed where the L<perl> interpreter
  thinks it is (see L<Config>), the -perldoc option may be used to supply
  the correct path to L<perldoc>.
  
  =item C<-perldocopt> I<string>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  This option may be used to supply options to L<perldoc>. The
  string may contain several, space-separated options.
  
  =back
  
  =head2 Formatting base class
  
  The default text formatter is L<Pod::Text>. The base class for Pod::Usage can
  be defined by pre-setting C<$Pod::Usage::Formatter> I<before>
  loading Pod::Usage, e.g.:
  
      BEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
      use Pod::Usage qw(pod2usage);
  
  Pod::Usage uses L<Pod::Simple>'s _handle_element_end() method to implement
  the section selection, and in case of verbosity < 2 it down-cases the
  all-caps headings to first capital letter and rest lowercase, and adds
  a colon/newline at the end of the headings, for better readability. Same for
  verbosity = 99.
  
  =head2 Pass-through options
  
  The following options are passed through to the underlying text formatter.
  See the manual pages of these modules for more information.
  
    alt code indent loose margin quotes sentence stderr utf8 width
  
  =head1 DESCRIPTION
  
  B<pod2usage> will print a usage message for the invoking script (using
  its embedded pod documentation) and then exit the script with the
  desired exit status. The usage message printed may have any one of three
  levels of "verboseness": If the verbose level is 0, then only a synopsis
  is printed. If the verbose level is 1, then the synopsis is printed
  along with a description (if present) of the command line options and
  arguments. If the verbose level is 2, then the entire manual page is
  printed.
  
  Unless they are explicitly specified, the default values for the exit
  status, verbose level, and output stream to use are determined as
  follows:
  
  =over 4
  
  =item *
  
  If neither the exit status nor the verbose level is specified, then the
  default is to use an exit status of 2 with a verbose level of 0.
  
  =item *
  
  If an exit status I<is> specified but the verbose level is I<not>, then the
  verbose level will default to 1 if the exit status is less than 2 and
  will default to 0 otherwise.
  
  =item *
  
  If an exit status is I<not> specified but verbose level I<is> given, then
  the exit status will default to 2 if the verbose level is 0 and will
  default to 1 otherwise.
  
  =item *
  
  If the exit status used is less than 2, then output is printed on
  C<STDOUT>.  Otherwise output is printed on C<STDERR>.
  
  =back
  
  Although the above may seem a bit confusing at first, it generally does
  "the right thing" in most situations.  This determination of the default
  values to use is based upon the following typical Unix conventions:
  
  =over 4
  
  =item *
  
  An exit status of 0 implies "success". For example, B<diff(1)> exits
  with a status of 0 if the two files have the same contents.
  
  =item *
  
  An exit status of 1 implies possibly abnormal, but non-defective, program
  termination.  For example, B<grep(1)> exits with a status of 1 if
  it did I<not> find a matching line for the given regular expression.
  
  =item *
  
  An exit status of 2 or more implies a fatal error. For example, B<ls(1)>
  exits with a status of 2 if you specify an illegal (unknown) option on
  the command line.
  
  =item *
  
  Usage messages issued as a result of bad command-line syntax should go
  to C<STDERR>.  However, usage messages issued due to an explicit request
  to print usage (like specifying B<-help> on the command line) should go
  to C<STDOUT>, just in case the user wants to pipe the output to a pager
  (such as B<more(1)>).
  
  =item *
  
  If program usage has been explicitly requested by the user, it is often
  desirable to exit with a status of 1 (as opposed to 0) after issuing
  the user-requested usage message.  It is also desirable to give a
  more verbose description of program usage in this case.
  
  =back
  
  B<pod2usage> does not force the above conventions upon you, but it will
  use them by default if you don't expressly tell it to do otherwise.  The
  ability of B<pod2usage()> to accept a single number or a string makes it
  convenient to use as an innocent looking error message handling function:
  
      use strict;
      use Pod::Usage;
      use Getopt::Long;
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||  pod2usage(2);
      pod2usage(1)  if ($opt{help});
      pod2usage(-exitval => 0, -verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage("$0: Too many files given.\n")  if (@ARGV > 1);
  
  Some user's however may feel that the above "economy of expression" is
  not particularly readable nor consistent and may instead choose to do
  something more like the following:
  
      use strict;
      use Pod::Usage qw(pod2usage);
      use Getopt::Long qw(GetOptions);
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||
        pod2usage(-verbose => 0);
  
      pod2usage(-verbose => 1)  if ($opt{help});
      pod2usage(-verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage(-verbose => 2, -message => "$0: Too many files given.\n")
        if (@ARGV > 1);
  
  
  As with all things in Perl, I<there's more than one way to do it>, and
  B<pod2usage()> adheres to this philosophy.  If you are interested in
  seeing a number of different ways to invoke B<pod2usage> (although by no
  means exhaustive), please refer to L<"EXAMPLES">.
  
  =head2 Scripts
  
  The Pod::Usage distribution comes with a script pod2usage which offers
  a command line interface to the functionality of Pod::Usage. See
  L<pod2usage>.
  
  
  =head1 EXAMPLES
  
  Each of the following invocations of C<pod2usage()> will print just the
  "SYNOPSIS" section to C<STDERR> and will exit with a status of 2:
  
      pod2usage();
  
      pod2usage(2);
  
      pod2usage(-verbose => 0);
  
      pod2usage(-exitval => 2);
  
      pod2usage({-exitval => 2, -output => \*STDERR});
  
      pod2usage({-verbose => 0, -output  => \*STDERR});
  
      pod2usage(-exitval => 2, -verbose => 0);
  
      pod2usage(-exitval => 2, -verbose => 0, -output => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print a message
  of "Syntax error." (followed by a newline) to C<STDERR>, immediately
  followed by just the "SYNOPSIS" section (also printed to C<STDERR>) and
  will exit with a status of 2:
  
      pod2usage("Syntax error.");
  
      pod2usage(-message => "Syntax error.", -verbose => 0);
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2);
  
      pod2usage({-msg => "Syntax error.", -exitval => 2, -output => \*STDERR});
  
      pod2usage({-msg => "Syntax error.", -verbose => 0, -output => \*STDERR});
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2, -verbose => 0);
  
      pod2usage(-message => "Syntax error.",
                -exitval => 2,
                -verbose => 0,
                -output  => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print the
  "SYNOPSIS" section and any "OPTIONS" and/or "ARGUMENTS" sections to
  C<STDOUT> and will exit with a status of 1:
  
      pod2usage(1);
  
      pod2usage(-verbose => 1);
  
      pod2usage(-exitval => 1);
  
      pod2usage({-exitval => 1, -output => \*STDOUT});
  
      pod2usage({-verbose => 1, -output => \*STDOUT});
  
      pod2usage(-exitval => 1, -verbose => 1);
  
      pod2usage(-exitval => 1, -verbose => 1, -output => \*STDOUT});
  
  Each of the following invocations of C<pod2usage()> will print the
  entire manual page to C<STDOUT> and will exit with a status of 1:
  
      pod2usage(-verbose  => 2);
  
      pod2usage({-verbose => 2, -output => \*STDOUT});
  
      pod2usage(-exitval  => 1, -verbose => 2);
  
      pod2usage({-exitval => 1, -verbose => 2, -output => \*STDOUT});
  
  =head2 Recommended Use
  
  Most scripts should print some type of usage message to C<STDERR> when a
  command line syntax error is detected. They should also provide an
  option (usually C<-H> or C<-help>) to print a (possibly more verbose)
  usage message to C<STDOUT>. Some scripts may even wish to go so far as to
  provide a means of printing their complete documentation to C<STDOUT>
  (perhaps by allowing a C<-man> option). The following complete example
  uses B<Pod::Usage> in combination with B<Getopt::Long> to do all of these
  things:
  
      use strict;
      use Getopt::Long qw(GetOptions);
      use Pod::Usage qw(pod2usage);
  
      my $man = 0;
      my $help = 0;
      ## Parse options and print usage if there is a syntax error,
      ## or if usage was explicitly requested.
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-verbose => 2) if $man;
  
      ## If no arguments were given, then allow STDIN to be used only
      ## if it's not connected to a terminal (otherwise print usage)
      pod2usage("$0: No files given.")  if ((@ARGV == 0) && (-t STDIN));
  
      __END__
  
      =head1 NAME
  
      sample - Using GetOpt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 4
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  =head1 CAVEATS
  
  By default, B<pod2usage()> will use C<$0> as the path to the pod input
  file.  Unfortunately, not all systems on which Perl runs will set C<$0>
  properly (although if C<$0> is not found, B<pod2usage()> will search
  C<$ENV{PATH}> or else the list specified by the C<-pathlist> option).
  If this is the case for your system, you may need to explicitly specify
  the path to the pod docs for the invoking script using something
  similar to the following:
  
      pod2usage(-exitval => 2, -input => "/path/to/your/pod/docs");
  
  In the pathological case that a script is called via a relative path
  I<and> the script itself changes the current working directory
  (see L<perlfunc/chdir>) I<before> calling pod2usage, Pod::Usage will
  fail even on robust platforms. Don't do that. Or use L<FindBin> to locate
  the script:
  
      use FindBin;
      pod2usage(-input => $FindBin::Bin . "/" . $FindBin::Script);
  
  =head1 SUPPORT
  
  This module is managed in a GitHub repository,
  L<https://github.com/Dual-Life/Pod-Usage> Feel free to fork and contribute, or
  to clone and send patches!
  
  Please use L<https://github.com/Dual-Life/Pod-Usage/issues/new> to file a bug
  report.  The previous ticketing system,
  L<https://rt.cpan.org/Dist/Display.html?Queue=Pod-Usage>, is deprecated for
  this package.
  
  More general questions or discussion about POD should be sent to the
  C<pod-people@perl.org> mail list. Send an empty email to
  C<pod-people-subscribe@perl.org> to subscribe.
  
  =head1 AUTHOR
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>
  
  Nicolas R E<lt>nicolas@atoomic.orgE<gt>
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<Pod::Text::pod2text()> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  =head1 LICENSE
  
  Pod::Usage (the distribution) is licensed under the same terms as Perl.
  
  =head1 ACKNOWLEDGMENTS
  
  Nicolas R (ATOOMIC) for setting up the Github repo and modernizing this
  package.
  
  rjbs for refactoring Pod::Usage to not use Pod::Parser any more.
  
  Steven McDougall E<lt>swmcd@world.std.comE<gt> for his help and patience with
  re-writing this manpage.
  
  =head1 SEE ALSO
  
  B<Pod::Usage> is now a standalone distribution, depending on
  L<Pod::Text> which in turn depends on L<Pod::Simple>.
  
  L<Pod::Perldoc>, L<Getopt::Long>, L<Pod::Find>, L<FindBin>,
  L<Pod::Text>, L<Pod::Text::Termcap>, L<Pod::Simple>
  
  =cut
  
POD_USAGE

$fatpacked{"Text/Tabs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_TABS';
  use strict; use warnings;
  
  package Text::Tabs;
  
  BEGIN { require Exporter; *import = \&Exporter::import }
  
  our @EXPORT = qw( expand unexpand $tabstop );
  
  our $VERSION = '2023.0511';
  our $SUBVERSION = 'modern'; # back-compat vestige
  
  our $tabstop = 8;
  
  sub expand {
  	my @l;
  	my $pad;
  	for ( @_ ) {
  		defined or do { push @l, ''; next };
  		my $s = '';
  		for (split(/^/m, $_, -1)) {
  			my $offs;
  			for (split(/\t/, $_, -1)) {
  				if (defined $offs) {
  					$pad = $tabstop - $offs % $tabstop;
  					$s .= " " x $pad;
  				}
  				$s .= $_;
  				$offs = /^\pM/ + ( () = /\PM/g );
  			}
  		}
  		push(@l, $s);
  	}
  	return @l if wantarray;
  	return $l[0];
  }
  
  sub unexpand
  {
  	my (@l) = @_;
  	my @e;
  	my $x;
  	my $line;
  	my @lines;
  	my $lastbit;
  	my $ts_as_space = " " x $tabstop;
  	for $x (@l) {
  		defined $x or next;
  		@lines = split("\n", $x, -1);
  		for $line (@lines) {
  			$line = expand($line);
  			@e = split(/((?:\PM\pM*|^\pM+){$tabstop})/,$line,-1);
  			$lastbit = pop(@e);
  			$lastbit = '' 
  				unless defined $lastbit;
  			$lastbit = "\t"
  				if $lastbit eq $ts_as_space;
  			for $_ (@e) {
  				s/  +$/\t/;
  			}
  			$line = join('',@e, $lastbit);
  		}
  		$x = join("\n", @lines);
  	}
  	return @l if wantarray;
  	return $l[0];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)
  
  =head1 SYNOPSIS
  
    use Text::Tabs;
  
    $tabstop = 4;  # default = 8
    @lines_without_tabs = expand(@lines_with_tabs);
    @lines_with_tabs = unexpand(@lines_without_tabs);
  
  =head1 DESCRIPTION
  
  Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) 
  do.  Given a line with tabs in it, C<expand> replaces those tabs with
  the appropriate number of spaces.  Given a line with or without tabs in
  it, C<unexpand> adds tabs when it can save bytes by doing so, 
  like the C<unexpand -a> command.  
  
  Unlike the old unix utilities, this module correctly accounts for
  any Unicode combining characters (such as diacriticals) that may occur
  in each line for both expansion and unexpansion.  These are overstrike
  characters that do not increment the logical position.  Make sure
  you have the appropriate Unicode settings enabled.
  
  =head1 EXPORTS
  
  The following are exported:
  
  =over 4
  
  =item expand
  
  =item unexpand
  
  =item $tabstop
  
  The C<$tabstop> variable controls how many column positions apart each
  tabstop is.  The default is 8.
  
  Please note that C<local($tabstop)> doesn't do the right thing and if you want
  to use C<local> to override C<$tabstop>, you need to use
  C<local($Text::Tabs::tabstop)>.
  
  =back
  
  =head1 EXAMPLE
  
    #!perl
    # unexpand -a
    use Text::Tabs;
  
    while (<>) {
      print unexpand $_;
    }
  
  Instead of the shell's C<expand> command, use:
  
    perl -MText::Tabs -n -e 'print expand $_'
  
  Instead of the shell's C<unexpand -a> command, use:
  
    perl -MText::Tabs -n -e 'print unexpand $_'
  
  =head1 BUGS
  
  Text::Tabs handles only tabs (C<"\t">) and combining characters (C</\pM/>).  It doesn't
  count backwards for backspaces (C<"\t">), omit other non-printing control characters (C</\pC/>),
  or otherwise deal with any other zero-, half-, and full-width characters.
  
  =head1 LICENSE
  
  Copyright (C) 1996-2002,2005,2006 David Muir Sharnoff.  
  Copyright (C) 2005 Aristotle Pagaltzis 
  Copyright (C) 2012-2013 Google, Inc.
  This module may be modified, used, copied, and redistributed at your own risk.
  Although allowed by the preceding license, please do not publicly
  redistribute modified versions of this code with the name "Text::Tabs"
  unless it passes the unmodified Text::Tabs test suite.
TEXT_TABS

$fatpacked{"Text/Wrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_WRAP';
  use strict; use warnings;
  
  package Text::Wrap;
  
  use warnings::register;
  
  BEGIN { require Exporter; *import = \&Exporter::import }
  
  our @EXPORT = qw( wrap fill );
  our @EXPORT_OK = qw( $columns $break $huge );
  
  our $VERSION = '2023.0511';
  our $SUBVERSION = 'modern'; # back-compat vestige
  
  BEGIN { eval sprintf 'sub REGEXPS_USE_BYTES () { %d }', scalar( pack('U*', 0x80) =~ /\xc2/ ) }
  
  my $brkspc = "\x{a0}\x{202f}" =~ /\s/ ? '[^\x{a0}\x{202f}\S]' : '\s';
  
  our $columns = 76;  # <= screen width
  our $break = '(?>\n|\r\n|'.$brkspc.'\pM*)';
  our $huge = 'wrap'; # alternatively: 'die' or 'overflow'
  our $unexpand = 1;
  our $tabstop = 8;
  our $separator = "\n";
  our $separator2 = undef;
  
  sub _xlen { $_[0] =~ /^\pM/ + ( () = $_[0] =~ /\PM/g ) }
  
  use Text::Tabs qw(expand unexpand);
  
  sub wrap
  {
  	my ($ip, $xp, @t) = map +( defined $_ ? $_ : '' ), @_;
  
  	local($Text::Tabs::tabstop) = $tabstop;
  	my $r = "";
  	my $tail = pop(@t);
  	my $t = expand(join("", (map { /\s+\z/ ? ( $_ ) : ($_, ' ') } @t), $tail));
  	my $lead = $ip;
  	my $nll = $columns - _xlen(expand($xp)) - 1;
  	if ($nll <= 0 && $xp ne '') {
  		my $nc = _xlen(expand($xp)) + 2;
  		warnings::warnif "Increasing \$Text::Wrap::columns from $columns to $nc to accommodate length of subsequent tab";
  		$columns = $nc;
  		$nll = 1;
  	}
  	my $ll = $columns - _xlen(expand($ip)) - 1;
  	$ll = 0 if $ll < 0;
  	my $nl = "";
  	my $remainder = "";
  
  	use re 'taint';
  
  	pos($t) = 0;
  	while ($t !~ /\G(?:$break)*\Z/gc) {
  		if ($t =~ /\G((?>(?!\n)\PM\pM*|(?<![^\n])\pM+){0,$ll})($break|\n+|\z)/xmgc) {
  			$r .= $unexpand 
  				? unexpand($nl . $lead . $1)
  				: $nl . $lead . $1;
  			$remainder = $2;
  		} elsif ($huge eq 'wrap' && $t =~ /\G((?>(?!\n)\PM\pM*|(?<![^\n])\pM+){$ll})/gc) {
  			$r .= $unexpand 
  				? unexpand($nl . $lead . $1)
  				: $nl . $lead . $1;
  			$remainder = defined($separator2) ? $separator2 : $separator;
  		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)(?!(?<![^\n])\pM)($break|\n+|\z)/xmgc) {
  			$r .= $unexpand 
  				? unexpand($nl . $lead . $1)
  				: $nl . $lead . $1;
  			$remainder = $2;
  		} elsif ($huge eq 'die') {
  			die "couldn't wrap '$t'";
  		} elsif ($columns < 2) {
  			warnings::warnif "Increasing \$Text::Wrap::columns from $columns to 2";
  			$columns = 2;
  			return @_;
  		} else {
  			die "This shouldn't happen";
  		}
  			
  		$lead = $xp;
  		$ll = $nll;
  		$nl = defined($separator2)
  			? ($remainder eq "\n"
  				? "\n"
  				: $separator2)
  			: $separator;
  	}
  	$r .= $remainder;
  
  	$r .= $lead . substr($t, pos($t), length($t) - pos($t))
  		if pos($t) ne length($t);
  
  	# the 5.6 regexp engine ignores the UTF8 flag, so using capture buffers acts as an implicit _utf8_off
  	# that means on 5.6 we now have to manually set UTF8=on on the output if the input had it, for which
  	# we extract just the UTF8 flag from the input and check if it forces chr(0x80) to become multibyte
  	return REGEXPS_USE_BYTES && (substr($t,0,0)."\x80") =~ /\xc2/ ? pack('U0a*', $r) : $r;
  }
  
  sub fill 
  {
  	my ($ip, $xp, @raw) = map +( defined $_ ? $_ : '' ), @_;
  	my @para;
  	my $pp;
  
  	for $pp (split(/\n\s+/, join("\n",@raw))) {
  		$pp =~ s/\s+/ /g;
  		my $x = wrap($ip, $xp, $pp);
  		push(@para, $x);
  	}
  
  	# if paragraph_indent is the same as line_indent, 
  	# separate paragraphs with blank lines
  
  	my $ps = ($ip eq $xp) ? "\n\n" : "\n";
  	return join ($ps, @para);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Text::Wrap - line wrapping to form simple paragraphs
  
  =head1 SYNOPSIS 
  
  B<Example 1>
  
  	use Text::Wrap;
  
  	$initial_tab = "\t";	# Tab before first line
  	$subsequent_tab = "";	# All other lines flush left
  
  	print wrap($initial_tab, $subsequent_tab, @text);
  	print fill($initial_tab, $subsequent_tab, @text);
  
  	$lines = wrap($initial_tab, $subsequent_tab, @text);
  
  	@paragraphs = fill($initial_tab, $subsequent_tab, @text);
  
  B<Example 2>
  
  	use Text::Wrap qw(wrap $columns $huge);
  
  	$columns = 132;		# Wrap at 132 characters
  	$huge = 'die';
  	$huge = 'wrap';
  	$huge = 'overflow';
  
  B<Example 3>
  
  	use Text::Wrap;
  
  	$Text::Wrap::columns = 72;
  	print wrap('', '', @text);
  
  =head1 DESCRIPTION
  
  C<Text::Wrap::wrap()> is a very simple paragraph formatter.  It formats a
  single paragraph at a time by breaking lines at word boundaries.
  Indentation is controlled for the first line (C<$initial_tab>) and
  all subsequent lines (C<$subsequent_tab>) independently.  Please note: 
  C<$initial_tab> and C<$subsequent_tab> are the literal strings that will
  be used: it is unlikely you would want to pass in a number.
  
  C<Text::Wrap::fill()> is a simple multi-paragraph formatter.  It formats
  each paragraph separately and then joins them together when it's done.  It
  will destroy any whitespace in the original text.  It breaks text into
  paragraphs by looking for whitespace after a newline.  In other respects,
  it acts like wrap().
  
  C<wrap()> compresses trailing whitespace into one newline, and C<fill()>
  deletes all trailing whitespace.
  
  Both C<wrap()> and C<fill()> return a single string.
  
  Unlike the old Unix fmt(1) utility, this module correctly accounts for
  any Unicode combining characters (such as diacriticals) that may occur
  in each line for both expansion and unexpansion.  These are overstrike
  characters that do not increment the logical position.  Make sure
  you have the appropriate Unicode settings enabled.
  
  =head1 OVERRIDES
  
  C<Text::Wrap::wrap()> has a number of variables that control its behavior.
  Because other modules might be using C<Text::Wrap::wrap()> it is suggested
  that you leave these variables alone!  If you can't do that, then 
  use C<local($Text::Wrap::VARIABLE) = YOURVALUE> when you change the
  values so that the original value is restored.  This C<local()> trick
  will not work if you import the variable into your own namespace.
  
  Lines are wrapped at C<$Text::Wrap::columns> columns (default value: 76).
  C<$Text::Wrap::columns> should be set to the full width of your output
  device.  In fact, every resulting line will have length of no more than
  C<$columns - 1>.
  
  It is possible to control which characters terminate words by
  modifying C<$Text::Wrap::break>. Set this to a string such as
  C<'[\s:]'> (to break before spaces or colons) or a pre-compiled regexp
  such as C<qr/[\s']/> (to break before spaces or apostrophes). The
  default is simply C<'\s'>; that is, words are terminated by spaces.
  (This means, among other things, that trailing punctuation  such as
  full stops or commas stay with the word they are "attached" to.)
  Setting C<$Text::Wrap::break> to a regular expression that doesn't
  eat any characters (perhaps just a forward look-ahead assertion) will
  cause warnings.
  
  Beginner note: In example 2, above C<$columns> is imported into
  the local namespace, and set locally.  In example 3,
  C<$Text::Wrap::columns> is set in its own namespace without importing it.
  
  C<Text::Wrap::wrap()> starts its work by expanding all the tabs in its
  input into spaces.  The last thing it does it to turn spaces back
  into tabs.  If you do not want tabs in your results, set 
  C<$Text::Wrap::unexpand> to a false value.  Likewise if you do not
  want to use 8-character tabstops, set C<$Text::Wrap::tabstop> to
  the number of characters you do want for your tabstops.
  
  If you want to separate your lines with something other than C<\n>
  then set C<$Text::Wrap::separator> to your preference.  This replaces
  all newlines with C<$Text::Wrap::separator>.  If you just want to 
  preserve existing newlines but add new breaks with something else, set
  C<$Text::Wrap::separator2> instead.
  
  When words that are longer than C<$columns> are encountered, they
  are broken up.  C<wrap()> adds a C<"\n"> at column C<$columns>.
  This behavior can be overridden by setting C<$huge> to
  'die' or to 'overflow'.  When set to 'die', large words will cause
  C<die()> to be called.  When set to 'overflow', large words will be
  left intact.  
  
  Historical notes: 'die' used to be the default value of
  C<$huge>.  Now, 'wrap' is the default value.
  
  =head1 EXAMPLES
  
  Code:
  
    print wrap("\t","",<<END);
    This is a bit of text that forms 
    a normal book-style indented paragraph
    END
  
  Result:
  
    "	This is a bit of text that forms
    a normal book-style indented paragraph   
    "
  
  Code:
  
    $Text::Wrap::columns=20;
    $Text::Wrap::separator="|";
    print wrap("","","This is a bit of text that forms a normal book-style paragraph");
  
  Result:
  
    "This is a bit of|text that forms a|normal book-style|paragraph"
  
  =head1 SEE ALSO
  
  For correct handling of East Asian half- and full-width characters, 
  see L<Text::WrapI18N>.  For more detailed controls: L<Text::Format>.
  
  =head1 AUTHOR
  
  David Muir Sharnoff <cpan@dave.sharnoff.org> with help from Tim Pierce and
  many many others.  
  
  =head1 LICENSE
  
  Copyright (C) 1996-2009 David Muir Sharnoff.  
  Copyright (C) 2012-2013 Google, Inc.
  This module may be modified, used, copied, and redistributed at your own risk.
  Although allowed by the preceding license, please do not publicly
  redistribute modified versions of this code with the name "Text::Wrap"
  unless it passes the unmodified Text::Wrap test suite.
TEXT_WRAP

$fatpacked{"match/simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MATCH_SIMPLE';
  package match::simple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny;
  use List::Util 1.33 qw( any );
  use Scalar::Util qw( blessed );
  
  BEGIN {
  	$match::simple::AUTHORITY = 'cpan:TOBYINK';
  	$match::simple::VERSION   = '0.012';
  }
  
  our @ISA       = qw( Exporter::Tiny );
  our @EXPORT    = qw( M );
  our @EXPORT_OK = qw( match );
  
  my $xs;
  unless (($ENV{MATCH_SIMPLE_IMPLEMENTATION}||'') =~ /pp/i) {
  	eval {
  		require match::simple::XS;
  		match::simple::XS->VERSION( 0.002 );  # minimum
  		
  		# Unless we're a development version...
  		# Avoid using an unstable version of ::XS
  		unless (match::simple->VERSION =~ /_/) {
  			die if match::simple::XS->VERSION =~ /_/;
  		}
  		
  		$xs = match::simple::XS->can('match');
  	};
  }
  
  eval($xs ? <<'XS' : <<'PP');
  
  sub IMPLEMENTATION () { "XS" }
  
  *match = *match::simple::XS::match;
  
  XS
  
  sub IMPLEMENTATION () { "PP" }
  
  sub match {
  	no warnings qw( uninitialized numeric );
  	
  	my ( $a, $b ) = @_;
  	my $method;
  	
  	return !defined $a                      if !defined($b);
  	return $a eq $b                         if !ref($b);
  	return $a =~ $b                         if ref($b) eq q(Regexp);
  	return do { local $_ = $a; !!$b->($a) } if ref($b) eq q(CODE);
  	return any { match( $a, $_ ) } @$b      if ref($b) eq q(ARRAY);
  	return !!$b->$method( $a, 1 )           if blessed($b) && ( $method = _overloaded_smartmatch( $b ) );
  	
  	require Carp;
  	Carp::croak( "match::simple cannot match anything against: $b" );
  }
  
  unless ( eval 'require re; 1' and exists &re::is_regexp ) {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object( $_[0] )->MAGIC->TYPE eq 'r' };
  	};
  }
  
  sub _overloaded_smartmatch {
  	my ( $obj ) = @_;
  	return if re::is_regexp( $obj );
  	
  	if ( $obj->isa( 'Type::Tiny' ) ) {
  		return $obj->can( 'check' );
  	}
  	
  	if ( my $match = $obj->can( 'MATCH' ) ) {
  		return $match;
  	}
  	
  	if ( $] lt '5.010' ) { require MRO::Compat; }
  	else                 { require mro;         }
  	
  	my @mro = @{ mro::get_linear_isa( ref $obj ) };
  	for my $class ( @mro ) {
  		my $name = "$class\::(~~";
  		my $overload = do {
  			no strict 'refs';
  			exists( &$name ) ? \&$name : undef;
  		};
  		return $overload if $overload;
  	}
  	
  	return;
  }
  
  PP
  
  sub _generate_M {
  	require Sub::Infix;
  	&Sub::Infix::infix( \&match );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smartmatch recurses
  
  =head1 NAME
  
  match::simple - simplified clone of smartmatch operator
  
  =head1 SYNOPSIS
  
     use v5.10;
     use match::simple;
     
     if ( $this |M| $that ) {
        say "$this matches $that";
     }
  
  =head1 DESCRIPTION
  
  match::simple provides a simple match operator C<< |M| >> that acts like
  a sane subset of the (as of Perl 5.18) deprecated smart match operator.
  Unlike smart match, the behaviour of the match is determined entirely by
  the operand on the right hand side.
  
  =over
  
  =item *
  
  If the right hand side is C<undef>, then there is only a match if the left
  hand side is also C<undef>.
  
  =item *
  
  If the right hand side is a non-reference, then the match is a simple string
  match.
  
  =item *
  
  If the right hand side is a reference to a regexp, then the left hand is
  evaluated .
  
  =item *
  
  If the right hand side is a code reference, then it is called in a boolean
  context with the left hand side being passed as an argument.
  
  =item *
  
  If the right hand side is an object which provides a C<MATCH> method, then
  it this is called as a method, with the left hand side being passed as an
  argument.
  
  =item *
  
  If the right hand side is an object which overloads C<< ~~ >>, then this
  will be used.
  
  =item *
  
  If the right hand side is an arrayref, then the operator recurses into the
  array, with the match succeeding if the left hand side matches any array
  element.
  
  =item *
  
  If any other value appears on the right hand side, the operator will croak.
  
  =back
  
  If you don't like the crazy L<Sub::Infix> operator, you can alternatively
  export a more normal function:
  
     use v5.10;
     use match::simple qw(match);
     
     if ( match($this, $that) ) {
        say "$this matches $that";
     }
  
  If you're making heavy use of this module, then this is probably your best
  option, as it runs significantly faster.
  
  =head2 XS Backend
  
  If you install match::simple::XS, a faster XS-based implementation will be
  used instead of the pure Perl functions. Depending on what sort of match you
  are doing, this is likely to be several times faster. In extreme cases, such
  as matching a string in an arrayref, it can be twenty-five times faster, or
  more. However, where C<< $that >> is a single regexp, it's around 30% slower.
  Overall though, I think the performance improvement is worthwhile.
  
  If you want to take advantage of this speed up, use the C<match> function
  rather than the C<< |M| >> operator. Otherwise all your gains will be lost to
  the slow implementation of operator overloading.
  
  The constant C<< match::simple::IMPLEMENTATION >> tells you which backend
  is currently in use.
  
  =head2 Environment
  
  Setting the C<MATCH_SIMPLE_IMPLEMENTATION> environment variable to "PP"
  encourages match::simple to use the pure Perl backend.
  
  =begin trustme
  
  =item M
  
  =item match
  
  =item IMPLEMENTATION
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-match-simple/issues>.
  
  =head1 SEE ALSO
  
  L<match::smart>, L<match::simple::sugar>.
  
  This module uses L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017, 2022-2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MATCH_SIMPLE

$fatpacked{"match/simple/sugar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MATCH_SIMPLE_SUGAR';
  package match::simple::sugar;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny;
  use Carp qw( croak );
  use Scalar::Util qw( blessed );
  use match::simple qw( match );
  
  BEGIN {
  	$match::simple::sugar::AUTHORITY = 'cpan:TOBYINK';
  	$match::simple::sugar::VERSION   = '0.012';
  	my $strict = 0;
  	$ENV{$_} && $strict++ for qw(
  		EXTENDED_TESTING
  		AUTHOR_TESTING
  		RELEASE_TESTING
  		PERL_STRICT
  	);
  	eval qq{
  		sub STRICT () { !! $strict }
  		sub LAX    () {  ! $strict }
  	};
  }
  
  our @ISA       = qw( Exporter::Tiny );
  our @EXPORT    = qw( when then numeric match );
  
  my $then_class    = __PACKAGE__ . '::then';
  my $numeric_class = __PACKAGE__ . '::numeric';
  
  sub when {
  	my @things = @_;
  	my $then = pop @things;
  	if ( blessed $then and $then->isa( $then_class ) ) {
  		if ( match $_, \@things ) {
  			no warnings 'exiting';
  			$then->();
  			next;
  		}
  	}
  	else {
  		croak "when: expects then";
  	}
  	return;
  }
  
  sub _check_coderef {
  	my $coderef = shift;
  	require B;
  	local *B::OP::__match_simple_sugar_callback = sub {
  		my $name = $_[0]->name;
  		croak "Block appears to contain a `$name` statement; not suitable for use with when/then"
  			if match $name, [ qw/ wantarray return redo last next / ];
  		return;
  	};
  	B::svref_2object( $coderef )->ROOT->B::walkoptree( '__match_simple_sugar_callback' );
  }
  
  sub then (&) {
  	my $coderef = shift;
  	_check_coderef $coderef if STRICT;
  	bless $coderef, $then_class;
  }
  
  sub numeric ($) {
  	my $n = shift;
  	bless \$n, $numeric_class;
  }
  
  {
  	my $check = sub {
  		my ( $x, $y ) = map {
  			( blessed $_ and $_->isa( $numeric_class ) )
  				? $$_
  				: $_;
  		} @_[0, 1];
  		no warnings qw( numeric );
  		defined $x and defined $y and !ref $x and !ref $y and $x == $y;
  	};
  	no strict 'refs';
  	*{"$numeric_class\::MATCH"} = $check;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smartmatch recurses
  
  =head1 NAME
  
  match::simple::sugar - a few extras for match::simple
  
  =head1 SYNOPSIS
  
  This module provides a C<given>/C<when> substitute for L<match::simple>.
  
     use match::simple::sugar;
     
     for ( $var ) {
        when 'foo',        then { ... };
        when 'bar', 'baz', then { ... };
        ...;  # otherwise
     }
  
  It also provides a function for numeric matching (because L<match::simple>
  always assumes you want stringy matching if the right-hand-side is a defined
  non-reference value).
  
     use match::simple::sugar;
     
     for ( $var ) {
        when numeric 0, then { ... };
        when numeric 1, then { ... };
        ...;  # otherwise
     }
  
  
  =head1 DESCRIPTION
  
  This module exports three functions C<when>, C<then>, and C<numeric>,
  and also re-exports C<match> from L<match::simple>.
  
  =head2 C<when> and C<then>
  
  The C<when> and C<then> functions are intended to be used together,
  inside a C<< for ( SCALAR ) { ... } >> block. The block acts as a
  topicalizer (it sets C<< $_ >>) and also a control-flow mechanism
  (C<when> can use C<next> to jump out of it). Any other use of C<when>
  and C<then> is unsupported.
  
  =head3 C<< when( @values, $then ) >>
  
  The C<when> function accepts a list of values, followed by a special
  C<< $then >> argument.
  
  If C<< $_ >> matches (according to the definition in L<match::simple>)
  any of the values, then the C<< $then >> argument will be executed, and
  C<when> will use the Perl built-in C<next> keyword to jump out of the
  surrounding C<for> block.
  
  =head3 C<< then { ... } >>
  
  The C<then> function takes a block of code and returns an object suitable
  for use as C<when>'s C<< $then >> argument.
  
  In the current implementation, the block of code should not inspect
  C<< @_ >> or C<wantarray>, and should not use the C<return>, C<next>,
  C<last>, or C<redo> keywords. (If you set any of the C<PERL_STRICT>,
  C<EXTENDED_TESTING>, C<AUTHOR_TESTING>, or C<RELEASE_TESTING> environment
  variables to true, then match::simple::sugar will I<try> to enforce this!
  This is intended to catch faulty C<then> blocks when running your test
  suite.)
  
  =head2 C<numeric>
  
  The C<numeric> function accepts a number and returns a blessed object
  which has a C<MATCH> method. The C<MATCH> method returns true if it is
  called with a single defined non-referece scalar that is numerically
  equal to the original number passed to C<numeric>. Example:
  
     numeric( '5.0' )->MATCH( '5.000' );    # true
  
  This is intended for use in cases like:
  
     if ( match $var, numeric 1 ) {
        ...;
     }
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-match-simple/issues>.
  
  =head1 SEE ALSO
  
  L<match::simple>.
  
  This module uses L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  This module is inspired by a talk I gave to
  L<Boston.PM|https://boston-pm.github.io/>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MATCH_SIMPLE_SUGAR

$fatpacked{"match/smart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MATCH_SMART';
  package match::smart;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use B qw();
  use Exporter::Tiny;
  use List::Util 1.33 qw( any all );
  use Scalar::Util qw( blessed looks_like_number refaddr );
  
  BEGIN {
  	$match::smart::AUTHORITY = 'cpan:TOBYINK';
  	$match::smart::VERSION   = '0.012';
  }
  
  our @ISA       = qw( Exporter::Tiny );
  our @EXPORT    = qw( M );
  our @EXPORT_OK = qw( match );
  
  sub match {
  	no warnings qw( uninitialized numeric );
  	
  	my ( $a, $b, $seen ) = @_;
  	my $method;
  	
  	return !defined $a                     if !defined( $b );
  	return !!$b->$method( $a, 1 )          if blessed( $b ) && ( $method = _overloaded_smartmatch( $b ) );
  	
  	if ( blessed($b) and not $b->isa("Regexp") ) {
  		require Carp;
  		Carp::croak( "Smart matching a non-overloaded object breaks encapsulation" );
  	}
  	
  	$seen ||= {};
  	my $refb = refaddr($b);
  	return refaddr( $a ) == $refb if $refb && $seen->{$refb}++;
  	
  	if ( ref($b) eq q(ARRAY) ) {
  		if ( ref($a) eq q(ARRAY) ) {
  			return !!0 unless @$a == @$b;
  			for my $i ( 0 .. $#$a ) {
  				return !!0 unless match( $a->[$i], $b->[$i], $seen );
  			}
  			return !!1;
  		}
  		
  		return any { exists $a->{$_} } @$b  if ref( $a ) eq q(HASH);
  		return any { $_ =~ $a } @$b         if ref( $a ) eq q(Regexp);
  		return any { !defined( $_ ) } @$b   if !defined( $a );
  		return any { match( $a, $_ ) } @$b;
  	}
  	
  	if ( ref($b) eq q(HASH) ) {
  		return match( [ sort map "$_", keys %$a ], [ sort map "$_", keys %$b ] )
  			if ref($a) eq q(HASH);
  		
  		return any { exists $b->{$_} } @$a  if ref( $a ) eq q(ARRAY);
  		return any { $_ =~ $a } keys %$b    if ref( $a ) eq q(Regexp);
  		return !!0                          if !defined( $a );
  		return exists $b->{$a};
  	}
  	
  	if ( ref($b) eq q(CODE) ) {
  		return all { !!$b->($_) } @$a       if ref( $a ) eq q(ARRAY);
  		return all { !!$b->($_) } keys %$a  if ref( $a ) eq q(HASH);
  		return $b->( $a );
  	}
  	
  	if ( ref($b) eq q(Regexp) ) {
  		return any { $_ =~ $b } @$a       if ref( $a ) eq q(ARRAY);
  		return any { $_ =~ $b } keys %$a  if ref( $a ) eq q(HASH);
  		return $a =~ $b;
  	}
  	
  	return !!$a->$method( $b, 0 )           if blessed( $a ) && ( $method = _overloaded_smartmatch( $a ) );
  	return !defined( $b )                   if !defined( $a );
  	return $a == $b                         if _is_number( $b );
  	return $a == $b                         if _is_number( $a ) && looks_like_number( $b );
  	
  	return $a eq $b;
  }
  
  sub _is_number {
  	my $value = shift;
  	return if ref $value;
  	my $flags = B::svref_2object( \$value )->FLAGS;
  	$flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK );
  }
  
  sub _generate_M {
  	require Sub::Infix;
  	&Sub::Infix::infix( \&match );
  }
  
  unless ( eval 'require re; 1' and exists &re::is_regexp ) {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object( $_[0] )->MAGIC->TYPE eq 'r' };
  	};
  }
  
  sub _overloaded_smartmatch {
  	my ( $obj ) = @_;
  	return if re::is_regexp( $obj );
  	
  	if ( $obj->isa( 'Type::Tiny' ) ) {
  		return $obj->can( 'check' );
  	}
  	
  	if ( my $match = $obj->can( 'MATCH' ) ) {
  		return $match;
  	}
  	
  	if ( $] lt '5.010' ) { require MRO::Compat; }
  	else                 { require mro;         }
  	
  	my @mro = @{ mro::get_linear_isa( ref $obj ) };
  	for my $class ( @mro ) {
  		my $name = "$class\::(~~";
  		my $overload = do {
  			no strict 'refs';
  			exists( &$name ) ? \&$name : undef;
  		};
  		return $overload if defined $overload;
  	}
  	
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smartmatch recurses
  
  =head1 NAME
  
  match::smart - clone of smartmatch operator
  
  =head1 SYNOPSIS
  
     use v5.10;
     use match::smart;
     
     if ($this |M| $that)
     {
        say "$this matches $that";
     }
  
  =head1 DESCRIPTION
  
  match::smart provides a match operator C<< |M| >> that acts like more or
  less identically to the (as of Perl 5.18) deprecated smart match operator.
  
  If you don't like the crazy L<Sub::Infix> operator, you can alternatively
  export a more normal function:
  
     use v5.10;
     use match::smart qw(match);
     
     if (match($this, $that))
     {
        say "$this matches $that";
     }
  
  =head2 Differences with ~~
  
  There were major changes to smart match between 5.10.0 and 5.10.1. This
  module attempts to emulate the behaviour of the operator in more recent
  versions of Perl. In particular, 5.18.0 (minus the warnings). Divergences
  not noted below should be considered bugs.
  
  While the real smart match operator implicitly takes references to operands
  that are hashes or arrays, match::smart's operator does not.
  
     @foo ~~ %bar       # means: \@foo ~~ \%bar
     @foo |M| %bar      # means: scalar(@foo) |M| scalar(%bar)
  
  If you want the C<< \@foo ~~ \%bar >> behaviour, you need to add the
  backslashes yourself:
  
     \@foo |M| \%bar
  
  Similarly:
  
     "foo" ~~  /foo/    # works
     "foo" |M| /foo/    # no worky!
     "foo" |M| qr/foo/  # do this instead
  
  match::smart treats the C<MATCH> method on blessed objects (if it exists)
  like an overloaded C<< ~~ >>. This is for compatibility with L<match::simple>,
  and for compatibility with versions of Perl that don't have documented support
  for overloading C<< ~~ >>.
  
  =begin trustme
  
  =item M
  
  =item match
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-match-simple/issues>.
  
  =head1 SEE ALSO
  
  L<match::simple>.
  
  This module uses L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017, 2022-2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MATCH_SMART

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  
  our $VERSION = '0.241';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_; # dies if a loop is detected
      };
  };
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<base>
  
  =item L<parent::versioned>
  
  A fork of L<parent> that provides version checking in parent class modules.
  
  =back
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-2017 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"x86_64-linux-gnu-thread-multi/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO';
  #
  
  package IO;
  
  use XSLoader ();
  use Carp;
  use strict;
  use warnings;
  
  our $VERSION = "1.51";
  XSLoader::load 'IO', $VERSION;
  
  sub import {
      shift;
  
      warnings::warnif('deprecated', qq{Parameterless "use IO" deprecated})
          if @_ == 0 ;
      
      my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);
  
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      eval join("", map { "require IO::" . (/(\w+)/)[0] . ";\n" } @l)
  	or croak $@;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO - load various IO modules
  
  =head1 SYNOPSIS
  
     use IO qw(Handle File); # loads IO modules, here IO::Handle, IO::File
     use IO;                 # DEPRECATED
  
  =head1 DESCRIPTION
  
  C<IO> provides a simple mechanism to load several of the IO modules
  in one go.  The IO modules belonging to the core are:
  
        IO::Handle
        IO::Seekable
        IO::File
        IO::Pipe
        IO::Socket
        IO::Dir
        IO::Select
        IO::Poll
  
  Some other IO modules don't belong to the perl core but can be loaded
  as well if they have been installed from CPAN.  You can discover which
  ones exist with this query:  L<https://metacpan.org/search?q=IO%3A%3A>.
  
  For more information on any of these modules, please see its respective
  documentation.
  
  =head1 DEPRECATED
  
      use IO;                # loads all the modules listed below
  
  The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe,
  IO::Socket, IO::Dir.  You should instead explicitly import the IO
  modules you want.
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_IO

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_DIR';
  # IO::Dir.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Dir;
  
  use 5.008_001;
  
  use strict;
  use Carp;
  use Symbol;
  use Exporter;
  use IO::File;
  use Tie::Hash;
  use File::stat;
  use File::Spec;
  
  our @ISA = qw(Tie::Hash Exporter);
  our $VERSION = "1.51";
  
  our @EXPORT_OK = qw(DIR_UNLINK);
  
  sub DIR_UNLINK () { 1 }
  
  sub new {
      @_ >= 1 && @_ <= 2 or croak 'usage: IO::Dir->new([DIRNAME])';
      my $class = shift;
      my $dh = gensym;
      if (@_) {
  	IO::Dir::open($dh, $_[0])
  	    or return undef;
      }
      bless $dh, $class;
  }
  
  sub DESTROY {
      my ($dh) = @_;
      local($., $@, $!, $^E, $?);
      no warnings 'io';
      closedir($dh);
  }
  
  sub open {
      @_ == 2 or croak 'usage: $dh->open(DIRNAME)';
      my ($dh, $dirname) = @_;
      return undef
  	unless opendir($dh, $dirname);
      # a dir name should always have a ":" in it; assume dirname is
      # in current directory
      $dirname = ':' .  $dirname if ( ($^O eq 'MacOS') && ($dirname !~ /:/) );
      ${*$dh}{io_dir_path} = $dirname;
      1;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $dh->close()';
      my ($dh) = @_;
      closedir($dh);
  }
  
  sub read {
      @_ == 1 or croak 'usage: $dh->read()';
      my ($dh) = @_;
      readdir($dh);
  }
  
  sub seek {
      @_ == 2 or croak 'usage: $dh->seek(POS)';
      my ($dh,$pos) = @_;
      seekdir($dh,$pos);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $dh->tell()';
      my ($dh) = @_;
      telldir($dh);
  }
  
  sub rewind {
      @_ == 1 or croak 'usage: $dh->rewind()';
      my ($dh) = @_;
      rewinddir($dh);
  }
  
  sub TIEHASH {
      my($class,$dir,$options) = @_;
  
      my $dh = $class->new($dir)
  	or return undef;
  
      $options ||= 0;
  
      ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;
      $dh;
  }
  
  sub FIRSTKEY {
      my($dh) = @_;
      $dh->rewind;
      scalar $dh->read;
  }
  
  sub NEXTKEY {
      my($dh) = @_;
      scalar $dh->read;
  }
  
  sub EXISTS {
      my($dh,$key) = @_;
      -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  }
  
  sub FETCH {
      my($dh,$key) = @_;
      &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));
  }
  
  sub STORE {
      my($dh,$key,$data) = @_;
      my($atime,$mtime) = ref($data) ? @$data : ($data,$data);
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
      unless(-e $file) {
  	my $io = IO::File->new($file,O_CREAT | O_RDWR);
  	$io->close if $io;
      }
      utime($atime,$mtime, $file);
  }
  
  sub DELETE {
      my($dh,$key) = @_;
  
      # Only unlink if unlink-ing is enabled
      return 0
  	unless ${*$dh}{io_dir_unlink};
  
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  
      -d $file
  	? rmdir($file)
  	: unlink($file);
  }
  
  1;
  
  __END__
  
  =head1 NAME 
  
  IO::Dir - supply object methods for directory handles
  
  =head1 SYNOPSIS
  
      use IO::Dir;
      my $d = IO::Dir->new(".");
      if (defined $d) {
          while (defined($_ = $d->read)) { something($_); }
          $d->rewind;
          while (defined($_ = $d->read)) { something_else($_); }
          undef $d;
      }
  
      tie my %dir, 'IO::Dir', ".";
      foreach (keys %dir) {
  	print $_, " " , $dir{$_}->size,"\n";
      }
  
  =head1 DESCRIPTION
  
  The C<IO::Dir> package provides two interfaces to perl's directory reading
  routines.
  
  The first interface is an object approach. C<IO::Dir> provides an object
  constructor and methods, which are just wrappers around perl's built in
  directory reading routines.
  
  =over 4
  
  =item new ( [ DIRNAME ] )
  
  C<new> is the constructor for C<IO::Dir> objects. It accepts one optional
  argument which,  if given, C<new> will pass to C<open>
  
  =back
  
  The following methods are wrappers for the directory related functions built
  into perl (the trailing 'dir' has been removed from the names). See L<perlfunc>
  for details of these functions.
  
  =over 4
  
  =item open ( DIRNAME )
  
  =item read ()
  
  =item seek ( POS )
  
  =item tell ()
  
  =item rewind ()
  
  =item close ()
  
  =back
  
  C<IO::Dir> also provides an interface to reading directories via a tied
  hash. The tied hash extends the interface beyond just the directory
  reading routines by the use of C<lstat>, from the C<File::stat> package,
  C<unlink>, C<rmdir> and C<utime>.
  
  =over 4
  
  =item tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]
  
  =back
  
  The keys of the hash will be the names of the entries in the directory. 
  Reading a value from the hash will be the result of calling
  C<File::stat::lstat>.  Deleting an element from the hash will 
  delete the corresponding file or subdirectory,
  provided that C<DIR_UNLINK> is included in the C<OPTIONS>.
  
  Assigning to an entry in the hash will cause the time stamps of the file
  to be modified. If the file does not exist then it will be created. Assigning
  a single integer to a hash element will cause both the access and 
  modification times to be changed to that value. Alternatively a reference to
  an array of two values can be passed. The first array element will be used to
  set the access time and the second element will be used to set the modification
  time.
  
  =head1 SEE ALSO
  
  L<File::stat>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_DIR

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_FILE';
  #
  
  package IO::File;
  
  =head1 NAME
  
  IO::File - supply object methods for filehandles
  
  =head1 SYNOPSIS
  
      use IO::File;
  
      my $fh = IO::File->new();
      if ($fh->open("< file")) {
          print <$fh>;
          $fh->close;
      }
  
      my $fh = IO::File->new("> file");
      if (defined $fh) {
          print $fh "bar\n";
          $fh->close;
      }
  
      my $fh = IO::File->new("file", "r");
      if (defined $fh) {
          print <$fh>;
          undef $fh;       # automatically closes the file
      }
  
      my $fh = IO::File->new("file", O_WRONLY|O_APPEND);
      if (defined $fh) {
          print $fh "corge\n";
  
          my $pos = $fh->getpos;
          $fh->setpos($pos);
  
          undef $fh;       # automatically closes the file
      }
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::File> inherits from C<IO::Handle> and C<IO::Seekable>. It extends
  these classes with methods that are specific to file handles.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( FILENAME [,MODE [,PERMS]] )
  
  Creates an C<IO::File>.  If it receives any parameters, they are passed to
  the method C<open>; if the open fails, the object is destroyed.  Otherwise,
  it is returned to the caller.
  
  =item new_tmpfile
  
  Creates an C<IO::File> opened for read/write on a newly created temporary
  file.  On systems where this is possible, the temporary file is anonymous
  (i.e. it is unlinked after creation, but held open).  If the temporary
  file cannot be created or opened, the C<IO::File> object is destroyed.
  Otherwise, it is returned to the caller.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item open( FILENAME [,MODE [,PERMS]] )
  
  =item open( FILENAME, IOLAYERS )
  
  C<open> accepts one, two or three parameters.  With one parameter,
  it is just a front end for the built-in C<open> function.  With two or three
  parameters, the first parameter is a filename that may include
  whitespace or other special characters, and the second parameter is
  the open mode, optionally followed by a file permission value.
  
  If C<IO::File::open> receives a Perl mode string ("E<gt>", "+E<lt>", etc.)
  or an ANSI C fopen() mode string ("w", "r+", etc.), it uses the basic
  Perl C<open> operator (but protects any special characters).
  
  If C<IO::File::open> is given a numeric mode, it passes that mode
  and the optional permissions value to the Perl C<sysopen> operator.
  The permissions default to 0666.
  
  If C<IO::File::open> is given a mode that includes the C<:> character,
  it passes all the three arguments to the three-argument C<open> operator.
  
  For convenience, C<IO::File> exports the O_XXX constants from the
  Fcntl module, if this module is available.
  
  =item binmode( [LAYER] )
  
  C<binmode> sets C<binmode> on the underlying C<IO> object, as documented
  in C<perldoc -f binmode>.
  
  C<binmode> accepts one optional parameter, which is the layer to be
  passed on to the C<binmode> call.
  
  =back
  
  =head1 NOTE
  
  Some operating systems may perform  C<IO::File::new()> or C<IO::File::open()>
  on a directory without errors.  This behavior is not portable and not
  suggested for use.  Using C<opendir()> and C<readdir()> or C<IO::Dir> are
  suggested instead.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>,
  L<IO::Seekable>,
  L<IO::Dir>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>.
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO::Seekable;
  
  require Exporter;
  
  our @ISA = qw(IO::Handle IO::Seekable Exporter);
  
  our $VERSION = "1.51";
  
  our @EXPORT = @IO::Seekable::EXPORT;
  
  eval {
      # Make all Fcntl O_XXX constants available for importing
      require Fcntl;
      my @O = grep /^O_/, @Fcntl::EXPORT;
      Fcntl->import(@O);  # first we import what we want to export
      push(@EXPORT, @O);
  };
  
  ################################################
  ## Constructor
  ##
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::File";
      @_ >= 0 && @_ <= 3
  	or croak "usage: $class->new([FILENAME [,MODE [,PERMS]]])";
      my $fh = $class->SUPER::new();
      if (@_) {
  	$fh->open(@_)
  	    or return undef;
      }
      $fh;
  }
  
  ################################################
  ## Open
  ##
  
  sub open {
      @_ >= 2 && @_ <= 4 or croak 'usage: $fh->open(FILENAME [,MODE [,PERMS]])';
      my ($fh, $file) = @_;
      if (@_ > 2) {
  	my ($mode, $perms) = @_[2, 3];
  	if ($mode =~ /^\d+$/) {
  	    defined $perms or $perms = 0666;
  	    return sysopen($fh, $file, $mode, $perms);
  	} elsif ($mode =~ /:/) {
  	    return open($fh, $mode, $file) if @_ == 3;
  	    croak 'usage: $fh->open(FILENAME, IOLAYERS)';
  	} else {
              return open($fh, IO::Handle::_open_mode_string($mode), $file);
          }
      }
      open($fh, $file);
  }
  
  ################################################
  ## Binmode
  ##
  
  sub binmode {
      ( @_ == 1 or @_ == 2 ) or croak 'usage $fh->binmode([LAYER])';
  
      my($fh, $layer) = @_;
  
      return binmode $$fh unless $layer;
      return binmode $$fh, $layer;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_FILE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_HANDLE';
  package IO::Handle;
  
  =head1 NAME
  
  IO::Handle - supply object methods for I/O handles
  
  =head1 SYNOPSIS
  
      use IO::Handle;
  
      my $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDIN),"r")) {
          print $io->getline;
          $io->close;
      }
  
      my $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDOUT),"w")) {
          $io->print("Some text\n");
      }
  
      # setvbuf is not available by default on Perls 5.8.0 and later.
      use IO::Handle '_IOLBF';
      $io->setvbuf(my $buffer_var, _IOLBF, 1024);
  
      undef $io;       # automatically closes the file if it's open
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::Handle> is the base class for all other IO handle classes. It is
  not intended that objects of C<IO::Handle> would be created directly,
  but instead C<IO::Handle> is inherited from by several other classes
  in the IO hierarchy.
  
  If you are reading this documentation, looking for a replacement for
  the C<FileHandle> package, then I suggest you read the documentation
  for C<IO::File> too.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ()
  
  Creates a new C<IO::Handle> object.
  
  =item new_from_fd ( FD, MODE )
  
  Creates an C<IO::Handle> like C<new> does.
  It requires two parameters, which are passed to the method C<fdopen>;
  if the fdopen fails, the object is destroyed. Otherwise, it is returned
  to the caller.
  
  =back
  
  =head1 METHODS
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Handle> methods, which are just front ends for the
  corresponding built-in functions:
  
      $io->close
      $io->eof
      $io->fcntl( FUNCTION, SCALAR )
      $io->fileno
      $io->format_write( [FORMAT_NAME] )
      $io->getc
      $io->ioctl( FUNCTION, SCALAR )
      $io->read ( BUF, LEN, [OFFSET] )
      $io->print ( ARGS )
      $io->printf ( FMT, [ARGS] )
      $io->say ( ARGS )
      $io->stat
      $io->sysread ( BUF, LEN, [OFFSET] )
      $io->syswrite ( BUF, [LEN, [OFFSET]] )
      $io->truncate ( LEN )
  
  See L<perlvar> for complete descriptions of each of the following
  supported C<IO::Handle> methods.  All of them return the previous
  value of the attribute and takes an optional single argument that when
  given will set the value.  If no argument is given the previous value
  is unchanged (except for $io->autoflush will actually turn ON
  autoflush by default).
  
      $io->autoflush ( [BOOL] )                         $|
      $io->format_page_number( [NUM] )                  $%
      $io->format_lines_per_page( [NUM] )               $=
      $io->format_lines_left( [NUM] )                   $-
      $io->format_name( [STR] )                         $~
      $io->format_top_name( [STR] )                     $^
      $io->input_line_number( [NUM])                    $.
  
  The following methods are not supported on a per-filehandle basis.
  
      IO::Handle->format_line_break_characters( [STR] ) $:
      IO::Handle->format_formfeed( [STR])               $^L
      IO::Handle->output_field_separator( [STR] )       $,
      IO::Handle->output_record_separator( [STR] )      $\
  
      IO::Handle->input_record_separator( [STR] )       $/
  
  Furthermore, for doing normal I/O you might need these:
  
  =over 4
  
  =item $io->fdopen ( FD, MODE )
  
  C<fdopen> is like an ordinary C<open> except that its first parameter
  is not a filename but rather a file handle name, an IO::Handle object,
  or a file descriptor number.  (For the documentation of the C<open>
  method, see L<IO::File>.)
  
  =item $io->opened
  
  Returns true if the object is currently a valid file descriptor, false
  otherwise.
  
  =item $io->getline
  
  This works like <$io> described in L<perlop/"I/O Operators">
  except that it's more readable and can be safely called in a
  list context but still returns just one line.  If used as the conditional
  within a C<while> or C-style C<for> loop, however, you will need to
  emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.
  
  =item $io->getlines
  
  This works like <$io> when called in a list context to read all
  the remaining lines in a file, except that it's more readable.
  It will also croak() if accidentally called in a scalar context.
  
  =item $io->ungetc ( ORD )
  
  Pushes a character with the given ordinal value back onto the given
  handle's input stream.  Only one character of pushback per handle is
  guaranteed.
  
  =item $io->write ( BUF, LEN [, OFFSET ] )
  
  This C<write> is somewhat like C<write> found in C, in that it is the
  opposite of read. The wrapper for the perl C<write> function is
  called C<format_write>. However, whilst the C C<write> function returns
  the number of bytes written, this C<write> function simply returns true
  if successful (like C<print>). A more C-like C<write> is C<syswrite>
  (see above).
  
  =item $io->error
  
  Returns a true value if the given handle has experienced any errors
  since it was opened or since the last call to C<clearerr>, or if the
  handle is invalid. It only returns false for a valid handle with no
  outstanding errors.
  
  =item $io->clearerr
  
  Clear the given handle's error indicator. Returns -1 if the handle is
  invalid, 0 otherwise.
  
  =item $io->sync
  
  C<sync> synchronizes a file's in-memory state  with  that  on the
  physical medium. C<sync> does not operate at the perlio api level, but
  operates on the file descriptor (similar to sysread, sysseek and
  systell). This means that any data held at the perlio api level will not
  be synchronized. To synchronize data that is buffered at the perlio api
  level you must use the flush method. C<sync> is not implemented on all
  platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
  for an invalid handle. See L<fsync(3c)>.
  
  =item $io->flush
  
  C<flush> causes perl to flush any buffered data at the perlio api level.
  Any unread data in the buffer will be discarded, and any unwritten data
  will be written to the underlying file descriptor. Returns "0 but true"
  on success, C<undef> on error.
  
  =item $io->printflush ( ARGS )
  
  Turns on autoflush, print ARGS and then restores the autoflush status of the
  C<IO::Handle> object. Returns the return value from print.
  
  =item $io->blocking ( [ BOOL ] )
  
  If called with an argument C<blocking> will turn on non-blocking IO if
  C<BOOL> is false, and turn it off if C<BOOL> is true.
  
  C<blocking> will return the value of the previous setting, or the
  current setting if C<BOOL> is not given. 
  
  If an error occurs C<blocking> will return undef and C<$!> will be set.
  
  =back
  
  
  If the C functions setbuf() and/or setvbuf() are available, then
  C<IO::Handle::setbuf> and C<IO::Handle::setvbuf> set the buffering
  policy for an IO::Handle.  The calling sequences for the Perl functions
  are the same as their C counterparts--including the constants C<_IOFBF>,
  C<_IOLBF>, and C<_IONBF> for setvbuf()--except that the buffer parameter
  specifies a scalar variable to use as a buffer. You should only
  change the buffer before any I/O, or immediately after calling flush.
  
  WARNING: The IO::Handle::setvbuf() is not available by default on
  Perls 5.8.0 and later because setvbuf() is rather specific to using
  the stdio library, while Perl prefers the new perlio subsystem instead.
  
  WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
  be modified> in any way until the IO::Handle is closed or C<setbuf> or
  C<setvbuf> is called again, or memory corruption may result! Remember that
  the order of global destruction is undefined, so even if your buffer
  variable remains in scope until program termination, it may be undefined
  before the file IO::Handle is closed. Note that you need to import the
  constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
  returns nothing. setvbuf returns "0 but true", on success, C<undef> on
  failure.
  
  Lastly, there is a special method for working under B<-T> and setuid/gid
  scripts:
  
  =over 4
  
  =item $io->untaint
  
  Marks the object as taint-clean, and as such data read from it will also
  be considered taint-clean. Note that this is a very trusting action to
  take, and appropriate consideration for the data source and potential
  vulnerability should be kept in mind. Returns 0 on success, -1 if setting
  the taint-clean flag failed. (eg invalid handle)
  
  =back
  
  =head1 NOTE
  
  An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
  the L<Symbol> package).  Some modules that
  inherit from C<IO::Handle> may want to keep object related variables
  in the hash table part of the GLOB. In an attempt to prevent modules
  trampling on each other I propose the that any such module should prefix
  its variables with its own name separated by _'s. For example the IO::Socket
  module keeps a C<timeout> variable in 'io_socket_timeout'.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::File>
  
  =head1 BUGS
  
  Due to backwards compatibility, all filehandles resemble objects
  of class C<IO::Handle>, or actually classes derived from that class.
  They actually aren't.  Which means you can't derive your own 
  class from C<IO::Handle> and inherit those methods.
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO ();	# Load the XS module
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.51";
  
  our @EXPORT_OK = qw(
      autoflush
      output_field_separator
      output_record_separator
      input_record_separator
      input_line_number
      format_page_number
      format_lines_per_page
      format_lines_left
      format_name
      format_top_name
      format_line_break_characters
      format_formfeed
      format_write
  
      print
      printf
      say
      getline
      getlines
  
      printflush
      flush
  
      SEEK_SET
      SEEK_CUR
      SEEK_END
      _IOFBF
      _IOLBF
      _IONBF
  );
  
  ################################################
  ## Constructors, destructors.
  ##
  
  sub new {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      if (@_ != 1) {
  	# Since perl will automatically require IO::File if needed, but
  	# also initialises IO::File's @ISA as part of the core we must
  	# ensure IO::File is loaded if IO::Handle is. This avoids effect-
  	# ively "half-loading" IO::File.
  	if ($] > 5.013 && $class eq 'IO::File' && !$INC{"IO/File.pm"}) {
  	    require IO::File;
  	    shift;
  	    return IO::File::->new(@_);
  	}
  	croak "usage: $class->new()";
      }
      my $io = gensym;
      bless $io, $class;
  }
  
  sub new_from_fd {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      @_ == 3 or croak "usage: $class->new_from_fd(FD, MODE)";
      my $io = gensym;
      shift;
      IO::Handle::fdopen($io, @_)
  	or return undef;
      bless $io, $class;
  }
  
  #
  # There is no need for DESTROY to do anything, because when the
  # last reference to an IO object is gone, Perl automatically
  # closes its associated files (if any).  However, to avoid any
  # attempts to autoload DESTROY, we here define it to do nothing.
  #
  sub DESTROY {}
  
  
  ################################################
  ## Open and close.
  ##
  
  sub _open_mode_string {
      my ($mode) = @_;
      $mode =~ /^\+?(<|>>?)$/
        or $mode =~ s/^r(\+?)$/$1</
        or $mode =~ s/^w(\+?)$/$1>/
        or $mode =~ s/^a(\+?)$/$1>>/
        or croak "IO::Handle: bad open mode: $mode";
      $mode;
  }
  
  sub fdopen {
      @_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
      my ($io, $fd, $mode) = @_;
      local(*GLOB);
  
      if (ref($fd) && "$fd" =~ /GLOB\(/o) {
  	# It's a glob reference; Alias it as we cannot get name of anon GLOBs
  	my $n = qualify(*GLOB);
  	*GLOB = *{*$fd};
  	$fd =  $n;
      } elsif ($fd =~ m#^\d+$#) {
  	# It's an FD number; prefix with "=".
  	$fd = "=$fd";
      }
  
      open($io, _open_mode_string($mode) . '&' . $fd)
  	? $io : undef;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $io->close()';
      my($io) = @_;
  
      close($io);
  }
  
  ################################################
  ## Normal I/O functions.
  ##
  
  # flock
  # select
  
  sub opened {
      @_ == 1 or croak 'usage: $io->opened()';
      defined fileno($_[0]);
  }
  
  sub fileno {
      @_ == 1 or croak 'usage: $io->fileno()';
      fileno($_[0]);
  }
  
  sub getc {
      @_ == 1 or croak 'usage: $io->getc()';
      getc($_[0]);
  }
  
  sub eof {
      @_ == 1 or croak 'usage: $io->eof()';
      eof($_[0]);
  }
  
  sub print {
      @_ or croak 'usage: $io->print(ARGS)';
      my $this = shift;
      print $this @_;
  }
  
  sub printf {
      @_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
      my $this = shift;
      printf $this @_;
  }
  
  sub say {
      @_ or croak 'usage: $io->say(ARGS)';
      my $this = shift;
      local $\ = "\n";
      print $this @_;
  }
  
  sub truncate {
      @_ == 2 or croak 'usage: $io->truncate(LEN)';
      truncate($_[0], $_[1]);
  }
  
  sub read {
      @_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
      read($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub sysread {
      @_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
      sysread($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub write {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
      local($\) = "";
      $_[2] = length($_[1]) unless defined $_[2];
      print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
  }
  
  sub syswrite {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
      if (defined($_[2])) {
  	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
      } else {
  	syswrite($_[0], $_[1]);
      }
  }
  
  sub stat {
      @_ == 1 or croak 'usage: $io->stat()';
      stat($_[0]);
  }
  
  ################################################
  ## State modification functions.
  ##
  
  sub autoflush {
      my $old = SelectSaver->new(qualify($_[0], caller));
      my $prev = $|;
      $| = @_ > 1 ? $_[1] : 1;
      $prev;
  }
  
  sub output_field_separator {
      carp "output_field_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $,;
      $, = $_[1] if @_ > 1;
      $prev;
  }
  
  sub output_record_separator {
      carp "output_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $\;
      $\ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_record_separator {
      carp "input_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $/;
      $/ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_line_number {
      local $.;
      () = tell qualify($_[0], caller) if ref($_[0]);
      my $prev = $.;
      $. = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_page_number {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $%;
      $% = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_per_page {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $=;
      $= = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_left {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $-;
      $- = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $~;
      $~ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_top_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $^;
      $^ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_line_break_characters {
      carp "format_line_break_characters is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $:;
      $: = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_formfeed {
      carp "format_formfeed is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $^L;
      $^L = $_[1] if @_ > 1;
      $prev;
  }
  
  sub formline {
      my $io = shift;
      my $picture = shift;
      local($^A) = $^A;
      local($\) = "";
      formline($picture, @_);
      print $io $^A;
  }
  
  sub format_write {
      @_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
      if (@_ == 2) {
  	my ($io, $fmt) = @_;
  	my $oldfmt = $io->format_name(qualify($fmt,caller));
  	CORE::write($io);
  	$io->format_name($oldfmt);
      } else {
  	CORE::write($_[0]);
      }
  }
  
  sub fcntl {
      @_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
      my ($io, $op) = @_;
      return fcntl($io, $op, $_[2]);
  }
  
  sub ioctl {
      @_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
      my ($io, $op) = @_;
      return ioctl($io, $op, $_[2]);
  }
  
  # this sub is for compatibility with older releases of IO that used
  # a sub called constant to determine if a constant existed -- GMB
  #
  # The SEEK_* and _IO?BF constants were the only constants at that time
  # any new code should just check defined(&CONSTANT_NAME)
  
  sub constant {
      no strict 'refs';
      my $name = shift;
      (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
  	? &{$name}() : undef;
  }
  
  
  # so that flush.pl can be deprecated
  
  sub printflush {
      my $io = shift;
      my $old;
      $old = SelectSaver->new(qualify($io, caller)) if ref($io);
      local $| = 1;
      if(ref($io)) {
          print $io @_;
      }
      else {
  	print @_;
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_HANDLE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_PIPE';
  # IO::Pipe.pm
  #
  # Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Pipe;
  
  use 5.008_001;
  
  use IO::Handle;
  use strict;
  use Carp;
  use Symbol;
  
  our $VERSION = "1.51";
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::Pipe";
      @_ == 0 || @_ == 2 or croak "usage: $class->([READFH, WRITEFH])";
  
      my $me = bless gensym(), $class;
  
      my($readfh,$writefh) = @_ ? @_ : $me->handles;
  
      pipe($readfh, $writefh)
  	or return undef;
  
      @{*$me} = ($readfh, $writefh);
  
      $me;
  }
  
  sub handles {
      @_ == 1 or croak 'usage: $pipe->handles()';
      (IO::Pipe::End->new(), IO::Pipe::End->new());
  }
  
  my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';
  
  sub _doit {
      my $me = shift;
      my $rw = shift;
  
      my $pid = $do_spawn ? 0 : fork();
  
      if($pid) { # Parent
          return $pid;
      }
      elsif(defined $pid) { # Child or spawn
          my $fh;
          my $io = $rw ? \*STDIN : \*STDOUT;
          my ($mode, $save) = $rw ? "r" : "w";
          if ($do_spawn) {
            require Fcntl;
            $save = IO::Handle->new_from_fd($io, $mode);
  	  my $handle = shift;
            # Close in child:
  	  unless ($^O eq 'MSWin32') {
              fcntl($handle, Fcntl::F_SETFD(), 1) or croak "fcntl: $!";
  	  }
            $fh = $rw ? ${*$me}[0] : ${*$me}[1];
          } else {
            shift;
            $fh = $rw ? $me->reader() : $me->writer(); # close the other end
          }
          bless $io, "IO::Handle";
          $io->fdopen($fh, $mode);
  	$fh->close;
  
          if ($do_spawn) {
            $pid = eval { system 1, @_ }; # 1 == P_NOWAIT
            my $err = $!;
      
            $io->fdopen($save, $mode);
            $save->close or croak "Cannot close $!";
            croak "IO::Pipe: Cannot spawn-NOWAIT: $err" if not $pid or $pid < 0;
            return $pid;
          } else {
            exec @_ or
              croak "IO::Pipe: Cannot exec: $!";
          }
      }
      else {
          croak "IO::Pipe: Cannot fork: $!";
      }
  
      # NOT Reached
  }
  
  sub reader {
      @_ >= 1 or croak 'usage: $pipe->reader( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[0];
      my $pid;
      $pid = $me->_doit(0, $fh, @_)
          if(@_);
  
      close ${*$me}[1];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"r")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  sub writer {
      @_ >= 1 or croak 'usage: $pipe->writer( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[1];
      my $pid;
      $pid = $me->_doit(1, $fh, @_)
          if(@_);
  
      close ${*$me}[0];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"w")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  package IO::Pipe::End;
  
  our(@ISA);
  
  @ISA = qw(IO::Handle);
  
  sub close {
      my $fh = shift;
      my $r = $fh->SUPER::close(@_);
  
      waitpid(${*$fh}{'io_pipe_pid'},0)
  	if(defined ${*$fh}{'io_pipe_pid'});
  
      $r;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pipe - supply object methods for pipes
  
  =head1 SYNOPSIS
  
  	use IO::Pipe;
  
  	$pipe = IO::Pipe->new();
  
  	if($pid = fork()) { # Parent
  	    $pipe->reader();
  
  	    while(<$pipe>) {
  		...
  	    }
  
  	}
  	elsif(defined $pid) { # Child
  	    $pipe->writer();
  
  	    print $pipe ...
  	}
  
  	or
  
  	$pipe = IO::Pipe->new();
  
  	$pipe->reader(qw(ls -l));
  
  	while(<$pipe>) {
  	    ...
  	}
  
  =head1 DESCRIPTION
  
  C<IO::Pipe> provides an interface to creating pipes between
  processes.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [READER, WRITER] )
  
  Creates an C<IO::Pipe>, which is a reference to a newly created symbol
  (see the L<Symbol> package). C<IO::Pipe::new> optionally takes two
  arguments, which should be objects blessed into C<IO::Handle>, or a
  subclass thereof. These two objects will be used for the system call
  to C<pipe>. If no arguments are given then method C<handles> is called
  on the new C<IO::Pipe> object.
  
  These two handles are held in the array part of the GLOB until either
  C<reader> or C<writer> is called.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item reader ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the reading end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item writer ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the writing end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item handles ()
  
  This method is called during construction by C<IO::Pipe::new>
  on the newly created C<IO::Pipe> object. It returns an array of two objects
  blessed into C<IO::Pipe::End>, or a subclass thereof.
  
  =back
  
  =head1 SEE ALSO
  
  L<IO::Handle>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_PIPE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_POLL';
  
  # IO::Poll.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Poll;
  
  use strict;
  use IO::Handle;
  use Exporter ();
  
  our @ISA = qw(Exporter);
  our $VERSION = "1.51";
  
  our @EXPORT = qw( POLLIN
  	      POLLOUT
  	      POLLERR
  	      POLLHUP
  	      POLLNVAL
  	    );
  
  our @EXPORT_OK = qw(
   POLLPRI
   POLLRDNORM
   POLLWRNORM
   POLLRDBAND
   POLLWRBAND
   POLLNORM
  	       );
  
  # [0] maps fd's to requested masks
  # [1] maps fd's to returned  masks
  # [2] maps fd's to handles
  sub new {
      my $class = shift;
  
      my $self = bless [{},{},{}], $class;
  
      $self;
  }
  
  sub mask {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      return unless defined $fd;
      if (@_) {
  	my $mask = shift;
  	if($mask) {
  	  $self->[0]{$fd}{$io} = $mask; # the error events are always returned
  	  $self->[1]{$fd}      = 0;     # output mask
  	  $self->[2]{$io}      = $io;   # remember handle
  	} else {
            delete $self->[0]{$fd}{$io};
            unless(%{$self->[0]{$fd}}) {
              # We no longer have any handles for this FD
              delete $self->[1]{$fd};
              delete $self->[0]{$fd};
            }
            delete $self->[2]{$io};
  	}
      }
      
      return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
  	return $self->[0]{$fd}{$io};
  }
  
  
  sub poll {
      my($self,$timeout) = @_;
  
      $self->[1] = {};
  
      my($fd,$mask,$iom);
      my @poll = ();
  
      while(($fd,$iom) = each %{$self->[0]}) {
  	$mask   = 0;
  	$mask  |= $_ for values(%$iom);
  	push(@poll,$fd => $mask);
      }
  
      my $ret = _poll(defined($timeout) ? $timeout * 1000 : -1,@poll);
  
      return $ret
  	unless $ret > 0;
  
      while(@poll) {
  	my($fd,$got) = splice(@poll,0,2);
  	$self->[1]{$fd} = $got if $got;
      }
  
      return $ret;  
  }
  
  sub events {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
                  ? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
  	: 0;
  }
  
  sub remove {
      my $self = shift;
      my $io = shift;
      $self->mask($io,0);
  }
  
  sub handles {
      my $self = shift;
      return values %{$self->[2]} unless @_;
  
      my $events = shift || 0;
      my($fd,$ev,$io,$mask);
      my @handles = ();
  
      while(($fd,$ev) = each %{$self->[1]}) {
  	while (($io,$mask) = each %{$self->[0]{$fd}}) {
  	    $mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
  	    push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
  	}
      }
      return @handles;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Poll - Object interface to system poll call
  
  =head1 SYNOPSIS
  
      use IO::Poll qw(POLLRDNORM POLLWRNORM POLLIN POLLHUP);
  
      $poll = IO::Poll->new();
  
      $poll->mask($input_handle => POLLIN);
      $poll->mask($output_handle => POLLOUT);
  
      $poll->poll($timeout);
  
      $ev = $poll->events($input);
  
  =head1 DESCRIPTION
  
  C<IO::Poll> is a simple interface to the system level poll routine.
  
  =head1 METHODS
  
  =over 4
  
  =item mask ( IO [, EVENT_MASK ] )
  
  If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the
  list of file descriptors and the next call to poll will check for
  any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be
  removed from the list of file descriptors.
  
  If EVENT_MASK is not given then the return value will be the current
  event mask value for IO.
  
  =item poll ( [ TIMEOUT ] )
  
  Call the system level poll routine. If TIMEOUT is not specified then the
  call will block. Returns the number of handles which had events
  happen, or -1 on error.
  
  =item events ( IO )
  
  Returns the event mask which represents the events that happened on IO
  during the last call to C<poll>.
  
  =item remove ( IO )
  
  Remove IO from the list of file descriptors for the next poll.
  
  =item handles( [ EVENT_MASK ] )
  
  Returns a list of handles. If EVENT_MASK is not given then a list of all
  handles known will be returned. If EVENT_MASK is given then a list
  of handles will be returned which had one of the events specified by
  EVENT_MASK happen during the last call ti C<poll>
  
  =back
  
  =head1 SEE ALSO
  
  L<poll(2)>, L<IO::Handle>, L<IO::Select>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_POLL

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Seekable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SEEKABLE';
  #
  
  package IO::Seekable;
  
  =head1 NAME
  
  IO::Seekable - supply seek based methods for I/O objects
  
  =head1 SYNOPSIS
  
      use IO::Seekable;
      package IO::Something;
      @ISA = qw(IO::Seekable);
  
  =head1 DESCRIPTION
  
  C<IO::Seekable> does not have a constructor of its own as it is intended to
  be inherited by other C<IO::Handle> based objects. It provides methods
  which allow seeking of the file descriptors.
  
  =over 4
  
  =item $io->getpos
  
  Returns an opaque value that represents the current position of the
  IO::File, or C<undef> if this is not possible (eg an unseekable stream such
  as a terminal, pipe or socket). If the fgetpos() function is available in
  your C library it is used to implements getpos, else perl emulates getpos
  using C's ftell() function.
  
  =item $io->setpos
  
  Uses the value of a previous getpos call to return to a previously visited
  position. Returns "0 but true" on success, C<undef> on failure.
  
  =back
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Seekable> methods, which are just front ends for the
  corresponding built-in functions:
  
  =over 4
  
  =item $io->seek ( POS, WHENCE )
  
  Seek the IO::File to position POS, relative to WHENCE:
  
  =over 8
  
  =item WHENCE=0 (SEEK_SET)
  
  POS is absolute position. (Seek relative to the start of the file)
  
  =item WHENCE=1 (SEEK_CUR)
  
  POS is an offset from the current position. (Seek relative to current)
  
  =item WHENCE=2 (SEEK_END)
  
  POS is an offset from the end of the file. (Seek relative to end)
  
  =back
  
  The SEEK_* constants can be imported from the C<Fcntl> module if you
  don't wish to use the numbers C<0> C<1> or C<2> in your code.
  
  Returns C<1> upon success, C<0> otherwise.
  
  =item $io->sysseek( POS, WHENCE )
  
  Similar to $io->seek, but sets the IO::File's position using the system
  call lseek(2) directly, so will confuse most perl IO operators except
  sysread and syswrite (see L<perlfunc> for full details)
  
  Returns the new position, or C<undef> on failure.  A position
  of zero is returned as the string C<"0 but true">
  
  =item $io->tell
  
  Returns the IO::File's current position, or -1 on error.
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>
  L<IO::File>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>gbarr@pobox.comE<gt>
  
  =cut
  
  use 5.008_001;
  use Carp;
  use strict;
  use IO::Handle ();
  # XXX we can't get these from IO::Handle or we'll get prototype
  # mismatch warnings on C<use POSIX; use IO::File;> :-(
  use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
  require Exporter;
  
  our @EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.51";
  
  sub seek {
      @_ == 3 or croak 'usage: $io->seek(POS, WHENCE)';
      seek($_[0], $_[1], $_[2]);
  }
  
  sub sysseek {
      @_ == 3 or croak 'usage: $io->sysseek(POS, WHENCE)';
      sysseek($_[0], $_[1], $_[2]);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $io->tell()';
      tell($_[0]);
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_SEEKABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SELECT';
  # IO::Select.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Select;
  
  use     strict;
  use warnings::register;
  require Exporter;
  
  our $VERSION = "1.51";
  
  our @ISA = qw(Exporter); # This is only so we can do version checking
  
  sub VEC_BITS () {0}
  sub FD_COUNT () {1}
  sub FIRST_FD () {2}
  
  sub new
  {
   my $self = shift;
   my $type = ref($self) || $self;
  
   my $vec = bless [undef,0], $type;
  
   $vec->add(@_)
      if @_;
  
   $vec;
  }
  
  sub add
  {
   shift->_update('add', @_);
  }
  
  
  sub remove
  {
   shift->_update('remove', @_);
  }
  
  
  sub exists
  {
   my $vec = shift;
   my $fno = $vec->_fileno(shift);
   return undef unless defined $fno;
   $vec->[$fno + FIRST_FD];
  }
  
  
  sub _fileno
  {
   my($self, $f) = @_;
   return unless defined $f;
   $f = $f->[0] if ref($f) eq 'ARRAY';
   if($f =~ /^[0-9]+$/) { # plain file number
    return $f;
   }
   elsif(defined(my $fd = fileno($f))) {
    return $fd;
   }
   else {
    # Neither a plain file number nor an opened filehandle; but maybe it was
    # previously registered and has since been closed. ->remove still wants to
    # know what fileno it had
    foreach my $i ( FIRST_FD .. $#$self ) {
     return $i - FIRST_FD if defined $self->[$i] && $self->[$i] == $f;
    }
    return undef;
   }
  }
  
  sub _update
  {
   my $vec = shift;
   my $add = shift eq 'add';
  
   my $bits = $vec->[VEC_BITS];
   $bits = '' unless defined $bits;
  
   my $count = 0;
   my $f;
   foreach $f (@_)
    {
     my $fn = $vec->_fileno($f);
     if ($add) {
       next unless defined $fn;
       my $i = $fn + FIRST_FD;
       if (defined $vec->[$i]) {
  	 $vec->[$i] = $f;  # if array rest might be different, so we update
  	 next;
       }
       $vec->[FD_COUNT]++;
       vec($bits, $fn, 1) = 1;
       $vec->[$i] = $f;
     } else {      # remove
       if ( ! defined $fn ) { # remove if fileno undef'd
         $fn = 0;
         for my $fe (@{$vec}[FIRST_FD .. $#$vec]) {
           if (defined($fe) && $fe == $f) {
  	   $vec->[FD_COUNT]--;
  	   $fe = undef;
  	   vec($bits, $fn, 1) = 0;
  	   last;
  	 }
  	 ++$fn;
         }
       }
       else {
         my $i = $fn + FIRST_FD;
         next unless defined $vec->[$i];
         $vec->[FD_COUNT]--;
         vec($bits, $fn, 1) = 0;
         $vec->[$i] = undef;
       }
     }
     $count++;
    }
   $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
   $count;
  }
  
  sub can_read
  {
   my $vec = shift;
   my $timeout = shift;
   my $r = $vec->[VEC_BITS];
  
   defined($r) && (select($r,undef,undef,$timeout) > 0)
      ? handles($vec, $r)
      : ();
  }
  
  sub can_write
  {
   my $vec = shift;
   my $timeout = shift;
   my $w = $vec->[VEC_BITS];
  
   defined($w) && (select(undef,$w,undef,$timeout) > 0)
      ? handles($vec, $w)
      : ();
  }
  
  sub has_exception
  {
   my $vec = shift;
   my $timeout = shift;
   my $e = $vec->[VEC_BITS];
  
   defined($e) && (select(undef,undef,$e,$timeout) > 0)
      ? handles($vec, $e)
      : ();
  }
  
  sub has_error
  {
   warnings::warn("Call to deprecated method 'has_error', use 'has_exception'")
  	if warnings::enabled();
   goto &has_exception;
  }
  
  sub count
  {
   my $vec = shift;
   $vec->[FD_COUNT];
  }
  
  sub bits
  {
   my $vec = shift;
   $vec->[VEC_BITS];
  }
  
  sub as_string  # for debugging
  {
   my $vec = shift;
   my $str = ref($vec) . ": ";
   my $bits = $vec->bits;
   my $count = $vec->count;
   $str .= defined($bits) ? unpack("b*", $bits) : "undef";
   $str .= " $count";
   my @handles = @$vec;
   splice(@handles, 0, FIRST_FD);
   for (@handles) {
       $str .= " " . (defined($_) ? "$_" : "-");
   }
   $str;
  }
  
  sub _max
  {
   my($a,$b,$c) = @_;
   $a > $b
      ? $a > $c
          ? $a
          : $c
      : $b > $c
          ? $b
          : $c;
  }
  
  sub select
  {
   shift
     if defined $_[0] && !ref($_[0]);
  
   my($r,$w,$e,$t) = @_;
   my @result = ();
  
   my $rb = defined $r ? $r->[VEC_BITS] : undef;
   my $wb = defined $w ? $w->[VEC_BITS] : undef;
   my $eb = defined $e ? $e->[VEC_BITS] : undef;
  
   if(select($rb,$wb,$eb,$t) > 0)
    {
     my @r = ();
     my @w = ();
     my @e = ();
     my $i = _max(defined $r ? scalar(@$r)-1 : 0,
                  defined $w ? scalar(@$w)-1 : 0,
                  defined $e ? scalar(@$e)-1 : 0);
  
     for( ; $i >= FIRST_FD ; $i--)
      {
       my $j = $i - FIRST_FD;
       push(@r, $r->[$i])
          if defined $rb && defined $r->[$i] && vec($rb, $j, 1);
       push(@w, $w->[$i])
          if defined $wb && defined $w->[$i] && vec($wb, $j, 1);
       push(@e, $e->[$i])
          if defined $eb && defined $e->[$i] && vec($eb, $j, 1);
      }
  
     @result = (\@r, \@w, \@e);
    }
   @result;
  }
  
  
  sub handles
  {
   my $vec = shift;
   my $bits = shift;
   my @h = ();
   my $i;
   my $max = scalar(@$vec) - 1;
  
   for ($i = FIRST_FD; $i <= $max; $i++)
    {
     next unless defined $vec->[$i];
     push(@h, $vec->[$i])
        if !defined($bits) || vec($bits, $i - FIRST_FD, 1);
    }
   
   @h;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IO::Select - OO interface to the select system call
  
  =head1 SYNOPSIS
  
      use IO::Select;
  
      $s = IO::Select->new();
  
      $s->add(\*STDIN);
      $s->add($some_handle);
  
      @ready = $s->can_read($timeout);
  
      @ready = IO::Select->new(@handles)->can_read(0);
  
  =head1 DESCRIPTION
  
  The C<IO::Select> package implements an object approach to the system C<select>
  function call. It allows the user to see what IO handles, see L<IO::Handle>,
  are ready for reading, writing or have an exception pending.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ HANDLES ] )
  
  The constructor creates a new object and optionally initialises it with a set
  of handles.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item add ( HANDLES )
  
  Add the list of handles to the C<IO::Select> object. It is these values that
  will be returned when an event occurs. C<IO::Select> keeps these values in a
  cache which is indexed by the C<fileno> of the handle, so if more than one
  handle with the same C<fileno> is specified then only the last one is cached.
  
  Each handle can be an C<IO::Handle> object, an integer or an array
  reference where the first element is an C<IO::Handle> or an integer.
  
  =item remove ( HANDLES )
  
  Remove all the given handles from the object. This method also works
  by the C<fileno> of the handles. So the exact handles that were added
  need not be passed, just handles that have an equivalent C<fileno>
  
  =item exists ( HANDLE )
  
  Returns a true value (actually the handle itself) if it is present.
  Returns undef otherwise.
  
  =item handles
  
  Return an array of all registered handles.
  
  =item can_read ( [ TIMEOUT ] )
  
  Return an array of handles that are ready for reading.  C<TIMEOUT> is the
  maximum amount of time to wait before returning an empty list (with C<$!>
  unchanged), in seconds, possibly fractional.  If C<TIMEOUT> is not given
  and any handles are registered then the call will block indefinitely.
  Upon error, an empty list is returned, with C<$!> set to indicate the
  error.  To distinguish between timeout and error, set C<$!> to zero
  before calling this method, and check it after an empty list is returned.
  
  =item can_write ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that can be written to.
  
  =item has_exception ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that have an exception
  condition, for example pending out-of-band data.
  
  =item count ()
  
  Returns the number of handles that the object will check for when
  one of the C<can_> methods is called or the object is passed to
  the C<select> static method.
  
  =item bits()
  
  Return the bit string suitable as argument to the core select() call.
  
  =item select ( READ, WRITE, EXCEPTION [, TIMEOUT ] )
  
  C<select> is a static method, that is you call it with the package name
  like C<new>. C<READ>, C<WRITE> and C<EXCEPTION> are either C<undef> or
  C<IO::Select> objects. C<TIMEOUT> is optional and has the same effect as
  for the core select call.
  
  If at least one handle is ready for the specified kind of operation,
  the result will be an array of 3 elements, each a reference to an array
  which will hold the handles that are ready for reading, writing and
  have exceptions respectively.  Upon timeout, an empty list is returned,
  with C<$!> unchanged.  Upon error, an empty list is returned, with C<$!>
  set to indicate the error.  To distinguish between timeout and error,
  set C<$!> to zero before calling this method, and check it after an
  empty list is returned.
  
  =back
  
  =head1 EXAMPLE
  
  Here is a short example which shows how C<IO::Select> could be used
  to write a server which communicates with several sockets while also
  listening for more connections on a listen socket
  
      use IO::Select;
      use IO::Socket;
  
      $lsn = IO::Socket::INET->new(Listen => 1, LocalPort => 8080);
      $sel = IO::Select->new( $lsn );
  
      while(@ready = $sel->can_read) {
          foreach $fh (@ready) {
              if($fh == $lsn) {
                  # Create a new socket
                  $new = $lsn->accept;
                  $sel->add($new);
              }
              else {
                  # Process socket
  
                  # Maybe we have finished with the socket
                  $sel->remove($fh);
                  $fh->close;
              }
          }
      }
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_IO_SELECT

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET';
  
  # IO::Socket.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket;
  
  use 5.008_001;
  
  use IO::Handle;
  use Socket 1.3;
  use Carp;
  use strict;
  use Exporter;
  use Errno;
  
  # legacy
  
  require IO::Socket::INET;
  require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
  
  our @ISA = qw(IO::Handle);
  
  our $VERSION = "1.51";
  
  our @EXPORT_OK = qw(sockatmark);
  
  our $errstr;
  
  sub import {
      my $pkg = shift;
      if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
  	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
      } else {
  	my $callpkg = caller;
  	Exporter::export 'Socket', $callpkg, @_;
      }
  }
  
  sub new {
      my($class,%arg) = @_;
      my $sock = $class->SUPER::new();
  
      $sock->autoflush(1);
  
      ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
  
      return scalar(%arg) ? $sock->configure(\%arg)
  			: $sock;
  }
  
  my @domain2pkg;
  
  sub register_domain {
      my($p,$d) = @_;
      $domain2pkg[$d] = $p;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my $domain = delete $arg->{Domain};
  
      croak 'IO::Socket: Cannot configure a generic socket'
  	unless defined $domain;
  
      croak "IO::Socket: Unsupported socket domain"
  	unless defined $domain2pkg[$domain];
  
      croak "IO::Socket: Cannot configure socket in domain '$domain'"
  	unless ref($sock) eq "IO::Socket";
  
      bless($sock, $domain2pkg[$domain]);
      $sock->configure($arg);
  }
  
  sub socket {
      @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
      my($sock,$domain,$type,$protocol) = @_;
  
      socket($sock,$domain,$type,$protocol) or
      	return undef;
  
      ${*$sock}{'io_socket_domain'} = $domain;
      ${*$sock}{'io_socket_type'}   = $type;
  
      # "A value of 0 for protocol will let the system select an
      # appropriate protocol"
      # so we need to look up what the system selected,
      # not cache PF_UNSPEC.
      ${*$sock}{'io_socket_proto'} = $protocol if $protocol;
  
      $sock;
  }
  
  sub socketpair {
      @_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
      my($class,$domain,$type,$protocol) = @_;
      my $sock1 = $class->new();
      my $sock2 = $class->new();
  
      socketpair($sock1,$sock2,$domain,$type,$protocol) or
      	return ();
  
      ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
      ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;
  
      ($sock1,$sock2);
  }
  
  sub connect {
      @_ == 2 or croak 'usage: $sock->connect(NAME)';
      my $sock = shift;
      my $addr = shift;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $err;
      my $blocking;
  
      $blocking = $sock->blocking(0) if $timeout;
      if (!connect($sock, $addr)) {
  	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
  	    require IO::Select;
  
  	    my $sel = IO::Select->new( $sock );
  
  	    undef $!;
  	    my($r,$w,$e) = IO::Select::select(undef,$sel,$sel,$timeout);
  	    if(@$e[0]) {
  		# Windows return from select after the timeout in case of
  		# WSAECONNREFUSED(10061) if exception set is not used.
  		# This behavior is different from Linux.
  		# Using the exception
  		# set we now emulate the behavior in Linux
  		#    - Karthik Rajagopalan
  		$err = $sock->getsockopt(SOL_SOCKET,SO_ERROR);
  		$errstr = $@ = "connect: $err";
  	    }
  	    elsif(!@$w[0]) {
  		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  		$errstr = $@ = "connect: timeout";
  	    }
  	    elsif (!connect($sock,$addr) &&
                  not ($!{EISCONN} || ($^O eq 'MSWin32' &&
                  ($! == (($] < 5.019004) ? 10022 : Errno::EINVAL))))
              ) {
  		# Some systems refuse to re-connect() to
  		# an already open socket and set errno to EISCONN.
  		# Windows sets errno to WSAEINVAL (10022) (pre-5.19.4) or
  		# EINVAL (22) (5.19.4 onwards).
  		$err = $!;
  		$errstr = $@ = "connect: $!";
  	    }
  	}
          elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
  	    $err = $!;
  	    $errstr = $@ = "connect: $!";
  	}
      }
  
      $sock->blocking(1) if $blocking;
  
      $! = $err if $err;
  
      $err ? undef : $sock;
  }
  
  # Enable/disable blocking IO on sockets.
  # Without args return the current status of blocking,
  # with args change the mode as appropriate, returning the
  # old setting, or in case of error during the mode change
  # undef.
  
  sub blocking {
      my $sock = shift;
  
      return $sock->SUPER::blocking(@_)
          if $^O ne 'MSWin32' && $^O ne 'VMS';
  
      # Windows handles blocking differently
      #
      # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
      # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
      #
      # 0x8004667e is FIONBIO
      #
      # which is used to set blocking behaviour.
  
      # NOTE:
      # This is a little confusing, the perl keyword for this is
      # 'blocking' but the OS level behaviour is 'non-blocking', probably
      # because sockets are blocking by default.
      # Therefore internally we have to reverse the semantics.
  
      my $orig= !${*$sock}{io_sock_nonblocking};
  
      return $orig unless @_;
  
      my $block = shift;
  
      if ( !$block != !$orig ) {
          ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
          ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
              or return undef;
      }
  
      return $orig;
  }
  
  
  sub close {
      @_ == 1 or croak 'usage: $sock->close()';
      my $sock = shift;
      ${*$sock}{'io_socket_peername'} = undef;
      $sock->SUPER::close();
  }
  
  sub bind {
      @_ == 2 or croak 'usage: $sock->bind(NAME)';
      my $sock = shift;
      my $addr = shift;
  
      return bind($sock, $addr) ? $sock
  			      : undef;
  }
  
  sub listen {
      @_ >= 1 && @_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
      my($sock,$queue) = @_;
      $queue = 5
  	unless $queue && $queue > 0;
  
      return listen($sock, $queue) ? $sock
  				 : undef;
  }
  
  sub accept {
      @_ == 1 || @_ == 2 or croak 'usage $sock->accept([PKG])';
      my $sock = shift;
      my $pkg = shift || $sock;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $new = $pkg->new(Timeout => $timeout);
      my $peer = undef;
  
      if(defined $timeout) {
  	require IO::Select;
  
  	my $sel = IO::Select->new( $sock );
  
  	unless ($sel->can_read($timeout)) {
  	    $errstr = $@ = 'accept: timeout';
  	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  	    return;
  	}
      }
  
      $peer = accept($new,$sock)
  	or return;
  
      ${*$new}{$_} = ${*$sock}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
      return wantarray ? ($new, $peer)
      	      	     : $new;
  }
  
  sub sockname {
      @_ == 1 or croak 'usage: $sock->sockname()';
      getsockname($_[0]);
  }
  
  sub peername {
      @_ == 1 or croak 'usage: $sock->peername()';
      my($sock) = @_;
      ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
  }
  
  sub connected {
      @_ == 1 or croak 'usage: $sock->connected()';
      my($sock) = @_;
      getpeername($sock);
  }
  
  sub send {
      @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
      my $sock  = $_[0];
      my $flags = $_[2] || 0;
      my $peer;
  
      if ($_[3]) {
          # the caller explicitly requested a TO, so use it
          # this is non-portable for "connected" UDP sockets
          $peer = $_[3];
      }
      elsif (!defined getpeername($sock)) {
          # we're not connected, so we require a peer from somewhere
          $peer = $sock->peername;
  
  	croak 'send: Cannot determine peer address'
  	    unless(defined $peer);
      }
  
      my $r = $peer
        ? send($sock, $_[1], $flags, $peer)
        : send($sock, $_[1], $flags);
  
      # remember who we send to, if it was successful
      ${*$sock}{'io_socket_peername'} = $peer
  	if(@_ == 4 && defined $r);
  
      $r;
  }
  
  sub recv {
      @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
      my $sock  = $_[0];
      my $len   = $_[2];
      my $flags = $_[3] || 0;
  
      # remember who we recv'd from
      ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);
  }
  
  sub shutdown {
      @_ == 2 or croak 'usage: $sock->shutdown(HOW)';
      my($sock, $how) = @_;
      ${*$sock}{'io_socket_peername'} = undef;
      shutdown($sock, $how);
  }
  
  sub setsockopt {
      @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
      setsockopt($_[0],$_[1],$_[2],$_[3]);
  }
  
  my $intsize = length(pack("i",0));
  
  sub getsockopt {
      @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
      my $r = getsockopt($_[0],$_[1],$_[2]);
      # Just a guess
      $r = unpack("i", $r)
  	if(defined $r && length($r) == $intsize);
      $r;
  }
  
  sub sockopt {
      my $sock = shift;
      @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)
  	    : $sock->setsockopt(SOL_SOCKET,@_);
  }
  
  sub atmark {
      @_ == 1 or croak 'usage: $sock->atmark()';
      my($sock) = @_;
      sockatmark($sock);
  }
  
  sub timeout {
      @_ == 1 || @_ == 2 or croak 'usage: $sock->timeout([VALUE])';
      my($sock,$val) = @_;
      my $r = ${*$sock}{'io_socket_timeout'};
  
      ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
  	if(@_ == 2);
  
      $r;
  }
  
  sub sockdomain {
      @_ == 1 or croak 'usage: $sock->sockdomain()';
      my $sock = shift;
      if (!defined(${*$sock}{'io_socket_domain'})) {
  	my $addr = $sock->sockname();
  	${*$sock}{'io_socket_domain'} = sockaddr_family($addr)
  	    if (defined($addr));
      }
      ${*$sock}{'io_socket_domain'};
  }
  
  sub socktype {
      @_ == 1 or croak 'usage: $sock->socktype()';
      my $sock = shift;
      ${*$sock}{'io_socket_type'} = $sock->sockopt(Socket::SO_TYPE)
  	if (!defined(${*$sock}{'io_socket_type'}) && defined(eval{Socket::SO_TYPE}));
      ${*$sock}{'io_socket_type'}
  }
  
  sub protocol {
      @_ == 1 or croak 'usage: $sock->protocol()';
      my($sock) = @_;
      ${*$sock}{'io_socket_proto'} = $sock->sockopt(Socket::SO_PROTOCOL)
  	if (!defined(${*$sock}{'io_socket_proto'}) && defined(eval{Socket::SO_PROTOCOL}));
      ${*$sock}{'io_socket_proto'};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket - Object interface to socket communications
  
  =head1 SYNOPSIS
  
      use strict;
      use warnings;
  
      use IO::Socket qw(AF_INET AF_UNIX);
  
      # create a new AF_INET socket
      my $sock = IO::Socket->new(Domain => AF_INET);
      # which is the same as
      $sock = IO::Socket::INET->new();
  
      # create a new AF_UNIX socket
      $sock = IO::Socket->new(Domain => AF_UNIX);
      # which is the same as
      $sock = IO::Socket::UNIX->new();
  
  =head1 DESCRIPTION
  
  C<IO::Socket> provides an object-oriented, L<IO::Handle>-based interface to
  creating and using sockets via L<Socket>, which provides a near one-to-one
  interface to the C socket library.
  
  C<IO::Socket> is a base class that really only defines methods for those
  operations which are common to all types of sockets. Operations which are
  specific to a particular socket domain have methods defined in subclasses of
  C<IO::Socket>. See L<IO::Socket::INET>, L<IO::Socket::UNIX>, and
  L<IO::Socket::IP> for examples of such a subclass.
  
  C<IO::Socket> will export all functions (and constants) defined by L<Socket>.
  
  =head1 CONSTRUCTOR ARGUMENTS
  
  Given that C<IO::Socket> doesn't have attributes in the traditional sense, the
  following arguments, rather than attributes, can be passed into the
  constructor.
  
  Constructor arguments should be passed in C<< Key => 'Value' >> pairs.
  
  The only required argument is L<IO::Socket/"Domain">.
  
  =head2 Blocking
  
      my $sock = IO::Socket->new(..., Blocking => 1);
      $sock = IO::Socket->new(..., Blocking => 0);
  
  If defined but false, the socket will be set to non-blocking mode. If not
  specified it defaults to C<1> (blocking mode).
  
  =head2 Domain
  
      my $sock = IO::Socket->new(Domain => IO::Socket::AF_INET);
      $sock = IO::Socket->new(Domain => IO::Socket::AF_UNIX);
  
  The socket domain will define which subclass of C<IO::Socket> to use. The two
  options available along with this distribution are C<AF_INET> and C<AF_UNIX>.
  
  C<AF_INET> is for the internet address family of sockets and is handled via
  L<IO::Socket::INET>. C<AF_INET> sockets are bound to an internet address and
  port.
  
  C<AF_UNIX> is for the unix domain socket and is handled via
  L<IO::Socket::UNIX>. C<AF_UNIX> sockets are bound to the file system as their
  address name space.
  
  This argument is B<required>. All other arguments are optional.
  
  =head2 Listen
  
      my $sock = IO::Socket->new(..., Listen => 5);
  
  Listen should be an integer value or left unset.
  
  If provided, this argument will place the socket into listening mode. New
  connections can then be accepted using the L<IO::Socket/"accept"> method. The
  value given is used as the C<listen(2)> queue size.
  
  If the C<Listen> argument is given, but false, the queue size will be set to
  5.
  
  =head2 Timeout
  
      my $sock = IO::Socket->new(..., Timeout => 5);
  
  The timeout value, in seconds, for this socket connection. How exactly this
  value is utilized is defined in the socket domain subclasses that make use of
  the value.
  
  =head2 Type
  
      my $sock = IO::Socket->new(..., Type => IO::Socket::SOCK_STREAM);
  
  The socket type that will be used. These are usually C<SOCK_STREAM>,
  C<SOCK_DGRAM>, or C<SOCK_RAW>. If this argument is left undefined an attempt
  will be made to infer the type from the service name.
  
  For example, you'll usually use C<SOCK_STREAM> with a C<tcp> connection and
  C<SOCK_DGRAM> with a C<udp> connection.
  
  =head1 CONSTRUCTORS
  
  C<IO::Socket> extends the L<IO::Handle> constructor.
  
  =head2 new
  
      my $sock = IO::Socket->new();
  
      # get a new IO::Socket::INET instance
      $sock = IO::Socket->new(Domain => IO::Socket::AF_INET);
      # get a new IO::Socket::UNIX instance
      $sock = IO::Socket->new(Domain => IO::Socket::AF_UNIX);
  
      # Domain is the only required argument
      $sock = IO::Socket->new(
          Domain => IO::Socket::AF_INET, # AF_INET, AF_UNIX
          Type => IO::Socket::SOCK_STREAM, # SOCK_STREAM, SOCK_DGRAM, ...
          Proto => 'tcp', # 'tcp', 'udp', IPPROTO_TCP, IPPROTO_UDP
          # and so on...
      );
  
  Creates an C<IO::Socket>, which is a reference to a newly created symbol (see
  the L<Symbol> package). C<new> optionally takes arguments, these arguments
  are defined in L<IO::Socket/"CONSTRUCTOR ARGUMENTS">.
  
  Any of the L<IO::Socket/"CONSTRUCTOR ARGUMENTS"> may be passed to the
  constructor, but if any arguments are provided, then one of them must be
  the L<IO::Socket/"Domain"> argument. The L<IO::Socket/"Domain"> argument can,
  by default, be either C<AF_INET> or C<AF_UNIX>. Other domains can be used if a
  proper subclass for the domain family is registered. All other arguments will
  be passed to the C<configuration> method of the package for that domain.
  
  If the constructor fails it will return C<undef> and set the C<$errstr> package
  variable to contain an error message.
  
      $sock = IO::Socket->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket->new(...)
          or die "Cannot create socket - $@\n";
  
  =head1 METHODS
  
  C<IO::Socket> inherits all methods from L<IO::Handle> and implements the
  following new ones.
  
  =head2 accept
  
      my $client_sock = $sock->accept();
      my $inet_sock = $sock->accept('IO::Socket::INET');
  
  The accept method will perform the system call C<accept> on the socket and
  return a new object. The new object will be created in the same class as the
  listen socket, unless a specific package name is specified. This object can be
  used to communicate with the client that was trying to connect.
  
  This differs slightly from the C<accept> function in L<perlfunc>.
  
  In a scalar context the new socket is returned, or C<undef> upon
  failure. In a list context a two-element array is returned containing
  the new socket and the peer address; the list will be empty upon failure.
  
  =head2 atmark
  
      my $integer = $sock->atmark();
      # read in some data on a given socket
      my $data;
      $sock->read($data, 1024) until $sock->atmark;
  
      # or, export the function to use:
      use IO::Socket 'sockatmark';
      $sock->read($data, 1024) until sockatmark($sock);
  
  True if the socket is currently positioned at the urgent data mark, false
  otherwise. If your system doesn't yet implement C<sockatmark> this will throw
  an exception.
  
  If your system does not support C<sockatmark>, the C<use> declaration will
  fail at compile time.
  
  =head2 autoflush
  
      # by default, autoflush will be turned on when referenced
      $sock->autoflush(); # turns on autoflush
      # turn off autoflush
      $sock->autoflush(0);
      # turn on autoflush
      $sock->autoflush(1);
  
  This attribute isn't overridden from L<IO::Handle>'s implementation. However,
  since we turn it on by default, it's worth mentioning here.
  
  =head2 bind
  
      use Socket qw(pack_sockaddr_in);
      my $port = 3000;
      my $ip_address = '0.0.0.0';
      my $packed_addr = pack_sockaddr_in($port, $ip_address);
      $sock->bind($packed_addr);
  
  Binds a network address to a socket, just as C<bind(2)> does. Returns true if
  it succeeded, false otherwise. You should provide a packed address of the
  appropriate type for the socket.
  
  =head2 connected
  
      my $peer_addr = $sock->connected();
      if ($peer_addr) {
          say "We're connected to $peer_addr";
      }
  
  If the socket is in a connected state, the peer address is returned. If the
  socket is not in a connected state, C<undef> is returned.
  
  Note that this method considers a half-open TCP socket to be "in a connected
  state".  Specifically, it does not distinguish between the
  B<ESTABLISHED> and B<CLOSE-WAIT> TCP states; it returns the peer address,
  rather than C<undef>, in either case.  Thus, in general, it cannot
  be used to reliably learn whether the peer has initiated a graceful shutdown
  because in most cases (see below) the local TCP state machine remains in
  B<CLOSE-WAIT> until the local application calls L<IO::Socket/"shutdown"> or
  C<close>. Only at that point does this function return C<undef>.
  
  The "in most cases" hedge is because local TCP state machine behavior may
  depend on the peer's socket options. In particular, if the peer socket has
  C<SO_LINGER> enabled with a zero timeout, then the peer's C<close> will
  generate a C<RST> segment. Upon receipt of that segment, the local TCP
  transitions immediately to B<CLOSED>, and in that state, this method I<will>
  return C<undef>.
  
  =head2 getsockopt
  
      my $value = $sock->getsockopt(SOL_SOCKET, SO_REUSEADDR);
      my $buf = $socket->getsockopt(SOL_SOCKET, SO_RCVBUF);
      say "Receive buffer is $buf bytes";
  
  Get an option associated with the socket. Levels other than C<SOL_SOCKET>
  may be specified here. As a convenience, this method will unpack a byte buffer
  of the correct size back into a number.
  
  =head2 listen
  
      $sock->listen(5);
  
  Does the same thing that the C<listen(2)> system call does. Returns true if it
  succeeded, false otherwise. Listens to a socket with a given queue size.
  
  =head2 peername
  
      my $sockaddr_in = $sock->peername();
  
  Returns the packed C<sockaddr> address of the other end of the socket
  connection. It calls C<getpeername>.
  
  
  =head2 protocol
  
      my $proto = $sock->protocol();
  
  Returns the number for the protocol being used on the socket, if
  known. If the protocol is unknown, as with an C<AF_UNIX> socket, zero
  is returned.
  
  =head2 recv
  
      my $buffer = "";
      my $length = 1024;
      my $flags = 0; # default. optional
      $sock->recv($buffer, $length);
      $sock->recv($buffer, $length, $flags);
  
  Similar in functionality to L<perlfunc/recv>.
  
  Receives a message on a socket. Attempts to receive C<$length> characters of
  data into C<$buffer> from the specified socket. C<$buffer> will be grown or
  shrunk to the length actually read. Takes the same flags as the system call of
  the same name. Returns the address of the sender if socket's protocol supports
  this; returns an empty string otherwise. If there's an error, returns
  C<undef>. This call is actually implemented in terms of the C<recvfrom(2)>
  system call.
  
  Flags are ORed together values, such as C<MSG_BCAST>, C<MSG_OOB>,
  C<MSG_TRUNC>. The default value for the flags is C<0>.
  
  The cached value of L<IO::Socket/"peername"> is updated with the result of
  C<recv>.
  
  B<Note:> In Perl v5.30 and newer, if the socket has been marked as C<:utf8>,
  C<recv> will throw an exception. The C<:encoding(...)> layer implicitly
  introduces the C<:utf8> layer. See L<perlfunc/binmode>.
  
  B<Note:> In Perl versions older than v5.30, depending on the status of the
  socket, either (8-bit) bytes or characters are received. By default all
  sockets operate on bytes, but for example if the socket has been changed
  using L<perlfunc/binmode> to operate with the C<:encoding(UTF-8)> I/O layer
  (see the L<perlfunc/open> pragma), the I/O will operate on UTF8-encoded
  Unicode characters, not bytes. Similarly for the C<:encoding> layer: in
  that case pretty much any characters can be read.
  
  =head2 send
  
      my $message = "Hello, world!";
      my $flags = 0; # defaults to zero
      my $to = '0.0.0.0'; # optional destination
      my $sent = $sock->send($message);
      $sent = $sock->send($message, $flags);
      $sent = $sock->send($message, $flags, $to);
  
  Similar in functionality to L<perlfunc/send>.
  
  Sends a message on a socket. Attempts to send the scalar message to the
  socket. Takes the same flags as the system call of the same name. On
  unconnected sockets, you must specify a destination to send to, in which case
  it does a C<sendto(2)> syscall. Returns the number of characters sent, or
  C<undef> on error. The C<sendmsg(2)> syscall is currently unimplemented.
  
  The C<flags> option is optional and defaults to C<0>.
  
  After a successful send with C<$to>, further calls to C<send> on an
  unconnected socket without C<$to> will send to the same address, and C<$to>
  will be used as the result of L<IO::Socket/"peername">.
  
  B<Note:> In Perl v5.30 and newer, if the socket has been marked as C<:utf8>,
  C<send> will throw an exception. The C<:encoding(...)> layer implicitly
  introduces the C<:utf8> layer. See L<perlfunc/binmode>.
  
  B<Note:> In Perl versions older than v5.30, depending on the status of the
  socket, either (8-bit) bytes or characters are sent. By default all
  sockets operate on bytes, but for example if the socket has been changed
  using L<perlfunc/binmode> to operate with the C<:encoding(UTF-8)> I/O layer
  (see the L<perlfunc/open> pragma), the I/O will operate on UTF8-encoded
  Unicode characters, not bytes. Similarly for the C<:encoding> layer: in
  that case pretty much any characters can be sent.
  
  =head2 setsockopt
  
      $sock->setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);
      $sock->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024);
  
  Set option associated with the socket. Levels other than C<SOL_SOCKET>
  may be specified here. As a convenience, this method will convert a number
  into a packed byte buffer.
  
  =head2 shutdown
  
      $sock->shutdown(SHUT_RD); # we stopped reading data
      $sock->shutdown(SHUT_WR); # we stopped writing data
      $sock->shutdown(SHUT_RDWR); # we stopped using this socket
  
  Shuts down a socket connection in the manner indicated by the value passed in,
  which has the same interpretation as in the syscall of the same name.
  
  This is useful with sockets when you want to tell the other side you're done
  writing but not done reading, or vice versa. It's also a more insistent form
  of C<close> because it also disables the file descriptor in any
  forked copies in other processes.
  
  Returns C<1> for success; on error, returns C<undef> if the socket is
  not a valid filehandle, or returns C<0> and sets C<$!> for any other failure.
  
  =head2 sockdomain
  
      my $domain = $sock->sockdomain();
  
  Returns the number for the socket domain type. For example, for
  an C<AF_INET> socket the value of C<&AF_INET> will be returned.
  
  =head2 socket
  
      my $sock = IO::Socket->new(); # no values given
      # now let's actually get a socket with the socket method
      # domain, type, and protocol are required
      $sock = $sock->socket(AF_INET, SOCK_STREAM, 'tcp');
  
  Opens a socket of the specified kind and returns it. Domain, type, and
  protocol are specified the same as for the syscall of the same name.
  
  =head2 socketpair
  
      my ($r, $w) = $sock->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
      ($r, $w) = IO::Socket::UNIX
          ->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
  
  Will return a list of two sockets created (read and write), or an empty list
  on failure.
  
  Differs slightly from C<socketpair> in L<perlfunc> in that the argument list
  is a bit simpler.
  
  =head2 sockname
  
      my $packed_addr = $sock->sockname();
  
  Returns the packed C<sockaddr> address of this end of the connection. It's the
  same as C<getsockname(2)>.
  
  =head2 sockopt
  
      my $value = $sock->sockopt(SO_REUSEADDR);
      $sock->sockopt(SO_REUSEADDR, 1);
  
  Unified method to both set and get options in the C<SOL_SOCKET> level. If
  called with one argument then L<IO::Socket/"getsockopt"> is called, otherwise
  L<IO::Socket/"setsockopt"> is called.
  
  =head2 socktype
  
      my $type = $sock->socktype();
  
  Returns the number for the socket type. For example, for
  a C<SOCK_STREAM> socket the value of C<&SOCK_STREAM> will be returned.
  
  =head2 timeout
  
      my $seconds = $sock->timeout();
      my $old_val = $sock->timeout(5); # set new and return old value
  
  Set or get the timeout value (in seconds) associated with this socket.
  If called without any arguments then the current setting is returned. If
  called with an argument the current setting is changed and the previous
  value returned.
  
  This method is available to all C<IO::Socket> implementations but may or may
  not be used by the individual domain subclasses.
  
  =head1 EXAMPLES
  
  Let's create a TCP server on C<localhost:3333>.
  
      use strict;
      use warnings;
      use feature 'say';
  
      use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
  
      my $server = IO::Socket->new(
          Domain => AF_INET,
          Type => SOCK_STREAM,
          Proto => 'tcp',
          LocalHost => '0.0.0.0',
          LocalPort => 3333,
          ReusePort => 1,
          Listen => 5,
      ) || die "Can't open socket: $IO::Socket::errstr";
      say "Waiting on 3333";
  
      while (1) {
          # waiting for a new client connection
          my $client = $server->accept();
  
          # get information about a newly connected client
          my $client_address = $client->peerhost();
          my $client_port = $client->peerport();
          say "Connection from $client_address:$client_port";
  
          # read up to 1024 characters from the connected client
          my $data = "";
          $client->recv($data, 1024);
          say "received data: $data";
  
          # write response data to the connected client
          $data = "ok";
          $client->send($data);
  
          # notify client that response has been sent
          $client->shutdown(SHUT_WR);
      }
  
      $server->close();
  
  A client for such a server could be
  
      use strict;
      use warnings;
      use feature 'say';
  
      use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
  
      my $client = IO::Socket->new(
          Domain => AF_INET,
          Type => SOCK_STREAM,
          proto => 'tcp',
          PeerPort => 3333,
          PeerHost => '0.0.0.0',
      ) || die "Can't open socket: $IO::Socket::errstr";
  
      say "Sending Hello World!";
      my $size = $client->send("Hello World!");
      say "Sent data of length: $size";
  
      $client->shutdown(SHUT_WR);
  
      my $buffer;
      $client->recv($buffer, 1024);
      say "Got back $buffer";
  
      $client->close();
  
  
  =head1 LIMITATIONS
  
  On some systems, for an IO::Socket object created with C<new_from_fd>,
  or created with L<IO::Socket/"accept"> from such an object, the
  L<IO::Socket/"protocol">, L<IO::Socket/"sockdomain"> and
  L<IO::Socket/"socktype"> methods may return C<undef>.
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Handle>, L<IO::Socket::INET>, L<IO::Socket::UNIX>,
  L<IO::Socket::IP>
  
  =head1 AUTHOR
  
  Graham Barr.  atmark() by Lincoln Stein.  Currently maintained by the Perl 5
  Porters.  Please report all bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  The atmark() implementation: Copyright 2001, Lincoln Stein <lstein@cshl.org>.
  This module is distributed under the same terms as Perl itself.
  Feel free to use, modify and redistribute it as long as you retain
  the correct attribution.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket/INET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_INET';
  # IO::Socket::INET.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::INET;
  
  use strict;
  use IO::Socket;
  use Socket;
  use Carp;
  use Exporter;
  use Errno;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.51";
  
  my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;
  
  IO::Socket::INET->register_domain( AF_INET );
  
  my %socket_type = ( tcp  => SOCK_STREAM,
  		    udp  => SOCK_DGRAM,
  		    icmp => SOCK_RAW
  		  );
  my %proto_number;
  $proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
  $proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
  $proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  my %proto_name = reverse %proto_number;
  
  sub new {
      my $class = shift;
      unshift(@_, "PeerAddr") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub _cache_proto {
      my @proto = @_;
      for (map lc($_), $proto[0], split(' ', $proto[1])) {
  	$proto_number{$_} = $proto[2];
      }
      $proto_name{$proto[2]} = $proto[0];
  }
  
  sub _get_proto_number {
      my $name = lc(shift);
      return undef unless defined $name;
      return $proto_number{$name} if exists $proto_number{$name};
  
      my @proto = eval { getprotobyname($name) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[2];
  }
  
  sub _get_proto_name {
      my $num = shift;
      return undef unless defined $num;
      return $proto_name{$num} if exists $proto_name{$num};
  
      my @proto = eval { getprotobynumber($num) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[0];
  }
  
  sub _sock_info {
    my($addr,$port,$proto) = @_;
    my $origport = $port;
    my @serv = ();
  
    $port = $1
  	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
  
    if(defined $proto  && $proto =~ /\D/) {
      my $num = _get_proto_number($proto);
      unless (defined $num) {
        $IO::Socket::errstr = $@ = "Bad protocol '$proto'";
        return;
      }
      $proto = $num;
    }
  
    if(defined $port) {
      my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
      my $pnum = ($port =~ m,^(\d+)$,)[0];
  
      @serv = getservbyname($port, _get_proto_name($proto) || "")
  	if ($port =~ m,\D,);
  
      $port = $serv[2] || $defport || $pnum;
      unless (defined $port) {
  	$IO::Socket::errstr = $@ = "Bad service '$origport'";
  	return;
      }
  
      $proto = _get_proto_number($serv[3]) if @serv && !$proto;
    }
  
   return ($addr || undef,
  	 $port || undef,
  	 $proto || undef
  	);
  }
  
  sub _error {
      my $sock = shift;
      my $err = shift;
      {
        local($!);
        my $title = ref($sock).": ";
        $IO::Socket::errstr = $@ = join("", $_[0] =~ /^$title/ ? "" : $title, @_);
        $sock->close()
  	if(defined fileno($sock));
      }
      $! = $err;
      return undef;
  }
  
  sub _get_addr {
      my($sock,$addr_str, $multi) = @_;
      my @addr;
      if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
  	(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);
      } else {
  	my $h = inet_aton($addr_str);
  	push(@addr, $h) if defined $h;
      }
      @addr;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($lport,$rport,$laddr,$raddr,$proto,$type);
  
  
      $arg->{LocalAddr} = $arg->{LocalHost}
  	if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};
  
      ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
  					$arg->{LocalPort},
  					$arg->{Proto})
  			or return _error($sock, $!, $@);
  
      $laddr = defined $laddr ? inet_aton($laddr)
  			    : INADDR_ANY;
  
      return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
  	unless(defined $laddr);
  
      $arg->{PeerAddr} = $arg->{PeerHost}
  	if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};
  
      unless(exists $arg->{Listen}) {
  	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
  					    $arg->{PeerPort},
  					    $proto)
  			or return _error($sock, $!, $@);
      }
  
      $proto ||= _get_proto_number('tcp');
  
      $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};
  
      my @raddr = ();
  
      if(defined $raddr) {
  	@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless @raddr;
      }
  
      while(1) {
  
  	$sock->socket(AF_INET, $type, $proto) or
  	    return _error($sock, $!, "$!");
  
          if (defined $arg->{Blocking}) {
  	    defined $sock->blocking($arg->{Blocking})
  		or return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
  	    $sock->sockopt(SO_REUSEADDR,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{ReusePort}) {
  	    $sock->sockopt(SO_REUSEPORT,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Broadcast}) {
  		$sock->sockopt(SO_BROADCAST,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
  	    $sock->bind($lport || 0, $laddr) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if(exists $arg->{Listen}) {
  	    $sock->listen($arg->{Listen} || 5) or
  		return _error($sock, $!, "$!");
  	    last;
  	}
  
   	# don't try to connect unless we're given a PeerAddr
   	last unless exists($arg->{PeerAddr});
   
          $raddr = shift @raddr;
  
  	return _error($sock, $EINVAL, 'Cannot determine remote port')
  		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);
  
  	last
  	    unless($type == SOCK_STREAM || defined $raddr);
  
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless defined $raddr;
  
  #        my $timeout = ${*$sock}{'io_socket_timeout'};
  #        my $before = time() if $timeout;
  
  	undef $@;
          if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
  #            ${*$sock}{'io_socket_timeout'} = $timeout;
              return $sock;
          }
  
  	return _error($sock, $!, $@ || "Timeout")
  	    unless @raddr;
  
  #	if ($timeout) {
  #	    my $new_timeout = $timeout - (time() - $before);
  #	    return _error($sock,
  #                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),
  #                         "Timeout") if $new_timeout <= 0;
  #	    ${*$sock}{'io_socket_timeout'} = $new_timeout;
  #        }
  
      }
  
      $sock;
  }
  
  sub connect {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
  }
  
  sub bind {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))
  }
  
  sub sockaddr {
      @_ == 1 or croak 'usage: $sock->sockaddr()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub sockport {
      @_ == 1 or croak 'usage: $sock->sockport()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub sockhost {
      @_ == 1 or croak 'usage: $sock->sockhost()';
      my($sock) = @_;
      my $addr = $sock->sockaddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  sub peeraddr {
      @_ == 1 or croak 'usage: $sock->peeraddr()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub peerport {
      @_ == 1 or croak 'usage: $sock->peerport()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub peerhost {
      @_ == 1 or croak 'usage: $sock->peerhost()';
      my($sock) = @_;
      my $addr = $sock->peeraddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::INET - Object interface for AF_INET domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::INET;
  
  =head1 DESCRIPTION
  
  C<IO::Socket::INET> provides an object interface to creating and using sockets
  in the AF_INET domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::INET> object, which is a reference to a
  newly created symbol (see the L<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::INET> provides.
  
  
   PeerAddr    Remote host address          <hostname>[:<port>]
   PeerHost    Synonym for PeerAddr
   PeerPort    Remote port or service       <service>[(<no>)] | <no>
   LocalAddr   Local host bind address      hostname[:port]
   LocalHost   Synonym for LocalAddr
   LocalPort   Local host bind port         <service>[(<no>)] | <no>
   Proto       Protocol name (or number)    "tcp" | "udp" | ...
   Type        Socket type              SOCK_STREAM | SOCK_DGRAM | ...
   Listen      Queue size for listen
   ReuseAddr   Set SO_REUSEADDR before binding
   Reuse       Set SO_REUSEADDR before binding (deprecated,
                                                prefer ReuseAddr)
   ReusePort   Set SO_REUSEPORT before binding
   Broadcast   Set SO_BROADCAST before binding
   Timeout     Timeout value for various operations
   MultiHomed  Try all addresses for multi-homed hosts
   Blocking    Determine if connection will be blocking mode
  
  If C<Listen> is defined then a listen socket is created, else if the
  socket type, which is derived from the protocol, is SOCK_STREAM then
  connect() is called.  If the C<Listen> argument is given, but false,
  the queue size will be set to 5.
  
  Although it is not illegal, the use of C<MultiHomed> on a socket
  which is in non-blocking mode is of little use. This is because the
  first connect will never fail with a timeout as the connect call
  will not block.
  
  The C<PeerAddr> can be a hostname or the IP-address on the
  "xx.xx.xx.xx" form.  The C<PeerPort> can be a number or a symbolic
  service name.  The service name might be followed by a number in
  parenthesis which is used if the service is not known by the system.
  The C<PeerPort> specification can also be embedded in the C<PeerAddr>
  by preceding it with a ":".
  
  If C<Proto> is not given and you specify a symbolic C<PeerPort> port,
  then the constructor will try to derive C<Proto> from the service
  name.  As a last resort C<Proto> "tcp" is assumed.  The C<Type>
  parameter will be deduced from C<Proto> if not specified.
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<PeerAddr> specification.
  
  If C<Blocking> is set to 0, the connection will be in nonblocking mode.
  If not specified it defaults to 1 (blocking mode).
  
  Examples:
  
     $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.org',
                                   PeerPort => 'http(80)',
                                   Proto    => 'tcp');
  
     $sock = IO::Socket::INET->new(PeerAddr => 'localhost:smtp(25)');
  
     $sock = IO::Socket::INET->new(Listen    => 5,
                                   LocalAddr => 'localhost',
                                   LocalPort => 9000,
                                   Proto     => 'tcp');
  
     $sock = IO::Socket::INET->new('127.0.0.1:25');
  
     $sock = IO::Socket::INET->new(
                             PeerPort  => 9999,
                             PeerAddr  => inet_ntoa(INADDR_BROADCAST),
                             Proto     => 'udp',
                             LocalAddr => 'localhost',
                             Broadcast => 1 ) 
                         or die "Can't bind : $IO::Socket::errstr\n";
  
  If the constructor fails it will return C<undef> and set the
  C<$IO::Socket::errstr> package variable to contain an error message.
  
      $sock = IO::Socket::INET->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket::INET->new(...)
          or die "Cannot create socket - $@\n";
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item sockaddr ()
  
  Return the address part of the sockaddr structure for the socket
  
  =item sockport ()
  
  Return the port number that the socket is using on the local host
  
  =item sockhost ()
  
  Return the address part of the sockaddr structure for the socket in a
  text form xx.xx.xx.xx
  
  =item peeraddr ()
  
  Return the address part of the sockaddr structure for the socket on
  the peer host
  
  =item peerport ()
  
  Return the port number for the socket on the peer host.
  
  =item peerhost ()
  
  Return the address part of the sockaddr structure for the socket on the
  peer host in a text form xx.xx.xx.xx
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_INET

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket/UNIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_UNIX';
  # IO::Socket::UNIX.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::UNIX;
  
  use strict;
  use IO::Socket;
  use Carp;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.51";
  
  IO::Socket::UNIX->register_domain( AF_UNIX );
  
  sub new {
      my $class = shift;
      unshift(@_, "Peer") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($bport,$cport);
  
      my $type = $arg->{Type} || SOCK_STREAM;
  
      $sock->socket(AF_UNIX, $type, 0) or
  	return undef;
  
      if(exists $arg->{Blocking}) {
          $sock->blocking($arg->{Blocking}) or
  	    return undef;
      }
      if(exists $arg->{Local}) {
  	my $addr = sockaddr_un($arg->{Local});
  	$sock->bind($addr) or
  	    return undef;
      }
      if(exists $arg->{Listen} && $type != SOCK_DGRAM) {
  	$sock->listen($arg->{Listen} || 5) or
  	    return undef;
      }
      elsif(exists $arg->{Peer}) {
  	my $addr = sockaddr_un($arg->{Peer});
  	$sock->connect($addr) or
  	    return undef;
      }
  
      $sock;
  }
  
  sub hostpath {
      @_ == 1 or croak 'usage: $sock->hostpath()';
      my $n = $_[0]->sockname || return undef;
      (sockaddr_un($n))[0];
  }
  
  sub peerpath {
      @_ == 1 or croak 'usage: $sock->peerpath()';
      my $n = $_[0]->peername || return undef;
      (sockaddr_un($n))[0];
  }
  
  1; # Keep require happy
  
  __END__
  
  =head1 NAME
  
  IO::Socket::UNIX - Object interface for AF_UNIX domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::UNIX;
  
      my $SOCK_PATH = "$ENV{HOME}/unix-domain-socket-test.sock";
  
      # Server:
      my $server = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Local => $SOCK_PATH,
          Listen => 1,
      );
  
      my $count = 1;
      while (my $conn = $server->accept()) {
          $conn->print("Hello " . ($count++) . "\n");
      }
  
      # Client:
      my $client = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Peer => $SOCK_PATH,
      );
  
      # Now read and write from $client
  
  =head1 DESCRIPTION
  
  C<IO::Socket::UNIX> provides an object interface to creating and using sockets
  in the AF_UNIX domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::UNIX> object, which is a reference to a
  newly created symbol (see the L<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::UNIX> provides.
  
      Type    	Type of socket (eg SOCK_STREAM or SOCK_DGRAM)
      Local   	Path to local fifo
      Peer    	Path to peer fifo
      Listen  	Queue size for listen
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<Peer> specification.
  
  If the C<Listen> argument is given, but false, the queue size will be set to 5.
  
  If the constructor fails it will return C<undef> and set the
  C<$IO::Socket::errstr> package variable to contain an error message.
  
      $sock = IO::Socket::UNIX->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket::UNIX->new(...)
          or die "Cannot create socket - $@\n";
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item hostpath()
  
  Returns the pathname to the fifo at the local end
  
  =item peerpath()
  
  Returns the pathanme to the fifo at the peer end
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_UNIX

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce reductions sum sum0
    sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.63";
  our $XS_VERSION = $VERSION;
  $VERSION =~ tr/_//d;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  # Used by shuffle()
  our $RAND;
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first reductions
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqint uniqnum uniqstr zip mesh
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all apply a given block of code to a list of
  values.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The other scalar-returning list reduction functions are all specialisations of
  this generic idea.
  
  =head2 reductions
  
      @results = reductions { BLOCK } @list
  
  I<Since version 1.54.>
  
  Similar to C<reduce> except that it also returns the intermediate values along
  with the final result. As before, C<$a> is set to the first element of the
  given list, and the C<BLOCK> is then called once for remaining item in the
  list set into C<$b>, with the result being captured for return as well as
  becoming the new value for C<$a>.
  
  The returned list will begin with the initial value for C<$a>, followed by
  each return value from the block in order. The final value of the result will
  be identical to what the C<reduce> function would have returned given the same
  block and list.
  
      reduce     { "$a-$b" }  "a".."d"    # "a-b-c-d"
      reductions { "$a-$b" }  "a".."d"    # "a", "a-b", "a-b-c", "a-b-c-d"
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  Since version C<1.51> they also have a C<TO_JSON> method to ease
  serialisation.
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  This function is affected by the C<$RAND> variable.
  
  =cut
  
  =head2 sample
  
      my @items = sample $count, @values
  
  I<Since version 1.54.>
  
  Randomly select the given number of elements from the input list. Any given
  position in the input list will be selected at most once.
  
  If there are fewer than C<$count> items in the list then the function will
  return once all of them have been randomly selected; effectively the function
  behaves similarly to L</shuffle>.
  
  This function is affected by the C<$RAND> variable.
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqint
  
      my @subset = uniqint @values
  
  I<Since version 1.55.>
  
  Filters a list of values to remove subsequent duplicates, as judged by an
  integer numerical equality test. Preserves the order of unique elements, and
  retains the first value of any duplicate set. Values in the returned list will
  be coerced into integers.
  
      my $count = uniqint @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqint> are well-behaved as integers.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  I<Since version 1.50.>
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  I<Since version 1.50.>
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head2 zip
  
      my @result = zip [1..3], ['a'..'c'];
      # [1, 'a'], [2, 'b'], [3, 'c']
  
  I<Since version 1.56.>
  
  Returns a list of array references, composed of elements from the given list
  of array references. Each array in the returned list is composed of elements
  at that corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  The C<zip> function is particularly handy for iterating over multiple arrays
  at the same time with a C<foreach> loop, taking one element from each:
  
      foreach ( zip \@xs, \@ys, \@zs ) {
          my ($x, $y, $z) = @$_;
          ...
      }
  
  B<NOTE> to users of L<List::MoreUtils>: This function does not behave the same
  as C<List::MoreUtils::zip>, but is actually a non-prototyped equivalent to
  C<List::MoreUtils::zip_unflatten>. This function does not apply a prototype,
  so make sure to invoke it with references to arrays.
  
  For a function similar to the C<zip> function from C<List::MoreUtils>, see
  L<mesh>.
  
      my @result = zip_shortest ...
  
  A variation of the function that differs in how it behaves when given input
  arrays of differing lengths. C<zip_shortest> will stop as soon as any one of
  the input arrays run out of elements, discarding any remaining unused values
  from the others.
  
      my @result = zip_longest ...
  
  C<zip_longest> is an alias to the C<zip> function, provided simply to be
  explicit about that behaviour as compared to C<zip_shortest>.
  
  =head2 mesh
  
      my @result = mesh [1..3], ['a'..'c'];
      # (1, 'a', 2, 'b', 3, 'c')
  
  I<Since version 1.56.>
  
  Returns a list of items collected from elements of the given list of array
  references. Each section of items in the returned list is composed of elements
  at the corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  This is similar to L<zip>, except that all of the ranges in the result are
  returned in one long flattened list, instead of being bundled into separate
  arrays.
  
  Because it returns a flat list of items, the C<mesh> function is particularly
  useful for building a hash out of two separate arrays of keys and values:
  
      my %hash = mesh \@keys, \@values;
  
      my $href = { mesh \@keys, \@values };
  
  B<NOTE> to users of L<List::MoreUtils>: This function is a non-prototyped
  equivalent to C<List::MoreUtils::mesh> or C<List::MoreUtils::zip> (themselves
  aliases of each other). This function does not apply a prototype, so make sure
  to invoke it with references to arrays.
  
      my @result = mesh_shortest ...
  
      my @result = mesh_longest ...
  
  These variations are similar to those of L<zip>, in that they differ in
  behaviour when one of the input lists runs out of elements before the others.
  
  =head1 CONFIGURATION VARIABLES
  
  =head2 $RAND
  
      local $List::Util::RAND = sub { ... };
  
  I<Since version 1.54.>
  
  This package variable is used by code which needs to generate random numbers
  (such as the L</shuffle> and L</sample> functions). If set to a CODE reference
  it provides an alternative to perl's builtin C<rand()> function. When a new
  random number is needed this function will be invoked with no arguments and is
  expected to return a floating-point value, of which only the fractional part
  will be used.
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.63";       # FIXUP
  $VERSION =~ tr/_//d;         # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-gnu-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.63";
  $VERSION =~ tr/_//d;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  # populating @EXPORT_FAIL is done in the XS code
  sub export_fail {
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in this version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =head2 Core Perl C<builtin> Functions
  
  Many functions in this module have served as the inspiration for a new
  experimental facility in recent versions of Perl. From various development
  versions, starting at 5.35.7, equivalent functions to many of these utilities
  are available in the C<builtin::> package.
  
      use Scalar::Util qw(blessed);
  
      $class = blessed $obj;
  
      $class = builtin::blessed $obj;  # equivalent
  
  For more information, see the documentation on L<builtin>.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::blessed>.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::refaddr>.
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  Note that for internal reasons, all precompiled regexps (C<qr/.../>) are
  blessed references; thus C<ref()> returns the package name string C<"Regexp">
  on these but C<reftype()> will return the underlying C structure type of
  C<"REGEXP"> in all capitals.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::reftype>.
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::weaken>.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::unweaken>.
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::is_weak>.
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  standard operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  The C<$!> variable is commonly dual-valued, though it is also magical in other
  ways:
  
      $! = 1;
      $dual = isdual($!);                 # true
      print("$!\n");                      # "Operation not permitted"
  
  B<CAUTION>: This function is not as useful as it may seem. Dualvars are not a
  distinct concept in Perl, but a standard internal construct of all scalar
  values. Almost any value could be considered as a dualvar by this function
  through the course of normal operations.
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself, if C<$fh> may be used as a filehandle and is open, or if
  it is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Vstrings are not implemented in this version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SOCKET';
  package Socket;
  
  use v5.6.1;
  use strict;
  
  our $VERSION = '2.037';
  
  =head1 NAME
  
  C<Socket> - networking constants and support functions
  
  =head1 SYNOPSIS
  
  C<Socket> a low-level module used by, among other things, the L<IO::Socket>
  family of modules. The following examples demonstrate some low-level uses but
  a practical program would likely use the higher-level API provided by
  C<IO::Socket> or similar instead.
  
      use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);
  
      socket(my $socket, PF_INET, SOCK_STREAM, 0)
          or die "socket: $!";
  
      my $port = getservbyname "echo", "tcp";
      connect($socket, pack_sockaddr_in($port, inet_aton("localhost")))
          or die "connect: $!";
  
      print $socket "Hello, world!\n";
      print <$socket>;
  
  See also the L</EXAMPLES> section.
  
  =head1 DESCRIPTION
  
  This module provides a variety of constants, structure manipulators and other
  functions related to socket-based networking. The values and functions
  provided are useful when used in conjunction with Perl core functions such as
  socket(), setsockopt() and bind(). It also provides several other support
  functions, mostly for dealing with conversions of network addresses between
  human-readable and native binary forms, and for hostname resolver operations.
  
  Some constants and functions are exported by default by this module; but for
  backward-compatibility any recently-added symbols are not exported by default
  and must be requested explicitly. When an import list is provided to the
  C<use Socket> line, the default exports are not automatically imported. It is
  therefore best practice to always to explicitly list all the symbols required.
  
  Also, some common socket "newline" constants are provided: the constants
  C<CR>, C<LF>, and C<CRLF>, as well as C<$CR>, C<$LF>, and C<$CRLF>, which map
  to C<\015>, C<\012>, and C<\015\012>. If you do not want to use the literal
  characters in your programs, then use the constants provided here. They are
  not exported by default, but can be imported individually, and with the
  C<:crlf> export tag:
  
      use Socket qw(:DEFAULT :crlf);
  
      $sock->print("GET / HTTP/1.0$CRLF");
  
  The entire getaddrinfo() subsystem can be exported using the tag C<:addrinfo>;
  this exports the getaddrinfo() and getnameinfo() functions, and all the
  C<AI_*>, C<NI_*>, C<NIx_*> and C<EAI_*> constants.
  
  =cut
  
  =head1 CONSTANTS
  
  In each of the following groups, there may be many more constants provided
  than just the ones given as examples in the section heading. If the heading
  ends C<...> then this means there are likely more; the exact constants
  provided will depend on the OS and headers found at compile-time.
  
  =cut
  
  =head2 PF_INET, PF_INET6, PF_UNIX, ...
  
  Protocol family constants to use as the first argument to socket() or the
  value of the C<SO_DOMAIN> or C<SO_FAMILY> socket option.
  
  =head2 AF_INET, AF_INET6, AF_UNIX, ...
  
  Address family constants used by the socket address structures, to pass to
  such functions as inet_pton() or getaddrinfo(), or are returned by such
  functions as sockaddr_family().
  
  =head2 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...
  
  Socket type constants to use as the second argument to socket(), or the value
  of the C<SO_TYPE> socket option.
  
  =head2 SOCK_NONBLOCK. SOCK_CLOEXEC
  
  Linux-specific shortcuts to specify the C<O_NONBLOCK> and C<FD_CLOEXEC> flags
  during a C<socket(2)> call.
  
      socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )
  
  =head2 SOL_SOCKET
  
  Socket option level constant for setsockopt() and getsockopt().
  
  =head2 SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...
  
  Socket option name constants for setsockopt() and getsockopt() at the
  C<SOL_SOCKET> level.
  
  =head2 IP_OPTIONS, IP_TOS, IP_TTL, ...
  
  Socket option name constants for IPv4 socket options at the C<IPPROTO_IP>
  level.
  
  =head2 IP_PMTUDISC_WANT, IP_PMTUDISC_DONT, ...
  
  Socket option value constants for C<IP_MTU_DISCOVER> socket option.
  
  =head2 IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...
  
  Socket option value constants for C<IP_TOS> socket option.
  
  =head2 MSG_BCAST, MSG_OOB, MSG_TRUNC, ...
  
  Message flag constants for send() and recv().
  
  =head2 SHUT_RD, SHUT_RDWR, SHUT_WR
  
  Direction constants for shutdown().
  
  =head2 INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE
  
  Constants giving the special C<AF_INET> addresses for wildcard, broadcast,
  local loopback, and invalid addresses.
  
  Normally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),
  inet_aton('localhost') and inet_aton('255.255.255.255') respectively.
  
  =head2 IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...
  
  IP protocol constants to use as the third argument to socket(), the level
  argument to getsockopt() or setsockopt(), or the value of the C<SO_PROTOCOL>
  socket option.
  
  =head2 TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...
  
  Socket option name constants for TCP socket options at the C<IPPROTO_TCP>
  level.
  
  =head2 IN6ADDR_ANY, IN6ADDR_LOOPBACK
  
  Constants giving the special C<AF_INET6> addresses for wildcard and local
  loopback.
  
  Normally equivalent to inet_pton(AF_INET6, "::") and
  inet_pton(AF_INET6, "::1") respectively.
  
  =head2 IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...
  
  Socket option name constants for IPv6 socket options at the C<IPPROTO_IPV6>
  level.
  
  =cut
  
  # Still undocumented: SCM_*, SOMAXCONN, IOV_MAX, UIO_MAXIOV
  
  =head1 STRUCTURE MANIPULATORS
  
  The following functions convert between lists of Perl values and packed binary
  strings representing structures.
  
  =cut
  
  =head2 $family = sockaddr_family $sockaddr
  
  Takes a packed socket address (as returned by pack_sockaddr_in(),
  pack_sockaddr_un() or the perl builtin functions getsockname() and
  getpeername()). Returns the address family tag. This will be one of the
  C<AF_*> constants, such as C<AF_INET> for a C<sockaddr_in> addresses or
  C<AF_UNIX> for a C<sockaddr_un>. It can be used to figure out what unpack to
  use for a sockaddr of unknown type.
  
  =head2 $sockaddr = pack_sockaddr_in $port, $ip_address
  
  Takes two arguments, a port number and an opaque string (as returned by
  inet_aton(), or a v-string). Returns the C<sockaddr_in> structure with those
  arguments packed in and C<AF_INET> filled in. For Internet domain sockets,
  this structure is normally what you need for the arguments in bind(),
  connect(), and send().
  
  An undefined $port argument is taken as zero; an undefined $ip_address is
  considered a fatal error.
  
  =head2 ($port, $ip_address) = unpack_sockaddr_in $sockaddr
  
  Takes a C<sockaddr_in> structure (as returned by pack_sockaddr_in(),
  getpeername() or recv()). Returns a list of two elements: the port and an
  opaque string representing the IP address (you can use inet_ntoa() to convert
  the address to the four-dotted numeric format). Will croak if the structure
  does not represent an C<AF_INET> address.
  
  In scalar context will return just the IP address.
  
  =head2 $sockaddr = sockaddr_in $port, $ip_address
  
  =head2 ($port, $ip_address) = sockaddr_in $sockaddr
  
  A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context,
  unpacks its argument and returns a list consisting of the port and IP address.
  In scalar context, packs its port and IP address arguments as a C<sockaddr_in>
  and returns it.
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_in() or unpack_sockaddr_in() explicitly.
  
  =head2 $sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
  
  Takes two to four arguments, a port number, an opaque string (as returned by
  inet_pton()), optionally a scope ID number, and optionally a flow label
  number. Returns the C<sockaddr_in6> structure with those arguments packed in
  and C<AF_INET6> filled in. IPv6 equivalent of pack_sockaddr_in().
  
  An undefined $port argument is taken as zero; an undefined $ip6_address is
  considered a fatal error.
  
  =head2 ($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr
  
  Takes a C<sockaddr_in6> structure. Returns a list of four elements: the port
  number, an opaque string representing the IPv6 address, the scope ID, and the
  flow label. (You can use inet_ntop() to convert the address to the usual
  string format). Will croak if the structure does not represent an C<AF_INET6>
  address.
  
  In scalar context will return just the IP address.
  
  =head2 $sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
  
  =head2 ($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr
  
  A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context,
  unpacks its argument according to unpack_sockaddr_in6(). In scalar context,
  packs its arguments according to pack_sockaddr_in6().
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.
  
  =head2 $sockaddr = pack_sockaddr_un $path
  
  Takes one argument, a pathname. Returns the C<sockaddr_un> structure with that
  path packed in with C<AF_UNIX> filled in. For C<PF_UNIX> sockets, this
  structure is normally what you need for the arguments in bind(), connect(),
  and send().
  
  =head2 ($path) = unpack_sockaddr_un $sockaddr
  
  Takes a C<sockaddr_un> structure (as returned by pack_sockaddr_un(),
  getpeername() or recv()). Returns a list of one element: the pathname. Will
  croak if the structure does not represent an C<AF_UNIX> address.
  
  =head2 $sockaddr = sockaddr_un $path
  
  =head2 ($path) = sockaddr_un $sockaddr
  
  A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context,
  unpacks its argument and returns a list consisting of the pathname. In a
  scalar context, packs its pathname as a C<sockaddr_un> and returns it.
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_un() or unpack_sockaddr_un() explicitly.
  
  These are only supported if your system has E<lt>F<sys/un.h>E<gt>.
  
  =head2 $ip_mreq = pack_ip_mreq $multiaddr, $interface
  
  Takes an IPv4 multicast address and optionally an interface address (or
  C<INADDR_ANY>). Returns the C<ip_mreq> structure with those arguments packed
  in. Suitable for use with the C<IP_ADD_MEMBERSHIP> and C<IP_DROP_MEMBERSHIP>
  sockopts.
  
  =head2 ($multiaddr, $interface) = unpack_ip_mreq $ip_mreq
  
  Takes an C<ip_mreq> structure. Returns a list of two elements; the IPv4
  multicast address and interface address.
  
  =head2 $ip_mreq_source = pack_ip_mreq_source $multiaddr, $source, $interface
  
  Takes an IPv4 multicast address, source address, and optionally an interface
  address (or C<INADDR_ANY>). Returns the C<ip_mreq_source> structure with those
  arguments packed in. Suitable for use with the C<IP_ADD_SOURCE_MEMBERSHIP>
  and C<IP_DROP_SOURCE_MEMBERSHIP> sockopts.
  
  =head2 ($multiaddr, $source, $interface) = unpack_ip_mreq_source $ip_mreq
  
  Takes an C<ip_mreq_source> structure. Returns a list of three elements; the
  IPv4 multicast address, source address and interface address.
  
  =head2 $ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex
  
  Takes an IPv6 multicast address and an interface number. Returns the
  C<ipv6_mreq> structure with those arguments packed in. Suitable for use with
  the C<IPV6_ADD_MEMBERSHIP> and C<IPV6_DROP_MEMBERSHIP> sockopts.
  
  =head2 ($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq
  
  Takes an C<ipv6_mreq> structure. Returns a list of two elements; the IPv6
  address and an interface number.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 $ip_address = inet_aton $string
  
  Takes a string giving the name of a host, or a textual representation of an IP
  address and translates that to an packed binary address structure suitable to
  pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved,
  returns C<undef>. For multi-homed hosts (hosts with more than one address),
  the first address found is returned.
  
  For portability do not assume that the result of inet_aton() is 32 bits wide,
  in other words, that it would contain only the IPv4 address in network order.
  
  This IPv4-only function is provided largely for legacy reasons. Newly-written
  code should use getaddrinfo() or inet_pton() instead for IPv6 support.
  
  =head2 $string = inet_ntoa $ip_address
  
  Takes a packed binary address structure such as returned by
  unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4
  address in network order) and translates it into a string of the form
  C<d.d.d.d> where the C<d>s are numbers less than 256 (the normal
  human-readable four dotted number notation for Internet addresses).
  
  This IPv4-only function is provided largely for legacy reasons. Newly-written
  code should use getnameinfo() or inet_ntop() instead for IPv6 support.
  
  =head2 $address = inet_pton $family, $string
  
  Takes an address family (such as C<AF_INET> or C<AF_INET6>) and a string
  containing a textual representation of an address in that family and
  translates that to an packed binary address structure.
  
  See also getaddrinfo() for a more powerful and flexible function to look up
  socket addresses given hostnames or textual addresses.
  
  =head2 $string = inet_ntop $family, $address
  
  Takes an address family and a packed binary address structure and translates
  it into a human-readable textual representation of the address; typically in
  C<d.d.d.d> form for C<AF_INET> or C<hhhh:hhhh::hhhh> form for C<AF_INET6>.
  
  See also getnameinfo() for a more powerful and flexible function to turn
  socket addresses into human-readable textual representations.
  
  =head2 ($err, @result) = getaddrinfo $host, $service, [$hints]
  
  Given both a hostname and service name, this function attempts to resolve the
  host name into a list of network addresses, and the service name into a
  protocol and port number, and then returns a list of address structures
  suitable to connect() to it.
  
  Given just a host name, this function attempts to resolve it to a list of
  network addresses, and then returns a list of address structures giving these
  addresses.
  
  Given just a service name, this function attempts to resolve it to a protocol
  and port number, and then returns a list of address structures that represent
  it suitable to bind() to. This use should be combined with the C<AI_PASSIVE>
  flag; see below.
  
  Given neither name, it generates an error.
  
  If present, $hints should be a reference to a hash, where the following keys
  are recognised:
  
  =over 4
  
  =item flags => INT
  
  A bitfield containing C<AI_*> constants; see below.
  
  =item family => INT
  
  Restrict to only generating addresses in this address family
  
  =item socktype => INT
  
  Restrict to only generating addresses of this socket type
  
  =item protocol => INT
  
  Restrict to only generating addresses for this protocol
  
  =back
  
  The return value will be a list; the first value being an error indication,
  followed by a list of address structures (if no error occurred).
  
  The error value will be a dualvar; comparable to the C<EAI_*> error constants,
  or printable as a human-readable error message string. If no error occurred it
  will be zero numerically and an empty string.
  
  Each value in the results list will be a hash reference containing the following
  fields:
  
  =over 4
  
  =item family => INT
  
  The address family (e.g. C<AF_INET>)
  
  =item socktype => INT
  
  The socket type (e.g. C<SOCK_STREAM>)
  
  =item protocol => INT
  
  The protocol (e.g. C<IPPROTO_TCP>)
  
  =item addr => STRING
  
  The address in a packed string (such as would be returned by
  pack_sockaddr_in())
  
  =item canonname => STRING
  
  The canonical name for the host if the C<AI_CANONNAME> flag was provided, or
  C<undef> otherwise. This field will only be present on the first returned
  address.
  
  =back
  
  The following flag constants are recognised in the $hints hash. Other flag
  constants may exist as provided by the OS.
  
  =over 4
  
  =item AI_PASSIVE
  
  Indicates that this resolution is for a local bind() for a passive (i.e.
  listening) socket, rather than an active (i.e. connecting) socket.
  
  =item AI_CANONNAME
  
  Indicates that the caller wishes the canonical hostname (C<canonname>) field
  of the result to be filled in.
  
  =item AI_NUMERICHOST
  
  Indicates that the caller will pass a numeric address, rather than a hostname,
  and that getaddrinfo() must not perform a resolve operation on this name. This
  flag will prevent a possibly-slow network lookup operation, and instead return
  an error if a hostname is passed.
  
  =back
  
  =head2 ($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]
  
  Given a packed socket address (such as from getsockname(), getpeername(), or
  returned by getaddrinfo() in a C<addr> field), returns the hostname and
  symbolic service name it represents. $flags may be a bitmask of C<NI_*>
  constants, or defaults to 0 if unspecified.
  
  The return value will be a list; the first value being an error condition,
  followed by the hostname and service name.
  
  The error value will be a dualvar; comparable to the C<EAI_*> error constants,
  or printable as a human-readable error message string. The host and service
  names will be plain strings.
  
  The following flag constants are recognised as $flags. Other flag constants may
  exist as provided by the OS.
  
  =over 4
  
  =item NI_NUMERICHOST
  
  Requests that a human-readable string representation of the numeric address be
  returned directly, rather than performing a name resolve operation that may
  convert it into a hostname. This will also avoid potentially-blocking network
  IO.
  
  =item NI_NUMERICSERV
  
  Requests that the port number be returned directly as a number representation
  rather than performing a name resolve operation that may convert it into a
  service name.
  
  =item NI_NAMEREQD
  
  If a name resolve operation fails to provide a name, then this flag will cause
  getnameinfo() to indicate an error, rather than returning the numeric
  representation as a human-readable string.
  
  =item NI_DGRAM
  
  Indicates that the socket address relates to a C<SOCK_DGRAM> socket, for the
  services whose name differs between TCP and UDP protocols.
  
  =back
  
  The following constants may be supplied as $xflags.
  
  =over 4
  
  =item NIx_NOHOST
  
  Indicates that the caller is not interested in the hostname of the result, so
  it does not have to be converted. C<undef> will be returned as the hostname.
  
  =item NIx_NOSERV
  
  Indicates that the caller is not interested in the service name of the result,
  so it does not have to be converted. C<undef> will be returned as the service
  name.
  
  =back
  
  =head1 getaddrinfo() / getnameinfo() ERROR CONSTANTS
  
  The following constants may be returned by getaddrinfo() or getnameinfo().
  Others may be provided by the OS.
  
  =over 4
  
  =item EAI_AGAIN
  
  A temporary failure occurred during name resolution. The operation may be
  successful if it is retried later.
  
  =item EAI_BADFLAGS
  
  The value of the C<flags> hint to getaddrinfo(), or the $flags parameter to
  getnameinfo() contains unrecognised flags.
  
  =item EAI_FAMILY
  
  The C<family> hint to getaddrinfo(), or the family of the socket address
  passed to getnameinfo() is not supported.
  
  =item EAI_NODATA
  
  The host name supplied to getaddrinfo() did not provide any usable address
  data.
  
  =item EAI_NONAME
  
  The host name supplied to getaddrinfo() does not exist, or the address
  supplied to getnameinfo() is not associated with a host name and the
  C<NI_NAMEREQD> flag was supplied.
  
  =item EAI_SERVICE
  
  The service name supplied to getaddrinfo() is not available for the socket
  type given in the $hints.
  
  =back
  
  =cut
  
  =head1 EXAMPLES
  
  =head2 Lookup for connect()
  
  The getaddrinfo() function converts a hostname and a service name into a list
  of structures, each containing a potential way to connect() to the named
  service on the named host.
  
      use IO::Socket;
      use Socket qw(SOCK_STREAM getaddrinfo);
  
      my %hints = (socktype => SOCK_STREAM);
      my ($err, @res) = getaddrinfo("localhost", "echo", \%hints);
      die "Cannot getaddrinfo - $err" if $err;
  
      my $sock;
  
      foreach my $ai (@res) {
          my $candidate = IO::Socket->new();
  
          $candidate->socket($ai->{family}, $ai->{socktype}, $ai->{protocol})
              or next;
  
          $candidate->connect($ai->{addr})
              or next;
  
          $sock = $candidate;
          last;
      }
  
      die "Cannot connect to localhost:echo" unless $sock;
  
      $sock->print("Hello, world!\n");
      print <$sock>;
  
  Because a list of potential candidates is returned, the C<while> loop tries
  each in turn until it finds one that succeeds both the socket() and connect()
  calls.
  
  This function performs the work of the legacy functions gethostbyname(),
  getservbyname(), inet_aton() and pack_sockaddr_in().
  
  In practice this logic is better performed by L<IO::Socket::IP>.
  
  =head2 Making a human-readable string out of an address
  
  The getnameinfo() function converts a socket address, such as returned by
  getsockname() or getpeername(), into a pair of human-readable strings
  representing the address and service name.
  
      use IO::Socket::IP;
      use Socket qw(getnameinfo);
  
      my $server = IO::Socket::IP->new(LocalPort => 12345, Listen => 1) or
          die "Cannot listen - $@";
  
      my $socket = $server->accept or die "accept: $!";
  
      my ($err, $hostname, $servicename) = getnameinfo($socket->peername);
      die "Cannot getnameinfo - $err" if $err;
  
      print "The peer is connected from $hostname\n";
  
  Since in this example only the hostname was used, the redundant conversion of
  the port number into a service name may be omitted by passing the
  C<NIx_NOSERV> flag.
  
      use Socket qw(getnameinfo NIx_NOSERV);
  
      my ($err, $hostname) = getnameinfo($socket->peername, 0, NIx_NOSERV);
  
  This function performs the work of the legacy functions unpack_sockaddr_in(),
  inet_ntoa(), gethostbyaddr() and getservbyport().
  
  In practice this logic is better performed by L<IO::Socket::IP>.
  
  =head2 Resolving hostnames into IP addresses
  
  To turn a hostname into a human-readable plain IP address use getaddrinfo()
  to turn the hostname into a list of socket structures, then getnameinfo() on
  each one to make it a readable IP address again.
  
      use Socket qw(:addrinfo SOCK_RAW);
  
      my ($err, @res) = getaddrinfo($hostname, "", {socktype => SOCK_RAW});
      die "Cannot getaddrinfo - $err" if $err;
  
      while( my $ai = shift @res ) {
          my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);
          die "Cannot getnameinfo - $err" if $err;
  
          print "$ipaddr\n";
      }
  
  The C<socktype> hint to getaddrinfo() filters the results to only include one
  socket type and protocol. Without this most OSes return three combinations,
  for C<SOCK_STREAM>, C<SOCK_DGRAM> and C<SOCK_RAW>, resulting in triplicate
  output of addresses. The C<NI_NUMERICHOST> flag to getnameinfo() causes it to
  return a string-formatted plain IP address, rather than reverse resolving it
  back into a hostname.
  
  This combination performs the work of the legacy functions gethostbyname()
  and inet_ntoa().
  
  =head2 Accessing socket options
  
  The many C<SO_*> and other constants provide the socket option names for
  getsockopt() and setsockopt().
  
      use IO::Socket::INET;
      use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);
  
      my $socket = IO::Socket::INET->new(LocalPort => 0, Proto => 'udp')
          or die "Cannot create socket: $@";
  
      $socket->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or
          die "setsockopt: $!";
  
      print "Receive buffer is ", $socket->getsockopt(SOL_SOCKET, SO_RCVBUF),
          " bytes\n";
  
      print "IP TTL is ", $socket->getsockopt(IPPROTO_IP, IP_TTL), "\n";
  
  As a convenience, L<IO::Socket>'s setsockopt() method will convert a number
  into a packed byte buffer, and getsockopt() will unpack a byte buffer of the
  correct size back into a number.
  
  =cut
  
  =head1 AUTHOR
  
  This module was originally maintained in Perl core by the Perl 5 Porters.
  
  It was extracted to dual-life on CPAN at version 1.95 by
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  use Carp;
  use warnings::register;
  
  require Exporter;
  require XSLoader;
  our @ISA = qw(Exporter);
  
  # <@Nicholas> you can't change @EXPORT without breaking the implicit API
  # Please put any new constants in @EXPORT_OK!
  
  # List re-ordered to match documentation above. Try to keep the ordering
  # consistent so it's easier to see which ones are or aren't documented.
  our @EXPORT = qw(
      PF_802 PF_AAL PF_APPLETALK PF_CCITT PF_CHAOS PF_CTF PF_DATAKIT
      PF_DECnet PF_DLI PF_ECMA PF_GOSIP PF_HYLINK PF_IMPLINK PF_INET PF_INET6
      PF_ISO PF_KEY PF_LAST PF_LAT PF_LINK PF_MAX PF_NBS PF_NIT PF_NS PF_OSI
      PF_OSINET PF_PUP PF_ROUTE PF_SNA PF_UNIX PF_UNSPEC PF_USER PF_WAN
      PF_X25
  
      AF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT
      AF_DECnet AF_DLI AF_ECMA AF_GOSIP AF_HYLINK AF_IMPLINK AF_INET AF_INET6
      AF_ISO AF_KEY AF_LAST AF_LAT AF_LINK AF_MAX AF_NBS AF_NIT AF_NS AF_OSI
      AF_OSINET AF_PUP AF_ROUTE AF_SNA AF_UNIX AF_UNSPEC AF_USER AF_WAN
      AF_X25
  
      SOCK_DGRAM SOCK_RAW SOCK_RDM SOCK_SEQPACKET SOCK_STREAM
  
      SOL_SOCKET
  
      SO_ACCEPTCONN SO_ATTACH_FILTER SO_BACKLOG SO_BROADCAST SO_CHAMELEON
      SO_DEBUG SO_DETACH_FILTER SO_DGRAM_ERRIND SO_DOMAIN SO_DONTLINGER
      SO_DONTROUTE SO_ERROR SO_FAMILY SO_KEEPALIVE SO_LINGER SO_OOBINLINE
      SO_PASSCRED SO_PASSIFNAME SO_PEERCRED SO_PROTOCOL SO_PROTOTYPE
      SO_RCVBUF SO_RCVLOWAT SO_RCVTIMEO SO_REUSEADDR SO_REUSEPORT
      SO_SECURITY_AUTHENTICATION SO_SECURITY_ENCRYPTION_NETWORK
      SO_SECURITY_ENCRYPTION_TRANSPORT SO_SNDBUF SO_SNDLOWAT SO_SNDTIMEO
      SO_STATE SO_TYPE SO_USELOOPBACK SO_XOPEN SO_XSE
  
      IP_HDRINCL IP_OPTIONS IP_RECVOPTS IP_RECVRETOPTS IP_RETOPTS IP_TOS
      IP_TTL
  
      MSG_BCAST MSG_BTAG MSG_CTLFLAGS MSG_CTLIGNORE MSG_CTRUNC MSG_DONTROUTE
      MSG_DONTWAIT MSG_EOF MSG_EOR MSG_ERRQUEUE MSG_ETAG MSG_FASTOPEN MSG_FIN
      MSG_MAXIOVLEN MSG_MCAST MSG_NOSIGNAL MSG_OOB MSG_PEEK MSG_PROXY MSG_RST
      MSG_SYN MSG_TRUNC MSG_URG MSG_WAITALL MSG_WIRE
  
      SHUT_RD SHUT_RDWR SHUT_WR
  
      INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
  
      SCM_CONNECT SCM_CREDENTIALS SCM_CREDS SCM_RIGHTS SCM_TIMESTAMP
  
      SOMAXCONN
  
      IOV_MAX
      UIO_MAXIOV
  
      sockaddr_family
      pack_sockaddr_in  unpack_sockaddr_in  sockaddr_in
      pack_sockaddr_in6 unpack_sockaddr_in6 sockaddr_in6
      pack_sockaddr_un  unpack_sockaddr_un  sockaddr_un 
  
      inet_aton inet_ntoa
  );
  
  # List re-ordered to match documentation above. Try to keep the ordering
  # consistent so it's easier to see which ones are or aren't documented.
  our @EXPORT_OK = qw(
      CR LF CRLF $CR $LF $CRLF
  
      SOCK_NONBLOCK SOCK_CLOEXEC
  
      IP_ADD_MEMBERSHIP IP_ADD_SOURCE_MEMBERSHIP IP_BIND_ADDRESS_NO_PORT
      IP_DROP_MEMBERSHIP IP_DROP_SOURCE_MEMBERSHIP IP_FREEBIND
      IP_MULTICAST_ALL IP_MULTICAST_IF IP_MULTICAST_LOOP IP_MULTICAST_TTL
      IP_MTU IP_MTU_DISCOVER IP_NODEFRAG IP_RECVERR IP_TRANSPARENT
  
      IPPROTO_IP IPPROTO_IPV6 IPPROTO_RAW IPPROTO_ICMP IPPROTO_IGMP
      IPPROTO_TCP IPPROTO_UDP IPPROTO_GRE IPPROTO_ESP IPPROTO_AH
      IPPROTO_ICMPV6 IPPROTO_SCTP
  
      IP_PMTUDISC_DO IP_PMTUDISC_DONT IP_PMTUDISC_PROBE IP_PMTUDISC_WANT
  
      IPTOS_LOWDELAY IPTOS_THROUGHPUT IPTOS_RELIABILITY IPTOS_MINCOST
  
      TCP_CONGESTION TCP_CONNECTIONTIMEOUT TCP_CORK TCP_DEFER_ACCEPT
      TCP_FASTOPEN TCP_INFO TCP_INIT_CWND TCP_KEEPALIVE TCP_KEEPCNT
      TCP_KEEPIDLE TCP_KEEPINTVL TCP_LINGER2 TCP_MAXRT TCP_MAXSEG
      TCP_MD5SIG TCP_NODELAY TCP_NOOPT TCP_NOPUSH TCP_QUICKACK
      TCP_SACK_ENABLE TCP_STDURG TCP_SYNCNT TCP_USER_TIMEOUT
      TCP_WINDOW_CLAMP
  
      IN6ADDR_ANY IN6ADDR_LOOPBACK
  
      IPV6_ADDRFROM IPV6_ADD_MEMBERSHIP IPV6_DROP_MEMBERSHIP IPV6_JOIN_GROUP
      IPV6_LEAVE_GROUP IPV6_MTU IPV6_MTU_DISCOVER IPV6_MULTICAST_HOPS
      IPV6_MULTICAST_IF IPV6_MULTICAST_LOOP IPV6_RECVERR IPV6_ROUTER_ALERT
      IPV6_UNICAST_HOPS IPV6_V6ONLY
  
      SO_INCOMING_CPU SO_INCOMING_NAPI_ID SO_LOCK_FILTER SO_RCVBUFFORCE
      SO_SNDBUFFORCE
  
      pack_ip_mreq unpack_ip_mreq pack_ip_mreq_source unpack_ip_mreq_source
  
      pack_ipv6_mreq unpack_ipv6_mreq
  
      inet_pton inet_ntop
  
      getaddrinfo getnameinfo
  
      AI_ADDRCONFIG AI_ALL AI_CANONIDN AI_CANONNAME AI_IDN
      AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES AI_NUMERICHOST
      AI_NUMERICSERV AI_PASSIVE AI_V4MAPPED
  
      NI_DGRAM NI_IDN NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES
      NI_NAMEREQD NI_NOFQDN NI_NUMERICHOST NI_NUMERICSERV
  
      NIx_NOHOST NIx_NOSERV
  
      EAI_ADDRFAMILY EAI_AGAIN EAI_BADFLAGS EAI_BADHINTS EAI_FAIL EAI_FAMILY
      EAI_NODATA EAI_NONAME EAI_PROTOCOL EAI_SERVICE EAI_SOCKTYPE EAI_SYSTEM
  );
  
  our %EXPORT_TAGS = (
      crlf     => [qw(CR LF CRLF $CR $LF $CRLF)],
      addrinfo => [qw(getaddrinfo getnameinfo), grep m/^(?:AI|NI|NIx|EAI)_/, @EXPORT_OK],
      all      => [@EXPORT, @EXPORT_OK],
  );
  
  BEGIN {
      sub CR   () {"\015"}
      sub LF   () {"\012"}
      sub CRLF () {"\015\012"}
  
      # These are not gni() constants; they're extensions for the perl API
      # The definitions in Socket.pm and Socket.xs must match
      sub NIx_NOHOST() {1 << 0}
      sub NIx_NOSERV() {1 << 1}
  }
  
  *CR   = \CR();
  *LF   = \LF();
  *CRLF = \CRLF();
  
  # The four deprecated addrinfo constants
  foreach my $name (qw( AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES )) {
      no strict 'refs';
      *$name = sub {
          croak "The addrinfo constant $name is deprecated";
      };
  }
  
  sub sockaddr_in {
      if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die
          my($af, $port, @quad) = @_;
          warnings::warn "6-ARG sockaddr_in call is deprecated" 
              if warnings::enabled();
          pack_sockaddr_in($port, inet_aton(join('.', @quad)));
      } elsif (wantarray) {
          croak "usage:   (port,iaddr) = sockaddr_in(sin_sv)" unless @_ == 1;
          unpack_sockaddr_in(@_);
      } else {
          croak "usage:   sin_sv = sockaddr_in(port,iaddr))" unless @_ == 2;
          pack_sockaddr_in(@_);
      }
  }
  
  sub sockaddr_in6 {
      if (wantarray) {
          croak "usage:   (port,in6addr,scope_id,flowinfo) = sockaddr_in6(sin6_sv)" unless @_ == 1;
          unpack_sockaddr_in6(@_);
      }
      else {
          croak "usage:   sin6_sv = sockaddr_in6(port,in6addr,[scope_id,[flowinfo]])" unless @_ >= 2 and @_ <= 4;
          pack_sockaddr_in6(@_);
      }
  }
  
  sub sockaddr_un {
      if (wantarray) {
          croak "usage:   (filename) = sockaddr_un(sun_sv)" unless @_ == 1;
          unpack_sockaddr_un(@_);
      } else {
          croak "usage:   sun_sv = sockaddr_un(filename)" unless @_ == 1;
          pack_sockaddr_un(@_);
      }
  }
  
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my %errstr;
  
  if( defined &getaddrinfo ) {
      # These are not part of the API, nothing uses them, and deleting them
      # reduces the size of %Socket:: by about 12K
      delete $Socket::{fake_getaddrinfo};
      delete $Socket::{fake_getnameinfo};
  } else {
      require Scalar::Util;
  
      *getaddrinfo = \&fake_getaddrinfo;
      *getnameinfo = \&fake_getnameinfo;
  
      # These numbers borrowed from GNU libc's implementation, but since
      # they're only used by our emulation, it doesn't matter if the real
      # platform's values differ
      my %constants = (
          AI_PASSIVE     => 1,
          AI_CANONNAME   => 2,
          AI_NUMERICHOST => 4,
          AI_V4MAPPED    => 8,
          AI_ALL         => 16,
          AI_ADDRCONFIG  => 32,
          # RFC 2553 doesn't define this but Linux does - lets be nice and
          # provide it since we can
          AI_NUMERICSERV => 1024,
  
          EAI_BADFLAGS   => -1,
          EAI_NONAME     => -2,
          EAI_NODATA     => -5,
          EAI_FAMILY     => -6,
          EAI_SERVICE    => -8,
  
          NI_NUMERICHOST => 1,
          NI_NUMERICSERV => 2,
          NI_NOFQDN      => 4,
          NI_NAMEREQD    => 8,
          NI_DGRAM       => 16,
  
          # Constants we don't support. Export them, but croak if anyone tries to
          # use them
          AI_IDN      => 64,
          AI_CANONIDN => 128,
          NI_IDN      => 32,
  
          # Error constants we'll never return, so it doesn't matter what value
          # these have, nor that we don't provide strings for them
          EAI_SYSTEM   => -11,
          EAI_BADHINTS => -1000,
          EAI_PROTOCOL => -1001
      );
  
      foreach my $name ( keys %constants ) {
          my $value = $constants{$name};
  
          no strict 'refs';
          defined &$name or *$name = sub () { $value };
      }
  
      %errstr = (
          # These strings from RFC 2553
          EAI_BADFLAGS()   => "invalid value for ai_flags",
          EAI_NONAME()     => "nodename nor servname provided, or not known",
          EAI_NODATA()     => "no address associated with nodename",
          EAI_FAMILY()     => "ai_family not supported",
          EAI_SERVICE()    => "servname not supported for ai_socktype",
      );
  }
  
  # The following functions are used if the system does not have a
  # getaddrinfo(3) function in libc; and are used to emulate it for the AF_INET
  # family
  
  # Borrowed from Regexp::Common::net
  my $REGEXP_IPv4_DECIMAL = qr/25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}/;
  my $REGEXP_IPv4_DOTTEDQUAD = qr/$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL/;
  
  sub fake_makeerr
  {
      my ( $errno ) = @_;
      my $errstr = $errno == 0 ? "" : ( $errstr{$errno} || $errno );
      return Scalar::Util::dualvar( $errno, $errstr );
  }
  
  sub fake_getaddrinfo
  {
      my ( $node, $service, $hints ) = @_;
  
      $node = "" unless defined $node;
  
      $service = "" unless defined $service;
  
      my ( $family, $socktype, $protocol, $flags ) = @$hints{qw( family socktype protocol flags )};
  
      $family ||= Socket::AF_INET(); # 0 == AF_UNSPEC, which we want too
      $family == Socket::AF_INET() or return fake_makeerr( EAI_FAMILY() );
  
      $socktype ||= 0;
  
      $protocol ||= 0;
  
      $flags ||= 0;
  
      my $flag_passive     = $flags & AI_PASSIVE();     $flags &= ~AI_PASSIVE();
      my $flag_canonname   = $flags & AI_CANONNAME();   $flags &= ~AI_CANONNAME();
      my $flag_numerichost = $flags & AI_NUMERICHOST(); $flags &= ~AI_NUMERICHOST();
      my $flag_numericserv = $flags & AI_NUMERICSERV(); $flags &= ~AI_NUMERICSERV();
  
      # These constants don't apply to AF_INET-only lookups, so we might as well
      # just ignore them. For AI_ADDRCONFIG we just presume the host has ability
      # to talk AF_INET. If not we'd have to return no addresses at all. :)
      $flags &= ~(AI_V4MAPPED()|AI_ALL()|AI_ADDRCONFIG());
  
      $flags & (AI_IDN()|AI_CANONIDN()) and
          croak "Socket::getaddrinfo() does not support IDN";
  
      $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
  
      $node eq "" and $service eq "" and return fake_makeerr( EAI_NONAME() );
  
      my $canonname;
      my @addrs;
      if( $node ne "" ) {
          return fake_makeerr( EAI_NONAME() ) if( $flag_numerichost and $node !~ m/^$REGEXP_IPv4_DOTTEDQUAD$/ );
          ( $canonname, undef, undef, undef, @addrs ) = gethostbyname( $node );
          defined $canonname or return fake_makeerr( EAI_NONAME() );
  
          undef $canonname unless $flag_canonname;
      }
      else {
          $addrs[0] = $flag_passive ? Socket::inet_aton( "0.0.0.0" )
                                    : Socket::inet_aton( "127.0.0.1" );
      }
  
      my @ports; # Actually ARRAYrefs of [ socktype, protocol, port ]
      my $protname = "";
      if( $protocol ) {
          $protname = eval { getprotobynumber( $protocol ) };
      }
  
      if( $service ne "" and $service !~ m/^\d+$/ ) {
          return fake_makeerr( EAI_NONAME() ) if( $flag_numericserv );
          getservbyname( $service, $protname ) or return fake_makeerr( EAI_SERVICE() );
      }
  
      foreach my $this_socktype ( Socket::SOCK_STREAM(), Socket::SOCK_DGRAM(), Socket::SOCK_RAW() ) {
          next if $socktype and $this_socktype != $socktype;
  
          my $this_protname = "raw";
          $this_socktype == Socket::SOCK_STREAM() and $this_protname = "tcp";
          $this_socktype == Socket::SOCK_DGRAM()  and $this_protname = "udp";
  
          next if $protname and $this_protname ne $protname;
  
          my $port;
          if( $service ne "" ) {
              if( $service =~ m/^\d+$/ ) {
                  $port = "$service";
              }
              else {
                  ( undef, undef, $port, $this_protname ) = getservbyname( $service, $this_protname );
                  next unless defined $port;
              }
          }
          else {
              $port = 0;
          }
  
          push @ports, [ $this_socktype, eval { scalar getprotobyname( $this_protname ) } || 0, $port ];
      }
  
      my @ret;
      foreach my $addr ( @addrs ) {
          foreach my $portspec ( @ports ) {
              my ( $socktype, $protocol, $port ) = @$portspec;
              push @ret, {
                  family    => $family,
                  socktype  => $socktype,
                  protocol  => $protocol,
                  addr      => Socket::pack_sockaddr_in( $port, $addr ),
                  canonname => undef,
              };
          }
      }
  
      # Only supply canonname for the first result
      if( defined $canonname ) {
          $ret[0]->{canonname} = $canonname;
      }
  
      return ( fake_makeerr( 0 ), @ret );
  }
  
  sub fake_getnameinfo
  {
      my ( $addr, $flags, $xflags ) = @_;
  
      my ( $port, $inetaddr );
      eval { ( $port, $inetaddr ) = Socket::unpack_sockaddr_in( $addr ) }
          or return fake_makeerr( EAI_FAMILY() );
  
      my $family = Socket::AF_INET();
  
      $flags ||= 0;
  
      my $flag_numerichost = $flags & NI_NUMERICHOST(); $flags &= ~NI_NUMERICHOST();
      my $flag_numericserv = $flags & NI_NUMERICSERV(); $flags &= ~NI_NUMERICSERV();
      my $flag_nofqdn      = $flags & NI_NOFQDN();      $flags &= ~NI_NOFQDN();
      my $flag_namereqd    = $flags & NI_NAMEREQD();    $flags &= ~NI_NAMEREQD();
      my $flag_dgram       = $flags & NI_DGRAM()   ;    $flags &= ~NI_DGRAM();
  
      $flags & NI_IDN() and
          croak "Socket::getnameinfo() does not support IDN";
  
      $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
  
      $xflags ||= 0;
  
      my $node;
      if( $xflags & NIx_NOHOST ) {
          $node = undef;
      }
      elsif( $flag_numerichost ) {
          $node = Socket::inet_ntoa( $inetaddr );
      }
      else {
          $node = gethostbyaddr( $inetaddr, $family );
          if( !defined $node ) {
              return fake_makeerr( EAI_NONAME() ) if $flag_namereqd;
              $node = Socket::inet_ntoa( $inetaddr );
          }
          elsif( $flag_nofqdn ) {
              my ( $shortname ) = split m/\./, $node;
              my ( $fqdn ) = gethostbyname $shortname;
              $node = $shortname if defined $fqdn and $fqdn eq $node;
          }
      }
  
      my $service;
      if( $xflags & NIx_NOSERV ) {
          $service = undef;
      }
      elsif( $flag_numericserv ) {
          $service = "$port";
      }
      else {
          my $protname = $flag_dgram ? "udp" : "";
          $service = getservbyport( $port, $protname );
          if( !defined $service ) {
              $service = "$port";
          }
      }
  
      return ( fake_makeerr( 0 ), $node, $service );
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_SOCKET

$fatpacked{"x86_64-linux-gnu-thread-multi/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.63";
  $VERSION =~ tr/_//d;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If the package the code was compiled in has been deleted
  (e.g. using C<delete_package> from L<Symbol>), C<__ANON__> will be returned as
  the package name. If a name has been set using L</set_subname>, this name will be
  returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Want.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_WANT';
  package Want;
  
  require 5.006;
  use Carp 'croak';
  use strict;
  use warnings;
  
  require Exporter;
  require DynaLoader;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw(want rreturn lnoreturn);
  our @EXPORT_OK = qw(howmany wantref);
  our $VERSION = '0.29';
  
  bootstrap Want $VERSION;
  
  my %reftype = (
      ARRAY  => 1,
      HASH   => 1,
      CODE   => 1,
      GLOB   => 1,
      OBJECT => 1,
  );
  
  sub _wantone {
      my ($uplevel, $arg) = @_;
      
      my $wantref = wantref($uplevel + 1);
      if	  ($arg =~ /^\d+$/) {
  	my $want_count = want_count($uplevel);
  	return ($want_count == -1 || $want_count >= $arg);
      }
      elsif (lc($arg) eq 'infinity') {
  	return (want_count($uplevel) == -1);
      }
      elsif ($arg eq 'REF') {
  	return $wantref;
      }
      elsif ($reftype{$arg}) {
  	return ($wantref eq $arg);
      }
      elsif ($arg eq 'REFSCALAR') {
  	return ($wantref eq 'SCALAR');
      }
      elsif ($arg eq 'LVALUE') {
  	return want_lvalue($uplevel);
      }
      elsif ($arg eq 'RVALUE') {
  	return !want_lvalue($uplevel);
      }
      elsif ($arg eq 'VOID') {
  	return !defined(wantarray_up($uplevel));
      }
      elsif ($arg eq 'SCALAR') {
  	my $gimme = wantarray_up($uplevel);
  	return (defined($gimme) && 0 == $gimme);
      }
      elsif ($arg eq 'BOOL' || $arg eq 'BOOLEAN') {
  	return want_boolean(bump_level($uplevel));
      }
      elsif ($arg eq 'LIST') {
  	return wantarray_up($uplevel);
      }
      elsif ($arg eq 'COUNT') {
  	croak("want: COUNT must be the *only* parameter");
      }
      elsif ($arg eq 'ASSIGN') {
  	return !!wantassign($uplevel + 1);
      }
      else {
  	croak ("want: Unrecognised specifier $arg");
      }    
  }
  
  sub want {
      if (@_ == 1 && $_[0] eq 'ASSIGN') {
  	@_ = (1);
  	goto &wantassign;
      }
      want_uplevel(1, @_);
  }
  
  # Simulate the propagation of context through a return value.
  sub bump_level {
      my ($level) = @_;
      for(;;) {
  	my ($p, $r) = parent_op_name($level+1);
  	if ($p eq "return"
          or  $p eq "(none)" && $r =~ /^leavesub(lv)?$/)
  	{
  	    ++$level
  	}
  	else {
  	    return $level
  	}
      }
  }
  
  sub want_uplevel {
      my ($level, @args) = @_;
  
      # Deal with special cases (for RFC21-consistency):
      if (1 == @args) {
  	@_ = (1 + $level);
  	goto &wantref    if $args[0] eq 'REF';
  	goto &howmany    if $args[0] eq 'COUNT';
  	goto &wantassign if $args[0] eq 'ASSIGN';
      }
  
      for my $arg (map split, @args) {
  	if ($arg =~ /^!(.*)/) {
  	    return 0 unless !_wantone(2 + $level, $1);
  	}
  	else {
  	    return 0 unless _wantone(2 + $level, $arg);
  	}
      }
      
      return 1;
  }
  
  sub howmany () {
      my $level = bump_level(@_, 1);
      my $count = want_count($level);
      return ($count < 0 ? undef : $count);
  }
  
  sub wantref {
      my $level = bump_level(@_, 1);
      my $n = parent_op_name($level);
      if    ($n eq 'rv2av') {
  	return "ARRAY";
      }
      elsif ($n eq 'rv2hv') {
  	return "HASH";
      }
      elsif ($n eq 'rv2cv' || $n eq 'entersub') {
  	return "CODE";
      }
      elsif ($n eq 'rv2gv' || $n eq 'gelem') {
  	return "GLOB";
      }
      elsif ($n eq 'rv2sv') {
  	return "SCALAR";
      }
      elsif ($n eq 'method_call') {
  	return 'OBJECT';
      }
      elsif ($n eq 'multideref') {
  	return first_multideref_type($level);
      }
      else {
  	return "";
      }
  }
  
  sub wantassign {
      my $uplevel = shift();
      return unless want_lvalue($uplevel);
      my $r = want_assign(bump_level($uplevel));
      if (want('BOOL')) {
  	return (defined($r) && 0 != $r);
      }
      else {
  	return $r ? (want('SCALAR') ? $r->[$#$r] : @$r) : ();
      }
  }
  
  sub double_return :lvalue;
  
  sub rreturn (@) {
      if (want_lvalue(1)) {
          croak "Can't rreturn in lvalue context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      {
          return double_return(@_);
      }
  }
  
  sub lnoreturn () : lvalue {
      if (!want_lvalue(1) || !want_assign(1)) {
          croak "Can't lnoreturn except in ASSIGN context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      #
      # But in older versions of perl, adding the extra scope
      # causes the error:
      #   Can't modify loop exit in lvalue subroutine return
      # so we have to check the version.
      if ($] >= 5.019) {
          return double_return(disarm_temp(my $undef));
      }
      return double_return(disarm_temp(my $undef));
  }
  
  # Some naughty people were relying on these internal methods.
  *_wantref = \&wantref;
  *_wantassign = \&wantassign;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Want - A generalisation of C<wantarray>
  
  =head1 SYNOPSIS
  
    use Want;
    sub foo :lvalue {
        if    (want(qw'LVALUE ASSIGN')) {
          print "We have been assigned ", want('ASSIGN');
          lnoreturn;
        }
        elsif (want('LIST')) {
          rreturn (1, 2, 3);
        }
        elsif (want('BOOL')) {
          rreturn 0;
        }
        elsif (want(qw'SCALAR !REF')) {
          rreturn 23;
        }
        elsif (want('HASH')) {
          rreturn { foo => 17, bar => 23 };
        }
        return;  # You have to put this at the end to keep the compiler happy
    }
  
  =head1 DESCRIPTION
  
  This module generalises the mechanism of the B<wantarray> function,
  allowing a function to determine in some detail how its return value
  is going to be immediately used.
  
  =head2 Top-level contexts:
  
  The three kinds of top-level context are well known:
  
  =over 4
  
  =item B<VOID>
  
  The return value is not being used in any way. It could be an entire statement
  like C<foo();>, or the last component of a compound statement which is itself in
  void context, such as C<$test || foo();>n. Be warned that the last statement
  of a subroutine will be in whatever context the subroutine was called in, because
  the result is implicitly returned.
  
  =item B<SCALAR>
  
  The return value is being treated as a scalar value of some sort:
  
    my $x = foo();
    $y += foo();
    print "123" x foo();
    print scalar foo();
    warn foo()->{23};
    ...etc...
  
  =item B<LIST>
  
  The return value is treated as a list of values:
  
    my @x = foo();
    my ($x) = foo();
    () = foo();		# even though the results are discarded
    print foo();
    bar(foo());		# unless the bar subroutine has a prototype
    print @hash{foo()};	# (hash slice)
    ...etc...
  
  =back
  
  =head2 Lvalue subroutines:
  
  The introduction of B<lvalue subroutines> in Perl 5.6 has created a new type
  of contextual information, which is independent of those listed above. When
  an lvalue subroutine is called, it can either be called in the ordinary way
  (so that its result is treated as an ordinary value, an B<rvalue>); or else
  it can be called so that its result is considered updatable, an B<lvalue>.
  
  These rather arcane terms (lvalue and rvalue) are easier to remember if you
  know why they are so called. If you consider a simple assignment statement
  C<left = right>, then the B<l>eft-hand side is an B<l>value and the B<r>ight-hand
  side is an B<r>value.
  
  So (for lvalue subroutines only) there are two new types of context:
  
  =over 4
  
  =item B<RVALUE>
  
  The caller is definitely not trying to assign to the result:
  
    foo();
    my $x = foo();
    ...etc...
  
  If the sub is declared without the C<:lvalue> attribute, then it will
  I<always> be in RVALUE context.
  
  If you need to return values from an lvalue subroutine in RVALUE context,
  you should use the C<rreturn> function rather than an ordinary C<return>.
  Otherwise you'll probably get a compile-time error in perl 5.6.1 and later.
  
  =item B<LVALUE>
  
  Either the caller is directly assigning to the result of the sub call:
  
    foo() = $x;
    foo() = (1, 1, 2, 3, 5, 8);
  
  or the caller is making a reference to the result, which might be assigned to
  later:
  
    my $ref = \(foo());	# Could now have: $$ref = 99;
    
    # Note that this example imposes LIST context on the sub call.
    # So we're taking a reference to the first element to be
    # returned _in list context_.
    # If we want to call the function in scalar context, we can
    # do it like this:
    my $ref = \(scalar foo());
  
  or else the result of the function call is being used as part of the argument list
  for I<another> function call:
  
    bar(foo());	# Will *always* call foo in lvalue context,
    		# (provided that foo is an C<:lvalue> sub)
    		# regardless of what bar actually does.
  
  The reason for this last case is that bar might be a sub which modifies its
  arguments. They're rare in contemporary Perl code, but perfectly possible:
  
    sub bar {
      $_[0] = 23;
    }
  
  (This is really a throwback to Perl 4, which didn't support explicit references.)
  
  =back
  
  =head2 Assignment context:
  
  The commonest use of lvalue subroutines is with the assignment statement:
  
    size() = 12;
    (list()) = (1..10);
  
  A useful motto to remember when thinking about assignment statements is
  I<context comes from the left>. Consider code like this:
  
    my ($x, $y, $z);
    sub list () :lvalue { ($x, $y, $z) }
    list = (1, 2, 3);
    print "\$x = $x; \$y = $y; \$z = $z\n";
  
  This prints C<$x = ; $y = ; $z = 3>, which may not be what you were expecting.
  The reason is that the assignment is in scalar context, so the comma operator
  is in scalar context too, and discards all values but the last. You can fix
  it by writing C<(list) = (1,2,3);> instead.
  
  If your lvalue subroutine is used on the left of an assignment statement,
  it's in B<ASSIGN> context.  If ASSIGN is the only argument to C<want()>, then
  it returns a reference to an array of the value(s) of the right-hand side.
  
  In this case, you should return with the C<lnoreturn> function, rather than
  an ordinary C<return>. 
  
  This makes it very easy to write lvalue subroutines which do clever things:
  
    use Want;
    use strict;
    sub backstr :lvalue {
      if (want(qw'LVALUE ASSIGN')) {
        my ($a) = want('ASSIGN');
        $_[0] = reverse $a;
        lnoreturn;
      }
      elsif (want('RVALUE')) {
        rreturn scalar reverse $_[0];
      }
      else {
        carp("Not in ASSIGN context");
      }
      return
    }
   
    print "foo -> ", backstr("foo"), "\n";	# foo -> oof
    backstr(my $robin) = "nibor";
    print "\$robin is now $robin\n";		# $robin is now robin
  
  Notice that you need to put a (meaningless) return
  statement at the end of the function, otherwise you will get the
  error
  I<Can't modify non-lvalue subroutine call in lvalue subroutine return>.
  
  The only way to write that C<backstr> function without using Want is to return
  a tied variable which is tied to a custom class.
  
  =head2 Reference context:
  
  Sometimes in scalar context the caller is expecting a reference of some sort
  to be returned:
  
      print foo()->();     # CODE reference expected
      print foo()->{bar};  # HASH reference expected
      print foo()->[23];   # ARRAY reference expected
      print ${foo()};	 # SCALAR reference expected
      print foo()->bar();	 # OBJECT reference expected
      
      my $format = *{foo()}{FORMAT} # GLOB reference expected
  
  You can check this using conditionals like C<if (want('CODE'))>.
  There is also a function C<wantref()> which returns one of the strings
  "CODE", "HASH", "ARRAY", "GLOB", "SCALAR" or "OBJECT"; or the empty string
  if a reference is not expected.
  
  Because C<want('SCALAR')> is already used to select ordinary scalar context,
  you have to use C<want('REFSCALAR')> to find out if a SCALAR reference is
  expected. Or you could use C<want('REF') eq 'SCALAR'> of course.
  
  Be warned that C<want('ARRAY')> is a B<very> different thing from C<wantarray()>.
  
  =head2 Item count
  
  Sometimes in list context the caller is expecting a particular number of items
  to be returned:
  
      my ($x, $y) = foo();   # foo is expected to return two items
  
  If you pass a number to the C<want> function, then it will return true or false
  according to whether at least that many items are wanted. So if we are in the
  definition of a sub which is being called as above, then:
  
      want(1) returns true
      want(2) returns true
      want(3) returns false
  
  Sometimes there is no limit to the number of items that might be used:
  
      my @x = foo();
      do_something_with( foo() );
  
  In this case, C<want(2)>, C<want(100)>, C<want(1E9)> and so on will all return
  true; and so will C<want('Infinity')>.
  
  The C<howmany> function can be used to find out how many items are wanted.
  If the context is scalar, then C<want(1)> returns true and C<howmany()> returns
  1. If you want to check whether your result is being assigned to a singleton
  list, you can say C<if (want('LIST', 1)) { ... }>.
  
  
  =head2 Boolean context
  
  Sometimes the caller is only interested in the truth or falsity of a function's
  return value:
  
      if (everything_is_okay()) {
  	# Carry on
      }
      
      print (foo() ? "ok\n" : "not ok\n");
      
  In the following example, all subroutine calls are in BOOL context:
  
      my $x = ( (foo() && !bar()) xor (baz() || quux()) );
  
  Boolean context, like the reference contexts above, is considered to be a subcontext
  of SCALAR.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item want(SPECIFIERS)
  
  This is the primary interface to this module, and should suffice for most
  purposes. You pass it a list of context specifiers, and the return value
  is true whenever all of the specifiers hold.
  
      want('LVALUE', 'SCALAR');   # Are we in scalar lvalue context?
      want('RVALUE', 3);		# Are at least three rvalues wanted?
      want('ARRAY');	# Is the return value used as an array ref?
  
  You can also prefix a specifier with an exclamation mark to indicate that you
  B<don't> want it to be true
  
      want(2, '!3');		# Caller wants exactly two items.
      want(qw'REF !CODE !GLOB');  # Expecting a reference that
      				#   isn't a CODE or GLOB ref.
      want(100, '!Infinity');	# Expecting at least 100 items,
      				#   but there is a limit.
  
  If the I<REF> keyword is the only parameter passed, then the type of reference will be
  returned.  This is just a synonym for the C<wantref> function: it's included because
  you might find it useful if you don't want to pollute your namespace by importing
  several functions, and to conform to Damian Conway's suggestion in RFC 21.
  
  Finally, the keyword I<COUNT> can be used, provided that it's the only keyword
  you pass. Mixing COUNT with other keywords is an error. This is a synonym for the
  C<howmany> function.
  
  A full list of the permitted keyword is in the B<ARGUMENTS> section below.
  
  =item rreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you know that you're in RVALUE context. If you try to use a normal C<return>,
  you'll get a compile-time error in Perl 5.6.1 and above unless you return an
  lvalue. (Note: this is no longer true in Perl 5.16, where an ordinary return
  will once again work.)
  
  =item lnoreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you're in ASSIGN context and you've used C<want('ASSIGN')> to carry out the
  appropriate action.
  
  If you use C<rreturn> or C<lnoreturn>, then you have to put a bare C<return;>
  at the very end of your lvalue subroutine, in order to stop the Perl compiler
  from complaining. Think of it as akin to the C<1;> that you have to put at the
  end of a module. (Note: this is no longer true in Perl 5.16.)
  
  =item howmany()
  
  Returns the I<expectation count>, i.e. the number of items expected. If the 
  expectation count is undefined, that
  indicates that an unlimited number of items might be used (e.g. the return
  value is being assigned to an array). In void context the expectation count
  is zero, and in scalar context it is one.
  
  The same as C<want('COUNT')>.
  
  =item wantref()
  
  Returns the type of reference which the caller is expecting, or the empty string
  if the caller isn't expecting a reference immediately.
  
  The same as C<want('REF')>.
  
  =back
  
  =head1 EXAMPLES
  
      use Carp 'croak';
      use Want 'howmany';
      sub numbers {
  	my $count = howmany();
  	croak("Can't make an infinite list") if !defined($count);
  	return (1..$count);
      }
      my ($one, $two, $three) = numbers();
      
      
      use Want 'want';
      sub pi () {
  	if    (want('ARRAY')) {
  	    return [3, 1, 4, 1, 5, 9];
  	}
  	elsif (want('LIST')) {
  	    return (3, 1, 4, 1, 5, 9);
  	}
  	else {
  	    return 3;
  	}
      }
      print pi->[2];	# prints 4
      print ((pi)[3]);	# prints 1
  
  =head1 ARGUMENTS
  
  The permitted arguments to the C<want> function are listed below.
  The list is structured so that sub-contexts appear below the context that they
  are part of.
  
  =over 4
  
  =item *
  
  VOID
  
  =item *
  
  SCALAR
  
  =over 4
  
  =item *
  
  REF
  
  =over 4
  
  =item *
  
  REFSCALAR
  
  =item *
  
  CODE
  
  =item *
  
  HASH
  
  =item *
  
  ARRAY
  
  =item *
  
  GLOB
  
  =item *
  
  OBJECT
  
  =back
  
  =item *
  
  BOOL
  
  =back
  
  =item *
  
  LIST
  
  =over 4
  
  =item *
  
  COUNT
  
  =item *
  
  E<lt>numberE<gt>
  
  =item *
  
  Infinity
  
  =back
  
  =item *
  
  LVALUE
  
  =over 4
  
  =item *
  
  ASSIGN
  
  =back
  
  =item *
  
  RVALUE
  
  =back
  
  =head1 EXPORT
  
  The C<want> and C<rreturn> functions are exported by default.
  The C<wantref> and/or C<howmany> functions can also be imported:
  
    use Want qw'want howmany';
  
  If you don't import these functions, you must qualify their names as (e.g.)
  C<Want::wantref>.
  
  =head1 INTERFACE
  
  This module is still under development, and the public interface may change in
  future versions. The C<want> function can now be regarded as stable.
  
  I'd be interested to know how you're using this module.
  
  =head1 SUBTLETIES
  
  There are two different levels of B<BOOL> context. I<Pure> boolean context
  occurs in conditional expressions, and the operands of the C<xor> and C<!>/C<not>
  operators.
  Pure boolean context also propagates down through the C<&&> and C<||> operators.
  
  However, consider an expression like C<my $x = foo() && "yes">. The subroutine
  is called in I<pseudo>-boolean context - its return value isn't B<entirely>
  ignored, because the undefined value, the empty string and the integer 0 are
  all false.
  
  At the moment C<want('BOOL')> is true in either pure or pseudo boolean
  context. Let me know if this is a problem.
  
  =head1 BUGS
  
   * Doesn't work from inside a tie-handler.
  
  =head1 AUTHOR
  
  Robin Houston, E<lt>robin@cpan.orgE<gt>
  
  Thanks to Damian Conway for encouragement and good suggestions,
  and Father Chrysostomos for a patch.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<perlfunc/wantarray>
  
  =item *
  
  Perl6 RFC 21, by Damian Conway.
  http://dev.perl.org/rfc/21.html
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2012, Robin Houston. All Rights Reserved.
  This module is free software. It may be used, redistributed
  and/or modified under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_WANT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.36;
use utf8;
use strictures 2; # nice `use strict`, `use warnings` defaults
use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
use diagnostics -verbose;

# Carp
    use Carp;
    use Carp::Assert;
# filepath functions
    use Cwd qw(abs_path);
    use File::Basename qw(basename dirname);
    use File::Spec;
# misc file utilities
    use File::Temp;
    use File::Slurp;
# misc scripting IO utilities
    use IO::Prompter;
    # `capture_stdout` for backticks w/o shell (escaping issues)
    use Capture::Tiny qw(:all);
    # for more complicated stuff
    # eg timeout, redirection
    use IPC::Run qw(run);
    use IPC::Cmd qw(can_run);
# option/arg handling
    use Getopt::Long qw(:config gnu_getopt auto_version); # auto_help not the greatest
    use Pod::Usage;
# use local modules
    use lib (
        dirname(abs_path($0)),
        ); # https://stackoverflow.com/a/46550384
 
# turn on features
    use builtin qw(true false is_bool reftype);
    no warnings 'experimental::builtin';
    use feature 'try';
    no warnings 'experimental::try';

    our $VERSION = version->declare('v2023.05.01');
# end prelude

my @builds = glob 'Gradescope-Utils-*';
@builds = grep {m/^Gradescope-Utils-([\d\.]+)(\.tar\.gz)?$/} @builds;
say '[debug] found versions:';
say for @builds;
my @versions = map {m/^Gradescope-Utils-([\d\.]+)(\.tar\.gz)?$/; version->parse($1)} @builds;
@versions = sort @versions;
my $latest_version = pop @versions;
should($latest_version->stringify, "$latest_version"); # I'm a bit nervous about how version objects are handled
say "[debug] using version: $latest_version";
# NOTE: we could use the perl equivalents for portability, but I'm assuming so much *nix anyways, there's no point
# (ie sorry windows users)
my $local_share = File::Spec->catdir($ENV{HOME}, '.local', 'share', 'gradescope-utils');
my $confirm_overwrite_install = sub{
    if(-e $local_share){
        my $confirm = IO::Prompter::prompt(
            "Confirm: update existing install at '$local_share'? (y/N)? ",
            -in => *STDIN
        );
        croak '[error] user cancelled' if $confirm ne 'y';
    }
    else{
        run ['mkdir', '-p', $local_share] or croak '[error] `mkdir` failed';
    }
};
@builds = grep {m/^Gradescope-Utils-$latest_version(\.tar\.gz)?$/} @builds;
# prefer the regular build dir over the tar 'd one, if it exists
if(grep {m/^Gradescope-Utils-$latest_version$/} @builds){
    say "[debug] using build at 'Gradescope-Utils-$latest_version/'";
    &$confirm_overwrite_install;
    run ['cp', '-rT', "Gradescope-Utils-$latest_version", $local_share] or croak '[error] `cp` failed';
}
elsif(grep {m/\.tar\.gz$/} @builds){
    say "[debug] using build at 'Gradescope-Utils-$latest_version.tar.gz'";
    &$confirm_overwrite_install;
    my $tmpdir = File::Temp->newdir();
    run ['tar', '-xf', "Gradescope-Utils-$latest_version.tar.gz", '-C', $tmpdir] or croak '[error] `tar` failed';
    run ['cp', '-rT', File::Spec->catdir($tmpdir, "Gradescope-Utils-$latest_version"), $local_share] or croak '[error] `cp` failed';
}
else{
    croak '[error] no suitable builds found';
}

my $local_bin = File::Spec->catdir($ENV{HOME}, '.local', 'bin');
if(!-e $local_bin){
    run ['mkdir', '-p', File::Spec->catdir($ENV{HOME}, '.local', 'bin')] or croak '[error] `mkdir` failed';
}
run ['ln', '-fs', File::Spec->catfile($local_share, 'bin', 'gradescope-utils.pl'), File::Spec->catfile($ENV{HOME}, '.local', 'bin', 'gu')] or croak '[error] `ln` failed';

# PODNAME:
# ABSTRACT: Gradescope Utils installer
=pod

=encoding utf8

=head1 SYNOPSIS

=head1 DESCRIPTION

see README.md

=cut
