#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;
  use strict;
  use warnings;
  package Capture::Tiny;
  # ABSTRACT: Capture STDOUT and STDERR from Perl, XS or external programs
  our $VERSION = '0.48';
  use Carp ();
  use Exporter ();
  use IO::Handle ();
  use File::Spec ();
  use File::Temp qw/tempfile tmpnam/;
  use Scalar::Util qw/reftype blessed/;
  # Get PerlIO or fake it
  BEGIN {
    local $@;
    eval { require PerlIO; PerlIO->can('get_layers') }
      or *PerlIO::get_layers = sub { return () };
  }
  
  #--------------------------------------------------------------------------#
  # create API subroutines and export them
  # [do STDOUT flag, do STDERR flag, do merge flag, do tee flag]
  #--------------------------------------------------------------------------#
  
  my %api = (
    capture         => [1,1,0,0],
    capture_stdout  => [1,0,0,0],
    capture_stderr  => [0,1,0,0],
    capture_merged  => [1,1,1,0],
    tee             => [1,1,0,1],
    tee_stdout      => [1,0,0,1],
    tee_stderr      => [0,1,0,1],
    tee_merged      => [1,1,1,1],
  );
  
  for my $sub ( keys %api ) {
    my $args = join q{, }, @{$api{$sub}};
    eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; ## no critic
  }
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = keys %api;
  our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  #--------------------------------------------------------------------------#
  # constants and fixtures
  #--------------------------------------------------------------------------#
  
  my $IS_WIN32 = $^O eq 'MSWin32';
  
  ##our $DEBUG = $ENV{PERL_CAPTURE_TINY_DEBUG};
  ##
  ##my $DEBUGFH;
  ##open $DEBUGFH, "> DEBUG" if $DEBUG;
  ##
  ##*_debug = $DEBUG ? sub(@) { print {$DEBUGFH} @_ } : sub(){0};
  
  our $TIMEOUT = 30;
  
  #--------------------------------------------------------------------------#
  # command to tee output -- the argument is a filename that must
  # be opened to signal that the process is ready to receive input.
  # This is annoying, but seems to be the best that can be done
  # as a simple, portable IPC technique
  #--------------------------------------------------------------------------#
  my @cmd = ($^X, '-C0', '-e', <<'HERE');
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
  
  #--------------------------------------------------------------------------#
  # filehandle manipulation
  #--------------------------------------------------------------------------#
  
  sub _relayer {
    my ($fh, $apply_layers) = @_;
    # _debug("# requested layers (@{$layers}) for @{[fileno $fh]}\n");
  
    # eliminate pseudo-layers
    binmode( $fh, ":raw" );
    # strip off real layers until only :unix is left
    while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
        binmode( $fh, ":pop" );
    }
    # apply other layers
    my @to_apply = @$apply_layers;
    shift @to_apply; # eliminate initial :unix
    # _debug("# applying layers  (unix @to_apply) to @{[fileno $fh]}\n");
    binmode($fh, ":" . join(":",@to_apply));
  }
  
  sub _name {
    my $glob = shift;
    no strict 'refs'; ## no critic
    return *{$glob}{NAME};
  }
  
  sub _open {
    open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
    # _debug( "# open " . join( ", " , map { defined $_ ? _name($_) : 'undef' } @_ ) . " as " . fileno( $_[0] ) . "\n" );
  }
  
  sub _close {
    # _debug( "# closing " . ( defined $_[0] ? _name($_[0]) : 'undef' )  . " on " . fileno( $_[0] ) . "\n" );
    close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
  }
  
  my %dup; # cache this so STDIN stays fd0
  my %proxy_count;
  sub _proxy_std {
    my %proxies;
    if ( ! defined fileno STDIN ) {
      $proxy_count{stdin}++;
      if (defined $dup{stdin}) {
        _open \*STDIN, "<&=" . fileno($dup{stdin});
        # _debug( "# restored proxy STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
      }
      else {
        _open \*STDIN, "<" . File::Spec->devnull;
        # _debug( "# proxied STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
        _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
      }
      $proxies{stdin} = \*STDIN;
      binmode(STDIN, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDOUT ) {
      $proxy_count{stdout}++;
      if (defined $dup{stdout}) {
        _open \*STDOUT, ">&=" . fileno($dup{stdout});
        # _debug( "# restored proxy STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
      }
      else {
        _open \*STDOUT, ">" . File::Spec->devnull;
         # _debug( "# proxied STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
        _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
      }
      $proxies{stdout} = \*STDOUT;
      binmode(STDOUT, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDERR ) {
      $proxy_count{stderr}++;
      if (defined $dup{stderr}) {
        _open \*STDERR, ">&=" . fileno($dup{stderr});
         # _debug( "# restored proxy STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
      }
      else {
        _open \*STDERR, ">" . File::Spec->devnull;
         # _debug( "# proxied STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
        _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
      }
      $proxies{stderr} = \*STDERR;
      binmode(STDERR, ':utf8') if $] >= 5.008; ## no critic
    }
    return %proxies;
  }
  
  sub _unproxy {
    my (%proxies) = @_;
    # _debug( "# unproxying: " . join(" ", keys %proxies) . "\n" );
    for my $p ( keys %proxies ) {
      $proxy_count{$p}--;
      # _debug( "# unproxied " . uc($p) . " ($proxy_count{$p} left)\n" );
      if ( ! $proxy_count{$p} ) {
        _close $proxies{$p};
        _close $dup{$p} unless $] < 5.008; # 5.6 will have already closed this as dup
        delete $dup{$p};
      }
    }
  }
  
  sub _copy_std {
    my %handles;
    for my $h ( qw/stdout stderr stdin/ ) {
      next if $h eq 'stdin' && ! $IS_WIN32; # WIN32 hangs on tee without STDIN copied
      my $redir = $h eq 'stdin' ? "<&" : ">&";
      _open $handles{$h} = IO::Handle->new(), $redir . uc($h); # ">&STDOUT" or "<&STDIN"
    }
    return \%handles;
  }
  
  # In some cases we open all (prior to forking) and in others we only open
  # the output handles (setting up redirection)
  sub _open_std {
    my ($handles) = @_;
    _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
    _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
    _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
  }
  
  #--------------------------------------------------------------------------#
  # private subs
  #--------------------------------------------------------------------------#
  
  sub _start_tee {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    # setup pipes
    $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
    pipe $stash->{reader}{$which}, $stash->{tee}{$which};
    # _debug( "# pipe for $which\: " .  _name($stash->{tee}{$which}) . " " . fileno( $stash->{tee}{$which} ) . " => " . _name($stash->{reader}{$which}) . " " . fileno( $stash->{reader}{$which}) . "\n" );
    select((select($stash->{tee}{$which}), $|=1)[0]); # autoflush
    # setup desired redirection for parent and child
    $stash->{new}{$which} = $stash->{tee}{$which};
    $stash->{child}{$which} = {
      stdin   => $stash->{reader}{$which},
      stdout  => $stash->{old}{$which},
      stderr  => $stash->{capture}{$which},
    };
    # flag file is used to signal the child is ready
    $stash->{flag_files}{$which} = scalar( tmpnam() ) . $$;
    # execute @cmd as a separate process
    if ( $IS_WIN32 ) {
      my $old_eval_err=$@;
      undef $@;
  
      eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
      # _debug( "# Win32API::File loaded\n") unless $@;
      my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
      # _debug( "# Couldn't get OS handle: " . fileLastError() . "\n") if ! defined $os_fhandle || $os_fhandle == INVALID_HANDLE_VALUE();
      my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
      # _debug( $result ? "# set no-inherit flag on $which tee\n" : ("# can't disable tee handle flag inherit: " . fileLastError() . "\n"));
      _open_std( $stash->{child}{$which} );
      $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
      # not restoring std here as it all gets redirected again shortly anyway
      $@=$old_eval_err;
    }
    else { # use fork
      _fork_exec( $which, $stash );
    }
  }
  
  sub _fork_exec {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    my $pid = fork;
    if ( not defined $pid ) {
      Carp::confess "Couldn't fork(): $!";
    }
    elsif ($pid == 0) { # child
      # _debug( "# in child process ...\n" );
      untie *STDIN; untie *STDOUT; untie *STDERR;
      _close $stash->{tee}{$which};
      # _debug( "# redirecting handles in child ...\n" );
      _open_std( $stash->{child}{$which} );
      # _debug( "# calling exec on command ...\n" );
      exec @cmd, $stash->{flag_files}{$which};
    }
    $stash->{pid}{$which} = $pid
  }
  
  my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
  sub _files_exist {
    return 1 if @_ == grep { -f } @_;
    Time::HiRes::usleep(1000) if $have_usleep;
    return 0;
  }
  
  sub _wait_for_tees {
    my ($stash) = @_;
    my $start = time;
    my @files = values %{$stash->{flag_files}};
    my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
                ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
    1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
    Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
    unlink $_ for @files;
  }
  
  sub _kill_tees {
    my ($stash) = @_;
    if ( $IS_WIN32 ) {
      # _debug( "# closing handles\n");
      close($_) for values %{ $stash->{tee} };
      # _debug( "# waiting for subprocesses to finish\n");
      my $start = time;
      1 until wait == -1 || (time - $start > 30);
    }
    else {
      _close $_ for values %{ $stash->{tee} };
      waitpid $_, 0 for values %{ $stash->{pid} };
    }
  }
  
  sub _slurp {
    my ($name, $stash) = @_;
    my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
    # _debug( "# slurping captured $name from " . fileno($fh) . " at pos $pos with layers: @{[PerlIO::get_layers($fh)]}\n");
    seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
    my $text = do { local $/; scalar readline $fh };
    return defined($text) ? $text : "";
  }
  
  #--------------------------------------------------------------------------#
  # _capture_tee() -- generic main sub for capturing or teeing
  #--------------------------------------------------------------------------#
  
  sub _capture_tee {
    # _debug( "# starting _capture_tee with (@_)...\n" );
    my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
    my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
    Carp::confess("Custom capture options must be given as key/value pairs\n")
      unless @opts % 2 == 0;
    my $stash = { capture => { @opts } };
    for ( keys %{$stash->{capture}} ) {
      my $fh = $stash->{capture}{$_};
      Carp::confess "Custom handle for $_ must be seekable\n"
        unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
    }
    # save existing filehandles and setup captures
    local *CT_ORIG_STDIN  = *STDIN ;
    local *CT_ORIG_STDOUT = *STDOUT;
    local *CT_ORIG_STDERR = *STDERR;
    # find initial layers
    my %layers = (
      stdin   => [PerlIO::get_layers(\*STDIN) ],
      stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
      stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
    );
    # _debug( "# existing layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # get layers from underlying glob of tied filehandles if we can
    # (this only works for things that work like Tie::StdHandle)
    $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
      if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
    $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
      if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
    # _debug( "# tied object corrected layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # bypass scalar filehandles and tied handles
    # localize scalar STDIN to get a proxy to pick up FD0, then restore later to CT_ORIG_STDIN
    my %localize;
    $localize{stdin}++,  local(*STDIN)
      if grep { $_ eq 'scalar' } @{$layers{stdin}};
    $localize{stdout}++, local(*STDOUT)
      if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
    $localize{stderr}++, local(*STDERR)
      if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
    $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
      if tied *STDIN && $] >= 5.008;
    $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
      if $do_stdout && tied *STDOUT && $] >= 5.008;
    $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
      if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
    # _debug( "# localized $_\n" ) for keys %localize;
    # proxy any closed/localized handles so we don't use fds 0, 1 or 2
    my %proxy_std = _proxy_std();
    # _debug( "# proxy std: @{ [%proxy_std] }\n" );
    # update layers after any proxying
    $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
    $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
    # _debug( "# post-proxy layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # store old handles and setup handles for capture
    $stash->{old} = _copy_std();
    $stash->{new} = { %{$stash->{old}} }; # default to originals
    for ( keys %do ) {
      $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
      seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
      $stash->{pos}{$_} = tell $stash->{capture}{$_};
      # _debug("# will capture $_ on " . fileno($stash->{capture}{$_})."\n" );
      _start_tee( $_ => $stash ) if $do_tee; # tees may change $stash->{new}
    }
    _wait_for_tees( $stash ) if $do_tee;
    # finalize redirection
    $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
    # _debug( "# redirecting in parent ...\n" );
    _open_std( $stash->{new} );
    # execute user provided code
    my ($exit_code, $inner_error, $outer_error, $orig_pid, @result);
    {
      $orig_pid = $$;
      local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; # get original, not proxy STDIN
      # _debug( "# finalizing layers ...\n" );
      _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
      _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
      # _debug( "# running code $code ...\n" );
      my $old_eval_err=$@;
      undef $@;
      eval { @result = $code->(); $inner_error = $@ };
      $exit_code = $?; # save this for later
      $outer_error = $@; # save this for later
      STDOUT->flush if $do_stdout;
      STDERR->flush if $do_stderr;
      $@ = $old_eval_err;
    }
    # restore prior filehandles and shut down tees
    # _debug( "# restoring filehandles ...\n" );
    _open_std( $stash->{old} );
    _close( $_ ) for values %{$stash->{old}}; # don't leak fds
    # shouldn't need relayering originals, but see rt.perl.org #114404
    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
    _unproxy( %proxy_std );
    # _debug( "# killing tee subprocesses ...\n" ) if $do_tee;
    _kill_tees( $stash ) if $do_tee;
    # return captured output, but shortcut in void context
    # unless we have to echo output to tied/scalar handles;
    my %got;
    if ( $orig_pid == $$ and ( defined wantarray or ($do_tee && keys %localize) ) ) {
      for ( keys %do ) {
        _relayer($stash->{capture}{$_}, $layers{$_});
        $got{$_} = _slurp($_, $stash);
        # _debug("# slurped " . length($got{$_}) . " bytes from $_\n");
      }
      print CT_ORIG_STDOUT $got{stdout}
        if $do_stdout && $do_tee && $localize{stdout};
      print CT_ORIG_STDERR $got{stderr}
        if $do_stderr && $do_tee && $localize{stderr};
    }
    $? = $exit_code;
    $@ = $inner_error if $inner_error;
    die $outer_error if $outer_error;
    # _debug( "# ending _capture_tee with (@_)...\n" );
    return unless defined wantarray;
    my @return;
    push @return, $got{stdout} if $do_stdout;
    push @return, $got{stderr} if $do_stderr && ! $do_merge;
    push @return, @result;
    return wantarray ? @return : $return[0];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
  
  =head1 VERSION
  
  version 0.48
  
  =head1 SYNOPSIS
  
    use Capture::Tiny ':all';
  
    # capture from external command
  
    ($stdout, $stderr, $exit) = capture {
      system( $cmd, @args );
    };
  
    # capture from arbitrary code (Perl or external)
  
    ($stdout, $stderr, @result) = capture {
      # your code here
    };
  
    # capture partial or merged output
  
    $stdout = capture_stdout { ... };
    $stderr = capture_stderr { ... };
    $merged = capture_merged { ... };
  
    # tee output
  
    ($stdout, $stderr) = tee {
      # your code here
    };
  
    $stdout = tee_stdout { ... };
    $stderr = tee_stderr { ... };
    $merged = tee_merged { ... };
  
  =head1 DESCRIPTION
  
  Capture::Tiny provides a simple, portable way to capture almost anything sent
  to STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program.  Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles.  Yes, it even
  works on Windows (usually).  Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
  
  =head1 USAGE
  
  The following functions are available.  None are exported by default.
  
  =head2 capture
  
    ($stdout, $stderr, @result) = capture \&code;
    $stdout = capture \&code;
  
  The C<capture> function takes a code reference and returns what is sent to
  STDOUT and STDERR as well as any return values from the code reference.  In
  scalar context, it returns only STDOUT.  If no output was received for a
  filehandle, it returns an empty string for that filehandle.  Regardless of calling
  context, all output is captured -- nothing is passed to the existing filehandles.
  
  It is prototyped to take a subroutine reference as an argument. Thus, it
  can be called in block form:
  
    ($stdout, $stderr) = capture {
      # your code here ...
    };
  
  Note that the coderef is evaluated in list context.  If you wish to force
  scalar context on the return value, you must use the C<scalar> keyword.
  
    ($stdout, $stderr, $count) = capture {
      my @list = qw/one two three/;
      return scalar @list; # $count will be 3
    };
  
  Also note that within the coderef, the C<@_> variable will be empty.  So don't
  use arguments from a surrounding subroutine without copying them to an array
  first:
  
    sub wont_work {
      my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
      ...
    }
  
    sub will_work {
      my @args = @_;
      my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
      ...
    }
  
  Captures are normally done to an anonymous temporary filehandle.  To
  capture via a named file (e.g. to externally monitor a long-running capture),
  provide custom filehandles as a trailing list of option pairs:
  
    my $out_fh = IO::File->new("out.txt", "w+");
    my $err_fh = IO::File->new("out.txt", "w+");
    capture { ... } stdout => $out_fh, stderr => $err_fh;
  
  The filehandles must be read/write and seekable.  Modifying the files or
  filehandles during a capture operation will give unpredictable results.
  Existing IO layers on them may be changed by the capture.
  
  When called in void context, C<capture> saves memory and time by
  not reading back from the capture handles.
  
  =head2 capture_stdout
  
    ($stdout, @result) = capture_stdout \&code;
    $stdout = capture_stdout \&code;
  
  The C<capture_stdout> function works just like C<capture> except only
  STDOUT is captured.  STDERR is not captured.
  
  =head2 capture_stderr
  
    ($stderr, @result) = capture_stderr \&code;
    $stderr = capture_stderr \&code;
  
  The C<capture_stderr> function works just like C<capture> except only
  STDERR is captured.  STDOUT is not captured.
  
  =head2 capture_merged
  
    ($merged, @result) = capture_merged \&code;
    $merged = capture_merged \&code;
  
  The C<capture_merged> function works just like C<capture> except STDOUT and
  STDERR are merged. (Technically, STDERR is redirected to the same capturing
  handle as STDOUT before executing the function.)
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head2 tee
  
    ($stdout, $stderr, @result) = tee \&code;
    $stdout = tee \&code;
  
  The C<tee> function works just like C<capture>, except that output is captured
  as well as passed on to the original STDOUT and STDERR.
  
  When called in void context, C<tee> saves memory and time by
  not reading back from the capture handles, except when the
  original STDOUT OR STDERR were tied or opened to a scalar
  handle.
  
  =head2 tee_stdout
  
    ($stdout, @result) = tee_stdout \&code;
    $stdout = tee_stdout \&code;
  
  The C<tee_stdout> function works just like C<tee> except only
  STDOUT is teed.  STDERR is not teed (output goes to STDERR as usual).
  
  =head2 tee_stderr
  
    ($stderr, @result) = tee_stderr \&code;
    $stderr = tee_stderr \&code;
  
  The C<tee_stderr> function works just like C<tee> except only
  STDERR is teed.  STDOUT is not teed (output goes to STDOUT as usual).
  
  =head2 tee_merged
  
    ($merged, @result) = tee_merged \&code;
    $merged = tee_merged \&code;
  
  The C<tee_merged> function works just like C<capture_merged> except that output
  is captured as well as passed on to STDOUT.
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head1 LIMITATIONS
  
  =head2 Portability
  
  Portability is a goal, not a guarantee.  C<tee> requires fork, except on
  Windows where C<system(1, @cmd)> is used instead.  Not tested on any
  particularly esoteric platforms yet.  See the
  L<CPAN Testers Matrix|http://matrix.cpantesters.org/?dist=Capture-Tiny>
  for test result by platform.
  
  =head2 PerlIO layers
  
  Capture::Tiny does its best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
  STDOUT or STDERR I<before> the call to C<capture> or C<tee>.  This may not work
  for tied filehandles (see below).
  
  =head2 Modifying filehandles before capturing
  
  Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety of
  unexpected, undesirable and/or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
  
  =head3 Closed filehandles
  
  Capture::Tiny will work even if STDIN, STDOUT or STDERR have been previously
  closed.  However, since they will be reopened to capture or tee output, any
  code within the captured block that depends on finding them closed will, of
  course, not find them to be closed.  If they started closed, Capture::Tiny will
  close them again when the capture block finishes.
  
  Note that this reopening will happen even for STDIN or a filehandle not being
  captured to ensure that the filehandle used for capture is not opened to file
  descriptor 0, as this causes problems on various platforms.
  
  Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D leaks filehandles
  and also breaks tee() for undiagnosed reasons.  So don't do that.
  
  =head3 Localized filehandles
  
  If code localizes any of Perl's standard filehandles before capturing, the capture
  will affect the localized filehandles and not the original ones.  External system
  calls are not affected by localizing a filehandle in Perl and will continue
  to send output to the original filehandles (which will thus not be captured).
  
  =head3 Scalar filehandles
  
  If STDOUT or STDERR are reopened to scalar filehandles prior to the call to
  C<capture> or C<tee>, then Capture::Tiny will override the output filehandle for
  the duration of the C<capture> or C<tee> call and then, for C<tee>, send captured
  output to the output filehandle after the capture is complete.  (Requires Perl
  5.8)
  
  Capture::Tiny attempts to preserve the semantics of STDIN opened to a scalar
  reference, but note that external processes will not be able to read from such
  a handle.  Capture::Tiny tries to ensure that external processes will read from
  the null device instead, but this is not guaranteed.
  
  =head3 Tied output filehandles
  
  If STDOUT or STDERR are tied prior to the call to C<capture> or C<tee>, then
  Capture::Tiny will attempt to override the tie for the duration of the
  C<capture> or C<tee> call and then send captured output to the tied filehandle after
  the capture is complete.  (Requires Perl 5.8)
  
  Capture::Tiny may not succeed resending UTF-8 encoded data to a tied
  STDOUT or STDERR filehandle.  Characters may appear as bytes.  If the tied filehandle
  is based on L<Tie::StdHandle>, then Capture::Tiny will attempt to determine
  appropriate layers like C<:utf8> from the underlying filehandle and do the right
  thing.
  
  =head3 Tied input filehandle
  
  Capture::Tiny attempts to preserve the semantics of tied STDIN, but this
  requires Perl 5.8 and is not entirely predictable.  External processes
  will not be able to read from such a handle.
  
  Unless having STDIN tied is crucial, it may be safest to localize STDIN when
  capturing:
  
    my ($out, $err) = do { local *STDIN; capture { ... } };
  
  =head2 Modifying filehandles during a capture
  
  Attempting to modify STDIN, STDOUT or STDERR I<during> C<capture> or C<tee> is
  almost certainly going to cause problems.  Don't do that.
  
  =head3 Forking inside a capture
  
  Forks aren't portable.  The behavior of filehandles during a fork is even
  less so.  If Capture::Tiny detects that a fork has occurred within a
  capture, it will shortcut in the child process and return empty strings for
  captures.  Other problems may occur in the child or parent, as well.
  Forking in a capture block is not recommended.
  
  =head3 Using threads
  
  Filehandles are global.  Mixing up I/O and captures in different threads
  without coordination is going to cause problems.  Besides, threads are
  officially discouraged.
  
  =head3 Dropping privileges during a capture
  
  If you drop privileges during a capture, temporary files created to
  facilitate the capture may not be cleaned up afterwards.
  
  =head2 No support for Perl 5.8.0
  
  It's just too buggy when it comes to layers and UTF-8.  Perl 5.8.1 or later
  is recommended.
  
  =head2 Limited support for Perl 5.6
  
  Perl 5.6 predates PerlIO.  UTF-8 data may not be captured correctly.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_CAPTURE_TINY_TIMEOUT
  
  Capture::Tiny uses subprocesses internally for C<tee>.  By default,
  Capture::Tiny will timeout with an error if such subprocesses are not ready to
  receive data within 30 seconds (or whatever is the value of
  C<$Capture::Tiny::TIMEOUT>).  An alternate timeout may be specified by setting
  the C<PERL_CAPTURE_TINY_TIMEOUT> environment variable.  Setting it to zero will
  disable timeouts.  B<NOTE>, this does not timeout the code reference being
  captured -- this only prevents Capture::Tiny itself from hanging your process
  waiting for its child processes to be ready to proceed.
  
  =head1 SEE ALSO
  
  This module was inspired by L<IO::CaptureOutput>, which provides
  similar functionality without the ability to tee output and with more
  complicated code and API.  L<IO::CaptureOutput> does not handle layers
  or most of the unusual cases described in the L</Limitations> section and
  I no longer recommend it.
  
  There are many other CPAN modules that provide some sort of output capture,
  albeit with various limitations that make them appropriate only in particular
  circumstances.  I'm probably missing some.  The long list is provided to show
  why I felt Capture::Tiny was necessary.
  
  =over 4
  
  =item *
  
  L<IO::Capture>
  
  =item *
  
  L<IO::Capture::Extended>
  
  =item *
  
  L<IO::CaptureOutput>
  
  =item *
  
  L<IPC::Capture>
  
  =item *
  
  L<IPC::Cmd>
  
  =item *
  
  L<IPC::Open2>
  
  =item *
  
  L<IPC::Open3>
  
  =item *
  
  L<IPC::Open3::Simple>
  
  =item *
  
  L<IPC::Open3::Utils>
  
  =item *
  
  L<IPC::Run>
  
  =item *
  
  L<IPC::Run::SafeHandles>
  
  =item *
  
  L<IPC::Run::Simple>
  
  =item *
  
  L<IPC::Run3>
  
  =item *
  
  L<IPC::System::Simple>
  
  =item *
  
  L<Tee>
  
  =item *
  
  L<IO::Tee>
  
  =item *
  
  L<File::Tee>
  
  =item *
  
  L<Filter::Handle>
  
  =item *
  
  L<Tie::STDERR>
  
  =item *
  
  L<Tie::STDOUT>
  
  =item *
  
  L<Test::Output>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Capture-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Capture-Tiny>
  
    git clone https://github.com/dagolden/Capture-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David E. Wheeler fecundf Graham Knop Peter Rabbitson
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =item *
  
  fecundf <not.com+github@gmail.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2009 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CAPTURE_TINY

$fatpacked{"Carp/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_ASSERT';
  package Carp::Assert;
  
  require 5.006;
  use strict qw(subs vars);
  use warnings;
  use Exporter;
  
  use vars qw(@ISA $VERSION %EXPORT_TAGS);
  
  BEGIN {
      $VERSION = '0.22';
  
      @ISA = qw(Exporter);
  
      %EXPORT_TAGS = (
                      NDEBUG => [qw(assert affirm should shouldnt DEBUG)],
                     );
      $EXPORT_TAGS{DEBUG} = $EXPORT_TAGS{NDEBUG};
      Exporter::export_tags(qw(NDEBUG DEBUG));
  }
  
  # constant.pm, alas, adds too much load time (yes, I benchmarked it)
  sub REAL_DEBUG  ()  { 1 }       # CONSTANT
  sub NDEBUG      ()  { 0 }       # CONSTANT
  
  # Export the proper DEBUG flag according to if :NDEBUG is set.
  # Also export noop versions of our routines if NDEBUG
  sub noop { undef }
  sub noop_affirm (&;$) { undef };
  
  sub import {
      my $env_ndebug = exists $ENV{PERL_NDEBUG} ? $ENV{PERL_NDEBUG}
                                                : $ENV{'NDEBUG'};
      if( grep(/^:NDEBUG$/, @_) or $env_ndebug ) {
          my $caller = caller;
          foreach my $func (grep !/^DEBUG$/, @{$EXPORT_TAGS{'NDEBUG'}}) {
              if( $func eq 'affirm' ) {
                  *{$caller.'::'.$func} = \&noop_affirm;
              } else {
                  *{$caller.'::'.$func} = \&noop;
              }
          }
          *{$caller.'::DEBUG'} = \&NDEBUG;
      }
      else {
          *DEBUG = *REAL_DEBUG;
          Carp::Assert->_export_to_level(1, @_);
      }
  }
  
  
  # 5.004's Exporter doesn't have export_to_level.
  sub _export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;                  # XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  
  sub unimport {
      *DEBUG = *NDEBUG;
      push @_, ':NDEBUG';
      goto &import;
  }
  
  
  # Can't call confess() here or the stack trace will be wrong.
  sub _fail_msg {
      my($name) = shift;
      my $msg = 'Assertion';
      $msg   .= " ($name)" if defined $name;
      $msg   .= " failed!\n";
      return $msg;
  }
  
  
  =head1 NAME
  
  Carp::Assert - executable comments
  
  =head1 SYNOPSIS
  
      # Assertions are on.
      use Carp::Assert;
  
      $next_sunrise_time = sunrise();
  
      # Assert that the sun must rise in the next 24 hours.
      assert(($next_sunrise_time - time) < 24*60*60) if DEBUG;
  
      # Assert that your customer's primary credit card is active
      affirm {
          my @cards = @{$customer->credit_cards};
          $cards[0]->is_active;
      };
  
  
      # Assertions are off.
      no Carp::Assert;
  
      $next_pres = divine_next_president();
  
      # Assert that if you predict Dan Quayle will be the next president
      # your crystal ball might need some polishing.  However, since
      # assertions are off, IT COULD HAPPEN!
      shouldnt($next_pres, 'Dan Quayle') if DEBUG;
  
  
  =head1 DESCRIPTION
  
  =begin testing
  
  BEGIN {
      local %ENV = %ENV;
      delete @ENV{qw(PERL_NDEBUG NDEBUG)};
      require Carp::Assert;
      Carp::Assert->import;
  }
  
  local %ENV = %ENV;
  delete @ENV{qw(PERL_NDEBUG NDEBUG)};
  
  =end testing
  
      "We are ready for any unforseen event that may or may not 
      occur."
          - Dan Quayle
  
  Carp::Assert is intended for a purpose like the ANSI C library
  L<assert.h|http://en.wikipedia.org/wiki/Assert.h>.
  If you're already familiar with assert.h, then you can
  probably skip this and go straight to the FUNCTIONS section.
  
  Assertions are the explicit expressions of your assumptions about the
  reality your program is expected to deal with, and a declaration of
  those which it is not.  They are used to prevent your program from
  blissfully processing garbage inputs (garbage in, garbage out becomes
  garbage in, error out) and to tell you when you've produced garbage
  output.  (If I was going to be a cynic about Perl and the user nature,
  I'd say there are no user inputs but garbage, and Perl produces
  nothing but...)
  
  An assertion is used to prevent the impossible from being asked of
  your code, or at least tell you when it does.  For example:
  
  =for example begin
  
      # Take the square root of a number.
      sub my_sqrt {
          my($num) = shift;
  
          # the square root of a negative number is imaginary.
          assert($num >= 0);
  
          return sqrt $num;
      }
  
  =for example end
  
  =for example_testing
  is( my_sqrt(4),  2,            'my_sqrt example with good input' );
  ok( !eval{ my_sqrt(-1); 1 },   '  and pukes on bad' );
  
  The assertion will warn you if a negative number was handed to your
  subroutine, a reality the routine has no intention of dealing with.
  
  An assertion should also be used as something of a reality check, to
  make sure what your code just did really did happen:
  
      open(FILE, $filename) || die $!;
      @stuff = <FILE>;
      @stuff = do_something(@stuff);
  
      # I should have some stuff.
      assert(@stuff > 0);
  
  The assertion makes sure you have some @stuff at the end.  Maybe the
  file was empty, maybe do_something() returned an empty list... either
  way, the assert() will give you a clue as to where the problem lies,
  rather than 50 lines down at when you wonder why your program isn't
  printing anything.
  
  Since assertions are designed for debugging and will remove themelves
  from production code, your assertions should be carefully crafted so
  as to not have any side-effects, change any variables, or otherwise
  have any effect on your program.  Here is an example of a bad
  assertation:
  
      assert($error = 1 if $king ne 'Henry');  # Bad!
  
  It sets an error flag which may then be used somewhere else in your
  program. When you shut off your assertions with the $DEBUG flag,
  $error will no longer be set.
  
  Here's another example of B<bad> use:
  
      assert($next_pres ne 'Dan Quayle' or goto Canada);  # Bad!
  
  This assertion has the side effect of moving to Canada should it fail.
  This is a very bad assertion since error handling should not be
  placed in an assertion, nor should it have side-effects.
  
  In short, an assertion is an executable comment.  For instance, instead
  of writing this
  
      # $life ends with a '!'
      $life = begin_life();
  
  you'd replace the comment with an assertion which B<enforces> the comment.
  
      $life = begin_life();
      assert( $life =~ /!$/ );
  
  =for testing
  my $life = 'Whimper!';
  ok( eval { assert( $life =~ /!$/ ); 1 },   'life ends with a bang' );
  
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item B<assert>
  
      assert(EXPR) if DEBUG;
      assert(EXPR, $name) if DEBUG;
  
  assert's functionality is effected by compile time value of the DEBUG
  constant, controlled by saying C<use Carp::Assert> or C<no
  Carp::Assert>.  In the former case, assert will function as below.
  Otherwise, the assert function will compile itself out of the program.
  See L<Debugging vs Production> for details.
  
  =for testing
  {
    package Some::Other;
    no Carp::Assert;
    ::ok( eval { assert(0) if DEBUG; 1 } );
  }
  
  Give assert an expression, assert will Carp::confess() if that
  expression is false, otherwise it does nothing.  (DO NOT use the
  return value of assert for anything, I mean it... really!).
  
  =for testing
  ok( eval { assert(1); 1 } );
  ok( !eval { assert(0); 1 } );
  
  The error from assert will look something like this:
  
      Assertion failed!
              Carp::Assert::assert(0) called at prog line 23
              main::foo called at prog line 50
  
  =for testing
  eval { assert(0) };
  like( $@, '/^Assertion failed!/',       'error format' );
  like( $@, '/Carp::Assert::assert\(0\) called at/',      '  with stack trace' );
  
  Indicating that in the file "prog" an assert failed inside the
  function main::foo() on line 23 and that foo() was in turn called from
  line 50 in the same file.
  
  If given a $name, assert() will incorporate this into your error message,
  giving users something of a better idea what's going on.
  
      assert( Dogs->isa('People'), 'Dogs are people, too!' ) if DEBUG;
      # Result - "Assertion (Dogs are people, too!) failed!"
  
  =for testing
  eval { assert( Dogs->isa('People'), 'Dogs are people, too!' ); };
  like( $@, '/^Assertion \(Dogs are people, too!\) failed!/', 'names' );
  
  =cut
  
  sub assert ($;$) {
      unless($_[0]) {
          require Carp;
          Carp::confess( _fail_msg($_[1]) );
      }
      return undef;
  }
  
  
  =item B<affirm>
  
      affirm BLOCK if DEBUG;
      affirm BLOCK $name if DEBUG;
  
  Very similar to assert(), but instead of taking just a simple
  expression it takes an entire block of code and evaluates it to make
  sure its true.  This can allow more complicated assertions than
  assert() can without letting the debugging code leak out into
  production and without having to smash together several
  statements into one.
  
  =for example begin
  
      affirm {
          my $customer = Customer->new($customerid);
          my @cards = $customer->credit_cards;
          grep { $_->is_active } @cards;
      } "Our customer has an active credit card";
  
  =for example end
  
  =for testing
  my $foo = 1;  my $bar = 2;
  eval { affirm { $foo == $bar } };
  like( $@, '/\$foo == \$bar/' );
  
  
  affirm() also has the nice side effect that if you forgot the C<if DEBUG>
  suffix its arguments will not be evaluated at all.  This can be nice
  if you stick affirm()s with expensive checks into hot loops and other
  time-sensitive parts of your program.
  
  If the $name is left off and your Perl version is 5.6 or higher the
  affirm() diagnostics will include the code begin affirmed.
  
  =cut
  
  sub affirm (&;$) {
      unless( eval { &{$_[0]}; } ) {
          my $name = $_[1];
  
          if( !defined $name ) {
              eval {
                  require B::Deparse;
                  $name = B::Deparse->new->coderef2text($_[0]);
              };
              $name = 
                'code display non-functional on this version of Perl, sorry'
                  if $@;
          }
  
          require Carp;
          Carp::confess( _fail_msg($name) );
      }
      return undef;
  }
  
  =item B<should>
  
  =item B<shouldnt>
  
      should  ($this, $shouldbe)   if DEBUG;
      shouldnt($this, $shouldntbe) if DEBUG;
  
  Similar to assert(), it is specially for simple "this should be that"
  or "this should be anything but that" style of assertions.
  
  Due to Perl's lack of a good macro system, assert() can only report
  where something failed, but it can't report I<what> failed or I<how>.
  should() and shouldnt() can produce more informative error messages:
  
      Assertion ('this' should be 'that'!) failed!
              Carp::Assert::should('this', 'that') called at moof line 29
              main::foo() called at moof line 58
  
  So this:
  
      should($this, $that) if DEBUG;
  
  is similar to this:
  
      assert($this eq $that) if DEBUG;
  
  except for the better error message.
  
  Currently, should() and shouldnt() can only do simple eq and ne tests
  (respectively).  Future versions may allow regexes.
  
  =cut
  
  sub should ($$) {
      unless($_[0] eq $_[1]) {
          require Carp;
          &Carp::confess( _fail_msg("'$_[0]' should be '$_[1]'!") );
      }
      return undef;
  }
  
  sub shouldnt ($$) {
      unless($_[0] ne $_[1]) {
          require Carp;
          &Carp::confess( _fail_msg("'$_[0]' shouldn't be that!") );
      }
      return undef;
  }
  
  =back
  
  =head1 Debugging vs Production
  
  Because assertions are extra code and because it is sometimes necessary to
  place them in 'hot' portions of your code where speed is paramount,
  Carp::Assert provides the option to remove its assert() calls from your
  program.
  
  So, we provide a way to force Perl to inline the switched off assert()
  routine, thereby removing almost all performance impact on your production
  code.
  
      no Carp::Assert;  # assertions are off.
      assert(1==1) if DEBUG;
  
  DEBUG is a constant set to 0.  Adding the 'if DEBUG' condition on your
  assert() call gives perl the cue to go ahead and remove assert() call from
  your program entirely, since the if conditional will always be false.
  
      # With C<no Carp::Assert> the assert() has no impact.
      for (1..100) {
          assert( do_some_really_time_consuming_check ) if DEBUG;
      }
  
  If C<if DEBUG> gets too annoying, you can always use affirm().
  
      # Once again, affirm() has (almost) no impact with C<no Carp::Assert>
      for (1..100) {
          affirm { do_some_really_time_consuming_check };
      }
  
  Another way to switch off all asserts, system wide, is to define the
  NDEBUG or the PERL_NDEBUG environment variable.
  
  You can safely leave out the "if DEBUG" part, but then your assert()
  function will always execute (and its arguments evaluated and time
  spent).  To get around this, use affirm().  You still have the
  overhead of calling a function but at least its arguments will not be
  evaluated.
  
  
  =head1 Differences from ANSI C
  
  assert() is intended to act like the function from ANSI C fame. 
  Unfortunately, due to Perl's lack of macros or strong inlining, it's not
  nearly as unobtrusive.
  
  Well, the obvious one is the "if DEBUG" part.  This is cleanest way I could
  think of to cause each assert() call and its arguments to be removed from
  the program at compile-time, like the ANSI C macro does.
  
  Also, this version of assert does not report the statement which
  failed, just the line number and call frame via Carp::confess.  You
  can't do C<assert('$a == $b')> because $a and $b will probably be
  lexical, and thus unavailable to assert().  But with Perl, unlike C,
  you always have the source to look through, so the need isn't as
  great.
  
  
  =head1 EFFICIENCY
  
  With C<no Carp::Assert> (or NDEBUG) and using the C<if DEBUG> suffixes
  on all your assertions, Carp::Assert has almost no impact on your
  production code.  I say almost because it does still add some load-time
  to your code (I've tried to reduce this as much as possible).
  
  If you forget the C<if DEBUG> on an C<assert()>, C<should()> or
  C<shouldnt()>, its arguments are still evaluated and thus will impact
  your code.  You'll also have the extra overhead of calling a
  subroutine (even if that subroutine does nothing).
  
  Forgetting the C<if DEBUG> on an C<affirm()> is not so bad.  While you
  still have the overhead of calling a subroutine (one that does
  nothing) it will B<not> evaluate its code block and that can save
  a lot.
  
  Try to remember the B<if DEBUG>.
  
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item NDEBUG
  
  Defining NDEBUG switches off all assertions.  It has the same effect
  as changing "use Carp::Assert" to "no Carp::Assert" but it effects all
  code.
  
  =item PERL_NDEBUG
  
  Same as NDEBUG and will override it.  Its provided to give you
  something which won't conflict with any C programs you might be
  working on at the same time.
  
  =back
  
  
  =head1 BUGS, CAVETS and other MUSINGS
  
  =head2 Conflicts with C<POSIX.pm>
  
  The C<POSIX> module exports an C<assert> routine which will conflict with C<Carp::Assert> if both are used in the same namespace.  If you are using both together, prevent C<POSIX> from exporting like so:
  
      use POSIX ();
      use Carp::Assert;
  
  Since C<POSIX> exports way too much, you should be using it like that anyway.
  
  =head2 C<affirm> and C<$^S>
  
  affirm() mucks with the expression's caller and it is run in an eval
  so anything that checks $^S will be wrong.
  
  =head2 missing C<if DEBUG>
  
  It would be nice if we could warn about missing C<if DEBUG>.
  
  
  =head1 SEE ALSO
  
  L<assert.h|http://en.wikipedia.org/wiki/Assert.h> - the wikipedia
  page about C<assert.h>.
  
  L<Carp::Assert::More> provides a set of convenience functions
  that are wrappers around C<Carp::Assert>.
  
  L<Sub::Assert> provides support for subroutine pre- and post-conditions.
  The documentation says it's slow.
  
  L<PerlX::Assert> provides compile-time assertions, which are usually
  optimised away at compile time. Currently part of the L<Moops>
  distribution, but may get its own distribution sometime in 2014.
  
  L<Devel::Assert> also provides an C<assert> function, for Perl >= 5.8.1.
  
  L<assertions> provides an assertion mechanism for Perl >= 5.9.0.
  
  =head1 REPOSITORY
  
  L<https://github.com/schwern/Carp-Assert>
  
  =head1 COPYRIGHT
  
  Copyright 2001-2007 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =cut
  
  return q|You don't just EAT the largest turnip in the world!|;
CARP_ASSERT

$fatpacked{"Contextual/Return.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN';
  package Contextual::Return;
  use warnings;
  use strict;
  our $VERSION = '0.004014';
  
  my %attrs_of;
  
  # This is localized as caller to hide the interim blocks...
  my $smart_caller;
  
  # Fake out Carp::*, and Scalar::Util::blessed() very early...
  BEGIN {
      no warnings 'redefine';
  
      my $fallback_caller = *CORE::GLOBAL::caller{CODE};
      if (!defined $fallback_caller) {
          *CORE::GLOBAL::caller = sub (;$) {
              my ($height) = @_;
              $height++;
              my @caller = CORE::caller($height);
              if ( CORE::caller() eq 'DB' ) {
                  # Oops, redo picking up @DB::args
                  package DB;
                  @caller = CORE::caller($height);
              }
  
              return if ! @caller;                  # empty
              return $caller[0] if ! wantarray;     # scalar context
              return @_ ? @caller : @caller[0..2];  # extra info or regular
          };
      }
      $smart_caller = sub (;$) {
          my ($uplevels) = $_[0] || 0;
          my @caller;
          if (CORE::caller eq 'DB') {
              package DB;
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          else {
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          return if ! @caller;                  # empty
          return $caller[0] if ! wantarray;     # scalar context
          return @_ ? @caller : @caller[0..2];  # extra info or regular
      };
  
      use Carp;
      my $real_carp  = *Carp::carp{CODE};
      my $real_croak = *Carp::croak{CODE};
  
      *Carp::carp = sub {
          goto &{$real_carp} if !$Contextual::Return::uplevel;
          warn _in_context(@_);
      };
  
      *Carp::croak = sub {
          goto &{$real_croak} if !$Contextual::Return::uplevel;
          die _in_context(@_);
      };
  
      # Scalar::Util::blessed()...
      use Scalar::Util 'refaddr';
  
      # Remember the current blessed()...
      my $original_blessing = *Scalar::Util::blessed{CODE};
  
      # ...and replace it...
      *Scalar::Util::blessed = sub($) {
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Are we operating on a CRV???
          my $attrs = $attrs_of{refaddr $_[0] or q{}};
  
          # If not, use the original code...
          goto &{$original_blessing} if !$attrs;
  
          # Does this object have a BLESSED handler???
          if (exists $attrs->{BLESSED}) {
              return $attrs->{BLESSED}->(@{$attrs->{args}});
          }
  
          # Otherwise, find the appropriate scalar handler...
          handler:
          for my $context (qw( OBJREF LAZY REF SCALAR VALUE NONVOID DEFAULT )) {
              my $handler = $attrs->{$context}
                  or next handler;
  
              my $obj_ref = eval { $handler->(@{$attrs->{args}}) };
  
              my $was_blessed = $original_blessing->($obj_ref);
              return $was_blessed if $was_blessed;
          }
  
          # Otherwise, simulate unblessed status...
          return undef;
      };
  }
  
  
  
  sub _in_context {
      my $msg = join q{}, @_;
  
      # Start looking in caller...
      my $stack_frame = 1;
      my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
      my ($orig_package, $prev_package) = ($package) x 2;
      my $LOC = qq{at $file line $line};
  
      # Walk up stack...
      STACK_FRAME:
      while (1) {
          my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
          # Fall off the top of the stack...
          last STACK_FRAME if !defined $package;
  
          # Ignore this module (and any helpers)...
          next STACK_FRAME if $package =~ m{^Contextual::Return}xms;
  
          # Track the call up the stack...
          $LOC = qq{at $file line $line};
  
          # Ignore any @CARP_NOT'ed packages
          next STACK_FRAME
              if do { no strict 'refs'; *{$package.'::CARP_NOT'}{ARRAY}; };
  
          # Ignore transitions within original caller...
          next STACK_FRAME
              if $package eq $orig_package && $prev_package eq $orig_package;
  
          # If we get a transition out of the original package, we're there...
          last STACK_FRAME;
      }
  
      # Insert location details...
      $msg =~ s/<LOC>/$LOC/g or $msg =~ s/[^\S\n]*$/ $LOC/;
      $msg =~ s/$/\n/;
      return $msg;
  }
  
  # Indentation corresponds to inherited fall-back relationships...
  my @CONTEXTS = qw(
      DEFAULT
          VOID
          NONVOID
              LIST
              SCALAR
                  VALUE
                      STR
                      NUM
                      BOOL
                          PUREBOOL
                  REF
                      SCALARREF
                      ARRAYREF
                      CODEREF
                      HASHREF
                      GLOBREF
                      OBJREF
                          METHOD
                          BLESSED
  );
  
  my @ALL_EXPORTS = (
      @CONTEXTS,
      qw(
          LAZY       RESULT      RVALUE      METHOD     FAIL
          FIXED      RECOVER     LVALUE      RETOBJ     FAIL_WITH
          ACTIVE     CLEANUP     NVALUE      STRICT     BLESSED
      )
  );
  
  my %STD_NAME_FOR = map { $_ => $_ } @ALL_EXPORTS;
  
  sub import {
      # Load utility module for failure handlers...
      if (require Contextual::Return::Failure) {
          *FAIL      = \&Contextual::Return::Failure::_FAIL;
          *FAIL_WITH = \&Contextual::Return::Failure::_FAIL_WITH;
      }
  
      # Don't need the package name...
      shift @_;
  
      # If args, export nothing by default; otherwise export all...
      my %exports = @_ ? () : %STD_NAME_FOR;
  
      # All args are export either selectors and/or renamers...
      while (my $selector = shift @_) {
          my $next_arg = $_[0];
          my $renamer = (defined $next_arg
                      && !ref $next_arg
                      && !exists $STD_NAME_FOR{$next_arg})
                          ? shift(@_)
                          : undef;
          %exports = (%exports, _add_exports_for($selector, $renamer));
      }
  
      # Loop through possible exports, exporting anything requested...
      my $caller = CORE::caller;
      EXPORT:
      for my $subname (keys %exports) {
          no strict qw( refs );
          *{$caller.'::'.$exports{$subname}} = \&{$subname};
      }
  };
  
  sub _add_exports_for {
      my ($selector, $renamer) = @_;
  
      # If no renamer, use original name...
      $renamer ||= '%s';
  
      # Handle different types of selector...
      my $selector_type = ref($selector) || 'literal';
  
      # Array selector recursively export each element...
      if ($selector_type eq 'ARRAY') {
          return map { _add_exports_for($_,$renamer) } @{$selector};
      }
      elsif ($selector_type eq 'Regexp') {
          my @selected = grep {/$selector/} @ALL_EXPORTS;
          if (!@selected) {
              Carp::carp("use Contextual::Return $selector didn't export anything");
          }
          no if $] >= 5.022, warnings => 'redundant';
          return map { $_ => sprintf($renamer, $_) } @selected;
      }
      elsif ($selector_type eq 'literal') {
          Carp::croak "Can't export $selector: no such handler"
              if !exists $STD_NAME_FOR{$selector};
          no if $] >= 5.022, warnings => 'redundant';
          return ( $selector => sprintf($renamer, $selector) );
      }
      else {
          Carp::croak "Can't use $selector_type as export specifier";
      }
  }
  
  
  # Let handlers access the result object they're inside...
  
  sub RETOBJ() {
      our $__RETOBJ__;
      return $__RETOBJ__;
  }
  
  
  use Scalar::Util qw( refaddr );
  
  # Override return value in a C::R handler...
  sub RESULT(;&) {
      my ($block) = @_;
  
      # Determine call context and arg list...
      my $context;
      my $args = do { package DB; $context=(CORE::caller 1)[5]; my $args = \@DB::args; ()=CORE::caller(1); $args };
  
      # No args -> return appropriate value...
      if (!@_) {
          return $context ? @{ $Contextual::Return::__RESULT__ || [] }
                          :    $Contextual::Return::__RESULT__->[0]
                          ;
      }
  
      # Hide from caller() and the enclosing eval{}...
  
      # Evaluate block in context and cache result...
      local $Contextual::Return::uplevel = $Contextual::Return::uplevel+1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      $Contextual::Return::__RESULT__
          =         $context  ? [        $block->(@{$args})      ]
          : defined $context  ? [ scalar $block->(@{$args}) ]
          :                     do {     $block->(@{$args}); [] }
          ;
  
      return;
  }
  
  sub RVALUE(&;@) :lvalue;
  sub LVALUE(&;@) :lvalue;
  sub NVALUE(&;@) :lvalue;
  
  my %opposite_of = (
      'RVALUE' => 'LVALUE or NVALUE',
      'LVALUE' => 'RVALUE or NVALUE',
      'NVALUE' => 'LVALUE or RVALUE',
  );
  
  
  BEGIN {
      for my $subname (qw( RVALUE LVALUE NVALUE) ) {
          no strict 'refs';
          *{$subname} = sub(&;@) :lvalue {    # (handler, return_lvalue);
              my $handler = shift;
              my $impl;
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              if (@_==0) {
                  $impl = tie $_[0], 'Contextual::Return::Lvalue',
                      $subname => $handler, args=>$args;
              }
              elsif (@_==1 and $impl = tied $_[0]) {
                  die _in_context "Can't install two $subname handlers"
                      if exists $impl->{$subname};
                  $impl->{$subname} = $handler;
              }
              else {
                  my $vals = join q{, }, map { tied $_    ? keys %{tied $_}
                                             : defined $_ ? $_
                                             :              'undef'
                                             } @_;
                  die _in_context "Expected a $opposite_of{$subname} block ",
                                  "after the $subname block <LOC> ",
                                  "but found instead: $vals\n";
              }
  
              # Handle void context calls...
              if (!defined wantarray && $impl->{NVALUE}) {
                  # Fake out caller() and Carp...
                  local $Contextual::Return::uplevel = 1;
                  no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
                  # Call and clear handler...
                  local $Contextual::Return::__RETOBJ__ = $impl;
                  $impl->{NVALUE}( @{$impl->{args}} );
                  delete $impl->{NVALUE};
              }
              $_[0];
          }
      }
  }
  
  for my $modifier_name (qw< STRICT FIXED ACTIVE >) {
      no strict 'refs';
      *{$modifier_name} = sub ($) {
          my ($crv) = @_;
          my $attrs = $attrs_of{refaddr $crv or q{}};
  
          # Track context...
          my $wantarray = wantarray;
          use Want;
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Remember the modification...
          $attrs->{$modifier_name} = 1;
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last handler if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, let someone else handle it...
          return $crv;
      }
  }
  
  sub LIST (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !!(CORE::caller 1)[5] if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare LIST {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two LIST handlers"
          if exists $attrs->{LIST};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
  
          my @rv = eval { $block->(@{$attrs->{args}}) };
          if ($recover) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [@rv];
              }
              () = $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return @rv if !$Contextual::Return::__RESULT__;
          return @{$Contextual::Return::__RESULT__};
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          handler:
          for my $context (qw< VOID DEFAULT >) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              eval { $attrs->{$context}->(@{$attrs->{args}}) };
              if ($recover) {
                  $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
              last handler;
          }
          if ($attrs->{STRICT}) {
              $@ = _in_context "Can't call $attrs->{sub} in a void context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{LIST} = $block;
      return $crv;
  }
  
  
  sub VOID (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !defined( (CORE::caller 1)[5] ) if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare VOID {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two VOID handlers"
          if exists $attrs->{VOID};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly, if possible...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
          # List or ancestral handlers...
          handler:
          for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              my @rv = eval { $handler->(@{$attrs->{args}}) };
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [@rv];
                  }
                  () = $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              return @rv if !$Contextual::Return::__RESULT__;
              return @{$Contextual::Return::__RESULT__};
          }
          # Convert to list from arrayref handler...
          if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
              my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [$array_ref];
                  }
                  scalar $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              # Array ref may be returned directly, or via RESULT{}...
              $array_ref = $Contextual::Return::__RESULT__->[0]
                  if $Contextual::Return::__RESULT__;
  
              return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
          }
          # Return scalar object as one-elem list, if possible...
          handler:
          for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
              last handler if $attrs->{STRICT};
              return $crv if exists $attrs->{$context};
          }
          $@ = _in_context "Can't call $attrs->{sub} in a list context";
          if ($recover) {
              () = $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          eval { $block->(@{$attrs->{args}}) };
  
          if ($recover) {
              $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{VOID} = $block;
      return $crv;
  }
  
  for my $context (qw( SCALAR NONVOID )) {
      no strict qw( refs );
      *{$context} = sub (;&$) {
          my ($block, $crv) = @_;
  
          # Handle simple context tests...
          if (!@_) {
              my $callers_context = (CORE::caller 1)[5];
              return defined $callers_context
                  && ($context eq 'NONVOID' || !$callers_context);
          }
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                      = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          die _in_context "Can't install two $context handlers"
              if exists $attrs->{$context};
          $attrs->{$context} = $block;
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
  
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              die _in_context "Can't call $attrs->{sub} in a list context";
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  handler:
  for my $context_name (@CONTEXTS, qw< RECOVER _internal_LIST CLEANUP >) {
      next handler if $context_name eq 'LIST'       # These
                   || $context_name eq 'VOID'       #  four
                   || $context_name eq 'SCALAR'     #   handled
                   || $context_name eq 'NONVOID';   #    separately
  
      no strict qw( refs );
      *{$context_name} = sub (&;$) {
          my ($block, $crv) = @_;
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context_name {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                       = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          if ($context_name ne '_internal_LIST') {
              die _in_context "Can't install two $context_name handlers"
                  if exists $attrs->{$context_name};
              $attrs->{$context_name} = $block;
          }
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__
                  = $context_name eq 'RECOVER' ? $Contextual::Return::__RESULT__
                  :                              undef
                  ;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  local $Contextual::Return::uplevel = 2;
  
                  # Array ref may be returned directly, or via RESULT{}...
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw(VOID DEFAULT)) {
                  if (!$attrs->{$context}) {
                      last handler if $attrs->{STRICT};
                      next handler;
                  }
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  # Alias LAZY to SCALAR...
  *LAZY = *SCALAR;
  
  
  # Set $Data::Dumper::Freezer to 'Contextual::Return::FREEZE' to be able to
  # dump contextual return values...
  
  my %operator_impl;
  
  my $no_handler_message = qr{
      ^ Can't [ ] call [ ] .*? [ ] in [ ] [\w]+ [ ] context
    | ^ [\w:]+ [ ] can't [ ] return [ ] a [ ] \w+ [ ] reference
  }xms;
  
  sub _flag_self_ref_in {
      my ($data_ref, $obj_ref) = @_;
      my $type = ref $data_ref;
      return if !$type;
      for my $ref ( $type eq 'SCALAR' ? ${$data_ref} : $type eq 'ARRAY' ? @{$data_ref} : ()) {
          no warnings 'numeric', 'uninitialized';
          if (refaddr($ref) == refaddr($obj_ref)) {
              $ref = '<<<self-reference>>>';
          }
      }
  }
  
  sub FREEZE {
      my ($self) = @_;
      my $attrs_ref = $attrs_of{refaddr $self};
      my $args_ref  = $attrs_ref->{args};
  
      my @no_handler;
  
      # Call appropriate operator handler, defusing and recording exceptions...
      my $overloaded = sub {
          my ($context, $op) = @_;
  
          # Try the operator...
          my $retval = eval { $operator_impl{$op}->($self,@{$args_ref}) };
  
          # Detect and report internal exceptions...
          if (my $exception = $@) {
              if ($exception =~ $no_handler_message) {
                  push @no_handler, $context;
                  return ();
              }
              chomp $exception;
              return { $context => "<<<Throws exception: $exception>>>" };
          }
  
          # Detect self-referential overloadings (to avoid infinite recursion)...
          {
              no warnings 'numeric', 'uninitialized';
              if (ref $retval eq 'REF' && eval{ ${$retval} == ${$self} }) {
                  return { $context => "<<<self-reference>>>" };
              }
          }
  
          # Normal return of contextual value labelled by context...
          return { $context => $retval };
      };
  
      my @values;
  
      # Where did this value originate?
      push @values, { ISA  => 'Contextual::Return::Value' };
      push @values, { FROM => $attrs_ref->{sub} };
  
      # Does it return a value in void context?
      if (exists $attrs_ref->{VOID} || exists $attrs_ref->{DEFAULT}) {
          push @values, { VOID => undef };
      }
      else {
          push @no_handler, 'VOID';
      }
  
      # Generate list context value by "pretend" LIST handler...
      push @values, { LIST => eval{ [ _internal_LIST(sub{}, $self) ] } // do{ chomp $@; "<<<Throws exception: $@>>>"} };
          _flag_self_ref_in($values[-1]{LIST}, $self);
  
      # Generate scalar context values by calling appropriate handler...
      push @values, $overloaded->( STR       => q{""}  );
      push @values, $overloaded->( NUM       => '0+'   );
      push @values, $overloaded->( BOOL      => 'bool' );
      push @values, $overloaded->( SCALARREF => '${}'  );
          _flag_self_ref_in($values[-1]{SCALARREF}, $self);
      push @values, $overloaded->( ARRAYREF  => '@{}'  );
          _flag_self_ref_in($values[-1]{ARRAYREF}, $self);
      push @values, $overloaded->( CODEREF   => '&{}'  );
      push @values, $overloaded->( HASHREF   => '%{}'  );
      push @values, $overloaded->( GLOBREF   => '*{}'  );
  
      # Are there handlers for various "generic" super-contexts...
      my @fallbacks = grep { $attrs_ref->{$_} }
                         qw< DEFAULT NONVOID SCALAR VALUE REF RECOVER >;
  
      push @values, { NO_HANDLER => \@no_handler };
      push @values, { FALLBACKS  => \@fallbacks  };
  
      # Temporarily replace object being dumped, by values found...
      $_[0] = \@values;
  }
  
  # Call this method on a contextual return value object to debug it...
  
  sub DUMP {
      if (eval{ require Data::Dumper; 1; }) {
          my ($crv) = @_;
          if (eval{ ref($crv)->isa('Contextual::Return::Value')}) {
              Contextual::Return::FREEZE($crv);
          }
          local $Data::Dumper::Terse = 1;
          local $Data::Dumper::Indent = 1;
          my $dump = Data::Dumper::Dumper($crv);
          $dump =~ s<,\n  \{><,ZZZZ{>msg;
          $dump =~ s<\n\s+>< >msg;
          $dump =~ s<,ZZZZ\{><\n  {>msg;
          return $dump;
      }
      else {
          Carp::carp("Can't DUMP contextual return value (no Data::Dumper!)");
          return;
      }
  }
  
  
  package Contextual::Return::Value;
  BEGIN { *_in_context = *Contextual::Return::_in_context; }
  use Scalar::Util qw( refaddr );
  
  BEGIN {
      %operator_impl = (
          q{""} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(STR SCALAR LAZY VALUE NONVOID DEFAULT NUM)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a string";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{0+} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(NUM SCALAR LAZY VALUE NONVOID DEFAULT STR)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a number";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{bool} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
  
              # Handle Calls in Pure Boolean context...
              my @PUREBOOL = $attrs->{want_pure_bool} ? ('PUREBOOL') : ();
              $attrs->{want_pure_bool} = 0;
  
              handler:
              for my $context (@PUREBOOL, qw(BOOL STR NUM SCALAR LAZY VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $context eq 'BOOL' and $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $outer_sig_warn = $SIG{__WARN__};
                  local $SIG{__WARN__}
                      = sub{ return if $_[0] =~ /^Exiting \S+ via next/;
                             goto &{$outer_sig_warn} if $outer_sig_warn;
                             warn @_;
                        };
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a boolean";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '${}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(SCALARREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the scalar dereference"
                          if ref($rv) ne 'SCALAR' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return a scalar reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              if ( $attrs->{FIXED} ) {
                  $_[0] = \$self;
              }
              return \$self;
          },
          '@{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              local $Contextual::Return::__RESULT__;
              handler:
              for my $context (qw(ARRAYREF REF)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the array dereference"
                          if ref($rv) ne 'ARRAY' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  last handler if $attrs->{STRICT};
                  my $handler = $attrs->{$context}
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      @rv = @{$Contextual::Return::__RESULT__->[0]};
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = \@rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { @rv };
                  }
                  return \@rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return an array reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              return [ $self ];
          },
          '%{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(HASHREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the hash dereference"
                          if ref($rv) ne 'HASH' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a hash reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '&{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(CODEREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the subroutine dereference"
                          if ref($rv) ne 'CODE' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a subroutine reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '*{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(GLOBREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the typeglob dereference"
                          if ref($rv) ne 'GLOB' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a typeglob reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
      );
  }
  
  use overload %operator_impl, fallback => 1;
  
  sub DESTROY {
      my ($id) = refaddr shift;
      my $attrs = $attrs_of{$id};
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      if (my $handler = $attrs->{CLEANUP}) {
          $handler->(@{ $attrs->{args} });
      }
      delete $attrs_of{$id};
      return;
  }
  
  my $NO_SUCH_METHOD = qr/\ACan't (?:locate|call)(?: class| object)? method/ms;
  
  # Forward metainformation requests to actual class...
  sub can {
      my ($invocant) = @_;
      # Only forward requests on actual C::R::V objects...
      if (ref $invocant) {
          our $AUTOLOAD = 'can';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::can(@_[1..$#_]);
  }
  
  sub isa {
      # Only forward requests on actual C::R::V objects...
      my ($invocant) = @_;
      if (ref $invocant) {
          our $AUTOLOAD = 'isa';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::isa(@_[1..$#_]);
  }
  
  
  sub AUTOLOAD {
      my ($self) = @_;
      our $AUTOLOAD;
  
      my ($requested_method) = $AUTOLOAD =~ m{ .* :: (.*) }xms ? $1 : $AUTOLOAD;
  
      my $attrs = $attrs_of{refaddr $self} || {};
      local $Contextual::Return::__RETOBJ__ = $self;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # First, see if there is a method call handler...
      if (my $context_handler = $attrs->{METHOD}) {
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my @method_handlers = eval { $context_handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [\@method_handlers];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              @method_handlers = @{$Contextual::Return::__RESULT__};
          }
  
          # Locate the correct method handler (if any)...
          MATCHER:
          while (my ($matcher, $method_handler) = splice @method_handlers, 0, 2) {
  
              if (ref($matcher) eq 'ARRAY') {
                  next MATCHER
                      if !grep { $requested_method =~ $_ } @{$matcher};
              }
              elsif ($requested_method !~ $matcher) {
                  next MATCHER;
              }
  
              shift;
              if (wantarray) {
                  my @result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return @result;
              }
              else {
                  my $result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return $result;
              }
          }
      }
  
      # Next, try to create an object on which to call the method...
      handler:
      for my $context (qw(OBJREF STR SCALAR LAZY VALUE NONVOID DEFAULT)) {
          my $handler = $attrs->{$context}
              or $attrs->{STRICT} and last handler
              or next handler;
  
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my $object = eval { $handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [$object];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              $object = $Contextual::Return::__RESULT__->[0];
          }
  
          if ( $attrs->{FIXED} ) {
              $_[0] = $object;
          }
          elsif ( !$attrs->{ACTIVE} ) {
              $attrs->{$context} = sub { $object };
          }
          shift;
  
          if (wantarray) {
              my @result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return @result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          else {
              my $result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return $result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          $@ = _in_context "Can't call method '$requested_method' on $context value returned by $attrs->{sub}";
          if (my $recover = $attrs->{RECOVER}) {
              scalar $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Otherwise, the method cannot be called, so react accordingly...
      $@ = _in_context "Can't call method '$requested_method' on value returned by $attrs->{sub}";
      if (my $recover = $attrs->{RECOVER}) {
          return scalar $recover->(@{$attrs->{args}});
      }
      else {
          die $@;
      }
  }
  
  package Contextual::Return::Lvalue;
  
  sub TIESCALAR {
      my ($package, @handler) = @_;
      return bless {@handler}, $package;
  }
  
  # Handle calls that are lvalues...
  sub STORE {
      local *CALLER::_ = \$_;
      local *_         = \$_[1];
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{LVALUE}( @{$_[0]{args}} );
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  # Handle calls that are rvalues...
  sub FETCH {
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{RVALUE} ? $_[0]{RVALUE}( @{$_[0]{args}} ) : undef;
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  sub DESTROY {};
  
  1; # Magic true value required at end of module
  
  __END__
  
  =head1 NAME
  
  Contextual::Return - Create context-sensitive return values
  
  
  =head1 VERSION
  
  This document describes Contextual::Return version 0.004014
  
  
  =head1 SYNOPSIS
  
      use Contextual::Return;
      use Carp;
  
      sub foo {
          return
              SCALAR { 'thirty-twelve' }
              LIST   { 1,2,3 }
  
              BOOL { 1 }
              NUM  { 7*6 }
              STR  { 'forty-two' }
  
              HASHREF  { {name => 'foo', value => 99} }
              ARRAYREF { [3,2,1] }
  
              GLOBREF  { \*STDOUT }
              CODEREF  { croak "Don't use this result as code!"; }
          ;
      }
  
      # and later...
  
      if (my $foo = foo()) {
          for my $count (1..$foo) {
              print "$count: $foo is:\n"
                  . "  array: @{$foo}\n"
                  . "  hash:  $foo->{name} => $foo->{value}\n"
                  ;
          }
          print {$foo} $foo->();
      }
  
  =head1 DESCRIPTION
  
  Usually, when you need to create a subroutine that returns different values in
  different contexts (list, scalar, or void), you write something like:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data,
          # depending on call context...
          if (wantarray()) {
              return @server_data{ qw(name uptime load users) };
          }
          if (defined wantarray()) {
              return $server_data{load};
          }
          if (!defined wantarray()) {
              carp 'Useless use of get_server_status() in void context';
              return;
          }
          else {
              croak q{Bad context! No biscuit!};
          }
      }
  
  That works okay, but the code could certainly be more readable. In
  its simplest usage, this module makes that code more readable by
  providing three subroutines--C<LIST()>, C<SCALAR()>, C<VOID()>--that
  are true only when the current subroutine is called in the
  corresponding context:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          if (LIST)   { return @server_data{ qw(name uptime load users) } }
          if (SCALAR) { return $server_data{load}                         }
          if (VOID)   { print "$server_data{load}\n"                      }
          else        { croak q{Bad context! No biscuit!}                 }
      }
  
  =head2 Contextual returns
  
  Those three subroutines can also be used in another way: as labels on a
  series of I<contextual return blocks> (collectively known as a I<contextual
  return sequence>). When a context sequence is returned, it automatically
  selects the appropriate contextual return block for the calling context.
  So the previous example could be written even more cleanly as:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
              LIST    { return @server_data{ qw(name uptime load users) } }
              SCALAR  { return $server_data{load}                         }
              VOID    { print "$server_data{load}\n"                      }
              DEFAULT { croak q{Bad context! No biscuit!}                 }
          );
      }
  
  The context sequence automatically selects the appropriate block for each call
  context.
  
  
  =head2 Lazy contextual return values
  
  C<LIST> and C<VOID> blocks are always executed during the C<return>
  statement. However, scalar return blocks (C<SCALAR>, C<STR>, C<NUM>,
  C<BOOL>, etc.) blocks are not. Instead, returning any of scalar block
  types causes the subroutine to return an object that lazily
  evaluates that block only when the return value is used.
  
  This means that returning a C<SCALAR> block is a convenient way to
  implement a subroutine with a lazy return value. For example:
  
      sub digest {
          return SCALAR {
              my ($text) = @_;
              md5($text);
          }
      }
  
      my $digest = digest($text);
  
      print $digest;   # md5() called only when $digest used as string
  
  To better document this usage, the C<SCALAR> block has a synonym: C<LAZY>.
  
      sub digest {
          return LAZY {
              my ($text) = @_;
              md5($text);
          }
      }
  
  
  =head2 Active contextual return values
  
  Once a return value has been lazily evaluated in a given context,
  the resulting value is cached, and thereafter reused in that same context.
  
  However, you can specify that, rather than being cached, the value
  should be re-evaluated I<every> time the value is used:
  
       sub make_counter {
          my $counter = 0;
          return ACTIVE
              SCALAR   { ++$counter }
              ARRAYREF { [1..$counter] }
      }
  
      my $idx = make_counter();
  
      print "$idx\n";      # 1
      print "$idx\n";      # 2
      print "[@$idx]\n";   # [1 2]
      print "$idx\n";      # 3
      print "[@$idx]\n";   # [1 2 3]
  
  
  =head2 Semi-lazy contextual return values
  
  Sometimes, single or repeated lazy evaluation of a scalar return value
  in different contexts isn't what you really want. Sometimes what you
  really want is for the return value to be lazily evaluated once only (the
  first time it's used in any context), and then for that first value to
  be reused whenever the return value is subsequently reevaluated in any
  other context.
  
  To get that behaviour, you can use the C<FIXED> modifier, which causes
  the return value to morph itself into the actual value the first time it
  is used. For example:
  
      sub lazy {
          return
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $lazy = lazy();
      print $lazy + 1;            # 43
      print "@{$lazy}";           # 1 2 3
  
  
      sub semilazy {
          return FIXED
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $semi = semilazy();
      print $semi + 1;            # 43
      print "@{$semi}";           # die q{Can't use string ("42") as an ARRAY ref}
  
  
  
  =head2 Finer distinctions of scalar context
  
  Because the scalar values returned from a context sequence are lazily
  evaluated, it becomes possible to be more specific about I<what kind> of
  scalar value should be returned: a boolean, a number, or a string. To support
  those distinctions, Contextual::Return provides four extra context blocks:
  C<NUM>, C<STR>, C<BOOL>, and C<PUREBOOL>:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }          }
             PUREBOOL { $_ = $server_data{uptime}; $server_data{uptime} > 0 }
                 BOOL { $server_data{uptime} > 0                            }
                 NUM  { $server_data{load}                                  }
                 STR  { "$server_data{name}: $server_data{uptime}"          }
                 VOID { print "$server_data{load}\n"                        }
              DEFAULT { croak q{Bad context! No biscuit!}                   }
          );
      }
  
  With these in place, the object returned from a scalar-context call to
  C<get_server_status()> now behaves differently, depending on how
  it's used. For example:
  
      if ( my $status = get_server_status() ) {  # BOOL: True if uptime > 0
          $load_distribution[$status]++;         # INT:  Evaluates to load value
          print "$status\n";                     # STR:  Prints "name: uptime"
      }
  
      if (get_server_status()) {                 # PUREBOOL: also sets $_;
          print;                                 # ...which is then used here
      }
  
  =head3 Boolean vs Pure Boolean contexts
  
  There is a special subset of boolean contexts where the return value is being
  used and immediately thrown away. For example, in the loop:
  
      while (get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is tested for truth and then discarded.
  This is known as "pure boolean context". In contrast, in the loop:
  
      while (my $data = get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is first assigned to C<$data>, then
  tested for truth. Because of the assignment, the return value is I<not>
  discarded after the boolean test. This is ordinary "boolean context".
  
  In Perl, pure boolean context is often associated with a special side-effect,
  that does not occur in regular boolean contexts. For example:
  
      while (<>) {...}         # $_ set as side-effect of pure boolean context
  
      while ($v = <>) {...}    # $_ NOT set in ordinary boolean context
  
  Contextual::Return supports this with a special subcase of C<BOOL> named
  <PUREBOOL>. In pure boolean contexts, Contextual::Return will call a
  C<PUREBOOL> handler if one has been defined, or fall back to a C<BOOL>
  or C<SCALAR> handler if no C<PUREBOOL> handler exists. In ordinary
  boolean contexts only the C<BOOL> or C<SCALAR> handlers are tried, even
  if a C<PUREBOOL> handler is also defined.
  
  Typically C<PUREBOOL> handlers are set up to have some side-effect (most
  commonly: setting C<$_> or <$@>), like so:
  
      sub get_data {
          my ($succeeded, @data) = _go_and_get_data();
  
          return
              PUREBOOL { $_ = $data[0]; $succeeded; }
                  BOOL {                $succeeded; }
                SCALAR {                $data[0];   }
                  LIST {                @data;      }
      }
  
  However, there is no requirement that they have side-effects. For example,
  they can also be used to implement "look-but-don't-retrieve-yet" checking:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  
  =head2 Self-reference within handlers
  
  Any handler can refer to the contextual return object it is part of, by
  calling the C<RETOBJ()> function. This is particularly useful for C<PUREBOOL>
  and C<LIST> handlers. For example:
  
      return
          PUREBOOL { $_ = RETOBJ; next handler; }
              BOOL { !$failed;                  }
           DEFAULT { $data;                     };
  
  
  =head2 Referential contexts
  
  The other major kind of scalar return value is a reference.
  Contextual::Return provides contextual return blocks that allow you to
  specify what to (lazily) return when the return value of a subroutine is
  used as a reference to a scalar (C<SCALARREF {...}>), to an array
  (C<ARRAYREF {...}>), to a hash (C<HASHREF {...}>), to a subroutine
  (C<CODEREF {...}>), or to a typeglob (C<GLOBREF {...}>).
  
  For example, the server status subroutine shown earlier could be extended to
  allow it to return a hash reference, thereby supporting "named return values":
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }  }
                 BOOL { $server_data{uptime} > 0                    }
                  NUM { $server_data{load}                          }
                  STR { "$server_data{name}: $server_data{uptime}"  }
                 VOID { print "$server_data{load}\n"                }
              HASHREF { return \%server_data                        }
              DEFAULT { croak q{Bad context! No biscuit!}           }
          );
      }
  
      # and later...
  
      my $users = get_server_status->{users};
  
  
      # or, lazily...
  
      my $server = get_server_status();
  
      print "$server->{name} load = $server->{load}\n";
  
  
  =head2 Interpolative referential contexts
  
  The C<SCALARREF {...}> and C<ARRAYREF {...}> context blocks are
  especially useful when you need to interpolate a subroutine into
  strings. For example, if you have a subroutine like:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and later...
  
      print "There are ", scalar(get_todo_tasks()), " tasks:\n",
              get_todo_tasks();
  
  then you could make it much easier to interpolate calls to that
  subroutine by adding:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              SCALARREF { \scalar @todo_list }  # Ref to how many
              ARRAYREF  { \@todo_list        }  # Ref to them
          );
      }
  
      # and then...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  In fact, this behaviour is so useful that it's the default. If you
  don't provide an explicit C<SCALARREF {...}> block,
  Contextual::Return automatically provides an implicit one that simply
  returns a reference to whatever would have been returned in scalar context.
  Likewise, if no C<ARRAYREF {...}> block is specified, the module supplies one
  that returns the list-context return value wrapped up in an array reference.
  
  So you could just write:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and still do this...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  
  =head2 Fallback contexts
  
  As the previous sections imply, the C<BOOL {...}>, C<NUM {...}>, C<STR
  {...}>, and various C<*REF {...}> blocks, are special cases of the
  general C<SCALAR {...}> context block. If a subroutine is called in one
  of these specialized contexts but does not use the corresponding context
  block, then the more general C<SCALAR {...}> block is used instead (if
  it has been specified).
  
  So, for example:
  
      sub read_value_from {
          my ($fh) = @_;
  
          my $value = <$fh>;
          chomp $value;
  
          return (
              BOOL   { defined $value }
              SCALAR { $value         }
          );
      }
  
  ensures that the C<read_value_from()> subroutine returns true in boolean
  contexts if the read was successful. But, because no specific C<NUM {...}>
  or C<STR {...}> return behaviours were specified, the subroutine falls back on
  using its generic C<SCALAR {...}> block in all other scalar contexts.
  
  Another way to think about this behaviour is that the various kinds of
  scalar context blocks form a hierarchy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |
           `--< STR
  
  Contextual::Return uses this hierarchical relationship to choose the most
  specific context block available to handle any particular return context,
  working its way up the tree from the specific type it needs, to the more
  general type, if that's all that is available.
  
  There are two slight complications to this picture. The first is that Perl
  treats strings and numbers as interconvertable so the diagram (and the
  Contextual::Return module) also has to allow these interconversions as a
  fallback strategy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |    : ^
           |    v :
           `--< STR
  
  The dotted lines are meant to indicate that this intraconversion is secondary
  to the main hierarchical fallback. That is, in a numeric context, a C<STR
  {...}> block will only be used if there is no C<NUM {...}> block I<and> no
  C<SCALAR {...}> block. In other words, the generic context type is always
  used in preference to string<->number conversion.
  
  The second slight complication is that the above diagram only shows a
  small part of the complete hierarchy of contexts supported by
  Contextual::Return. The full fallback hierarchy (including dotted
  interconversions) is:
  
        DEFAULT
           ^
           |
           |--< VOID
           |
           `--< NONVOID
                   ^
                   |
                   |--< VALUE <...............
                   |      ^                   :
                   |      |                   :
                   |      |--< SCALAR <.......:...
                   |      |           ^           :
                   |      |           |           :
                   |      |           |--< BOOL   :
                   |      |           |     ^     :
                   |      |           |     |     :
                   |      |           |  PUREBOOL :
                   |      |           |           :
                   |      |           |--< NUM <..:.
                   |      |           |    : ^      :
                   |      |           |    v :      :
                   |      |           `--< STR <....:..
                   |      |                           :
                   |      |                          ::
                   |      `--< LIST ................: :
                   |            : ^                   :
                   |            : :                   :
                   `--- REF     : :                   :
                         ^      : :                   :
                         |      v :                   :
                         |--< ARRAYREF                :
                         |                            :
                         |--< SCALARREF .............:
                         |
                         |--< HASHREF
                         |
                         |--< CODEREF
                         |
                         |--< GLOBREF
                         |
                         `--< OBJREF <....... METHOD
                                 ^
                                 :........... BLESSED
  
  As before, each dashed arrow represents a fallback relationship. That
  is, if the required context specifier isn't available, the arrows are
  followed until a more generic one is found. The dotted arrows again
  represent the interconversion of return values, which is
  attempted only after the normal hierarchical fallback fails.
  
  For example, if a subroutine is called in a context that expects a
  scalar reference, but no C<SCALARREF {...}> block is provided, then
  Contextual::Return tries the following blocks in order:
  
          REF {...}
      NONVOID {...}
      DEFAULT {...}
          STR {...} (automatically taking a reference to the result)
          NUM {...} (automatically taking a reference to the result)
       SCALAR {...} (automatically taking a reference to the result)
        VALUE {...} (automatically taking a reference to the result)
  
  Likewise, in a list context, if there is no C<LIST {...}> context block, the
  module tries:
  
         VALUE {...}
       NONVOID {...}
       DEFAULT {...}
      ARRAYREF {...} (automatically dereferencing the result)
           STR {...} (treating it as a list of one element)
           NUM {...} (treating it as a list of one element)
        SCALAR {...} (treating it as a list of one element)
  
  The more generic context blocks are especially useful for intercepting
  unexpected and undesirable call contexts. For example, to turn I<off>
  the automatic scalar-ref and array-ref interpolative behaviour described
  in L<Interpolative referential contexts>, you could intercept I<all>
  referential contexts using a generic C<REF {...}> context block:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              REF { croak q{get_todo_task() can't be used as a reference} }
          );
      }
  
      print 'There are ', get_todo_tasks(), '...';    # Still okay
      print "There are ${get_todo_tasks()}...";       # Throws an exception
  
  
  =head2 Treating return values as objects
  
  Normally, when a return value is treated as an object (i.e. has a method
  called on it), Contextual::Return invokes any C<OBJREF> handler that was
  specified in the contextual return list, and delegates the method call to
  the object returned by that handler.
  
  However, you can also be more specific, by specifying a C<METHOD> context
  handler in the contextual return list. The block of this handler is expected
  to return one or more method-name/method-handler pairs, like so:
  
      return
          METHOD {
              get_count => sub { my $n = shift; $data[$n]{count} },
              get_items => sub { my $n = shift; $data[$n]{items} },
              clear     => sub { @data = (); },
              reset     => sub { @data = (); },
          }
  
  Then, whenever one of the specified methods is called on the return value,
  the corresponding subroutine will be called to implement it.
  
  The method handlers must always be subroutine references, but the method-name
  specifiers may be strings (as in the previous example) or they may be
  specified generically, as either regexes or array references. Generic method
  names are used to call the same handler for two or more distinct method names.
  For example, the previous example could be simplified to:
  
      return
          METHOD {
              qr/get_(\w+)/     => sub { my $n = shift; $data[$n]{$1} },
              ['clear','reset'] => sub { @data = (); },
          }
  
  A method name specified by regex will invoke the corresponding handler for any
  method call request that the regex matches. A method name specified by array
  ref will invoke the corresponding handler if the method requested matches any
  of the elements of the array (which may themselves be strings or regexes).
  
  When the method handler is invoked, the name of the method requested is
  passed to the handler in C<$_>, and the method's argument list is passed
  (as usual) via C<@_>.
  
  Note that any methods not explicitly handled by the C<METHOD> handlers
  will still be delegated to the object returned by the C<OBJREF> handler
  (if it is also specified).
  
  
  =head2 Not treating return values as objects
  
  The use of C<OBJREF> and C<METHOD> are slightly complicated by the fact
  that contextual return values are themselves objects.
  
  For example, prior to version 0.4.4 of the module, if you passed a
  contextual return value to C<Scalar::Util::blessed()>, it always
  returned a true value (namely, the string: 'Contextual::Return::Value'),
  even if the return value had not specified handlers for C<OBJREF> or
  C<METHOD>.
  
  In other words, the I<implementation> of contextual return values (as
  objects) was getting in the way of the I<use> of contextual return
  values (as non-objects).
  
  So the module now also provides a C<BLESSED> handler, which allows you
  to explicitly control how contextual return values interact with
  C<Scalar::Util::blessed()>.
  
  If C<$crv> is a contextual return value, by default
  C<Scalar::Util::blessed($crv)> will now only return true if that return
  value has a C<OBJREF>, C<LAZY>, C<REF>, C<SCALAR>, C<VALUE>, C<NONVOID>,
  or C<DEFAULT> handler that in turn returns a blessed object.
  
  However if C<$crv> also provides a C<BLESSED> handler, C<blessed()>
  will return whatever that handler returns.
  
  This means:
  
      sub simulate_non_object {
          return BOOL { 1 }
                  NUM { 42 }
      }
  
      sub simulate_real_object {
          return OBJREF { bless {}, 'My::Class' }
                   BOOL { 1 }
                    NUM { 42 }
      }
  
      sub simulate_faked_object {
          return BLESSED { 'Foo' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
      sub simulate_previous_behaviour {
          return BLESSED { 'Contextual::Return::Value' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
  
      say blessed( simulate_non_object()         );   # undef
      say blessed( simulate_real_object()        );   # My::Class
      say blessed( simulate_faked_object()       );   # Foo
      say blessed( simulate_previous_behaviour() );   # Contextual::Return::Value
  
  Typically, you either want no C<BLESSED> handler (in which case
  contextual return values pretend not to be blessed objects), or you want
  C<BLESSED { 'Contextual::Return::Value' }> for backwards compatibility
  with pre-v0.4.7 behaviour.
  
  
  =head3 Preventing fallbacks
  
  Sometimes fallbacks can be too helpful. Or sometimes you want to impose
  strict type checking on a return value.
  
  Contextual::Returns allows that via the C<STRICT> specifier. If you include
  C<STRICT> anywhere in your return statement, the module disables all
  fallbacks and will therefore through an exception if the return value is
  used in any way not explicitly specified in the contextual return sequence.
  
  For example, to create a subroutine that returns only a string:
  
      sub get_name {
          return STRICT STR { 'Bruce' }
      }
  
  If the return value of the subroutine is used in any other way than as
  a string, an exception will be thrown.
  
  You can still specify handlers for more than a single kind of context
  when using C<STRICT>:
  
      sub get_name {
          return STRICT
              STR  { 'Bruce' }
              BOOL { 0 }
      }
  
  ...but these will still be the only contexts in which the return value
  can be used:
  
      my $n = get_name() ? 1 : 2;  # Okay because BOOL handler specified
  
      my $n = 'Dr' . get_name();   # Okay because STR handler specified
  
      my $n = 1 + get_name();      # Exception thrown because no NUM handler
  
  In other words, C<STRICT> allows you to impose strict type checking on
  your contextual return value.
  
  
  =head2 Deferring handlers
  
  Because the various handlers form a hierarchy, it's possible to
  implement more specific handlers by falling back on ("deferring to")
  more general ones. For example, L<a C<PUREBOOL> handler|"Boolean vs Pure
  Boolean contexts"> is almost always identical in its basic behaviour to
  the corresponding C<BOOL> handler, except that it adds some side-effect.
  For example:
  
      return
          PUREBOOL { $_ = $return_val; defined $return_val && $return_val > 0 }
              BOOL {                   defined $return_val && $return_val > 0 }
            SCALAR {                   $return_val;                           }
  
  So Contextual::Return allows you to have a handler perform some action
  and then defer to a more general handler to supply the actual return
  value. To fall back to a more general case in this way, you simply write:
  
      next handler;
  
  at the end of the handler in question, after which Contextual::Return
  will find the next-most-specific handler and execute it as well. So the
  previous example, could be re-written:
  
      return
          PUREBOOL { $_ = $return_val; next handler;        }
              BOOL { defined $return_val && $return_val > 0 }
            SCALAR { $return_val;                           }
  
  Note that I<any> specific handler can defer to a more general one in
  this same way. For example, you could provide consistent and
  maintainable type-checking for a subroutine that returns references by
  providing C<ARRAYREF>, C<HASHREF>, and C<SCALARREF> handlers that all
  defer to a generic C<REF> handler, like so:
  
      my $retval = _get_ref();
  
      return
         SCALARREF { croak 'Type mismatch' if ref($retval) ne 'SCALAR';
                     next handler;
                   }
          ARRAYREF { croak 'Type mismatch' if ref($retval) ne 'ARRAY';
                     next handler;
                   }
           HASHREF { croak 'Type mismatch' if ref($retval) ne 'HASH';
                     next handler;
                   }
               REF { $retval }
  
  If, at a later time, the process of returning a reference became more complex,
  only the C<REF> handler would have to be updated.
  
  
  =head2 Nested handlers
  
  Another way of factoring out return behaviour is to nest more specific
  handlers inside more general ones. For instance, in the final example given in
  L<"Boolean vs Pure Boolean contexts">:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  you could factor out the repeated calls to C<_go_and_get_data()> like so:
  
      sub get_data {
          return
              PUREBOOL { _check_for_but_dont_get_data(); }
               DEFAULT {
                  my $data = _go_and_get_data();
  
                  BOOL { defined $data; }
                   REF {         $data; }
               }
      }
  
  Here, the C<DEFAULT> handler deals with every return context except pure
  boolean. Within that C<DEFAULT> handler, the data is first retrieved,
  and then two "sub-handlers" deal with the ordinary boolean and
  referential contexts.
  
  Typically nested handlers are used in precisely this way: to optimize
  for inexpensive special cases (such as pure boolean or integer or void
  return contexts) and only do extra work for those other cases that
  require it.
  
  
  =head2 Failure contexts
  
  Two of the most common ways to specify that a subroutine has failed
  are to return a false value, or to throw an exception. The
  Contextual::Return module provides a mechanism that allows the
  subroutine writer to support I<both> of these mechanisms at the
  same time, by using the C<FAIL> specifier.
  
  A return statement of the form:
  
      return FAIL;
  
  causes the surrounding subroutine to return C<undef> (i.e. false) in
  boolean contexts, and to throw an exception in any other context. For example:
  
      use Contextual::Return;
  
      sub get_next_val {
          my $next_val = <>;
          return FAIL if !defined $next_val;
          chomp $next_val;
          return $next_val;
      }
  
  If the C<return FAIL> statement is executed, it will either return false in a
  boolean context:
  
      if (my $val = get_next_val()) {      # returns undef if no next val
          print "[$val]\n";
      }
  
  or else throw an exception if the return value is used in any
  other context:
  
      print get_next_val();       # throws exception if no next val
  
      my $next_val = get_next_val();
      print "[$next_val]\n";      # throws exception if no next val
  
  
  The exception that is thrown is of the form:
  
      Call to main::get_next_val() failed at demo.pl line 42
  
  but you can change that message by providing a block to the C<FAIL>, like so:
  
      return FAIL { "No more data" } if !defined $next_val;
  
  in which case, the final value of the block becomes the exception message:
  
      No more data at demo.pl line 42
  
  A failure value can be interrogated for its error message, by calling its
  C<error()> method, like so:
  
      my $val = get_next_val();
      if ($val) {
          print "[$val]\n";
      }
      else {
          print $val->error, "\n";
      }
  
  
  =head2 Configurable failure contexts
  
  The default C<FAIL> behaviour--false in boolean context, fatal in all
  others--works well in most situations, but violates the Platinum Rule ("Do
  unto others as I<they> would have done unto them").
  
  So it may be user-friendlier if the user of a module is allowed decide how
  the module's subroutines should behave on failure. For example, one user
  might prefer that failing subs always return undef; another might prefer
  that they always throw an exception; a third might prefer that they
  always log the problem and return a special Failure object; whilst a
  fourth user might want to get back C<0> in scalar contexts, an empty list
  in list contexts, and an exception everywhere else.
  
  You could create a module that allows the user to specify all these
  alternatives, like so:
  
      package MyModule;
      use Contextual::Return;
      use Log::StdLog;
  
      sub import {
          my ($package, @args) = @_;
  
          Contextual::Return::FAIL_WITH {
              ':false' => sub { return undef },
              ':fatal' => sub { croak @_       },
              ':filed' => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              ':fussy' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @args;
      }
  
  This configures Contextual::Return so that, instead of the usual
  false-or-fatal semantics, every C<return FAIL> within MyModule's namespace is
  implemented by one of the four subroutines specified in the hash that was
  passed to C<FAIL_WITH>.
  
  Which of those four subs implements the C<FAIL> is determined by the
  arguments passed after the hash (i.e. by the contents of C<@args>).
  C<FAIL_WITH> walks through that list of arguments and compares
  them against the keys of the hash. If a key matches an argument, the
  corresponding value is used as the implementation of C<FAIL>. Note that,
  if subsequent arguments also match a key, their subroutine overrides the
  previously installed implementation, so only the final override has any
  effect. Contextual::Return generates warnings when multiple overrides are
  specified.
  
  All of which mean that, if a user loaded the MyModule module like this:
  
      use MyModule qw( :fatal other args here );
  
  then every C<FAIL> within MyModule would be reconfigured to throw an exception
  in all circumstances, since the presence of the C<':fatal'> in the argument
  list will cause C<FAIL_WITH> to select the hash entry whose key is C<':fatal'>.
  
  On the other hand, if they loaded the module:
  
      use MyModule qw( :fussy other args here );
  
  then each C<FAIL> within MyModule would return undef or empty list or throw an
  exception, depending on context, since that's what the subroutine whose key is
  C<':fussy'> does.
  
  Many people prefer module interfaces with a C<< I<flag> => I<value> >>
  format, and C<FAIL_WITH> supports this too. For example, if you
  wanted your module to take a C<-fail> flag, whose associated value could
  be any of C<"undefined">, C<"exception">, C<"logged">, or C<"context">,
  then you could implement that simply by specifying the flag as the first
  argument (i.e. I<before> the hash) like so:
  
      sub import {
          my $package = shift;
  
          Contextual::Return::FAIL_WITH -fail => {
              'undefined' => sub { return undef },
              'exception' => sub { croak @_ },
              'logged'    => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              'context' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @_;
  
  and then load the module:
  
      use MyModule qw( other args here ), -fail=>'undefined';
  
  or:
  
      use MyModule qw( other args here ), -fail=>'exception';
  
  In this case, C<FAIL_WITH> scans the argument list for a pair of values: its
  flag string, followed by some other selector value. Then it looks up the
  selector value in the hash, and installs the corresponding subroutine as its
  local C<FAIL> handler.
  
  If this "flagged" interface is used, the user of the module can also
  specify their own handler directly, by passing a subroutine reference as
  the selector value instead of a string:
  
      use MyModule qw( other args here ), -fail=>sub{ die 'horribly'};
  
  If this last example were used, any call to C<FAIL> within MyModule
  would invoke the specified anonymous subroutine (and hence throw a
  'horribly' exception).
  
  Note that, any overriding of a C<FAIL> handler is specific to the
  namespace and file from which the subroutine that calls C<FAIL_WITH> is
  itself called. Since C<FAIL_WITH> is designed to be called from within a
  module's C<import()> subroutine, that generally means that the C<FAIL>s
  within a given module X are only overridden for the current namespace
  within the particular file from module X is loaded. This means that two
  separate pieces of code (in separate files or separate namespaces) can
  each independently override a module's C<FAIL> behaviour, without
  interfering with each other.
  
  =head2 Lvalue contexts
  
  Recent versions of Perl offer (limited) support for lvalue subroutines:
  subroutines that return a modifiable variable, rather than a simple constant
  value.
  
  Contextual::Return can make it easier to create such subroutines, within the
  limitations imposed by Perl itself. The limitations that Perl places on lvalue
  subs are:
  
  =over
  
  =item 1.
  
  The subroutine must be declared with an C<:lvalue> attribute:
  
      sub foo :lvalue {...}
  
  =item 2.
  
  The subroutine must not return via an explicit C<return>. Instead, the
  last statement must evaluate to a variable, or must be a call to another
  lvalue subroutine call.
  
      my ($foo, $baz);
  
      sub foo :lvalue {
          $foo;               # last statement evals to a var
      }
  
      sub bar :lvalue {
          foo();              # last statement is lvalue sub call
      }
  
      sub baz :lvalue {
          my ($arg) = @_;
  
          $arg > 0            # last statement evals...
              ? $baz          # ...to a var
              : bar();        # ...or to an lvalue sub call
      }
  
  =back
  
  Thereafter, any call to the lvalue subroutine produces a result that can be
  assigned to:
  
      baz(0) = 42;            # same as: $baz = 42
  
      baz(1) = 84;            # same as:                  bar() = 84
                              #  which is the same as:    foo() = 84
                              #   which is the same as:   $foo  = 84
  
  Ultimately, every lvalue subroutine must return a scalar variable, which
  is then used as the lvalue of the assignment (or whatever other lvalue
  operation is applied to the subroutine call). Unfortunately, because the
  subroutine has to return this variable I<before> the assignment
  can take place, there is no way that a normal lvalue subroutine can
  get access to the value that will eventually be assigned to its
  return value.
  
  This is occasionally annoying, so the Contextual::Return module offers
  a solution: in addition to all the context blocks described above, it
  provides three special contextual return blocks specifically for use in
  lvalue subroutines: C<LVALUE>, C<RVALUE>, and C<NVALUE>.
  
  Using these blocks you can specify what happens when an lvalue
  subroutine is used in lvalue and non-lvalue (rvalue) context. For
  example:
  
      my $verbosity_level = 1;
  
      # Verbosity values must be between 0 and 5...
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = max(0, min($_, 5)) }
          RVALUE { $verbosity_level                      }
      }
  
  The C<LVALUE> block is executed whenever C<verbosity> is called as an lvalue:
  
      verbosity() = 7;
  
  The block has access to the value being assigned, which is passed to it
  as C<$_>. So, in the above example, the assigned value of 7 would be
  aliased to C<$_> within the C<LVALUE> block, would be reduced to 5 by the
  "min-of-max" expression, and then assigned to C<$verbosity_level>.
  
  (If you need to access the caller's C<$_>, it's also still available:
  as C<$CALLER::_>.)
  
  When the subroutine isn't used as an lvalue:
  
      print verbosity();
  
  the C<RVALUE> block is executed instead and its final value returned.
  Within an C<RVALUE> block you can use any of the other features of
  Contextual::Return. For example:
  
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  but the context sequence must be nested inside an C<RVALUE> block.
  
  You can also specify what an lvalue subroutine should do when it is used
  neither as an lvalue nor as an rvalue (i.e. in void context), by using an
  C<NVALUE> block:
  
      sub verbosity :lvalue {
          my ($level) = @_;
  
          NVALUE { $verbosity_level = int max(0, min($level, 5)) }
          LVALUE { $verbosity_level = int max(0, min($_,     5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  In this example, a call to C<verbosity()> in void context sets the verbosity
  level to whatever argument is passed to the subroutine:
  
      verbosity(1);
  
  Note that you I<cannot> get the same effect by nesting a C<VOID> block
  within an C<RVALUE> block:
  
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
              VOID { $verbosity_level = $level      }  # Wrong!
          }
  
  That's because, in a void context the return value is never evaluated,
  so it is never treated as an rvalue, which means the C<RVALUE> block
  never executes.
  
  
  =head2 Result blocks
  
  Occasionally, it's convenient to calculate a return value I<before> the
  end of a contextual return block. For example, you may need to clean up
  external resources involved in the calculation after it's complete.
  Typically, this requirement produces a slightly awkward code sequence
  like this:
  
      return
          VALUE {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  Such code sequences become considerably more awkward when you want
  the return value to be context sensitive, in which case you have to
  write either:
  
      return
          LIST {
              $db->start_work();
              my @result = $db->retrieve_query($query);
              $db->commit();
              @result;
          }
          SCALAR {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  or, worse:
  
      return
          VALUE {
              $db->start_work();
              my $result = LIST ? [$db->retrieve_query($query)]
                                :  $db->retrieve_query($query);
              $db->commit();
              LIST ? @{$result} : $result;
          }
  
  To avoid these infelicities, Contextual::Return provides a second way of
  setting the result of a context block; a way that doesn't require that the
  result be the last statement in the block:
  
      return
          LIST {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
          SCALAR {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  The presence of a C<RESULT> block inside a contextual return block causes
  that block to return the value of the final statement of the C<RESULT>
  block as the handler's return value, rather than returning the value of
  the handler's own final statement. In other words, the presence of a C<RESULT>
  block overrides the normal return value of a context handler.
  
  Better still, the C<RESULT> block always evaluates its final statement
  in the same context as the surrounding C<return>, so you can just write:
  
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  and the C<retrieve_query()> method will be called in the appropriate context
  in all cases.
  
  A C<RESULT> block can appear anywhere inside any contextual return
  block, but may not be used outside a context block. That is, this
  is an error:
  
      if ($db->closed) {
          RESULT { undef }; # Error: not in a context block
      }
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  
  =head2 Post-handler clean-up
  
  If a subroutine uses an external resource, it's often necessary to close
  or clean-up that resource after the subroutine ends...regardless of
  whether the subroutine exits normally or via an exception.
  
  Typically, this is done by encapsulating the resource in a lexically
  scoped object whose destructor does the clean-up. However, if the clean-up
  doesn't involve deallocation of an object (as in the C<< $db->commit() >>
  example in the previous section), it can be annoying to have to create a
  class and allocate a container object, merely to mediate the clean-up.
  
  To make it easier to manage such resources, Contextual::Return supplies
  a special labelled block: the C<RECOVER> block. If a C<RECOVER> block is
  specified as part of a contextual return sequence, that block is
  executed after any context handler, even if the context handler exits
  via an exception.
  
  So, for example, you could implement a simple commit-or-revert
  policy like so:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          RECOVER {
              if ($@) {
                  $db->revert();
              }
              else {
                  $db->commit();
              }
          }
  
  The presence of a C<RECOVER> block also intercepts all exceptions thrown
  in any other context block in the same contextual return sequence. Any
  such exception is passed into the C<RECOVER> block in the usual manner:
  via the C<$@> variable. The exception may be rethrown out of the
  C<RECOVER> block by calling C<die>:
  
      return
          LIST    { $db->retrieve_all($query) }
          DEFAULT { croak "Invalid call (not in list context)" }
          RECOVER {
              die $@ if $@;    # Propagate any exception
              $db->commit();   # Otherwise commit the changes
          }
  
  A C<RECOVER> block can also access or replace the returned value, by
  invoking a C<RESULT> block. For example:
  
      return
          LIST    { attempt_to_generate_list_for(@_)  }
          SCALAR  { attempt_to_generate_count_for(@_) }
          RECOVER {
              if ($@) {                # On any exception...
                  warn "Replacing return value. Previously: ", RESULT;
                  RESULT { undef }     # ...return undef
              }
          }
  
  
  =head2 Post-return clean-up
  
  Occasionally it's necessary to defer the clean-up of resources until
  after the return value has been used. Once again, this is usually
  done by returning an object with a suitable destructor.
  
  Using Contextual::Return you can get the same effect, by providing a
  C<CLEANUP> block in the contextual return sequence:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          CLEANUP { $db->commit()              }
  
  In this example, the C<commit> method call is only performed after the
  return value has been used by the caller. Note that this is quite
  different from using a C<RECOVER> block, which is called as the
  subroutine returns its value; a C<CLEANUP> is called when the returned
  value is garbage collected.
  
  A C<CLEANUP> block is useful for controlling resources allocated to support an
  C<ACTIVE> return value. For example:
  
      my %file;
  
      # Return an active value that is always the next line from a file...
      sub readline_from {
          my ($file_name) = @_;
  
          # Open the file, if not already open...
          if (!$file{$file_name}) {
              open $file{$file_name}{handle}, '<', $file_name;
          }
  
          # Track how many active return values are using this file...
          $file{$file_name}{count}++;
  
          return ACTIVE
              # Evaluating the return value returns the next line...
              VALUE   { readline $file{$file_name}{handle} }
  
              # Once the active value is finished with, clean up the filehandle...
              CLEANUP {
                  delete $file{$file_name}
                      if --$file{$file_name}{count} == 0;
              }
      }
  
  
  =head2 Debugging contextual return values
  
  Contextual return values are implemented as opaque objects (using the
  "inside-out" technique). This means that passing such values to
  Data::Dumper produces an uninformative output like:
  
      $VAR1 = bless( do{\(my $o = undef)}, 'Contextual::Return::Value' );
  
  So the module provides two methods that allow contextual return values
  to be correctly reported: either directly, or when dumped by
  Data::Dumper.
  
  To dump a contextual return value directly, call the module's C<DUMP()>
  method explicitly and print the result:
  
      print $crv->Contextual::Return::DUMP();
  
  This produces an output something like:
  
      [
       { FROM       => 'main::foo'                                       },
       { NO_HANDLER => [ 'VOID', 'CODEREF', 'HASHREF', 'GLOBREF' ]       },
       { FALLBACKS  => [ 'VALUE' ]                                       },
       { LIST       => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
       { STR        => '<<<Throws exception: Died at demo.pl line 7.>>>' },
       { NUM        => 42                                                },
       { BOOL       => -1                                                },
       { SCALARREF  => '<<<self-reference>>>'                            },
       { ARRAYREF   => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
      ];
  
  The C<FROM> hash entry names the subroutine that produced the return
  value. The C<NO_HANDLER> hash entry lists those contexts for which no
  handler was defined (and which would therefore normally produce "can't
  call" exceptions such as: C<"Can't call main::foo in VOID context">).
  The C<FALLBACKS> hash entry lists any "generic" contexts such as
  C<VALUE>, C<NONVOID>, C<REF>, C<DEFAULT>, etc. that the contextual
  return value can also handle. After these, all the remaining hash
  entries are actual contexts in which the return value could successfully
  be evaluated, and the value it would produce in each of those contexts.
  
  The Data::Dumper module also has a mechanism by which you can tell it
  how to produce a similar listing automatically whenever a contextual
  return value is passed to its C<Dumper> method. Data::Dumper allows you
  to register a "freezer" method, that is called prior to dumping, and
  which can be used to adapt an opaque object to make it dumpable.
  Contextual::Return provides just such a method
  (C<Contextual::Return::FREEZE()>) for you to register, like so:
  
      use Data::Dumper 'Dumper';
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
      print Dumper $foo;
  
  The output is then precisely the same as C<Contextual::Return::DUMP()>
  would produce.
  
  Note that, with both of the above dumping mechanisms, it is essential to use
  the full name of the method. That is:
  
      print $crv->Contextual::Return::DUMP();
  
  rather than:
  
      print $crv->DUMP();
  
  This is because the shorter version is interpreted as calling the
  C<DUMP()> method on the object returned by the return value's C<OBJREF>
  context block (see L<"Scalar reference contexts">)
  
  For the same reason, you must write:
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
  not:
  
      local $Data::Dumper::Freezer = 'FREEZE';
  
  
  =head2 Namespace controls
  
  By default the module exports a large number of return context markers:
  
      DEFAULT    REF          LAZY
      VOID       SCALARREF    FIXED
      NONVOID    ARRAYREF     ACTIVE
      LIST       CODEREF      RESULT
      SCALAR     HASHREF      RECOVER
      VALUE      GLOBREF      CLEANUP
      STR        OBJREF       RVALUE
      NUM        METHOD       LVALUE
      BOOL                    NVALUE
      PUREBOOL
  
  These are exported as subroutines, and so can conflict with existing
  subroutines in your namespace, or with subroutines imported from other
  modules.
  
  Contextual::Return allows you to control which contextual return blocks are
  exported into any namespace that uses the module. It also allows you to rename
  blocks to avoid namespace conflicts with existing subroutines.
  
  Both these features are controlled by passing arguments to the C<use>
  statement that loads the module as follows:
  
  =over
  
  =item *
  
  Any string passed as an argument to C<use Contextual::Return>,
  exports only the block name it specifies;
  
  =item *
  
  Any regex passed as an argument to C<use Contextual::Return>
  exports every block name it matches;
  
  =item *
  
  Any array ref (recursively) exports each of its elements
  
  =item *
  
  Any string that appears immediately after one of the above three specifiers,
  and which is not itself a block name, renames the handlers exported by that
  preceding specifier by filtering each handler name through C<sprintf()>
  
  =back
  
  That is, you can specify handlers to be exported by exact name (as a string),
  by general pattern (as a regex), or collectively (in an array). And after any
  of these export specifications, you can append a template in which any C<'%s'>
  will be replaced by the original name of the handler. For example:
  
      # Selectively export specific sets of handlers...
      use Contextual::Return  qr/[NLR]VALUE/;
      use Contextual::Return  qr/.*REF/;
  
      # Selective export specific sets and add a suffix to each...
      use Contextual::Return  qr/[NLR]VALUE/ => '%s_CONTEXT';
  
      # Selective export specific sets and add a prefix to each...
      use Contextual::Return  qr/.*REF/ => 'CR_%s';
  
      # Export a list of handlers...
      use Contextual::Return    'NUM', 'STR', 'BOOL' ;
      use Contextual::Return qw< NUM    STR    BOOL >;
      use Contextual::Return   ['NUM', 'STR', 'BOOL'];
  
      # Export a list of handlers, renaming them individually...
      use Contextual::Return  NUM => 'NUMERIC', STR => 'TEXT', BOOL => 'CR_%s';
  
      # Export a list of handlers, renaming them collectively...
      use Contextual::Return  ['NUM', 'STR', 'BOOL'] => '%s_CONTEXT';
  
      # Mixed exports and renames...
      use Contextual::Return (
          STR => 'TEXT',
          ['NUM', 'BOOL'] => 'CR_%s',
          ['LIST', 'SCALAR', 'VOID', qr/^[NLR]VALUE/] => '%s_CONTEXT',
      );
  
  
  
  =head1 INTERFACE
  
  =head2 Context tests
  
  =over
  
  =item C<< LIST() >>
  
  Returns true if the current subroutine was called in list context.
  A cleaner way of writing: C<< wantarray() >>
  
  =item C<< SCALAR() >>
  
  Returns true if the current subroutine was called in scalar context.
  A cleaner way of writing: C<< defined wantarray() && ! wantarray() >>
  
  
  =item C<< VOID() >>
  
  Returns true if the current subroutine was called in void context.
  A cleaner way of writing: C<< !defined wantarray() >>
  
  =item C<< NONVOID() >>
  
  Returns true if the current subroutine was called in list or scalar context.
  A cleaner way of writing: C<< defined wantarray() >>
  
  =back
  
  =head2 Standard contexts
  
  =over
  
  =item C<< LIST {...} >>
  
  The block specifies what the context sequence should evaluate to when
  called in list context.
  
  =item C<< SCALAR {...} >>
  
  The block specifies what the context sequence should evaluate to in
  scalar contexts, unless some more-specific specifier scalar context specifier
  (see below) also occurs in the same context sequence.
  
  =item C<< VOID {...} >>
  
  The block specifies what the context sequence should do when
  called in void context.
  
  =back
  
  =head2 Scalar value contexts
  
  =over
  
  =item C<< BOOL {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a boolean value.
  
  =item C<< NUM {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a numeric value.
  
  =item C<< STR {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a string value.
  
  =item C<< LAZY {...} >>
  
  Another name for C<SCALAR {...}>. Usefully self-documenting when the primary
  purpose of the contextual return is to defer evaluation of the return value
  until it's actually required.
  
  =back
  
  =head2 Scalar reference contexts
  
  =over
  
  =item C<< SCALARREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a scalar.
  
  =item C<< ARRAYREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an array.
  
  =item C<< HASHREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a hash.
  
  Note that a common error here is to write:
  
  HASHREF { a=>1, b=>2, c=>3 }
  
  The curly braces there are a block, not a hash constructor, so the block
  doesn't return a hash reference and the interpreter throws an exception.
  What's needed is:
  
  HASHREF { {a=>1, b=>2, c=>3} }
  
  in which the inner braces I<are> a hash constructor.
  
  =item C<< CODEREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a subroutine.
  
  =item C<< GLOBREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a typeglob.
  
  =item C<< OBJREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an object.
  
  =item C<< METHOD {...} >>
  
  The block can be used to specify particular handlers for specific method calls
  when the return value is treated as an object reference.
  It should return a list of methodname/methodbody pairs. Each method name can
  be specified as a string, a regex, or an array of strings or regexes. The
  method bodies must be specified as subroutine references (usually anonymous
  subs). The first method name that matches the actual method call selects the
  corresponding handler, which is then called.
  
  =back
  
  =head2 Generic contexts
  
  =over
  
  =item C<< VALUE {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a non-referential value (as a boolean, numeric, string,
  scalar, or list). Only used if there is no more-specific value context
  specifier in the context sequence.
  
  =item C<< REF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference of any kind. Only used if there is no
  more-specific referential context specifier in the context sequence.
  
  =item C<< NONVOID {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =item C<< DEFAULT {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a void or non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =back
  
  =head2 Failure context
  
  =over
  
  =item C<< FAIL >>
  
  This block is executed unconditionally and is used to indicate failure. In a
  Boolean context it return false. In all other contexts it throws an exception
  consisting of the final evaluated value of the block.
  
  That is, using C<FAIL>:
  
  return
  FAIL { "Could not defenestrate the widget" }
  
  is exactly equivalent to writing:
  
  return
  BOOL { 0 }
  DEFAULT { croak "Could not defenestrate the widget" }
  
  except that the reporting of errors is a little smarter under C<FAIL>.
  
  If C<FAIL> is called without specifying a block:
  
  return FAIL;
  
  it is equivalent to:
  
  return FAIL { croak "Call to <subname> failed" }
  
  (where C<< <subname> >> is replaced with the name of the surrounding
  subroutine).
  
  Note that, because C<FAIL> implicitly covers every possible return
  context, it cannot be chained with other context specifiers.
  
  =item C<< Contextual::Return::FAIL_WITH >>
  
  This subroutine is not exported, but may be called directly to reconfigure
  C<FAIL> behaviour in the caller's namespace.
  
  The subroutine is called with an optional string (the I<flag>), followed
  by a mandatory hash reference (the I<configurations hash>), followed by a
  list of zero-or-more strings (the I<selector list>). The values of the
  configurations hash must all be subroutine references.
  
  If the optional flag is specified, C<FAIL_WITH> searches the selector
  list looking for that string, then uses the I<following> item in the
  selector list as its I<selector value>. If that selector value is a
  string, C<FAIL_WITH> looks up that key in the hash, and installs the
  corresponding subroutine as the namespace's C<FAIL> handler (an
  exception is thrown if the selector string is not a valid key of the
  configurations hash). If the selector value is a subroutine reference,
  C<FAIL_WITH> installs that subroutine as the C<FAIL> handler.
  
  If the optional flag is I<not> specified, C<FAIL_WITH> searches the
  entire selector list looking for the last element that matches any
  key in the configurations hash. It then looks up that key in the
  hash, and installs the corresponding subroutine as the namespace's
  C<FAIL> handler.
  
  See L<Configurable failure contexts> for examples of using this feature.
  
  =back
  
  =head2 Lvalue contexts
  
  =over
  
  =item C<< LVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is assigned
  to. The assigned value is passed to the block as C<$_>. To access the caller's
  C<$_> value, use C<$CALLER::_>.
  
  =item C<< RVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is used
  as an rvalue. The final value that is evaluated in the block becomes the
  rvalue.
  
  =item C<< NVALUE >>
  
  This block is executed when an C<:lvalue> subroutine is evaluated in void
  context.
  
  =back
  
  =head2 Explicit result blocks
  
  =over
  
  =item C<< RESULT >>
  
  This block may only appear inside a context handler block. It causes the
  surrounding handler to return the final value of the C<RESULT>'s block,
  rather than the final value of the handler's own block. This override occurs
  regardless of the location to the C<RESULT> block within the handler.
  
  If called without a trailing C<{...}>, it simply returns the current result
  value in scalar contexts, or the list of result values in list context.
  
  =back
  
  =head2 Recovery blocks
  
  =over
  
  =item C<< RECOVER >>
  
  If present in a context return sequence, this block grabs control after
  any context handler returns or exits via an exception. If an exception
  was thrown it is passed to the C<RECOVER> block via the C<$@> variable.
  
  =back
  
  =head2 Clean-up blocks
  
  =over
  
  =item C<< CLEANUP >>
  
  If present in a context return sequence, this block grabs control when
  a return value is garbage collected.
  
  =back
  
  
  =head2 Modifiers
  
  =over
  
  =item C<< FIXED >>
  
  This specifies that the scalar value will only be evaluated once, the
  first time it is used, and that the value will then morph into that
  evaluated value.
  
  =item C<< ACTIVE >>
  
  This specifies that the scalar value's originating block will be re-
  evaluated every time the return value is used.
  
  =back
  
  =head2 Debugging support
  
  =over
  
  =item C<< $crv->Contextual::Return::DUMP() >>
  
  Return a dumpable representation of the return value in all viable contexts.
  
  =item C<< local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE'; >>
  
  =item C<< local $Data::Dumper::Freezer = \&Contextual::Return::FREEZE; >>
  
  Configure Data::Dumper to correctly dump a representation of the
  contextual return value.
  
  =back
  
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item C<Can't use %s as export specifier>
  
  In your C<use Contextual::Return> statement you specified something (such as a
  hash or coderef) that can't be used to select what the module exports. Make
  sure the list of selectors includes only strings, regexes, or references to
  arrays of strings or regexes.
  
  
  =item C<use Contextual::Return qr{%s} didn't export anything>
  
  In your C<use Contextual::Return> statement you specified a regex to select
  which handlers to support, but the regex didn't select any handlers. Check
  that the regex you're using actually does match at least one of the names of
  the modules many handlers.
  
  
  =item C<Can't export %s: no such handler>
  
  In your C<use Contextual::Return> statement you specified a string as the
  name of a context handler to be exported, but the module doesn't export a
  handler of that name. Check the spelling for the requested export.
  
  
  =item C<Can't call %s in a %s context>
  
  =item C<Can't use return value of %s in a %s context>
  
  The subroutine you called uses a contextual return, but doesn't specify what
  to return in the particular context in which you called it. You either need to
  change the context in which you're calling the subroutine, or else add a
  context block corresponding to the offending context (or perhaps a
  C<DEFAULT {...}> block).
  
  
  =item C<Can't call bare %s {...} in %s context>
  
  You specified a handler (such as C<VOID {...}> or C<LIST {...}>)
  outside any subroutine, and in a context that it
  can't handle. Did you mean to place the handler outside of a subroutine?
  If so, then you need to put it in a context it can actually handle.
  Otherwise, perhaps you need to replace the trailing block with parens
  (that is: C<VOID()> or C<LIST()>).
  
  
  =item C<Call to %s at %s didn't return a %s reference">
  
  You called the subroutine in a context that expected to get back a
  reference of some kind but the subroutine didn't specify the
  corresponding C<SCALARREF>, C<ARRAYREF>, C<HASHREF>, C<CODEREF>,
  C<GLOBREF>, or generic C<REF>, C<NONVOID>, or C<DEFAULT> handlers.
  You need to specify the appropriate one of these handlers in the subroutine.
  
  
  =item C<Can't call method '%s' on %s value returned by %s">
  
  You called the subroutine and then tried to call a method on the return
  value, but the subroutine returned a classname or object that doesn't
  have that method. This probably means that the subroutine didn't return
  the classname or object you expected. Or perhaps you need to specify
  an C<OBJREF {...}> context block.
  
  
  =item C<Can't install two %s handlers>
  
  You attempted to specify two context blocks of the same name in the same
  return context, which is ambiguous. For example:
  
      sub foo: lvalue {
          LVALUE { $foo = $_ }
          RVALUE { $foo }
          LVALUE { $foo = substr($_,1,10) }
      }
  
  or:
  
      sub bar {
          return
              BOOL { 0 }
              NUM  { 1 }
              STR  { "two" }
              BOOL { 1 };
      }
  
  Did you cut-and-paste wrongly, or mislabel one of the blocks?
  
  
  =item C<Expected a %s block after the %s block but found instead: %s>
  
  If you specify any of C<LVALUE>, C<RVALUE>, or C<NVALUE>, then you can only
  specify C<LVALUE>, C<RVALUE>, or C<NVALUE> blocks in the same return context.
  If you need to specify other contexts (like C<BOOL>, or C<STR>, or C<REF>,
  etc.), put them inside an C<RVALUE> block. See L<Lvalue contexts> for an
  example.
  
  
  =item C<Call to %s failed at %s>
  
  This is the default exception that a C<FAIL> throws in a non-scalar
  context. Which means that the subroutine you called has signalled
  failure by throwing an exception, and you didn't catch that exception.
  You should either put the call in an C<eval {...}> block or else call the
  subroutine in boolean context instead.
  
  
  =item C<Call to %s failed at %s. Attempted to use failure value at %s>
  
  This is the default exception that a C<FAIL> throws when a failure value
  is captured in a scalar variable and later used in a non-boolean
  context. That means that the subroutine you called must have failed, and
  you didn't check the return value for that failure, so when you tried to
  use that invalid value it killed your program. You should either put the
  original call in an C<eval {...}> or else test the return value in a
  boolean context and avoid using it if it's false.
  
  
  =item C<Usage: FAIL_WITH $flag_opt, \%selector, @args>
  
  The C<FAIL_WITH> subroutine expects an optional flag, followed by a reference
  to a configuration hash, followed by a list or selector arguments. You gave it
  something else. See L<Configurable Failure Contexts>.
  
  
  =item C<Selector values must be sub refs>
  
  You passed a configuration hash to C<FAIL_WITH> that specified non-
  subroutines as possible C<FAIL> handlers. Since non-subroutines can't
  possibly be handlers, maybe you forgot the C<sub> keyword somewhere?
  
  
  =item C<Invalid option: %s => %s>
  
  The C<FAIL_WITH> subroutine was passed a flag/selector pair, but the selector
  was not one of those allowed by the configuration hash.
  
  
  =item C<FAIL handler for package %s redefined>
  
  A warning that the C<FAIL> handler for a particular package was
  reconfigured more than once. Typically that's because the module was
  loaded in two places with difference configurations specified. You can't
  reasonably expect two different sets of behaviours from the one module within
  the one namespace.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Contextual::Return requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  Requires version.pm and Want.pm.
  
  
  =head1 INCOMPATIBILITIES
  
  C<LVALUE>, C<RVALUE>, and C<NVALUE> do not work correctly under the Perl
  debugger. This seems to be because the debugger injects code to capture
  the return values from subroutines, which interferes destructively with
  the optional final arguments that allow C<LVALUE>, C<RVALUE>, and C<NVALUE>
  to cascade within a single return.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005-2011, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
CONTEXTUAL_RETURN

$fatpacked{"Contextual/Return/Failure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN_FAILURE';
  package Contextual::Return::Failure;
  our $VERSION = 0.000_003;
  
  use Contextual::Return;
  BEGIN { *_in_context = *Contextual::Return::_in_context }
  
  use warnings;
  use strict;
  
  my %handler_for;
  
  sub _FAIL_WITH {
      # Unpack and vet args...
      my $flag = shift;
      my $selector_ref;
      if (ref $flag eq 'HASH') {
          $selector_ref = $flag;
          $flag = undef;
      }
      else {
          $selector_ref = shift;
          die _in_context 'Usage: FAIL_WITH $flag_opt, \%selector, @args'
              if ref $selector_ref ne 'HASH';
      }
      die _in_context "Selector values must be sub refs"
          if grep {ref ne 'CODE'} values %{$selector_ref};
  
      # Search for handler sub;
      my $handler;
      if (defined $flag) {
          ARG:
          while (@_) {
              last ARG if shift(@_) eq $flag;
          }
          my $selector = shift @_;
          if (ref $selector eq 'CODE') {
              $handler = $selector;
              @_ = ();
          }
          else {
              @_ = $selector;
          }
      }
  
      SELECTION:
      for my $selection (reverse @_) {
          if (exists $selector_ref->{$selection}) {
              $handler = $selector_ref->{$selection};
              last SELECTION;
          }
          elsif ($flag) {
              die _in_context "Invalid option: $flag => $selection";
          }
      }
  
      # (Re)set handler...
      if ($handler) {
          my $caller_loc = join '|', (CORE::caller 1)[0,1];
          if (exists $handler_for{$caller_loc}) {
              warn _in_context "FAIL handler for package ", scalar CORE::caller, " redefined";
          }
          $handler_for{$caller_loc} = $handler;
      }
  };
  
  sub _FAIL (;&) {
      # Generate args...
      my $arg_generator_ref = shift;
      my @args;
      if ($arg_generator_ref) {
          package DB;
          ()=CORE::caller(1);
          @args = $arg_generator_ref->(@DB::args);
      }
  
      # Handle user-defined failure semantics...
      my $caller_loc = join '|', (CORE::caller 1)[0,1];
      if (exists $handler_for{$caller_loc} ) {
          # Fake out caller() and Carp...
          local $Contextual::Return::uplevel = 1;
  
          return $handler_for{$caller_loc}->(@args);
      }
  
      my $exception = @args == 1 ? $args[0]
                    : @args > 0  ? join(q{}, @args)
                    :              "Call to " . (CORE::caller 1)[3] . "() failed"
                    ;
  
      # Join message with croak() semantics, if string...
      if (!ref $exception) {
          $exception .= _in_context @_;
      }
  
  #    # Check for immediate failure...
  #    use Want qw( want );
  #    return 0 if want 'BOOL';
  #    die $exception if !want 'SCALAR';
  
      # Return a delayed failure object...
      return
          BOOL    { 0 }
          DEFAULT {
              if (ref $exception) {
                  my $message = "$exception";
                  $message =~ s/$/\n/;
                  die _in_context $message, "Attempted to use failure value";
              }
              else {
                  die _in_context $exception, "Attempted to use failure value";
              }
          }
          METHOD {
              error => sub { _in_context $exception }
          }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Contextual::Return::Failure - Utility module for Contextual::Return
  
  =head1 NOTE
  
  Contains no user serviceable parts. See L<Contextual::Return> instead.
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2006, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
CONTEXTUAL_RETURN_FAILURE

$fatpacked{"Gradescope/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_COLOR';
  package Gradescope::Color v2023.02.14 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use IPC::Cmd qw(can_run);
      use IPC::Run qw(run);
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          color_print
      );
  
      our $has_colorizer = defined(can_run('batcat')) || defined(can_run('bat'));
      carp '[suggestion] get `bat` for colorized output' if !$has_colorizer;
  
      sub color_print {
          my ($str, $language) = @_;
          if($has_colorizer && !defined($ENV{GU_NO_PAGER})){
              my $bat = 'bat';
              if(can_run('batcat')){ # bat is sometimes named batcat
                  $bat = 'batcat';
              }
              run [$bat, '-l', $language], '<', \$str;
          }
          else{
              print $str;
          }
      }
  
      true;
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  =cut
GRADESCOPE_COLOR

$fatpacked{"Gradescope/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_CURL';
  package Gradescope::Curl v2022.11.13 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use IO::Prompter;
      use JSON;
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          login
      );
  
      our $baseurl;
  
      sub import {
          # in the style of Getopt::Long
          # (I figured people would be familiar w/ this import style since
          # Getopt::Long well known)
          shift; # package
          my @syms;
          my @config;
          my $dest = \@syms;
          for (@_){
              if($_ eq ':config'){
                  $dest = \@config;
              } else{
                  @$dest = (@$dest, $_);
              }
          }
          Gradescope::Curl->export_to_level(1, @syms);
          my %config = @config;
          assert(!defined($baseurl));
          $baseurl = $config{baseurl};
          assert(defined($baseurl));
      }
  
      sub login {
          # hacked together from the python script and a lot of netcat (thanks 489)
          # aka the curl snippets took a lot of trial and error
          open my $tty, '<', '/dev/tty' or confess 'This needs to be run in an interactive shell!';
          my $email = IO::Prompter::prompt('Enter your email: ', -in => $tty);
          my $password = IO::Prompter::prompt('Enter your password: ', -in => $tty, -echo => '');
          my %response = %{JSON::from_json(`curl -s --data 'email=$email&password=$password' $baseurl/api/v1/user_session`)};
          carp '[warning] curl returned error code on gradescope auth' if $? >> 8;
          $response{token} // confess "[error] Your gradescope login credentials are probably wrong";
          carp "[debug] token_expiration_time: $response{token_expiration_time}";
          return $response{token};
      }
  
      true;
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  =cut
GRADESCOPE_CURL

$fatpacked{"Gradescope/Translate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_TRANSLATE';
  package Gradescope::Translate v2022.12.30 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use Text::CSV;
      use JSON;
      use File::Slurp;
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          print_csv
          read_csv
      );
  
      sub print_csv {
          my ($in, $out) = @_;
          Text::CSV::csv({
              # attributes (OO interface)
              binary => 0,
              decode_utf8 => 0,
              strict => 1,
              # `csv` arguments
              in => $in,
              out => $out,
              encoding => ':utf8',
          }) or confess Text::CSV->error_diag;
      }
  
      sub read_csv {
          my ($csv_path, $key_header, $value_header, $filter) = @_;
          $filter //= sub {true};
          my %kv = %{Text::CSV::csv ({
              # attributes (OO interface)
              binary => 0,
              decode_utf8 => 0,
              strict => 1,
              # `csv` arguments
              in => $csv_path,
              filter => $filter,
              encoding => 'UTF-8',
              key => $key_header,
              value => $value_header,
          }) or confess Text::CSV->error_diag};
          return %kv;
      }
  
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  C<Text::CSV> wrappers
  
  =cut
GRADESCOPE_TRANSLATE

$fatpacked{"IO/Prompter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PROMPTER';
  use 5.010;
  package IO::Prompter;
  use utf8;
  
  use warnings;
  no if $] >= 5.018000, warnings => 'experimental';
  use strict;
  use Carp;
  use Contextual::Return qw< PUREBOOL BOOL SCALAR METHOD VOID LIST RETOBJ >;
  use Scalar::Util qw< openhandle looks_like_number >;
  use Symbol       qw< qualify_to_ref >;
  use match::smart qw< match >;
  
  our $VERSION = '0.005001';
  
  my $fake_input;     # Flag that we're faking input from the source
  
  my $DEFAULT_TERM_WIDTH   = 80;
  my $DEFAULT_VERBATIM_KEY = "\cV";
  
  # Completion control...
  my $COMPLETE_DISPLAY_FIELDS = 4;  #...per line
  my $COMPLETE_DISPLAY_GAP    = 3;  #...spaces
  
  my $COMPLETE_KEY  = $ENV{IO_PROMPTER_COMPLETE_KEY} // qq{\t};
  my $COMPLETE_HIST = $ENV{IO_PROMPTER_HISTORY_KEY}  // qq{\cR};
  my $COMPLETE_NEXT = qq{\cN};
  my $COMPLETE_PREV = qq{\cP};
  
  my $COMPLETE_INIT  = qr{ [\Q$COMPLETE_KEY$COMPLETE_HIST\E] }xms;
  my $COMPLETE_CYCLE = qr{ [$COMPLETE_NEXT$COMPLETE_PREV] }xms;
  
  my %COMPLETE_MODE = (
      $COMPLETE_KEY
          => [split /\s+/, $ENV{IO_PROMPTER_COMPLETE_MODES}//q{list+longest  full}],
      $COMPLETE_HIST
          => [split /\s+/, $ENV{IO_PROMPTER_HISTORY_MODES} // q{full}],
  );
  
  my $FAKE_ESC    = "\e";
  my $FAKE_INSERT = "\cF";
  my $MENU_ESC    = "\e";
  my $MENU_MK     = '__M_E_N_U__';
  
  my %EDIT = (
      BACK    => qq{\cB},
      FORWARD => qq{\cF},
      START   => qq{\cA},
      END     => qq{\cE},
  );
  my $EDIT_KEY = '['.join(q{},values %EDIT).']';
  
  # Extracting key letters...
  my $KL_EXTRACT = qr{ (?| \[  ( [[:alnum:]]++ )  \]
                         | \(  ( [[:alnum:]]++ )  \)
                         | \<  ( [[:alnum:]]++ )  \>
                         | \{  ( [[:alnum:]]++ )  \}
                       )
                     }xms;
  my $KL_DEF_EXTRACT = qr{ \[  ( [[:alnum:]]++ )  \] }xms;
  
  
  # Auxiliary prompts for -Yes => N construct...
  my @YESNO_PROMPTS = (
      q{Really?},
      q{You're quite certain?},
      q{Definitely?},
      q{You mean it?},
      q{You truly mean it?},
      q{You're sure?},
      q{Have you thought this through?},
      q{You understand the consequences?},
  );
  
  
  # Remember returned values for history completion...
  my %history_cache;
  
  # Track lexically-scoped default options and wrapper subs...
  my @lexical_options  = [];
  my @lexical_wrappers = [];
  
  # Export the prompt() sub...
  sub import {
      my (undef, $config_data, @other_args) = @_;
  
      # Handle -argv requests...
      if (defined $config_data && $config_data eq '-argv') {
          scalar prompt(-argv, @other_args);
      }
  
      # Handle lexical options...
      elsif (ref $config_data eq 'ARRAY') {
          push @lexical_options, $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
      }
  
      # Handle lexical wrappers...
      elsif (ref $config_data eq 'HASH') {
          push @lexical_options, [];
          $lexical_wrappers[ $#lexical_options ] = $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
          for my $subname (keys %{$config_data}) {
              my @args = @{$config_data->{$subname}};
              no strict 'refs';
              no warnings 'redefine';
              *{caller().'::'.$subname} = sub {
                  my $scope_number = (caller 0)[10]{'IO::Prompter::scope_number'};
                  return prompt(@{$lexical_wrappers[$scope_number]{$subname}//[]}, @_);
              };
          }
      }
  
      # Handler faked input specifications...
      elsif (defined $config_data) {
          $fake_input = $config_data;
      }
  
      no strict 'refs';
      *{caller().'::prompt'} = \&prompt;
  }
  
  # Prompt for, read, vet, and return input...
  sub prompt {
      # Reclaim full control of print statements while prompting...
      local $\ = '';
  
      # Locate any lexical default options...
      my $hints_hash = (caller 0)[10] // {};
      my $scope_num = $hints_hash->{'IO::Prompter::scope_number'} // 0;
  
      # Extract and sanitize configuration arguments...
      my $opt_ref = _decode_args(@{$lexical_options[$scope_num]}, @_);
  
      _warn( void => 'Useless use of prompt() in void context' )
          if VOID && !$opt_ref->{-void};
  
      # Set up yesno prompts if required...
      my @yesno_prompts
          = ($opt_ref->{-yesno}{count}//0) > 1 ? @YESNO_PROMPTS : ();
  
      # Work out where the prompts go, and where the input comes from...
      my $in_filehandle  = $opt_ref->{-in}  // _open_ARGV();
      my $out_filehandle = $opt_ref->{-out} // qualify_to_ref(select);
      if (!openhandle $in_filehandle) {
          open my $fh, '<', $in_filehandle
              or _opt_err('Unacceptable', '-in', 'valid filehandle or filename');
          $in_filehandle = $fh;
      }
      if (!openhandle $out_filehandle) {
          open my $fh, '>', $out_filehandle
              or _opt_err('Unacceptable', '-out', 'valid filehandle or filename');
          $out_filehandle = $fh;
      }
  
      # Track timeouts...
      my $in_pos = do { no warnings;  tell $in_filehandle } // 0;
  
      # Short-circuit if not valid handles...
      return if !openhandle($in_filehandle) || !openhandle($out_filehandle);
  
      # Work out how they're arriving and departing...
      my $outputter_ref = -t $in_filehandle && -t $out_filehandle
                              ? _std_printer_to($out_filehandle, $opt_ref)
                              : _null_printer()
                              ;
      my $inputter_ref = _generate_unbuffered_reader_from(
                              $in_filehandle, $outputter_ref, $opt_ref
                         );
  
      # Clear the screen if requested to...
      if ($opt_ref->{-wipe}) {
          $outputter_ref->(-nostyle => "\n" x 1000);
      }
  
      # Handle menu structures...
      my $input;
      eval {
          REPROMPT_YESNO:
          if ($opt_ref->{-menu}) {
              # Remember top of (possibly nested) menu...
              my @menu = ( $opt_ref->{-menu} );
              my $top_prompt = $opt_ref->{-prompt};
              $top_prompt =~ s{$MENU_MK}{$opt_ref->{-menu}{prompt}}xms;
              $menu[-1]{prompt} = $top_prompt;
  
              MENU:
              while (1) {
                  # Track the current level...
                  $opt_ref->{-menu_curr_level} = $menu[-1]{value_for};
  
                  # Show menu and retreive choice...
                  $outputter_ref->(-style => $menu[-1]{prompt});
                  my $tag = $inputter_ref->($menu[-1]{constraint});
  
                  # Handle a failure by exiting the loop...
                  last MENU if !defined $tag;
                  $tag =~ s{\A\s*(\S*).*}{$1}xms;
  
                  # Handle <ESC> by moving up menu stack...
                  if ($tag eq $MENU_ESC) {
                      $input = undef;
                      last MENU if @menu <= 1;
                      pop @menu;
                      next MENU;
                  }
  
                  # Handle defaults by selecting and ejecting...
                  if ($tag =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
                      $input = $tag;
                      last MENU;
                  }
  
                  # Otherwise, retrieve value for selected tag and exit if not a nested menu...
                  $input = $menu[-1]{value_for}{$tag};
                  last MENU if !ref $input;
  
                  # Otherwise, go down the menu one level...
                  push @menu,
                      _build_menu($input,
                                  "Select from $menu[-1]{key_for}{$tag}: ",
                                  $opt_ref->{-number} || $opt_ref->{-integer}
                      );
                  $menu[-1]{prompt} .= '> ';
              }
          }
  
          # Otherwise, simply ask and ye shall receive...
          else {
                  $outputter_ref->(-style => $opt_ref->{-prompt});
                  $input = $inputter_ref->();
          }
          1;
      }
      // do {
          # Supply the missing newline if requested...
          $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}))
              if exists $opt_ref->{-return};
  
          # Rethrow any other exception...
          my $error = $@;
          die $@ unless ref($error) eq 'IO::Prompter::Cancellation';
  
          # Return failure on cancellation...
          return if $opt_ref->{-verbatim};
          return PUREBOOL { 0 }
                     BOOL { 0 }
                   SCALAR { ${$error}  }
                   METHOD { defaulted => sub { 0 }, timedout  => sub { 0 } };
      };
  
      # Provide default value if available and necessary...
      my $defaulted = 0;
      if (defined $input && $input =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # The input line is usually chomped before being returned...
      if (defined $input && !$opt_ref->{-line}) {
          chomp $input;
      }
  
      # Check for a value indicating failure...
      if (exists $opt_ref->{-fail}   && match($input, $opt_ref->{-fail})) {
          $input = undef;
      }
  
      # Setting @ARGV is a special case; process it like a command-line...
      if ($opt_ref->{-argv}) {
          @ARGV = map { _shell_expand($_) }
                      grep {defined}
                              $input =~ m{
                                      ( '  [^'\\]* (?: \\. [^'\\]* )* ' )
                                  |   ( "  [^"\\]* (?: \\. [^"\\]* )* " )
                                  |   (?: ^ | \s)  ( [^\s"'] \S*        )
                              }gxms;
          return 1;
      }
  
      # "Those who remember history are enabled to repeat it"...
      if (defined $input and $opt_ref->{-history} ne 'NONE') {
          my $history_set = $history_cache{ $opt_ref->{-history} } //= [] ;
          @{ $history_set } = ($input, grep { $_ ne $input } @{ $history_set });
      }
  
      # If input timed out insert the default, if any...
      my $timedout = $in_pos == do{ no warnings; tell $in_filehandle } // 0;
      if ($timedout && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # A defined input is a successful input...
      my $succeeded = defined $input;
  
      # The -yesno variants also need a 'y' to be successful...
      if ($opt_ref->{-yesno}{count}) {
          $succeeded &&= $input =~ m{\A \s* y}ixms;
          if ($succeeded && $opt_ref->{-yesno}{count} > 1) {
              my $count = --$opt_ref->{-yesno}{count};
              $opt_ref->{-prompt}
                  = @yesno_prompts ? shift(@yesno_prompts) . q{ }
                  : $count > 1     ? qq{Please confirm $count more times }
                  :                   q{Please confirm one last time }
                  ;
              goto REPROMPT_YESNO;    # Gasp, yes goto is the cleanest way!
          }
      }
  
      # Verbatim return doesn't do fancy tricks...
      if ($opt_ref->{-verbatim}) {
          return $input // ();
      }
  
      # Failure in a list context returns nothing...
      return if LIST && !$succeeded;
  
      # Otherwise, be context sensitive...
      return
          PUREBOOL { $_ = RETOBJ; next handler;      }
              BOOL { $succeeded;                     }
            SCALAR { $input;                         }
            METHOD {
                      defaulted => sub { $defaulted  },
                      timedout  => sub {
                          return q{} if !$timedout;
                          return "timed out after $opt_ref->{-timeout} second"
                               . ($opt_ref->{-timeout} == 1 ? q{} : q{s});
                      },
                   };
  }
  
  
  # Simulate a command line expansion for the -argv option...
  sub _shell_expand {
      my ($text) = @_;
  
      # Single-quoted text is literal...
      if ($text =~ m{\A ' (.*) ' \z}xms) {
          return $1;
      }
  
      # Everything else has shell variables expanded...
      my $ENV_PAT = join '|', reverse sort keys %ENV;
      $text =~ s{\$ ($ENV_PAT)}{$ENV{$1}}gxms;
  
      # Double-quoted text isn't globbed...
      if ($text =~ m{\A " (.*) " \z}xms) {
          return $1;
      }
  
      # Everything else is...
      return glob($text);
  }
  
  # No completion is the default...
  my $DEFAULT_COMPLETER = sub { q{} };
  
  # Translate std constraints...
  my %STD_CONSTRAINT = (
      positive  => sub { $_ > 0      },
      negative  => sub { $_ < 0      },
      zero      => sub { $_ == 0     },
      even      => sub { $_ % 2 == 0 },
      odd       => sub { $_ % 2 != 0 },
  );
  
  # Create abbreviations...
  $STD_CONSTRAINT{pos} = $STD_CONSTRAINT{positive};
  $STD_CONSTRAINT{neg} = $STD_CONSTRAINT{negative};
  
  # Create antitheses...
  for my $constraint (keys %STD_CONSTRAINT) {
      my $implementation = $STD_CONSTRAINT{$constraint};
      $STD_CONSTRAINT{"non$constraint"}
          = sub { ! $implementation->(@_) };
  }
  
  # Special style specifications require decoding...
  
  sub _decode_echo {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no echoes...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_echostyle {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no styles...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_style {
      # No special prompt styles (yet)...
      return shift;
  }
  
  # Generate safe closure around active sub...
  sub _gen_wrapper_for {
      my ($arg) = @_;
      return ref $arg ne 'CODE'
             ? sub { $arg }
             : sub { eval { for (shift) { no warnings; return $arg->($_) // $_ } } };
  }
  
  # Create recognizer...
  my $STD_CONSTRAINT
      = '^(?:' . join('|', reverse sort keys %STD_CONSTRAINT) . ')';
  
  # Translate name constraints to implementations...
  sub _standardize_constraint {
      my ($option_type, $constraint_spec) = @_;
  
      return ("be an acceptable $option_type", $constraint_spec)
          if ref $constraint_spec;
  
      my @constraint_names = split /\s+/, $constraint_spec;
      my @constraints =
          map { $STD_CONSTRAINT{$_}
                // _opt_err('invalid',-$option_type,'"pos", "neg", "even", etc.', qq{"$_"})
              } @constraint_names;
  
      return (
          'be ' . join(' and ', @constraint_names),
          sub {
              my ($compare_val) = @_;
              for my $constraint (@constraints) {
                  return 0 if !$constraint->($compare_val);
              }
              return 1;
          }
      );
  }
  
  
  # Convert args to prompt + options hash...
  sub _decode_args {
      my %option = (
          -prompt    => undef,
          -complete  => $DEFAULT_COMPLETER,
          -must      => {},
          -history   => 'DEFAULT',
          -style     => sub{ q{} },
          -nostyle   => sub{ q{} },
          -echostyle => sub{ q{} },
          -echo      => sub { my $char = shift; $char eq "\t" ? q{ } : $char },
          -return    => sub { "\n" },
      );
  
      DECODING:
      while (defined(my $arg = shift @_)) {
          if (my $type = ref $arg) {
              _warn( reserved =>
                  'prompt(): Unexpected argument (' . lc($type) . ' ref) ignored'
              );
          }
          else {
              state $already_wiped;
              my $redo;
              # The sound of one hand clapping...
              if ($arg =~ /^-_/) {
                  $redo = 1;
              }
  
              # Non-chomping option...
              elsif ($arg =~ /^-line$/) {
                  $option{-line}++;
              }
              elsif ($arg =~ /^-l/) {
                  $option{-line}++;
                  $redo = 1;
              }
  
              # The -yesno variants...
              elsif ($arg =~ /^-YesNo$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = {
                      must => { '[YN]' => qr{\A \s* [YN] }xms },
                      count  => $count,
                  };
              }
              elsif ($arg =~ /^-YN/) {
                  $option{-yesno} = {
                      must => { '[YN]' => qr{\A \s* [YN] }xms },
                      count  => 1,
                  };
                  $redo = 2;
              }
              elsif ($arg =~ /^-yesno$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = {
                      must => { '[yn]' => qr{\A \s* [YN] }ixms },
                      count  => $count,
                  };
              }
              elsif ($arg =~ /^-yn/) {
                  $option{-yesno} = {
                      must => { '[yn]' => qr{\A \s* [YN] }ixms },
                      count  => 1,
                  };
                  $redo = 2;
              }
              elsif ($arg =~ /^-Yes$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = {
                      must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                      count  => $count,
                  };
              }
              elsif ($arg =~ /^-Y/) {
                  $option{-yesno} = {
                      must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                      count  => 1,
                  };
                  $redo = 1;
              }
              elsif ($arg =~ /^-yes$/) {
                  my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                  $option{-yesno} = { count  => $count };
              }
              elsif ($arg =~ /^-y/) {
                  $option{-yesno} = { count  => 1 };
                  $redo = 1;
              }
  
              # Load @ARGV...
              elsif ($arg =~ /^-argv$/) {
                  $option{-argv} = 1;
              }
  
              elsif ($arg =~ /^-a/) {
                  $option{-argv} = 1;
                  $redo = 1;
              }
  
              # Clear screen before prompt...
              elsif ($arg =~ /^-wipe(first)?$/) {
                  $option{-wipe} = $1 ? !$already_wiped : 1;
                  $already_wiped = 1;
              }
              elsif ($arg =~ /^-w/) {
                  $option{-wipe} = 1;
                  $already_wiped = 1;
                  $redo = 1;
              }
  
              # Specify a failure condition...
              elsif ($arg =~ /^-fail$/) {
                  _opt_err('Missing', -fail, 'failure condition') if !@_;
                  $option{-fail} = shift @_;
              }
  
              # Specify an immediate failure condition...
              elsif ($arg =~ /^-cancel/) {
                  _opt_err('Missing', -cancel, 'cancellation condition') if !@_;
                  $option{-cancel} = shift @_;
              }
  
              # Specify a file request...
              elsif ($arg =~ /^-f(?:ilenames?)?$/) {
                  $option{-must}{'0: be an existing file'} = sub { -e $_[0] };
                  $option{-must}{'1: be readable'}         = sub { -r $_[0] };
                  $option{-complete}                       = 'filenames';
              }
  
              # Specify prompt echoing colour/style...
              elsif ($arg =~ /^-style/) {
                  _opt_err('Missing -style specification') if !@_;
                  my $style = _decode_style(shift @_);
                  $option{-style} = _gen_wrapper_for($style);
              }
  
              # Specify input colour/style...
              elsif ($arg =~ /^-echostyle/) {
                  _opt_err('Missing -echostyle specification') if !@_;
                  my $style = _decode_echostyle(shift @_);
                  $option{-echostyle} = _gen_wrapper_for($style);
              }
  
  
              # Specify input and output filehandles...
              elsif ($arg =~ /^-stdio$/) { $option{-in}  = *STDIN;
                                  $option{-out} = *STDOUT;
                                  }
              elsif ($arg =~ /^-in$/)    { $option{-in}  = shift @_; }
              elsif ($arg =~ /^-out$/)   { $option{-out} = shift @_; }
  
  
              # Specify integer and number return value...
              elsif ($arg =~ /^-integer$/)       {
                  $option{-integer} = 1;
                  if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                      my ($errmsg, $constraint)
                          = _standardize_constraint('integer',shift);
                      $option{-must}{$errmsg} = $constraint;
                  }
              }
              elsif ($arg =~ /^-num(?:ber)?$/)   {
                  $option{-number}  = 1;
                  if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                      my ($errmsg, $constraint)
                          = _standardize_constraint('number',shift);
                      $option{-must}{$errmsg} = $constraint;
                  }
              }
              elsif ($arg =~ /^-i/)              { $option{-integer} = 1; $redo = 1; }
              elsif ($arg =~ /^-n/)              { $option{-number}  = 1; $redo = 1; }
  
              # Specify void context is okay...
              elsif ($arg =~ /^-void$/)          { $option{-void} = 1;               }
  
              # Specify verbatim return value...
              elsif ($arg =~ /^-verb(?:atim)?$/) { $option{-verbatim} = 1;           }
              elsif ($arg =~ /^-v/)              { $option{-verbatim} = 1; $redo = 1;}
  
              # Specify single character return...
              elsif ($arg =~ /^-sing(?:le)?$/)   { $option{-single} = 1;             }
              elsif ($arg =~ /^-[s1]/)           { $option{-single} = 1; $redo = 1;  }
  
              # Specify a default...
              elsif ($arg =~ /^-DEF(?:AULT)?/) {
                  _opt_err('Missing', '-DEFAULT', 'string') if !@_;
                  $option{-def} = shift @_;
                  $option{-def_nocheck} = 1;
                  _opt_err('Invalid', '-DEFAULT', 'string', 'reference')
                      if ref($option{-def});
              }
              elsif ($arg =~ /^-def(?:ault)?/) {
                  _opt_err('Missing', '-default', 'string') if !@_;
                  $option{-def} = shift @_;
                  _opt_err('Invalid', '-default', 'string', 'reference')
                      if ref($option{-def});
              }
              elsif ($arg =~ /^-d(.+)$/)   { $option{-def} = $1; }
  
              # Specify a timeout...
              elsif ($arg =~ /^-t(\d+)/)   {
                  $option{-timeout} = $1;
                  $arg =~ s{\d+}{}xms;
                  $redo = 1;
              }
              elsif ($arg =~ /^-timeout$/) {
                  _opt_err('Missing', -timeout, 'number of seconds') if !@_;
                  $option{-timeout} = shift @_;
                  _opt_err('Invalid', -timeout,'number of seconds', qq{'$option{-timeout}'})
                      if !looks_like_number($option{-timeout});
              }
  
              # Specify a set of input constraints...
              elsif ($arg =~ /^-g.*/) {
                  _opt_err('Missing', -guarantee, 'input restriction') if !@_;
                  my $restriction = shift @_;
                  my $restriction_type = ref $restriction;
  
                  $option{-must}{'be a valid input'} = $restriction;
  
                  # Hashes restrict input to their keys...
                  if ($restriction_type eq 'HASH') {
                      $restriction_type = 'ARRAY';
                      $restriction = [ keys %{$restriction} ];
                  }
                  # Arrays of strings matched (and completed) char-by-char...
                  if ($restriction_type eq 'ARRAY') {
                      my @restrictions = @{$restriction};
                      $option{-guarantee}
                          = '\A(?:'
                          . join('|', map {
                                  join(q{}, map { "(?:\Q$_\E" } split(q{}, $_))
                              . ')?' x length($_)
                              } @restrictions)
                          . ')\z'
                          ;
                      if ($option{-complete} == $DEFAULT_COMPLETER) {
                          $option{-complete} = \@restrictions;
                      }
                  }
                  # Regexes matched as-is...
                  elsif ($restriction_type eq 'Regexp') {
                      $option{-guarantee} = $restriction;
                  }
                  else {
                      _opt_err( 'Invalid', -guarantee,
                                  'array or hash reference, or regex'
                      );
                  }
              }
  
              # Specify a set of key letters...
              elsif ($arg =~ '-keyletters_implement') {
                  # Extract all keys and default keys...
                  my @keys  = ($option{-prompt} =~ m{$KL_EXTRACT}gxms);
  
                  # Convert default to a -default...
                  my @defaults = ($option{-prompt} =~ m{$KL_DEF_EXTRACT}gxms);
                  if (@defaults > 1) {
                      _warn( ambiguous =>
                          "prompt(): -keyletters found too many defaults"
                      )
                  }
                  elsif (@defaults) {
                      push @_, -default => $defaults[0];
                  }
  
                  # Convert key letters to a -guarantee...
                  @keys = ( map({uc} @keys), map({lc} @keys) );
                  if (@defaults == 1) {
                      push @keys, q{};
                  }
                  push @_, -guarantee => \@keys;
  
              }
              elsif ($arg =~ /^-key(?:let(?:ter)?)(?:s)?/) {
                  push @_, '-keyletters_implement';
              }
              elsif ($arg =~ /^-k/) {
                  push @_, '-keyletters_implement';
                  $redo = 1;
              }
  
              # Specify a set of return constraints...
              elsif ($arg =~ /^-must$/) {
                  _opt_err('Missing', -must, 'constraint hash') if !@_;
                  my $must = shift @_;
                  _opt_err('Invalid', -must, 'hash reference')
                      if ref($must) ne 'HASH';
                  for my $errmsg (keys %{$must}) {
                      $option{-must}{$errmsg} = $must->{$errmsg};
                  }
              }
  
              # Specify a history set...
              elsif ($arg =~ /^-history/) {
                  $option{-history}
                      = @_ && $_[0] !~ /^-/ ? shift @_
                      :                       undef;
                  _opt_err('Invalid', -history, 'history set name', qq{'$option{-history}'})
                      if ref($option{-history});
              }
              elsif ($arg =~ /^-h(.*)/)   { $option{-history} = length($1) ? $1 : undef; }
  
              # Specify completions...
              elsif ($arg =~ /^-comp(?:lete)?/) {
                  _opt_err('Missing', -complete, 'completions') if !@_;
                  my $comp_spec = shift @_;
                  my $comp_type = ref($comp_spec) || $comp_spec || '???';
                  if ($comp_type =~ m{\A(?: file\w* | dir\w* | ARRAY | HASH | CODE )\Z}xms) {
                      $option{-complete} = $comp_spec;
                  }
                  else {
                      _opt_err( 'Invalid', -complete,
                                  '"filenames", "dirnames", or reference to array, hash, or subroutine');
                  }
              }
  
              # Specify what to echo when a character is keyed...
              elsif ($arg =~ /^-(echo|ret(?:urn)?)$/) {
                  my $flag = $1 eq 'echo' ? '-echo' : '-return';
                  if ($flag eq '-echo' && !eval { no warnings 'deprecated'; require Term::ReadKey }) {
                      _warn( bareword => "Warning: next input will be in plaintext\n");
                  }
                  my $arg = @_ && $_[0] !~ /^-/ ? shift(@_)
                          : $flag eq '-echo'    ? q{}
                          :                       qq{\n};
                  $option{$flag} = _gen_wrapper_for(_decode_echo($arg));
              }
              elsif ($arg =~ /^-e(.*)/) {
                  if (!eval { no warnings 'deprecated'; require Term::ReadKey }) {
                      _warn( bareword => "Warning: next input will be in plaintext\n");
                  }
                  my $arg = $1;
                  $option{-echo} = _gen_wrapper_for(_decode_echo($arg));
              }
              elsif ($arg =~ /^-r(.+)/) {
                  my $arg = $1;
                  $option{-return} = _gen_wrapper_for(_decode_echo($arg));
              }
              elsif ($arg =~ /^-r/) {
                  $option{-return} = sub{ "\n" };
              }
  
              # Specify an initial input...
              elsif ($arg =~ /^-prefill/) {
                  _opt_err('Missing', '-prefill', 'string') if !@_;
                  $option{-prefill} = shift @_;
                  _opt_err('Invalid', '-prefill', 'string', 'reference')
                      if ref($option{-prefill});
              }
  
              # Explicit prompt replaces implicit prompts...
              elsif ($arg =~ /^-prompt$/) {
                  _opt_err('Missing', '-prompt', 'prompt string') if !@_;
                  $option{-prompt} = shift @_;
                  _opt_err('Invalid', '-prompt', 'string', 'reference')
                      if ref($option{-prompt});
              }
              elsif ($arg =~ /^-p(\S*)$/) {
                  $option{-prompt} = $1;
              }
  
              # Menus inject a placeholder in the prompt string...
              elsif ($arg =~ /^-menu$/) {
                  _opt_err('Missing', '-menu', 'menu specification') if !@_;
                  $option{-menu}         = ref $_[0] ? shift(@_) : \shift(@_);
                  $option{-prompt}      .= $MENU_MK;
                  $option{-def_nocheck}  = 1;
              }
  
              # A monitoring sub is called on every input character...
              elsif ($arg =~ /^-monitor/) {
                  _opt_err('Missing', '-monitor', 'a monitor subref')
                      if !@_ || ref $_[0] ne 'CODE';
                  $option{-monitor} = shift(@_);
              }
  
              # Anything else of the form '-...' is a misspelt option...
              elsif ($arg =~ /^-\w+$/) { _warn(misc => "prompt(): Unknown option $arg ignored"); }
  
              # Anything else is part fo the prompt...
              else { $option{-prompt} .= $arg; }
  
              # Handle option bundling...
              redo DECODING if $redo && $arg =~ s{\A -.{$redo} (?=.)}{-}xms;
          }
      }
  
      # Precompute top-level menu, if menuing...
      if (exists $option{-menu}) {
          $option{-menu} = _build_menu($option{-menu},
                                       undef,
                                       $option{-number}||$option{-integer}
                           );
      }
  
      # Handle return magic on -single...
      if (defined $option{-single} && length($option{-echo}('X')//'echoself')) {
          $option{-return} //= sub{ "\n" };
      }
  
      # Adjust prompt as necessary...
      if ($option{-argv}) {
          my $progname = $option{-prompt} // $0;
          $progname =~ s{^.*/}{}xms;
  
          my $HINT = '[enter command line args here]';
          $option{-prompt} = "> $progname  $HINT\r> $progname ";
  
          $option{-complete} = 'filenames';
  
          my $not_first;
          $option{-echo}   = sub{
              my $char = shift;
              $option{-prompt} = "> $progname ";  # Sneaky resetting to handle completions
              return $char if $not_first++;
              return "\r> $progname  " . (q{ } x length $HINT) . "\r> $progname $char";
          }
      }
      elsif (!defined $option{-prompt}) {
          $option{-prompt} = '> ';
      }
      elsif ($option{-prompt} =~ m{ \S \z}xms) {
          # If prompt doesn't end in whitespace, make it so...
          $option{-prompt} .= ' ';
      }
      elsif ($option{-prompt} =~ m{ (.*) \n \z}xms) {
          # If prompt ends in a newline, remove it...
          $option{-prompt} = $1;
      }
  
      # Steal history set name if -h given without a specification...
      $option{-history} //= $option{-prompt};
  
      # Verify any default satisfies any constraints...
      if (exists $option{-def} && !$option{-def_nocheck}) {
          if (!_verify_input_constraints(\q{},undef,undef,\%option)) {
              _warn( misc =>
                  'prompt(): -default value does not satisfy -must constraints'
              );
          }
      }
  
      return \%option;
  }
  
  #====[ Error Handlers ]=========================================
  
  sub _opt_err {
      my ($problem, $option, $expectation, $found) = @_;
      if (@_ > 3) {
          Carp::croak "prompt(): $problem value for $option (expected $expectation, but found $found)";
      }
      else {
          Carp::croak "prompt(): $problem value for $option (expected $expectation)";
      }
  }
  
  sub _warn {
      my ($category, @message) = @_;
  
      return if !warnings::enabled($category);
  
      my $message = join(q{},@message);
      warn $message =~ /\n$/ ? $message : Carp::shortmess($message);
  }
  
  
  #====[ Utility subroutines ]====================================
  
  # Return the *ARGV filehandle, "magic-opening" it if necessary...
  sub _open_ARGV {
      if (!openhandle \*ARGV) {
          $ARGV = shift @ARGV // '-';
          open *ARGV or Carp::croak(qq{prompt(): Can't open *ARGV: $!});
      }
      return \*ARGV;
  }
  
  my $INTEGER_PAT = qr{ \A \s*+ [+-]?+ \d++ (?: [Ee] \+? \d+ )? \s*+ \Z }xms;
  
  my $NUMBER_PAT  = qr{
      \A \s*+ [+-]?+
      (?:
          \d++ (?: [.,] \d*+ )?
      |   [.,] \d++
      )
      (?: [eE] [+-]?+ \d++ )?
      \s*+ \Z
  }xms;
  
  # Verify interactive constraints...
  sub _verify_input_constraints {
      my ($input_ref, $local_fake_input_ref, $outputter_ref, $opt_ref, $extras)
          = @_;
  
      # Use default if appropriate (but short-circuit checks if -DEFAULT set)...
      my $input = ${$input_ref};
      if (${$input_ref} =~ m{^\R?$}xms && exists $opt_ref->{-def}) {
          return 1 if $opt_ref->{-def_nocheck};
          $input = $opt_ref->{-def}
      }
      chomp $input;
  
      my $failed;
      # Integer constraint is hard-coded...
      if ($opt_ref->{-integer} && $input !~ $INTEGER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be an integer) ";
      }
  
      # Numeric constraint is hard-coded...
      if (!$failed && $opt_ref->{-number} && $input !~ $NUMBER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be a number) ";
      }
  
      # Sort and clean up -must list...
      my $must_ref = $opt_ref->{-must} // {};
      my @must_keys     = sort keys %{$must_ref};
      my %clean_key_for = map { $_ => (/^\d+[.:]?\s*(.*)/s ? $1 : $_) } @must_keys;
      my @must_kv_list  = map { $clean_key_for{$_} => $must_ref->{$_} } @must_keys;
  
      # Combine -yesno and -must constraints...
      my %constraint_for = (
          %{ $extras // {} },
          %{ $opt_ref->{-yesno}{must} // {} },
          @must_kv_list,
      );
      my @constraints = (
          keys %{ $extras // {} },
          keys %{ $opt_ref->{-yesno}{must} // {} },
          @clean_key_for{@must_keys},
      );
  
      # User-specified constraints...
      if (!$failed && keys %constraint_for) {
          CONSTRAINT:
          for my $msg (@constraints) {
              my $constraint = $constraint_for{$msg};
              next CONSTRAINT if eval { no warnings; local $_ = $input; match($input, $constraint); };
              $failed = $msg =~ m{\A [[:upper:]] }xms ? "$msg "
                      : $msg =~ m{\A \W }xms          ? $opt_ref->{-prompt}
                                                      . "$msg "
                      :                                 $opt_ref->{-prompt}
                                                      . "(must $msg) "
                      ;
              last CONSTRAINT;
          }
      }
  
      # If any constraint not satisfied...
      if ($failed) {
          # Return failure if not actually prompting at the moment...
          return 0 if !$outputter_ref;
  
          # Redraw post-menu prompt with failure message appended...
          $failed =~ s{.*$MENU_MK}{}xms;
          $outputter_ref->(-style => _wipe_line(), $failed);
  
          # Reset input collector...
          ${$input_ref}  = q{};
  
          # Reset faked input, if any...
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              ${$local_fake_input_ref} = $1;
          }
  
          no warnings 'exiting';
          next INPUT;
      }
  
      # Otherwise succeed...
      return 1;
  }
  
  # Build a sub to read from specified filehandle, with or without timeout...
  sub _generate_buffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      # Set-up for timeouts...
      my $fileno      = fileno($in_fh) // -1;
      my $has_timeout = exists $opt_ref->{-timeout} && $fileno >= 0;
      my $timeout     = $opt_ref->{-timeout};
      my $readbits    = q{};
      if ($has_timeout && $fileno >= 0) {
          vec($readbits,$fileno,1) = 1;
      }
  
      # Set up local faked input, if any...
      my $local_fake_input;
      my $orig_fake_input;
      if (defined $fake_input && length($fake_input) > 0) {
          $fake_input =~ s{ \A (.*) \R? }{}xm;
          $orig_fake_input = $local_fake_input = $1;
      }
  
      return sub {
          my ($extra_constraints) = @_;
  
          INPUT:
          while (1) {
              if (!$has_timeout || select $readbits, undef, undef, $timeout) {
                  my $input;
  
                  # Real input comes from real filehandles...
                  if (!defined $local_fake_input) {
                      $input = readline $in_fh;
                  }
                  # Fake input has to be typed...
                  else {
                      $input = $local_fake_input;
                      sleep 1;
                      for ($local_fake_input =~ m/\X/g) {
                          _simulate_typing();
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                      }
                      readline $in_fh;
  
                      # Check for simulated EOF...
                      if ($input =~ m{^ \s* (?: \cD | \cZ ) }xms) {
                          $input = undef;
                      }
                  }
  
                  if (exists $opt_ref->{-cancel}) {
                      for my $nextchar (split q{}, $input) {
                          die bless \$input, 'IO::Prompter::Cancellation'
                              if match($nextchar, $opt_ref->{-cancel});
                      }
                  }
  
                  if (defined $input) {
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref, $opt_ref, $extra_constraints
                      );
                  }
  
                  return defined $input && $opt_ref->{-single}
                              ? substr($input, 0, 1)
                              : $input;
              }
              else {
                  return;
              }
          }
      }
  }
  
  sub _autoflush {
      my ($fh) = @_;
      my $prev_selected = select $fh;
      $| = 1;
      select $prev_selected;
      return;
  }
  
  sub _simulate_typing {
      state $TYPING_SPEED = 0.07; # seconds per character
      select undef, undef, undef, rand $TYPING_SPEED;
  }
  
  sub _term_width {
      my ($term_width) = eval { no warnings 'deprecated'; Term::ReadKey::GetTerminalSize(\*STDERR) };
      return $term_width // $DEFAULT_TERM_WIDTH;
  }
  
  sub _wipe_line {
      return qq{\r} . q{ } x (_term_width()-1) . qq{\r};
  }
  
  # Convert a specification into a list of possible completions...
  sub _current_completions_for {
      my ($input_text, $opt_ref) = @_;
      my $completer = $opt_ref->{-complete};
  
      # Isolate the final whitespace-separated word...
      my ($prefix, $lastword)
          = $input_text =~ m{
              (?| ^ (.*\s+) (.*)
                | ^ ()      (.*)
              )
            }xms;
  
      # Find candidates...
      my @candidates;
      for my $completer_type (ref($completer) || $completer // q{}) {
          # If completer is sub, recursively call it with input words...
          if ($completer_type eq 'CODE') {
              ($prefix, @candidates)
                  = _current_completions_for(
                      $input_text,
                      { %{$opt_ref},
                        -complete => $completer->(split /\s+/, $input_text, -1)
                      }
                    );
          }
  
          # If completer is array, grep the appropriate elements...
          elsif ($completer_type eq 'ARRAY') {
              @candidates = grep { /\A\Q$lastword\E/ } @{$completer};
          }
  
          # If completer is hash, grep the appropriate keys...
          elsif ($completer_type eq 'HASH') {
              @candidates = grep { /\A\Q$lastword\E/ } keys %{$completer};
          }
  
          # If completer is 'file...', glob up the appropriate filenames...
          elsif ($completer_type eq /^file\w*$/) {
              @candidates = glob($lastword.'*');
          }
  
          # If completer is 'dir...', glob up the appropriate directories...
          elsif ($completer_type eq /^dir\w*$/) {
              @candidates = grep {-d} glob($lastword.'*');
          }
      }
  
      chomp @candidates;
      return ($prefix, @candidates);
  }
  
  
  sub _current_history_for {
      my ($prefix, $opt_ref) = @_;
  
      my $prefix_len = length($prefix);
      return q{}, map { /\A (.*?) \R \Z/x ? $1 : $_ }
                 grep { substr($_,0,$prefix_len) eq $prefix }
                      @{ $history_cache{$opt_ref->{-history}} };
  }
  
  sub _longest_common_prefix_for {
      my $prefix = shift @_;
      for my $comparison (@_) {
          ($comparison ^ $prefix) =~ m{ \A (\0*) }xms;
          my $common_length = length($1);
          return q{} if !$common_length;
          $prefix = substr($prefix, 0, $common_length);
      }
      return $prefix;
  }
  
  sub _display_completions {
      my ($input, @candidates) = @_;
  
      return q{} if @candidates <= 1;
  
      # How big is each field in the table?
      my $field_width
          = _term_width() / $COMPLETE_DISPLAY_FIELDS - $COMPLETE_DISPLAY_GAP;
  
      # Crop the possibilities intelligently to that width...
      for my $candidate (@candidates) {
          substr($candidate, 0, length($input)) =~ s{ \A .* [/\\] }{}xms;
          $candidate
              = sprintf "%-*s", $field_width, substr($candidate,0,$field_width);
      }
  
      # Collect them into rows...
      my $display = "\n";
      my $gap     = q{ } x $COMPLETE_DISPLAY_GAP;
      while (@candidates) {
          $display .= $gap
                    . join($gap, splice(@candidates, 0, $COMPLETE_DISPLAY_FIELDS))
                    . "\n";
      }
  
      return $display;
  }
  
  sub _generate_unbuffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      my $has_readkey = eval { no warnings 'deprecated'; require Term::ReadKey };
  
      # If no per-character reads, fall back on buffered input...
      if (!-t $in_fh || !$has_readkey) {
          return _generate_buffered_reader_from($in_fh, $outputter_ref, $opt_ref);
      }
  
      # Adapt to local control characters...
      my %ctrl = eval { Term::ReadKey::GetControlChars($in_fh) };
      delete $ctrl{$_} for grep { $ctrl{$_} eq "\cA" } keys %ctrl;
  
      $ctrl{EOF}       //= "\4";
      $ctrl{INTERRUPT} //= "\3";
      $ctrl{ERASE}     //= $^O eq 'MSWin32' ? "\10" : "0177";
  
      my $ctrl           = join '|', values %ctrl;
  
      my $VERBATIM_KEY = $ctrl{QUOTENEXT} // $DEFAULT_VERBATIM_KEY;
  
      # Translate timeout for ReadKey (with 32-bit MAXINT workaround for Windows)...
      my $timeout = !defined $opt_ref->{-timeout} ? 0x7FFFFFFF    # 68 years
                  : $opt_ref->{-timeout} == 0     ? -1
                  :                                 $opt_ref->{-timeout}
                  ;
  
      return sub {
          my ($extra_constraints) = @_;
  
          # Short-circuit on unreadable filehandle...
          return if !openhandle($in_fh);
  
          # Set up direct reading, and prepare to clean up on abnormal exit...
          Term::ReadKey::ReadMode('raw', $in_fh);
          my $prev_SIGINT = $SIG{INT};
          local $SIG{INT} = sub { return if $prev_SIGINT eq 'IGNORE';
                                  Term::ReadKey::ReadMode('restore', $in_fh);
                                  exit(1) if !defined $prev_SIGINT
                                          || $prev_SIGINT eq 'DEFAULT';
                                  {
                                      package main;
                                      no strict 'refs';
                                      $prev_SIGINT->()
                                  }
                            };
  
          # Set up local faked input, if any...
          my $local_fake_input;
          my $orig_fake_input;
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              $orig_fake_input = $local_fake_input = $1;
          }
  
          my $input = exists $opt_ref->{-prefill} ? $opt_ref->{-prefill} : q{};
          if (exists $opt_ref->{-prefill}) {
              if (exists $opt_ref->{-monitor}) {
                  my %opts = ( -cursor_pos => length($input),
                               -prompt     => $opt_ref->{-prompt},
                               -style      => $opt_ref->{-style}->(),
                               -echostyle  => $opt_ref->{-echostyle}->(),
                          );
                  my $input_copy = $input;
                  eval { $opt_ref->{-monitor}->($input_copy, \%opts) };
              }
              $outputter_ref->( -style => $opt_ref->{-style}, _wipe_line(), $opt_ref->{-prompt});
              $outputter_ref->( -echostyle => join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g) );
          }
  
          my $insert_offset = 0;
          INPUT:
          while (1) {
              state $prev_was_verbatim = 0;
              state $completion_level  = 0;
              state $completion_type   = q{};
  
              # Get next character entered...
              my $next = Term::ReadKey::ReadKey($timeout, $in_fh);
  
              # Check for cancellation...
              if (exists $opt_ref->{-cancel} && match($next, $opt_ref->{-cancel})) {
                  Term::ReadKey::ReadMode('restore', $in_fh);
                  die bless \$input, 'IO::Prompter::Cancellation';
              }
  
              # Finished with completion mode?
              if (($next//q{}) !~ m{ $COMPLETE_INIT | $COMPLETE_CYCLE }xms) {
                  $completion_level = 0;
                  $completion_type = q{};
              }
  
              # Are we faking input?
              my $faking = defined $local_fake_input;
  
              # If not EOF...
              if (defined $next) {
                  # Remember where we were parked...
                  my $prev_insert_offset = $insert_offset;
  
                  # Handle interrupts...
                  if ($next eq $ctrl{INTERRUPT}) {
                      $SIG{INT}();
                      next INPUT;
                  }
  
                  # Handle verbatim quoter...
                  elsif (!$prev_was_verbatim && $next eq $VERBATIM_KEY) {
                      $prev_was_verbatim = 1;
                      next INPUT;
                  }
  
                  # Handle completions...
                  elsif (!$prev_was_verbatim
                         && ( $next =~ $COMPLETE_INIT
                           || $completion_level > 0 && $next =~ $COMPLETE_CYCLE
                         )
                  ) {
                      state @completion_list;  # ...all candidates for completion
                      state @completion_ring;  # ..."next" candidate cycle
                      state $completion_ring_first;  # ...special case first time
                      state $completion_prefix;      # ...skipped before completing
  
                      # Track completion type and level (switch if necessary)...
                      if ($next =~ $COMPLETE_INIT && index($completion_type, $next) < 0) {
                          $completion_type = index($COMPLETE_KEY, $next) >= 0 ? $COMPLETE_KEY : $COMPLETE_HIST;
                          $completion_level = 1;
                      }
                      else {
                          $completion_level++;
                      }
  
                      # If starting completion, cache completions...
                      if ($completion_level == 1) {
                          ($completion_prefix, @completion_list)
                             = index($COMPLETE_KEY, $next) >= 0
                                  ? _current_completions_for($input, $opt_ref)
                                  : _current_history_for($input, $opt_ref);
                          @completion_ring = (@completion_list, q{});
                          $completion_ring_first = 1;
                      }
  
                      # Can only complete if there are completions to be had...
                      if (@completion_list) {
                          # Select the appropriate mode...
                          my $mode = $COMPLETE_MODE{$completion_type}[$completion_level-1]
                                  // $COMPLETE_MODE{$completion_type}[-1];
  
                          # 'longest mode' finds longest consistent prefix...
                          if ($mode =~ /longest/) {
                              $input
                                  = $completion_prefix
                                  . _longest_common_prefix_for(@completion_list);
                          }
                          # 'full mode' suggests next full match...
                          elsif ($mode =~ /full/) {
                              if (!$completion_ring_first) {
                                  if ($next eq $COMPLETE_PREV) {
                                      unshift @completion_ring,
                                              pop @completion_ring;
                                  }
                                  else {
                                      push @completion_ring,
                                           shift @completion_ring;
                                  }
                              }
                              $input = $completion_prefix . $completion_ring[0];
                              $completion_ring_first = 0;
                          }
                          # 'list mode' lists all possibilities...
                          my $list_display = $mode =~ /list/
                              ? _display_completions($input, @completion_list)
                              : q{};
  
                          # Update prompt with selected completion...
                          $outputter_ref->( -style =>
                              $list_display,
                              _wipe_line(),
                              $opt_ref->{-prompt}, $input
                          );
  
                          # If last completion was unique choice, completed...
                          if (@completion_list <= 1) {
                              $completion_level = 0;
                          }
                      }
                      next INPUT;
                  }
  
                  # Handle erasures (including pushbacks if faking)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{ERASE}) {
                      if (!length $input) {
                          # Do nothing...
                      }
                      elsif ($insert_offset) {
                          # Can't erase past start of input...
                          next INPUT if $insert_offset >= length($input);
  
                          # Erase character just before cursor...
                          substr($input, -$insert_offset-1, 1, q{});
  
                          # Redraw...
                          my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                          my $input_post = substr($input.' ',length($input)-$insert_offset);
                          my $display_pre
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                          my $display_post
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                              . q{ } x length($opt_ref->{-echo}(q{ }))
                              . "\b" x length($display_post)
                          );
                      }
                      else {
                          my $erased = substr($input, -1, 1, q{});
                          if ($faking) {
                              substr($local_fake_input,0,0,$erased);
                          }
                          $outputter_ref->( -nostyle =>
                              map { $_ x (length($opt_ref->{-echo}($_)//'X')) }
                                  "\b", ' ', "\b"
                          );
                      }
                      next INPUT;
                  }
  
                  # Handle EOF (including cancelling any remaining fake input)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{EOF}) {
                      Term::ReadKey::ReadMode('restore', $in_fh);
                      close $in_fh;
                      undef $fake_input;
                      return length($input) ? $input : undef;
                  }
  
                  # Handle escape from faking...
                  elsif (!$prev_was_verbatim && $faking && $next eq $FAKE_ESC) {
                      my $lookahead = Term::ReadKey::ReadKey(0, $in_fh);
  
                      # Two <ESC> implies the current faked line is deferred...
                      if ($lookahead eq $FAKE_ESC) {
                          $fake_input =~ s{ \A }{$orig_fake_input\n}xm;
                      }
                      # Only one <ESC> implies the current faked line is replaced...
                      else {
                          $in_fh->ungetc(ord($lookahead));
                      }
                      undef $local_fake_input;
                      $faking = 0;
                      next INPUT;
                  }
  
                  # Handle returns...
                  elsif (!$prev_was_verbatim && $next =~ /\A\R\z/) {
                      # Complete faked line, if faked input incomplete...
                      if ($faking && length($local_fake_input)) {
                          for ($local_fake_input =~ m/\X/g) {
                              _simulate_typing();
                              $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                          }
                          $input .= $local_fake_input;
                      }
  
                      # Add newline to the accumulated input string...
                      $input .= $next;
  
                      # Check that input satisfied any constraints...
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref,
                          $opt_ref, $extra_constraints,
                      );
  
                      # Echo a default value if appropriate...
                      if ($input =~ m{\A\R?\Z}xms && defined $opt_ref->{-def}) {
                          my $def_val = $opt_ref->{-def};
  
                          # Try to find the key, for a menu...
                          if (exists $opt_ref->{-menu_curr_level}) {
                              for my $key ( keys %{$opt_ref->{-menu_curr_level}}) {
                                  if (match($def_val, $opt_ref->{-menu_curr_level}{$key})) {
                                      $def_val = $key;
                                      last;
                                  }
                              }
                          }
  
                          # Echo it as if it had been typed...
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($def_val));
                      }
  
                      # Echo the return (or otherwise, as specified)...
                      $outputter_ref->(-echostyle => $opt_ref->{-return}($next));
  
                      # Clean up, and return the input...
                      Term::ReadKey::ReadMode('restore', $in_fh);
  
                      # Handle fake EOF...
                      if ($faking && $input =~ m{^ (?: \cD | \cZ) }xms) {
                          return undef;
                      }
  
                      return $input;
                  }
  
                  # Handle anything else...
                  elsif ($prev_was_verbatim || $next !~ /$ctrl/) {
                      # If so, get the next fake character...
                      if ($faking) {
                          $next = length($local_fake_input)
                                      ? substr($local_fake_input,0,1,q{})
                                      : q{};
                      }
  
                      # Handle editing...
                      if ($next eq $EDIT{BACK}) {
                          $insert_offset += ($insert_offset < length $input) ? 1 : 0;
                      }
                      elsif ($next eq $EDIT{FORWARD}) {
                          $insert_offset += ($insert_offset > 0) ? -1 : 0;
                      }
                      elsif ($next eq $EDIT{START}) {
                          $insert_offset = length($input);
                      }
                      elsif ($next eq $EDIT{END}) {
                          $insert_offset = 0;
                      }
  
                      # Handle non-editing...
                      else {
                          # Check for input restrictions...
                          if (exists $opt_ref->{-guarantee}) {
                              next INPUT if ($input.$next) !~ $opt_ref->{-guarantee};
                          }
  
                          # Add the new input char to the accumulated input string...
                          if ($insert_offset) {
                              substr($input, -$insert_offset, 0) = $next;
                              $prev_insert_offset++;
                          }
                          else {
                              $input .= $next;
                          }
                      }
  
                      # Display the character (or whatever was specified)...
  
                      if ($insert_offset || $prev_insert_offset) {
                          my $input_pre  = substr($input,0,length($input)-$prev_insert_offset);
                          my $input_post = substr($input,length($input)-$insert_offset);
                          my $display_pre
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                          my $display_post
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                              . "\b" x length($display_post)
                          );
                      }
                      elsif ($next !~ $EDIT_KEY) {
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($next));
                      }
  
                      # Not verbatim after this...
                      $prev_was_verbatim = 0;
                  }
                  else {
                      # Not verbatim after mysterious ctrl input...
                      $prev_was_verbatim = 0;
  
                      next INPUT;
                  }
              }
  
              if ($opt_ref->{-single} || !defined $next || $input =~ m{\Q$/\E$}) {
                  # Did we get an acceptable value?
                  if (defined $next) {
                      _verify_input_constraints(
                         \$input, \$local_fake_input, $outputter_ref,
                         $opt_ref, $extra_constraints,
                      );
                  }
  
                  # Reset terminal...
                  Term::ReadKey::ReadMode('restore', $in_fh);
  
                  # Return failure if failed before input or cancelled...
                  if (!defined $next && length($input) == 0
                  ||  exists $opt_ref->{-cancel} && match($next, $opt_ref->{-cancel})) {
                      return if $opt_ref->{-verbatim};
                      return PUREBOOL { 0 }
                                 BOOL { 0 }
                                 SCALAR { undef  }
                                 METHOD { defaulted => sub { 0 }, timedout  => sub { 0 } };
                  }
  
                  # Otherwise supply a final newline if necessary...
                  if ( $opt_ref->{-single}
                  &&   exists $opt_ref->{-return}
                  &&   $input !~ /\A\R\z/ ) {
                      $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}));
                  }
  
                  return $input;
              }
          }
          continue {
              # Perform monitor (if any) and redraw prompt (if required)...
              if ($opt_ref->{-monitor}) {
                  my %opts = ( -cursor_pos => length($input) - $insert_offset,
                               -prompt     => $opt_ref->{-prompt},
                               -style      => $opt_ref->{-style}->(),
                               -echostyle  => $opt_ref->{-echostyle}->(),
                          );
                  my $input_copy = $input;
                  my $output_pos = $outputter_ref->(-tell);
                  if (!defined eval { $opt_ref->{-monitor}->($input_copy, \%opts) }
                  ||  $output_pos != $outputter_ref->(-tell)) {
                      my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                      my $input_post = substr($input.' ',length($input)-$insert_offset);
                      my $display_pre
                          = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                      my $display_post
                          = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                      $outputter_ref->( -style => $opt_ref->{-style}, _wipe_line(), $opt_ref->{-prompt});
                      $outputter_ref->( -echostyle =>
                                      join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                                      . "\b" x (length($display_post)-1)
                      );
                  }
              }
          }
      }
  }
  
  # Build a menu...
  sub _build_menu {
      my ($source_ref, $initial_prompt, $is_numeric) = @_;
      my $prompt = ($initial_prompt//q{}) . qq{\n};
      my $final = q{};
      my %value_for;
      my %key_for;
      my @selectors;
  
      my $source_type = ref $source_ref;
      if ($source_type eq 'HASH') {
          my @sorted_keys = sort(keys(%{$source_ref}));
          @selectors = $is_numeric ? (1..@sorted_keys) : ('a'..'z','A'..'Z');
          @key_for{@selectors}   = @sorted_keys;
          @value_for{@selectors} = @{$source_ref}{@sorted_keys};
          $source_ref = \@sorted_keys;
      }
      elsif ($source_type eq 'SCALAR') {
          $source_ref = [ split "\n", ${$source_ref} ];
      }
  
      my @source = @{$source_ref};
      @selectors = $is_numeric ? (1..@source) : ('a'..'z','A'..'Z');
      if (!keys %value_for) {
          @value_for{@selectors} = @source;
      }
  
      ITEM:
      for my $tag (@selectors) {
          my $item = shift(@source) // last ITEM;
          chomp $item;
          $prompt .= sprintf("%4s. $item\n", $tag);
          $final = $tag;
      }
  
      if (@source) {
          _warn( misc =>
              "prompt(): Too many menu items. Ignoring the final " . @source
          );
      }
  
      my $constraint = $is_numeric       ? '(?:' . join('|',@selectors) .')'
                     : $final =~ /[A-Z]/ ? "[a-zA-$final]"
                     :                     "[a-$final]";
      my $constraint_desc = $is_numeric  ? "[1-$selectors[-1]]" : $constraint;
      $constraint = '\A\s*' . $constraint . '\s*\Z';
  
      return {
          data       => $source_ref,
          key_for    => \%key_for,
          value_for  => \%value_for,
          prompt     => "$prompt\n",
          is_numeric => $is_numeric,
          constraint => { "Enter $constraint_desc: " => qr/$constraint|$MENU_ESC/ },
      };
  }
  
  # Vocabulary that _stylize understands...
  my %synonyms = (
      bold      => [qw<boldly strong heavy emphasis emphatic highlight highlighted fort forte>],
      dark      => [qw<darkly dim deep>],
      faint     => [qw<faintly light soft>],
      underline => [qw<underlined underscore underscored>],
      italic    => [qw<italics>],
      blink     => [qw<blinking flicker flickering flash flashing>],
      reverse   => [qw<reversed inverse inverted>],
      concealed => [qw<hidden blank invisible>],
      reset     => [qw<normal default standard usual ordinary regular>],
      bright_   => [qw< bright\s+ vivid\s+ >],
      red       => [qw< scarlet vermilion crimson ruby cherry cerise cardinal carmine
                        burgundy claret chestnut copper garnet geranium russet
                        salmon titian coral cochineal rose cinnamon ginger gules >],
      yellow    => [qw< gold golden lemon cadmium daffodil mustard primrose tawny
                        amber aureate canary champagne citrine citron cream goldenrod honey straw >],
      green     => [qw< olive jade pea emerald lime chartreuse forest sage vert >],
      cyan      => [qw< aqua aquamarine teal turquoise ultramarine >],
      blue      => [qw< azure cerulean cobalt indigo navy sapphire >],
      magenta   => [qw< amaranthine amethyst lavender lilac mauve mulberry orchid periwinkle
                        plum pomegranate violet purple aubergine cyclamen fuchsia modena puce
                        purpure >],
      black     => [qw< charcoal ebon ebony jet obsidian onyx raven sable slate >],
      white     => [qw< alabaster ash chalk ivory milk pearl silver argent >],
  );
  
  # Back-mapping to standard terms...
  my %normalize
      = map { join('|', map { "$_\\b" } reverse sort @{$synonyms{$_}}) => $_ }
            keys %synonyms;
  
  my $BACKGROUND = qr{
       (\S+) \s+ (?: behind | beneath | below | under(?:neath)? )\b
     | \b (?:upon|over|on) \s+ (?:an?)? \s+ (.*?) \s+ (?:background|bg|field) \b
     | \b (?:upon\s+ | over\s+ | (?:(on|upon|over)\s+a\s+)?  (?:background|bg|field) \s+ (?:of\s+|in\s+)? | on\s+) (\S+)
  }ixms;
  
  # Convert a description to ANSI colour codes...
  sub _stylize {
      my $spec = shift // q{};
  
      # Handle arrays and hashes as args...
      if (ref($spec) eq 'ARRAY') {
          $spec = join q{ }, @{$spec};
      }
      elsif (ref($spec) eq 'HASH') {
          $spec = join q{ }, keys %{$spec};
      }
  
      # Ignore punctuation...
      $spec =~ s/[^\w\s]//g;
  
      # Handle backgrounds...
      $spec =~ s/$BACKGROUND/on_$+/g;
  
      # Apply standard translations...
      for my $pattern (keys %normalize) {
          $spec =~ s{\b(on_|\b) $pattern}{($1//q{}).$normalize{$pattern}}geixms;
      }
  
      # Ignore anything unknown...
      $spec =~ s{((?:on_)?(?:(ansi\d+|rgb\d+)|(\S+)))}{ $2 || exists $synonyms{$3} ? $1 : q{} }gxmse;
  
      # Build ANSI terminal codes around text...
      my $raw_text = join q{}, @_;
      my ($prews, $text, $postws) = $raw_text =~ m{\A (\s*) (.*?) (\s*) \Z}xms;
      my @style = split /\s+/, $spec;
      return $prews
           . ( @style ? Term::ANSIColor::colored(\@style, $text) : $text )
           . $postws;
  }
  
  # Build a subroutine that prints printable chars to the specified filehandle...
  sub _std_printer_to {
      my ($out_filehandle, $opt_ref) = @_;
      no strict 'refs';
      _autoflush($out_filehandle);
      if (eval { require Term::ANSIColor}) {
          return sub {
              my $style = shift;
              return tell($out_filehandle) if $style eq -tell;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} _stylize($opt_ref->{$style}(@loc), @loc);
          };
      }
      else {
          return sub {
              my $style = shift;
              return tell($out_filehandle) if $style eq -tell;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} @loc;
          };
      }
  }
  
  # Build a subroutine that prints to nowhere...
  sub _null_printer {
      return sub {};
  }
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Prompter - Prompt for input, read it, clean it, return it.
  
  
  =head1 VERSION
  
  This document describes IO::Prompter version 0.005001
  
  
  =head1 SYNOPSIS
  
      use IO::Prompter;
  
      while (prompt -num, 'Enter a number') {
          say "You entered: $_";
      }
  
      my $passwd
          = prompt 'Enter your password', -echo=>'*';
  
      my $selection
          = prompt 'Choose wisely...', -menu => {
                  wealth => [ 'moderate', 'vast', 'incalculable' ],
                  health => [ 'hale', 'hearty', 'rude' ],
                  wisdom => [ 'cosmic', 'folk' ],
            }, '>';
  
  
  =head1 CAVEATS
  
  =over
  
  =item 1.
  
  Several features of this module are known to have problems under
  Windows. If using that platform, you may have more success
  (and less distress) by trying IO::Prompt::Tiny, IO::Prompt::Simple,
  or IO::Prompt::Hooked first.
  
  =item 2.
  
  By default the C<prompt()> subroutine does not return a string; it
  returns an object with overloaded string and boolean conversions.
  This object B<I<always>> evaluates true in boolean contexts, unless the
  read operation actually failed. This means that the object evaluates
  true I<even when the input value is zero or
  an empty string.> See L<"Returning raw data"> to turn off this
  (occasionally counter-intuitive) behaviour.
  
  =back
  
  =head1 DESCRIPTION
  
  IO::Prompter exports a single subroutine, C<prompt>, that prints a
  prompt (but only if the program's selected input and output streams are
  connected to a terminal), then reads some input, then chomps it, and
  finally returns an object representing that text.
  
  The C<prompt()> subroutine expects zero-or-more arguments.
  
  Any argument that starts with a hyphen (C<->) is treated as a named
  option (many of which require an associated value, that may be passed as
  the next argument). See L<"Summary of options"> and L<"Options
  reference"> for details of the available options.
  
  Any other argument that is a string is treated as (part of) the prompt
  to be displayed. All such arguments are concatenated together before the
  prompt is issued. If no prompt string is provided, the string
  C<< '> ' >> is used instead.
  
  Normally, when C<prompt()> is called in either list or scalar context,
  it returns an opaque object that autoconverts to a string. In scalar
  boolean contexts this return object evaluates true if the input
  operation succeeded. In list contexts, if the input operation fails
  C<prompt()> returns an empty list instead of a return object. This
  allows failures in list context to behave correctly (i.e. be false).
  
  If you particularly need a list-context call to C<prompt()> to always
  return a value (i.e. even on failure), prefix the call with C<scalar>:
  
      # Only produces as many elements
      # as there were successful inputs...
      my @data = (
          prompt(' Name:'),
          prompt('  Age:'),
          prompt('Score:'),
      );
  
      # Always produces exactly three elements
      # (some of which may be failure objects)...
      my @data = (
          scalar prompt(' Name:'),
          scalar prompt('  Age:'),
          scalar prompt('Score:'),
      );
  
  In void contexts, C<prompt()> still requests input, but also issues a
  warning about the general uselessness of performing an I/O operation
  whose results are then immediately thrown away.
  See L<"Useful useless uses of C<prompt()>"> for an exception to this.
  
  The C<prompt()> function also sets C<$_> if it is called in a boolean
  context but its return value is not assigned to a variable. Hence, it is
  designed to be a drop-in replacement for C<readline> or C<< <> >>.
  
  =head1 INTERFACE
  
  All the options for C<prompt()> start with a hyphen (C<->).
  Most have both a short and long form. The short form is always
  the first letter of the long form.
  
  Most options have some associated value. For short-form options, this
  value is specified as a string appended to the option itself. The
  associated value for long-form options is always specified as a
  separated argument, immediately following the option (typically
  separated from it by a C<< => >>).
  
  Note that this implies that short-form options may not be able to
  specify every possible associated value (for example, the short-form
  C<-d> option cannot specify defaults with values C<'efault'> or
  C<'$%^!'>).  In such cases, just use the long form of the option
  (for example: S<< C<< -def => 'efault' >> >> or C<< -default=>'$%^!' >>).
  
  
  =head2 Summary of options
  
  Note: For options preceded by an asterisk, the short form is actually
  a Perl file operator, and hence cannot be used by itself.
  Either use the long form of these options,
  or L<bundle them with another option|"Bundling short-form options">,
  or add a L<"no-op"|"Escaping otherwise magic options"> to them.
  
  
      Short   Long
      form    form               Effect
      =====   =============      ======================================
  
      -a      -argv              Prompt for @ARGV data if !@ARGV
  
              -cancel=>SPEC      Immediately fail if input char smartmatches value
  
              -comp[lete]=>SPEC  Complete input on <TAB>, as specified
  
      -dSTR   -def[ault]=>STR    What to return if only <ENTER> typed
              -DEF[AULT]=>STR    (as above, but skip any -must checking)
  
    * -e[STR] -echo=>STR         Echo string for each character typed
  
              -echostyle=>SPEC   What colour/style to echo input in
  
    * -f      -filenames         Input should be name of a readable file
  
              -fail=>VALUE       Return failure if completed input smartmatches value
  
              -guar[antee]=>SPEC Only allow the specified words to be entered
  
      -h[STR] -hist[ory][=>SPEC] Specify the history set this call belongs to
  
              -in=>HANDLE        Read from specified handle
  
      -i      -integer[=>SPEC]   Accept only valid integers (that smartmatch SPEC)
  
      -k      -keyletters        Accept only keyletters (as specified in prompt)
  
    * -l      -line              Don't autochomp
  
              -menu=>SPEC        Specify a menu of responses to be displayed
  
              -must=>HASHREF     Specify requirements/constraints on input
  
              -monitor=>SUBREF   Specify a sub to be called on every character input
  
      -n      -num[ber][=>SPEC]  Accept only valid numbers (that smartmatch SPEC)
  
              -out=>HANDLE       Prompt to specified handle
  
              -prefill=>STR      Start with the specified string pre-entered
  
              -prompt=>STR       Specify prompt explicitly
  
    * -rSTR   -ret[urn]=>STR     After input, echo this string instead of <CR>
  
    * -s -1   -sing[le]          Return immediately after first key pressed
  
              -stdio             Use STDIN and STDOUT for prompting
  
              -style=>SPEC       What colour/style to display the prompt text in
  
      -tNUM   -time[out]=>NUM    Specify a timeout on the input operation
  
      -v      -verb[atim]        Return the input string (no context sensitivity)
  
              -void              Don't complain in void context
  
    * -w      -wipe              Clear screen
              -wipefirst         Clear screen on first prompt() call only
  
    * -y      -yes    [=> NUM]   Return true if [yY] entered, false otherwise
      -yn     -yesno  [=> NUM]   Return true if [yY] entered, false if [nN]
      -Y      -Yes    [=> NUM]   Return true if Y entered, false otherwise
      -YN     -YesNo  [=> NUM]   Return true if Y entered, false if N
  
    * -_                         No-op (handy for bundling ambiguous short forms)
  
  
  =head2 Automatic options
  
  Any of the options listed above (and described in detail below) can be
  automatically applied to every call to C<prompt()> in the current
  lexical scope, by passing them (via an array reference) as the arguments
  to a C<use IO::Prompter> statement.
  
  For example:
  
      use IO::Prompter;
  
      # This call has no automatically added options...
      my $assent = prompt "Do you wish to take the test?", -yn;
  
      {
          use IO::Prompter [-yesno, -single, -style=>'bold'];
  
          # These three calls all have: -yesno, -single, -style=>'bold' options
          my $ready = prompt 'Are you ready to begin?';
          my $prev  = prompt 'Have you taken this test before?';
          my $hints = prompt 'Do you want hints as we go?';
      }
  
      # This call has no automatically added options...
      scalar prompt 'Type any key to start...', -single;
  
  The current scope's lexical options are always I<prepended> to the
  argument list of any call to C<prompt()> in that scope.
  
  To turn off any existing automatic options for the rest of the current
  scope, use:
  
      use IO::Prompter [];
  
  
  =head2 Prebound options
  
  You can also ask IO::Prompter to export modified versions of C<prompt()>
  with zero or more options prebound. For example, you can request an
  C<ask()> subroutine that acts exactly like C<prompt()> but has the C<-
  yn> option pre-specified, or a C<pause()> subroutine that is C<prompt()>
  with a "canned" prompt and the C<-echo>, C<-single>, and C<-void> options.
  
  To specify such subroutines, pass a single hash reference when
  loading the module:
  
      use IO::Prompter {
          ask     => [-yn],
          pause   => [-prompt=>'(Press any key to continue)', -echo, -single, -void],
      }
  
  Each key will be used as the name of a separate subroutine to be
  exported, and each value must be an array reference, containing the
  arguments that are to be automatically supplied.
  
  The resulting subroutines are simply lexically scoped wrappers around
  C<prompt()>, with the specified arguments prepended to the normal
  argument list, equivalent to something like:
  
      my sub ask {
          return prompt(-yn, @_);
      }
  
      my sub pause {
          return prompt(-prompt=>'(Press any key to continue)', -echo, -single, -void, @_);
      }
  
  Note that these subroutines are lexically scoped, so if you want to use
  them throughtout a source file, they should be declared in the outermost
  scope of your program.
  
  
  =head2 Options reference
  
  =head3 Specifying what to prompt
  
  =over 4
  
  C<< -prompt => I<STRING> >>
  
  C<< -pI<STRING> >>
  
  =back
  
  By default, any argument passed to C<prompt()> that does not begin with
  a hyphen is taken to be part of the prompt string to be displayed before
  the input operation. Moreover, if no such string is specified in the
  argument list, the function supplies a default prompt (C<< '> ' >>)
  automatically.
  
  The C<-prompt> option allows you to specify a prompt explicitly, thereby
  enabling you to use a prompt that starts with a hyphen:
  
      my $input
          = prompt -prompt=>'-echo';
  
  or to disable prompting entirely:
  
      my $input
          = prompt -prompt => "";
  
  Note that the use of the C<-prompt> option doesn't override other string
  arguments, it merely adds its argument to the collective prompt.
  
  =head4 Prompt prettification
  
  If the specified prompt ends in a non-whitespace character, C<prompt()>
  adds a single space after it, to better format the output. On the other
  hand, if the prompt ends in a newline, C<prompt()> removes that
  character, to keep the input position on the same line as the prompt.
  
  You can use that second feature to override the first, if necessary. For
  example, if you wanted your prompt to look like:
  
      Load /usr/share/dict/_
  
  (where the _ represents the input cursor), then a call like:
  
      $filename = prompt 'Load /usr/share/dict/';
  
  would not work because it would automatically add a space, producing:
  
      Load /usr/share/dict/ _
  
  But since a terminal newline is removed, you could achieve the desired effect
  with:
  
      $filename = prompt "Load /usr/share/dict/\n";
  
  If for some reason you I<do> want a newline at the end of the prompt (i.e.
  with the input starting on the next line) just put two newlines at the end
  of the prompt. Only the very last one will be removed.
  
  
  =head3 Specifying how the prompt looks
  
  =over 4
  
  C<< -style  => I<SPECIFICATION> >>
  
  =back
  
  If the C<Term::ANSIColor> module is available, this option can be used
  to specify the colour and styling (e.g. bold, inverse, underlined, etc.)
  in which the prompt is displayed.
  
  You can can specify that styling as a single string:
  
      prompt 'next:' -style=>'bold red on yellow';
  
  or an array of styles:
  
      prompt 'next:' -style=>['bold', 'red', 'on_yellow'];
  
  The range of styles and colour names that the option understands is
  quite extensive. All of the following work as expected:
  
      prompt 'next:' -style=>'bold red on yellow';
  
      prompt 'next:' -style=>'strong crimson on gold';
  
      prompt 'next:' -style=>'highlighted vermilion, background of cadmium';
  
      prompt 'next:' -style=>'vivid russet over amber';
  
      prompt 'next:' -style=>'gules fort on a field or';
  
  However, because C<Term::ANSIColor> sometmes maps everything back to the
  standard eight ANSI text colours and seven ANSI text styles, all of the
  above may also be rendered identically. See that module's
  documentation for details.
  
  If C<Term::ANSIColor> is not available, this option is silently ignored.
  
  Please bear in mind that up to 10% of people using your interface will
  have some form of colour vision impairment, so its always a good idea
  to differentiate information by style I<and> colour, rather than by colour
  alone. For example:
  
      if ($dangerous_action) {
          prompt 'Really proceed?', -style=>'bold red underlined';
      }
      else {
          prompt 'Proceed?', -style=>'green';
      }
  
  Also bear in mind that (even though C<-style> does support the C<'blink'>
  style) up to 99% of people using your interface will have Flashing Text
  Tolerance Deficiency. Just say "no".
  
  
  =head3 Specifying where to prompt
  
  =over 4
  
  C<< -out => FILEHANDLE >>
  
  C<< -in => FILEHANDLE >>
  
  C<< -stdio >>
  
  =back
  
  The C<-out> option (which has no short form) is used to specify
  where the prompt should be written to. If this option is not specified,
  prompts are written to the currently C<select>-ed filehandle. The most
  common usage is:
  
      prompt(out => *STDERR)
  
  The C<-in> option (which also has no short form) specifies where the input
  should be read from. If this option is not specified, input is read from
  the C<*ARGV> filehandle. The most common usage is:
  
      prompt(in => *STDIN)
  
  in those cases where C<*ARGV> has been opened to a file, but you still
  wish to interact with the terminal (assuming C<*STDIN> is opened to that
  terminal).
  
  The C<-stdio> option (which again has no short form) is simply a shorthand
  for: C<< -in => *STDIN, -out => *STDOUT >>. This is particularly useful when
  there are arguments on the commandline, but you don't want prompt to treat
  those arguments as filenames for magic C<*ARGV> reads.
  
  
  =head3 Specifying how long to wait for input
  
  =over 4
  
  C<< -timeout => I<N> >>
  
  C<< -tI<N> >>
  
  =back
  
  Normally, the C<prompt()> function simply waits for input. However,
  you can use this option to specify a timeout on the read operation.
  If no input is received within the specified I<N> seconds, the call
  to C<prompt()> either returns the value specified by
  L<the C<-default> option|"Specifying what to return by default">
  (if any), or else an object indicating the read failed.
  
  Note that, if the short form is used, I<N> must be an integer. If the long
  form is used, I<N> may be an integer or floating point value.
  
  You can determine whether an input operation timed out, even if a
  default value was returned, by calling the C<timedout()> method on the
  object returned by C<prompt()>:
  
      if (prompt('Continue?', -y1, -timeout=>60) && !$_->timedout) {
          ...
      }
  
  If a time-out occurred, the return value of C<timedout()> is a string
  describing the timeout, such as:
  
      "timed out after 60 seconds"
  
  
  =head3 Prefilling the input
  
  =over
  
  =item C<< -prefill => I<STRING> >>
  
  =back
  
  Normally, the cursor is placed immediately after the prompt
  in preparation for input. Initially, of course, there is no input.
  
  However, using the C<-prefill> option it is possible to initialize
  the input buffer with an arbitrary string of text (rather than the
  usual empty string)...as if that text had already been entered.
  
  This is useful when a prompt is re-issued so as to allow the user
  to extend, truncate, or otherwise edit a previous input.
  
  
  =head3 Providing a menu of responses
  
  =over
  
  =item C<< -menu => I<SPECIFICATION> >>
  
  =back
  
  You can limit the allowable responses to a prompt, by providing a menu.
  
  A menu is specified using the C<-menu> option, and the menu choices
  are specified as an argument to the option, either as a reference to
  an array, hash, or string, or else as a literal string.
  
  If the menu is specified in a hash, C<prompt()> displays the keys of the
  hash, sorted alphabetically, and with each alternative marked with a
  single alphabetic character (its "selector key").
  
  For example, given:
  
      prompt 'Choose...',
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will display:
  
      Choose...
          a. die
          b. live free
          c. transcend
      > _
  
  It will then only permit the user to enter a valid selector key (in the
  previous example: 'a', 'b', or 'c'). Once one of the alternatives is
  selected, C<prompt()> will return the corresponding value from the hash
  (0, 1, or -1, respectively, in this case).
  
  Note that the use of alphabetics as selector keys inherently limits the
  number of usable menu items to 52. See L<"Numeric menus"> for a way to
  overcome this limitation.
  
  A menu is treated like a special kind of prompt, so that any
  other prompt strings in the C<prompt()> call will appear either before or
  after the menu of choices, depending on whether they appear before or
  after the menu specification in the call to C<prompt()>.
  
  If an array is used to specify the choices:
  
      prompt 'Choose...',
             -menu=>[ 'live free', 'die', 'transcend' ],
             '>';
  
  then each array element is displayed (in the original array order) with
  a selector key:
  
      Choose...
          a. live free
          b. die
          c. transcend
      > _
  
  and C<prompt()> returns the element corresponding to the selection (i.e.
  it returns 'live free' if 'a' is entered, 'die' if 'b' is entered, or
  'transcend' if 'c' is entered).
  
  Hence, the difference between using an array and a hash is that the
  array allows you to control the order of items in the menu, whereas a
  hash allows you to show one thing (i.e. keys) but have something related
  (i.e. values) returned instead.
  
  If the argument after C<-menu> is a string or a reference to a string, the
  option splits the string on newlines, and treats the resulting list as if it
  were an array of choices. This is useful, for example, to request the user
  select a filename:
  
      my $files = `ls`;
      prompt 'Select a file...', -menu=>$files, '>';
  
  
  =head4 Numbered menus
  
  As the previous examples indicate, each menu item is given a unique
  alphabetic selector key. However, if the C<-number> or C<-integer>
  option is specified as well:
  
      prompt 'Choose...',
             -number,
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will number each menu item instead, using consecutive integers
  as the selector keys:
  
      Choose...
          1. die
          2. live free
          3. transcend
      > _
  
  This allows for an unlimited number of alternatives in a single menu,
  but prevents the use of C<-single> for one-key selection from menus if
  the menu has more than nine items.
  
  
  =head4 Hierarchical menus
  
  If you use a hash to specify a menu, the values of the hash do not have
  to be strings. Instead, they can be references to nested hashes or
  arrays.
  
  This allows you to create hierarchical menus, where a selection at the
  top level may lead to a secondary menu, etc. until an actual choice is
  possible. For example, the following call to prompt:
  
      my $choices = {
          animates => {
              animals => {
                  felines => [qw<cat lion lynx>],
                  canines => [qw<dog fox wolf>],
                  bovines => [qw<cow ox buffalo>],
              },
              fish => [qw<shark carp trout bream>],
          },
          inanimates => {
              rocks     => [qw<igneous metamorphic sedimentary>],
              languages => [qw<Perl Python Ruby Tcl>],
          },
      };
  
      my $result = prompt -1, 'Select a species...', -menu=>$choices, '> ';
  
  might result in an interaction like this:
  
      Select a species...
      a.  animates
      b.  inanimates
      > a
  
      Select from animates:
      a.  animals
      b.  fish
      > b
  
      Select from fish:
      a.  shark
      b.  carp
      c.  trout
      d.  bream
      > c
  
  At which point, C<prompt()> would return the string C<'trout'>.
  
  Note that you can nest an arbitrary number of hashes, but that each
  "bottom" level choice has to be either a single string, or an array
  of strings.
  
  
  =head4 Navigating hierarchical menus
  
  Within a hierarchical menu, the user must either select a valid option
  (by entering the corresponding letter), or else may request that they be
  taken back up a level in the hierarchy, by entering C<< <ESC> >>.
  Pressing C<< <ESC> >> at the top level of a menu causes the call to
  C<prompt()> to immediately return with failure.
  
  
  =head3 Simulating a command-line
  
  =over 4
  
  C<< -argv >>
  
  C<< -a  >>
  
  =back
  
  The C<prompt()> subroutine can be used to request that the user provide
  command-line arguments interactively. When requested, the input
  operation is only carried out if C<@ARGV> is empty.
  
  Whatever the user enters is broken into a list and assigned to C<@ARGV>.
  
  The input is first C<glob>bed for file expansions, and has any
  environment variables (of the form C<$VARNAME> interpolated). The
  resulting string is then broken into individual words, except where
  parts of it contain single or double quotes, the contents of which are
  always treated as a single string.
  
  This feature is most useful during development, to allow a program to be
  run from within an editor, and yet pass it a variety of command-lines. The
  typical usage is (at the start of a program):
  
      use IO::Prompter;
      BEGIN { prompt -argv }
  
  However, because this pattern is so typical, there is a shortcut:
  
      use IO::Prompter -argv;
  
  You can also specify the name with which the program args, are to
  be prompted, in the usual way (i.e. by providing a prompt):
  
      use IO::Prompter -argv, 'demo.pl';
  
  Note, however, the critical difference between that shortcut
  (which calls C<prompt -argv> when the module is loaded) and:
  
      use IO::Prompter [-argv];
  
  (which sets C<-argv> as an automatic option for every subsequent call to
  C<prompt()> in the current lexical scope).
  
  Note too that the C<-argv> option also implies C<-complete=>'filenames'>.
  
  
  =head3 Input autocompletion
  
  =over 4
  
  C<< -comp[lete] => I<SPECIFICATION> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will complete
  input using the specified collection of strings. By default, when
  completion is active, word completion is requested using the C<< <TAB> >>
  key, but this can be changed by setting the C<$IO_PROMPTER_COMPLETE_KEY>
  environment variable. Once completion has been initiated, you can use
  the completion key or else C<< <CTRL-N> >> to advance to the next completion
  candidate. You can also use C<< <CTRL-P> >> to back up to the previous
  candidate.
  
  The specific completion mechanism can be defined either using a
  subroutine, an array reference, a hash reference, or a special string:
  
      Specification       Possible completions supplied by...
  
        sub {...}         ...whatever non-subroutine specification
                          (as listed below) is returned when the
                          subroutine is called. The subroutine is passed
                          the words of the current input text, split on
                          whitespace, as its argument list.
  
          [...]           ...the elements of the array
  
          {...}           ...the keys of the hash
  
       'filenames'        ...the list of files supplied by globbing the
                          last whitespace-separated word of the input text
  
       'dirnames'         ...the list of directories supplied by globbing the
                          last whitespace-separated word of the input text
  
  If an array or hash is used, only those elements or keys that begin with
  the last whitespace-separated word of the current input are offered as
  completions.
  
  For example:
  
      # Complete with the possible commands...
      my $next_cmd
          = prompt -complete => \%cmds;
  
      # Complete with valid usernames...
      my $user
          = prompt -complete => \@usernames;
  
      # Complete with valid directory names...
      my $file
          = prompt -complete => 'dirnames';
  
      # Complete with cmds on the first word, and filenames on the rest...
      my $cmdline
          = prompt -complete => sub { @_ <= 1 ? \%cmds : 'filenames' };
  
  
  =head4 Completing from your own input history
  
  The C<prompt()> subroutine also tracks previous input and allows you to
  complete with that instead. No special option is required, as the
  feature is enabled by default.
  
  At the start of a prompted input, the user can cycle backwards through
  previous inputs by pressing C<< <CTRL-R> >> (this can be changed
  externally by setting the C<$IO_PROMPTER_HISTORY_KEY> environment
  variable, or internally by assigning a new keyname to
  C<$ENV{IO_PROMPTER_HISTORY_KEY}>). After the first C<< <CTRL-R> >>,
  subsequent C<< <CTRL-R> >>'s will recall earlier inputs. You can also
  use C<< <CTRL-N> >> and C<< <CTRL-P> >>
  (as in L<user-specified completions|"Input autocompletion">) to move
  back and forth through your input history.
  
  If the user has already typed some input, the completion mechanism
  will only show previous inputs that begin with that partial input.
  
  
  =head4 History sets
  
  =over 4
  
  =item C<< -h[NAME] >>
  
  =item C<< -hist[ory] [=> NAME] >>
  
  =back
  
  By default, IO::Prompter tracks every call to C<prompt()> within a
  program, and accumulates a single set of history completions for all of
  them. That means that, at any prompt, C<< <CTRL-R> >> will take the user
  back through I<every> previous input, regardless of which call to
  C<prompt()> originally retrieved it.
  
  Sometimes that's useful, but sometimes you might prefer that different
  calls to C<prompt()> retained distinct memories. For example, consider
  the following input loop:
  
      while (my $name = prompt 'Name:') {
          my $grade   = prompt 'Grade:', -integer;
          my $comment = prompt 'Comment:';
          ...
      }
  
  If you're entering a name, there's no point in C<prompt()> offering
  to complete it with previous grades or comments. In fact, that's
  just annoying.
  
  IO::Prompter allows you to specify that a particular call to
  C<prompt()> belongs to a particular "history set". Then it completes
  input history using only the history of those calls belonging to the
  same history set.
  
  So the previous example could be improved like so:
  
      while (my $name = prompt 'Name:', -hNAME) {
          my $grade   = prompt 'Grade:', -hGRADE, -integer;
          my $comment = prompt 'Comment:', -hOTHER;
          ...
      }
  
  Now, when prompting for a name, only those inputs in the C<'NAME'>
  history set will be offered as history completions. Likewise only
  previous grades will be recalled when prompting for grades and earlier
  only comments when requesting comments.
  
  If you specify the C<-h> or C<-history> option without providing the
  name of the required history set, C<prompt()> uses the prompt text
  itself as the name of the call's history set. So the previous example
  would work equally well if written:
  
      while (my $name = prompt 'Name:', -h) {
          my $grade   = prompt 'Grade:', -h, -integer;
          my $comment = prompt 'Comment:', -h;
          ...
      }
  
  though now the names of the respective history sets would now be
  C<'Name: '>, C<'Grade: '>, and C<'Comment: '>. This is by far the more
  common method of specifying history sets, with explicitly named sets
  generally only being used when two or more separate calls to
  C<prompt()> have to share a common history despite using distinct
  prompts. For example:
  
      for my $n (1..3) {
          $address .= prompt "Address (line $n):", -hADDR;
      }
  
  If you specify C<'NONE'> as the history set, the input is not
  recorded in the history. This is useful when inputting passwords.
  
  
  =head4 Configuring the autocompletion interaction
  
  By default, when user-defined autocompletion is requested, the
  C<prompt()> subroutine determines the list of possible completions,
  displays it above the prompt, and completes to the longest common
  prefix. If the completion key is pressed again immediately, the
  subroutine then proceeds to complete with each possible completion in a
  cyclic sequence. This is known as "list+longest full" mode.
  
  On the other hand, when historical completion is requested, C<prompt()>
  just immediately cycles through previous full inputs. This is known as "full"
  mode.
  
  You can change these behaviours by setting the
  C<$IO_PROMPTER_COMPLETE_MODES> and C<$IO_PROMPTER_HISTORY_MODES>
  environment variables I<before the module is loaded> (either in your shell,
  or in a C<BEGIN> block before the module is imported).
  
  Specifically, you can set the individual string values of either of
  these variables to a whitespace-separated sequence containing any of the
  following:
  
      list         List all options above the input line
  
      longest      Complete to the longest common prefix
  
      full         Complete with each full match in turn
  
  For example:
  
      # Just list options without actually completing...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'list'; }
  
      # Just cycle full alternatives on each <TAB>...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'full'; }
  
      # For history completion, always start with the
      # longest common prefix on the first <CTRL-R>,
      # then just list the alternatives on a subsequent press...
      BEGIN{ $ENV{IO_PROMPTER_HISTORY_MODES} = 'longest list'; }
  
  
  =head3 Specifying what to return by default
  
  =over
  
  C<< -DEF[AULT] => I<STRING> >>
  
  C<< -def[ault] => I<STRING> >>
  
  C<< -dI<STRING> >>
  
  =back
  
  If a default value is specified, that value will be returned if the user
  enters an empty string at the prompt (i.e. if they just hit
  C<< <ENTER>/<RETURN> >> immediately) or if the input operation times out under
  L<the C<timeout> option|"Specifying how long to wait for input">.
  
  Note that the default value is not added to the prompt, unless you
  do so yourself. A typical usage might therefore be:
  
      my $frequency
          = prompt "Enter polling frequency [default: $DEF_FREQ]",
                   -num, -def=>$DEF_FREQ;
  
  You can determine if the default value was autoselected (as opposed to
  the same value being typed in explicitly) by calling the C<defaulted()>
  method on the object returned by C<prompt()>, like so:
  
      if ($frequency->defaulted) {
          say "Using default frequency";
      }
  
  If you use the L<< C<-must> option|"Constraining what can be returned" >>
  any default value must also satisfy all the constraints you specify,
  unless you use the C<-DEFAULT> form, which skips constraint checking
  when the default value is selected.
  
  If you use the L<< C<-menu> option|"Providing a menu of responses" >>,
  the specified default value will be returned immediately C<< <ENTER>/<RETURN> >> is
  pressed, regardless of the depth you are within the menu. Note that the
  default value specifies the value to be returned, not the selector key
  to be entered. The default value does not even have to be one of the
  menu choices.
  
  
  =head3 Specifying what to echo on input
  
  =over
  
  C<< -echo => I<STR> >>
  
  C<< -eI<STR> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will echo the
  specified string once for each character that is entered. Typically this
  would be used to shroud a password entry, like so:
  
      # Enter password silently:
      my $passwd
          = prompt 'Password:', -echo=>"";
  
      # Echo password showing only asterisks:
      my $passwd
          = prompt 'Password:', -echo=>"*";
  
  As a special case, if the C<-echo> value contains a slash (C</>) and the
  any of the <-yesno> options is also specified, the substring before the
  slash is taken as the string to echo for a 'yes' input, and the
  substring after the slash is echoed for a 'no' input.
  
  Note that this option is only available when the Term::ReadKey module
  is installed. If it is used when that module is not available, a warning
  will be issued.
  
  
  =head4 Specifying how to echo on input
  
  C<< -echostyle => I<SPECIFICATION> >>
  
  The C<-echostyle> option works for the text the user types in
  the same way that the C<-style> option works for the prompt.
  That is, you can specify the style and colour in which the user's
  input will be rendered like so:
  
      # Echo password showing only black asterisks on a red background:
      my $passwd
          = prompt 'Password:', -echo=>"*", -echostyle=>'black on red';
  
  Note that C<-echostyle> is completely independent of C<-echo>:
  
      # Echo user's name input in bold white:
      my $passwd
          = prompt 'Name:', -echostyle=>'bold white';
  
  The C<-echostyle> option requires C<Term::ANSIColor>, and will
  be silently ignored if that module is not available.
  
  
  =head4 Input editing
  
  When the Term::ReadKey module is available, C<prompt()> also honours a
  subset of the usual input cursor motion commands:
  
  =over
  
  =item C<CTRL-B>
  
  Move the cursor back one character
  
  =item C<CTRL-F>
  
  Move the cursor forward one character
  
  =item C<CTRL-A>
  
  Move the cursor to the start of the input
  
  =item C<CTRL-E>
  
  Move the cursor to the end of the input
  
  =back
  
  
  =head3 Specifying when input should fail
  
  =over 4
  
  C<< -fail => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, the final input value is compared with the
  associated string or value, by smartmatching just before the call to
  C<prompt()> returns. If the two match, C<prompt()> returns a failure
  value. This means that instead of writing:
  
      while (my $cmd = prompt '>') {
          last if $cmd eq 'quit';
          ...
      }
  
  you can just write:
  
      while (my $cmd = prompt '>', -fail=>'quit') {
          ...
      }
  
  
  =head3 Specifying when input should fail immediately
  
  =over 4
  
  C<< -cancel => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, then each individual input character is compared
  with the associated string or value, by smartmatching during the input process.
  If any individual input character matches the string/value, C<prompt()>
  immediately returns a failure value.
  
  Note that this is not the same as the behaviour C<-fail> option. A C<-fail>
  waits for the entire input to be completed (typically for a RETURN to be entered)
  and I<then> tests for failure. A C<-cancel> tests each input character as it is
  entered and fails immediately if any input matches the cancellation condition.
  
  Do, for example, to cancel a prompt whenever an ESCAPE character is entered:
  
      my $input = prompt '>', -cancel => "\e";
  
  Note that (as long as Term::ReadKey is available) the cancellation test
  is performed before any other internal processing, so you can set the
  cancellation criterion to be any character, including characters like CNTL-A or
  TAB, which otherwise have special meanings to C<prompt()>.
  
  Note too that the cancellation criterion is tested against each individual
  character as it is entered, B<not> against the cumulative input so far.
  If you need to cancel a call to C<prompt()> based on accumulated input,
  you need to track that yourself. For example, if your cancellation test
  is the presence of three consecutive exclamation marks:
  
      my $input = prompt '>', -cancel => sub ($nextchar) {
                                  state $input;
                                  $input .= $nextchar;
                                  return $input =~ /!!!/;
                              };
  
  
  =head3 Constraining what can be typed
  
  =over 4
  
  =item C<< -guar[antee] => SPEC >>
  
  =back
  
  This option allows you to control what input users can provide.
  The specification can be a regex or a reference to an array or a hash.
  
  If the specification is a regex, that regex is matched against the input
  so far, every time an extra character is input. If the regex ever fails
  to match, the guarantee fails.
  
  If the specification is an array, the input so far is matched against
  the same number of characters from the start of each of the (string)
  elements of the array. If none of these substrings match the input, the
  guarantee fails.
  
  If the specification is a hash, the input so far is matched against the
  same number of characters from the start of each key of the hash. If
  none of these substrings match the input, the guarantee fails.
  
  If the guarantee fails, the input is rejected
  (just as L<< the C<-must> option|"Constraining what can be returned" >>
  does). However, unlike C<-must>, C<-guarantee> rejects the input
  character-by-character as it typed, and I<before> it is even echoed. For
  example, if your call to C<prompt()> is:
  
      my $animal = prompt -guarantee=>['cat','dog','cow'];
  
  then at the prompt:
  
      > _
  
  you will only be able to type in 'c' or 'd'. If you typed 'c', then you would
  only be able to type 'a' or 'o'. If you then typed 'o', you would only be able
  to type 'w'.
  
  In other words, C<-guarantee> ensures that you can only type in a valid input,
  and simply ignores any typing that would not lead to such an input.
  
  To help users get the input right, specifying C<-guarantee> as an array
  or hash reference also automatically specifies a
  L<< C<-complete> option|"Input autocompletion" >> with the array or hash
  as its completion list as well. So, whenever a C<-guarantee> is in
  effect, the user can usually autocomplete the acceptable inputs.
  
  Note, however, that C<-guarantee> can only reject (or autocomplete)
  input as it is typed if the Term::ReadKey module is available. If that
  module cannot be loaded, C<-guarantee> only applies its test after the
  C<< <ENTER>/<RETURN> >> key is pressed, and there will be no autocompletion
  available.
  
  =head4 Constraining input to numbers
  
  =over 4
  
  =item C<< -i >>
  
  =item C<< -integer [=> SPEC] >>
  
  =item C<< -n  >>
  
  =item C<< -num[ber] [=> SPEC] >>
  
  =back
  
  If any of these options are specified, C<prompt()> will only accept a valid
  integer or number as input, and will reprompt until one is entered.
  
  If you need to restrict the kind of number further (say, to positive
  integers), you can supply an extra constraint as an argument to the
  long-form option. Any number entered must satisfy this constraint by
  successfully smart-matching it. For example:
  
      $rep_count = prompt 'How many reps?', -integer => sub{ $_ > 0 };
  
      $die_roll = prompt 'What did you roll?', -integer => [1..6];
  
      $factor = prompt 'Prime factor:', -integer => \&is_prime;
  
      $score = prompt 'Enter score:', -number => sub{ 0 <= $_ && $_ <= 100 };
  
  If the constraint is specified as a subroutine, the entered number will be
  passed to it both as its single argument and in C<$_>.
  
  You cannot pass a scalar value directly as a constraint, except those strings
  listed below. If you want a scalar value as a constraint, use a regex or
  array reference instead:
  
      # Wrong...
      $answer = prompt "What's the ultimate answer?",
                        -integer => 42;
  
      # Use this instead...
      $answer = prompt "What's the ultimate answer?",
                       -integer => qr/^42$/;
  
      # Or this...
      $answer = prompt "What's the ultimate answer?",
                       -integer => [42];
  
  
  Only the following strings may be passed directly as scalar value
  constraints. They do mot match exactly, but instead act as specifiers
  for one or more built-in constraints. You can also pass a string that
  contains two or more of them, separated by whitespace, in which case
  they must all be satisfied. The specifiers are:
  
  =over 4
  
  =item C<'pos'> or C<'positive'>
  
  The number must be greater than zero
  
  =item C<'neg'> or C<'negative'>
  
  The number must be less than zero
  
  =item C<'zero'>
  
  The number must be equal to zero
  
  =item C<'even'> or C<'odd'>
  
  The number must have the correct parity
  
  =back
  
  You can also prepend C<"non"> to any of the above to reverse their meaning.
  
  For example:
  
      $rep_count = prompt 'How much do you bid?', -number => 'positive';
  
      $step_value = prompt 'Next step:', -integer => 'even nonzero';
  
  
  =head4 Constraining input to filenames
  
  =over 4
  
  =item C<< -f >>
  
  =item C<< -filenames >>
  
  =back
  
  You can tell C<prompt()> to accept only valid filenames, using the
  C<-filenames> option (or its shortcut: C<-f>).
  
  This option is equivalent to the options:
  
      -must => {
          'File must exist'       => sub { -e },
          'File must be readable' => sub { -r },
      },
      -complete => 'filenames',
  
  In other words C<-filenames> requires C<prompt()> to accept only the name
  of an existing, readable file, and it also activates filename completion.
  
  
  =head4 Constraining input to "keyletters"
  
  =over
  
  =item C<< -k >>
  
  =item C<< -key[let[ter]][s] >>
  
  =back
  
  A common interaction is to offer the user a range of actions, each of
  which is specified by keying a unique letter, like so:
  
      INPUT:
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          when (/S/i) { save_file()    }
          default     { goto INPUT;    }
      }
  
  This can be cleaned up (very slightly) by using a guarantee:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S',
                    -guarantee=>qr/[SRD]/i
      ) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  However, it's still annoying to have to specify the three key letters
  twice (and the default choice three times) within the call to
  C<prompt()>. So IO::Prompter provides an option that extracts this
  information directly from the prompt itself:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -keyletters) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  This option scans the prompt string and extracts any purely alphanumeric
  character sequences that are enclosed in balanced brackets of any kind
  (square, angle, round, or curly). It then makes each of these character
  sequences a valid input (by implicitly setting the C<-guarantee>
  option), and adds the first option in square brackets (if any) as the
  C<-default> value of the prompt.
  
  Note that the key letters don't have to be at the start of a word, don't
  have to be a single character, and can be either upper or lower case.
  For example:
  
      my $action = prompt -k, '(S)ave, Save(a)ll, (Ex)it without saving';
  
  Multi-character key letters are often a good choice for options with
  serious or irreversible consequences.
  
  A common idiom with key letters is to use the C<-single> option as well,
  so that pressing any key letter immediately completes the input, without
  the user having to also press C<< <ENTER>/<RETURN> >>:
  
      given (prompt -k1, '[S]ave, (R)evert, or (D)iscard:') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  
  
  =head3 Monitoring input
  
  =over 4
  
  =item C<< -monitor => SUBREF  >>
  
  =back
  
  This option allows you to specify a subroutine that will be called
  after each character is input. This subroutine will be passed
  two arguments: a string containing the input so far, and a hash
  reference containing various options passed into the call to
  C<prompt()> (specifically: C<-prompt>, C<-style>, and C<-echostyle>).
  
  The hashref contains an extra key (C<-cursor_pos>) whose value is the
  current location of the input cursor within the string. This is
  typically one character past the end of the string, but see L<"Input editing">.
  
  The subroutine can perform any actions you choose: set variables, validate input,
  print out a response to each input character.
  
  If the subroutine prints anything out that will, of course, mess up the prompt
  and input echoing, so in that case the prompt will automatically be redrawn.
  The prompt is also redrawn if the monitor subroutine throws an exception.
  
  Monitor subroutines are useful for prvoding extra information during an
  input process. For example, when prompting for a filepath, as the path is
  being typed in you could echo all (partially) matching files
  with something like:
  
      my $path = prompt 'File path:',
                        -monitor => sub ($path, $opts) {
                                       clear_screen();
                                       say for glob("$path*");
                                    };
  
  
  =head3 Preserving terminal newlines
  
  =over 4
  
  =item C<< -l  >>
  
  =item C<< -line >>
  
  =back
  
  The (encapsulated) string returned by C<prompt()> is automatically chomped by
  default. To prevent that chomping, specify this option.
  
  
  =head3 Constraining what can be returned
  
  =over 4
  
  =item C<< -must => HASHREF >>
  
  =back
  
  This option allows you to specify requirements and constraints on the input
  string that is returned by C<prompt()>. These limitations are specified as the
  values of a hash.
  
  If the C<-must> option is specified, once input is complete every value in the
  specified hash is smartmatched against the input text. If any of them fail to
  match, the input is discarded, the corresponding hash key is printed as an
  error message, and the prompt is repeated.
  
  Note that the values of the constraint hash cannot be single strings or
  numbers, except for certain strings (such as C<'pos'>, C<'nonzero'>, or
  C<'even'>, as described in L<"Constraining input to numbers">).
  
  If you want to constrain the input to a single string or number (a very
  unusual requirement), just place the value in an array, or match it
  with a regex:
  
      # This doesn't work...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => 'please' };
  
      # Use this instead...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => ['please'] };
  
      # Or, better still...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => qr/please/i };
  
  
  The C<-must> option allows you to test inputs against multiple
  conditions and have the appropriate error messages for each displayed.
  It also ensures that, when C<prompt()> eventually returns, you are
  guaranteed that the input meets all the specified conditions.
  
  For example, suppose the user is required to enter a positive odd prime
  number less than 100. You could enforce that with:
  
      my $opnlt100 = prompt 'Enter your guess:',
                            -integer,
                            -must => { 'be odd'                 => 'odd',
                                       'be in range'            => [1..100],
                                       'It must also be prime:' => \&isprime,
                                     };
  
  Note that, if the error message begins with anything except an uppercase
  character, the prompt is reissued followed by the error message in
  parentheses with the word "must" prepended (where appropriate).
  Otherwise, if the error message does start with an uppercase character,
  the prompt is not reissued and the error message is printed verbatim. So
  a typical input sequence for the previous example might look like:
  
      Enter your guess: 101
      Enter your guess: (must be in range) 42
      It must also be prime: 2
      Enter your guess: (must be odd) 7
  
  at which point, the call to C<prompt()> would accept the input and return.
  
  See also L<the C<-guarantee> option|"Constraining what can be typed">,
  which allows you to constrain inputs as they are typed, rather than
  after they are entered.
  
  
  =head3 Changing how returns are echoed
  
  =over 4
  
  =item C<< -r[STR] >>
  
  =item C<< -ret[urn] [=> STR] >>
  
  =back
  
  When C<< <ENTER>/<RETURN> >> is pressed, C<prompt()> usually echoes a carriage return.
  However, if this option is given, C<prompt()> echoes the specified string
  instead. If the string is omitted, it defaults to C<"\n">.
  
  For example:
  
      while (1) {
          my $expr = prompt 'Calculate:', -ret=>' = ';
          say evaluate($expr);
      }
  
  would prompt for something like this:
  
      Calculate: 2*3+4^5_
  
  and when the C<< <ENTER>/<RETURN> >> key is pressed, respond with:
  
      Calculate: 2*3+4^5 = 1030
      Calculate: _
  
  The string specified with C<-return> is also automatically echoed if the
  L<< C<-single> option|"Single-character input" >> is used, or if an
  input is cancelled via the
  L<< C<-cancel> option|"Specifying when input should fail immediately" >>.
  So if you don't want the automatic carriage return that C<-single> mode
  or C<-cancel> supplies, specify C<< -return=>"" >>.
  
  
  =head3 Single-character input
  
  =over 4
  
  =item C<< -s >>
  
  =item C<< -1 >>
  
  =item C<< -sing[le] >>
  
  =back
  
  This option causes C<prompt()> to return immediately once any single
  character is input. The user does not have to push the C<< <ENTER>/<RETURN> >>
  key to complete the input operation. C<-single> mode input is only
  available if the Term::ReadKey module can be loaded.
  
  By default, C<prompt()> echoes the single character that is entered. Use
  the L<C<-echo> option|"Specifying what to echo on input"> to change or
  prevent that.
  
      # Let user navigate through maze by single, silent keypresses...
      while ($nextdir = prompt "\n", -single, -echo, -guarantee=>qr/[nsew]/) {
          move_player($nextdir);
      }
  
  Unless echoing has been disabled, by default C<prompt()> also supplies a
  carriage return after the input character. Use
  L<the C<-return> option|"Changing how returns are echoed"> to change
  that behaviour. For example, this:
  
      my $question = <<END_QUESTION;
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer:
      END_QUESTION
  
      my $response = prompt $question, -1, -return=>' is ', -g=>['a'..'d'];
      say $response eq $answer ? 'CORRECT' : 'incorrect';
  
  prompts like this:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: _
  
  accepts a single character, like so:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b_
  
  and completes the line thus:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b is CORRECT
      _
  
  
  =head3 Returning raw data
  
  =over 4
  
  =item C<< -v >>
  
  =item C<< -verb[atim] >>
  
  =back
  
  Normally, C<prompt()> returns a special object that contains the text
  input, the success value, and other information such as whether the
  default was selected and whether the input operation timed out.
  
  However, if you prefer to have C<prompt()> just return the input text string
  directly, you can specify this option.
  
  Note however that, under C<-verbatim>, the input is still
  autochomped (unless you also specify
  L<the C<-line> option|"Preserving terminal newlines">.
  
  
  =head3 Prompting on a clear screen
  
  =over 4
  
  =item C<< -w >>
  
  =item C<< -wipe[first] >>
  
  =back
  
  If this option is present, C<prompt()> prints 1000 newlines before
  printing its prompt, effectively wiping the screen clear of other text.
  
  If the C<-wipefirst> variant is used, the wipe will only occur if the
  particular call to C<prompt()> is the first such call anywhere in your
  program. This is useful if you'd like the screen cleared at the start of
  input only, but you're not sure which call to C<prompt()> will happen
  first: just use C<-wipefirst> on all possible initial calls and only the
  actual first call will wipe the screen.
  
  
  =head3 Requesting confirmations
  
  =over 4
  
  =item C<< -y[n] >> or C<< -Y[N] >>
  
  =item C<< -yes[no] >> or C<< -Yes[No] >>
  
  =item C<< -yes[no] => COUNT >> or C<< -Yes[No] => COUNT >>
  
  =back
  
  This option invokes a special mode that can be used to confirm (or deny)
  something. If one of these options is specified, C<prompt> still
  returns the user's input, but the success or failure of the object returned
  now depends on what the user types in.
  
  A true result is returned if C<'y'> is the first character entered. If
  the flag includes an C<n> or C<N>, a false result is returned if C<'n'>
  is the first character entered (and any other input causes the prompt to
  be reissued). If the option doesn't contain an C<n> or C<N>, any input
  except C<'y'> is treated as a "no" and a false value is returned.
  
  If the option is capitalized (C<-Y> or C<-YN>), the first letter of the
  input must be likewise a capital (this is a handy means of slowing down
  automatic unthinking C<y>..."Oh no!" responses to potentially serious
  decisions).
  
  This option is most often used in conjunction with the C<-single> option, like
  so:
  
      $continue = prompt("Continue? ", -yn1);
  
  so that the user can just hit C<y> or C<n> to continue, without having to hit
  C<< <ENTER>/<RETURN> >> as well.
  
  If the optional I<COUNT> argument is supplied, the prompting is repeated
  that many times, with increasingly insistent requests for confirmation.
  The answer must be "yes" in each case for the final result to be true.
  For example:
  
      $rm_star = prompt("Do you want to delete all files? ", -Yes=>3 );
  
  might prompt:
  
      Do you want to delete all files?  Y
      Really?  Y
      Are you sure?  Y
  
  
  
  =head3 Bundling short-form options
  
  You can bundle together any number of short-form options, including those that
  take string arguments. For example, instead of writing:
  
      if (prompt "Continue? ", -yes, -1, -t10, -dn) {
  
  you could just write:
  
      if (prompt "Continue? ", -y1t10dn) {...}
  
  This often does I<not> improve readability (as the preceding example
  demonstrates), but is handy for common usages such as C<-y1> ("ask for
  confirmation, don't require an C<< <ENTER>/<RETURN> >>) or C<-vl>
  ("Return a verbatim and unchomped string").
  
  
  =head3 Escaping otherwise-magic options
  
  =over 4
  
  C<< -_ >>
  
  =back
  
  The C<-_> option exists only to be an explicit no-op. It allows you to
  specify short-form options that would otherwise be interpreted as Perl
  file operators or other special constructs, simply by prepending or
  appending a C<_> to them. For example:
  
      my $input
          = prompt -l_;  # option -l, not the -l file operator.
  
  The following single-letter options require an underscore to chaperone them
  when they're on their own: C<-e>, C<-l>, C<-r>, C<-s>, C<-w>, and C<-y>.
  However, an underscore is not required if two or more are bundled together.
  
  
  =head2 Useful useless uses of C<prompt()>
  
  Normally, in a void context, a call to C<prompt()> issues a warning that
  you are doing an input operation whose input is immediately thrown away.
  
  There is, however, one situation where this useless use of C<prompt()> in a
  void context is actually useful:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single);
      exit;
  
  Here, we're using prompt simply to pause the application after the data is
  printed. It doesn't matter what the user types in; the typing itself is the
  message (and the message is "move along").
  
  In such cases, the "useless use..." warning can be suppressed using the
  C<< -void >> option:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single, -void);
      exit;
  
  
  =head2 Simulating input
  
  IO::Prompter provides a mechanism with which you can "script" a sequence of
  inputs to an application. This is particularly useful when demonstrating
  software during a presentation, as you do not have to remember what to type,
  or concentrate on typing at all.
  
  If you pass a string as an argument to C<use IO::Prompter>, the
  individual lines of that string are used as successive input lines to
  any call to C<prompt()>. So for example, you could specify several sets
  of input data, like so:
  
      use IO::Prompter <<END_DATA
      Leslie
      45
      165
      Jessie
      28
      178
      Dana
      12
      120
      END_DATA
  
  and then read this data in an input loop:
  
      while (my $name   = prompt 'Name:') {
             my $age    = prompt 'Age:';
             my $height = prompt 'Height:';
  
             process($name, $age, $height);
      }
  
  Because the C<use IO::Prompter> supplies input data,
  the three calls to C<prompt()> will no longer read
  data from C<*ARGV>. Instead they will read it from
  the supplied input data.
  
  Moreover, each call to C<prompt()> will simulate the typing-in process
  automatically. That is, C<prompt()> uses a special input mode where,
  each time you press a keyboard letter, it echoes not that character, but
  rather the next character from the specified input. The effect is that
  you can just type on the keyboard at random, but have the correct input
  appear. This greatly increases the convincingness of the simulation.
  
  If at any point, you hit C<< <ENTER>/<RETURN> >> on the keyboard, C<prompt()>
  finishes typing in the input for you (using a realistic typing speed),
  and returns the input string. So you can also just hit C<< <ENTER>/<RETURN> >>
  when the prompt first appears, to have the entire line of input typed
  for you.
  
  Alternatively, if you hit C<< <ESC> >> at any point, C<prompt()> escapes
  from the simulated input mode for that particular call to C<prompt()>,
  and allows you to (temporarily) type text in directly. If you enter only
  a single C<< <ESC> >>, then C<prompt()> throws away the current line of
  simulated input; if you enter two C<< <ESC> >>'s, the simulated input is
  merely deferred to the next call to C<prompt()>.
  
  All these keyboard behaviours require the Term::ReadKey module to be
  available. If it isn't, C<prompt()> falls back on a simpler simulation,
  where it just autotypes each entire line for you and pauses at the
  end of the line, waiting for you to hit C<< <ENTER>/<RETURN> >> manually.
  
  Note that any line of the simulated input that begins with
  a <CTRL-D> or <CTRL-Z> is treated as an input failure (just as
  if you'd typed that character as input).
  
  =head1 DIAGNOSTICS
  
  All non-fatal diagnostics can be disabled using a C<no warnings> with the
  appropriate category.
  
  =over
  
  =item C<< prompt(): Can't open *ARGV: %s >>
  
  (F)  By default, C<prompt()> attempts to read input from
       the C<*ARGV> filehandle. However, it failed to open
       that filehandle. The reason is specified at the end of
       the message.
  
  
  =item C<< prompt(): Missing value for %s (expected %s) >>
  
  (F)  A named option that requires an argument was specified,
       but no argument was provided after the option. See
       L<"Summary of options">.
  
  
  =item C<< prompt(): Invalid value for %s (expected %s) >>
  
  (F)  The named option specified expects an particular type
       of argument, but found one of an incompatible type
       instead. See L<"Summary of options">.
  
  
  =item C<< prompt(): Unknown option %s ignored >>
  
  (W misc)  C<prompt()> was passed a string starting with
            a hyphen, but could not parse that string as a
            valid option. The option may have been misspelt.
            Alternatively, if the string was supposed to be
            (part of) the prompt, it will be necessary to use
            L<the C<-prompt> option|"Specifying what to
            prompt"> to specify it.
  
  
  =item C<< prompt(): Unexpected argument (% ref) ignored >>
  
  (W reserved)  C<prompt()> was passed a reference to
                an array or hash or subroutine in a position
                where an option flag or a prompt string was
                expected. This may indicate that a string
                variable in the argument list didn't contain
                what was expected, or a reference variable was
                not properly dereferenced. Alternatively, the
                argument may have been intended as the
                argument to an option, but has become
                separated from it somehow, or perhaps the
                option was deleted without removing the
                argument as well.
  
  
  =item C<< Useless use of prompt() in void context >>
  
  (W void)  C<prompt()> was called but its return value was
            not stored or used in any way. Since the
            subroutine has no side effects in void context,
            calling it this way achieves nothing. Either make
            use of the return value directly or, if the usage
            is deliberate, put a C<scalar> in front of the
            call to remove the void context.
  
  
  =item C<< prompt(): -default value does not satisfy -must constraints >>
  
  (W misc)  The C<-must> flag was used to specify one or more
            input constraints. The C<-default> flag was also
            specified. Unfortunately, the default value
            provided did not satisfy the requirements
            specified by the C<-must> flag. The call to
            C<prompt()> will still go ahead (after issuing the
            warning), but the default value will never be
            returned, since the constraint check will reject
            it. It is probably better simply to include the
            default value in the list of constraints.
  
  
  =item C<< prompt(): -keyletters found too many defaults >>
  
  (W ambiguous)  The C<-keyletters> option was specified,
                 but analysis of the prompt revealed two or
                 more character sequences enclosed in square
                 brackets. Since such sequences are taken to
                 indicate a default value, having two or more
                 makes the default ambiguous. The prompt
                 should be rewritten with no more than one set
                 of square brackets.
  
  
  =item C<< Warning: next input will be in plaintext >>
  
  (W bareword)  The C<prompt()> subroutine was called with
                the C<-echo> flag, but the Term::ReadKey
                module was not available to implement this
                feature. The input will proceed as normal, but
                this warning is issued to ensure that the user
                doesn't type in something secret, expecting it
                to remain hidden, which it won't.
  
  
  =item C<< prompt(): Too many menu items. Ignoring the final %d >>
  
  (W misc)  A C<-menu> was specified with more than 52 choices.
            Because, by default, menus use upper and lower-
            case alphabetic characters as their selectors,
            there were no available selectors for the extra
            items after the first 52. Either reduce the number
            of choices to 52 or less, or else add the
            C<-number> option to use numeric selectors instead.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Prompter can be configured by setting any of the following
  environment variables:
  
  =over
  
  =item C<$IO_PROMPTER_COMPLETE_KEY>
  
  Specifies the key used to initiate
  L<user-specified completions|"Input autocompletion">.
  Defaults to <TAB>
  
  =item C<$IO_PROMPTER_HISTORY_KEY>
  
  Specifies the key used to initiate
  L<history completions|"Completing from your input history">.
  Defaults to <CTRL-R>
  
  =item C<$IO_PROMPTER_COMPLETE_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for user-defined completions.  Defaults to C<'list+longest  full'>
  
  =item C<$IO_PROMPTER_HISTORY_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for history completions.  Defaults to C<'full'>.
  
  =back
  
  
  =head1 DEPENDENCIES
  
  Requires the Contextual::Return module.
  
  The module also works much better if Term::ReadKey is available
  (though this is not essential).
  
  
  =head1 INCOMPATIBILITIES
  
  This module does not play well with Moose (or more specifically, with
  Moose::Exporter) because both of them try to play sneaky games with
  Scalar::Util::blessed.
  
  The current solution is to make sure that you load Moose before
  loading IO::Prompter. Even just doing this:
  
      use Moose ();
      use IO::Prompter;
  
  is sufficient.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No unresolved bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-prompter@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@CPAN.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2009, Damian Conway C<< <DCONWAY@CPAN.org> >>.
  All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
IO_PROMPTER

$fatpacked{"IPC/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN';
  package IPC::Run;
  use bytes;
  
  =pod
  
  =head1 NAME
  
  IPC::Run - system() and background procs w/ piping, redirs, ptys (Unix, Win32)
  
  =head1 SYNOPSIS
  
     ## First,a command to run:
        my @cat = qw( cat );
  
     ## Using run() instead of system():
        use IPC::Run qw( run timeout );
  
        run \@cat, \$in, \$out, \$err, timeout( 10 ) or die "cat: $?";
  
        # Can do I/O to sub refs and filenames, too:
        run \@cat, '<', "in.txt", \&out, \&err or die "cat: $?";
        run \@cat, '<', "in.txt", '>>', "out.txt", '2>>', "err.txt";
  
  
        # Redirecting using pseudo-terminals instead of pipes.
        run \@cat, '<pty<', \$in,  '>pty>', \$out_and_err;
  
     ## Scripting subprocesses (like Expect):
  
        use IPC::Run qw( start pump finish timeout );
  
        # Incrementally read from / write to scalars. 
        # $in is drained as it is fed to cat's stdin,
        # $out accumulates cat's stdout
        # $err accumulates cat's stderr
        # $h is for "harness".
        my $h = start \@cat, \$in, \$out, \$err, timeout( 10 );
  
        $in .= "some input\n";
        pump $h until $out =~ /input\n/g;
  
        $in .= "some more input\n";
        pump $h until $out =~ /\G.*more input\n/;
  
        $in .= "some final input\n";
        finish $h or die "cat returned $?";
  
        warn $err if $err; 
        print $out;         ## All of cat's output
  
     # Piping between children
        run \@cat, '|', \@gzip;
  
     # Multiple children simultaneously (run() blocks until all
     # children exit, use start() for background execution):
        run \@foo1, '&', \@foo2;
  
     # Calling \&set_up_child in the child before it executes the
     # command (only works on systems with true fork() & exec())
     # exceptions thrown in set_up_child() will be propagated back
     # to the parent and thrown from run().
        run \@cat, \$in, \$out,
           init => \&set_up_child;
  
     # Read from / write to file handles you open and close
        open IN,  '<in.txt'  or die $!;
        open OUT, '>out.txt' or die $!;
        print OUT "preamble\n";
        run \@cat, \*IN, \*OUT or die "cat returned $?";
        print OUT "postamble\n";
        close IN;
        close OUT;
  
     # Create pipes for you to read / write (like IPC::Open2 & 3).
        $h = start
           \@cat,
              '<pipe', \*IN, # may also be a lexical filehandle e.g. \my $infh
              '>pipe', \*OUT,
              '2>pipe', \*ERR 
           or die "cat returned $?";
        print IN "some input\n";
        close IN;
        print <OUT>, <ERR>;
        finish $h;
  
     # Mixing input and output modes
        run \@cat, 'in.txt', \&catch_some_out, \*ERR_LOG;
  
     # Other redirection constructs
        run \@cat, '>&', \$out_and_err;
        run \@cat, '2>&1';
        run \@cat, '0<&3';
        run \@cat, '<&-';
        run \@cat, '3<', \$in3;
        run \@cat, '4>', \$out4;
        # etc.
  
     # Passing options:
        run \@cat, 'in.txt', debug => 1;
  
     # Call this system's shell, returns TRUE on 0 exit code
     # THIS IS THE OPPOSITE SENSE OF system()'s RETURN VALUE
        run "cat a b c" or die "cat returned $?";
  
     # Launch a sub process directly, no shell.  Can't do redirection
     # with this form, it's here to behave like system() with an
     # inverted result.
        $r = run "cat a b c";
  
     # Read from a file in to a scalar
        run io( "filename", 'r', \$recv );
        run io( \*HANDLE,   'r', \$recv );
  
  =head1 DESCRIPTION
  
  IPC::Run allows you to run and interact with child processes using files, pipes,
  and pseudo-ttys.  Both system()-style and scripted usages are supported and
  may be mixed.  Likewise, functional and OO API styles are both supported and
  may be mixed.
  
  Various redirection operators reminiscent of those seen on common Unix and DOS
  command lines are provided.
  
  Before digging in to the details a few LIMITATIONS are important enough
  to be mentioned right up front:
  
  =over
  
  =item Win32 Support
  
  Win32 support is working but B<EXPERIMENTAL>, but does pass all relevant tests
  on NT 4.0.  See L</Win32 LIMITATIONS>.
  
  =item pty Support
  
  If you need pty support, IPC::Run should work well enough most of the
  time, but IO::Pty is being improved, and IPC::Run will be improved to
  use IO::Pty's new features when it is released.
  
  The basic problem is that the pty needs to initialize itself before the
  parent writes to the master pty, or the data written gets lost.  So
  IPC::Run does a sleep(1) in the parent after forking to (hopefully) give
  the child a chance to run.  This is a kludge that works well on non
  heavily loaded systems :(.
  
  ptys are not supported yet under Win32, but will be emulated...
  
  =item Debugging Tip
  
  You may use the environment variable C<IPCRUNDEBUG> to see what's going on
  under the hood:
  
     $ IPCRUNDEBUG=basic   myscript     # prints minimal debugging
     $ IPCRUNDEBUG=data    myscript     # prints all data reads/writes
     $ IPCRUNDEBUG=details myscript     # prints lots of low-level details
     $ IPCRUNDEBUG=gory    myscript     # (Win32 only) prints data moving through
                                        # the helper processes.
  
  =back
  
  We now return you to your regularly scheduled documentation.
  
  =head2 Harnesses
  
  Child processes and I/O handles are gathered in to a harness, then
  started and run until the processing is finished or aborted.
  
  =head2 run() vs. start(); pump(); finish();
  
  There are two modes you can run harnesses in: run() functions as an
  enhanced system(), and start()/pump()/finish() allow for background
  processes and scripted interactions with them.
  
  When using run(), all data to be sent to the harness is set up in
  advance (though one can feed subprocesses input from subroutine refs to
  get around this limitation). The harness is run and all output is
  collected from it, then any child processes are waited for:
  
     run \@cmd, \<<IN, \$out;
     blah
     IN
  
     ## To precompile harnesses and run them later:
     my $h = harness \@cmd, \<<IN, \$out;
     blah
     IN
  
     run $h;
  
  The background and scripting API is provided by start(), pump(), and
  finish(): start() creates a harness if need be (by calling harness())
  and launches any subprocesses, pump() allows you to poll them for
  activity, and finish() then monitors the harnessed activities until they
  complete.
  
     ## Build the harness, open all pipes, and launch the subprocesses
     my $h = start \@cat, \$in, \$out;
     $in = "first input\n";
  
     ## Now do I/O.  start() does no I/O.
     pump $h while length $in;  ## Wait for all input to go
  
     ## Now do some more I/O.
     $in = "second input\n";
     pump $h until $out =~ /second input/;
  
     ## Clean up
     finish $h or die "cat returned $?";
  
  You can optionally compile the harness with harness() prior to
  start()ing or run()ing, and you may omit start() between harness() and
  pump().  You might want to do these things if you compile your harnesses
  ahead of time.
  
  =head2 Using regexps to match output
  
  As shown in most of the scripting examples, the read-to-scalar facility
  for gathering subcommand's output is often used with regular expressions
  to detect stopping points.  This is because subcommand output often
  arrives in dribbles and drabs, often only a character or line at a time.
  This output is input for the main program and piles up in variables like
  the C<$out> and C<$err> in our examples.
  
  Regular expressions can be used to wait for appropriate output in
  several ways.  The C<cat> example in the previous section demonstrates
  how to pump() until some string appears in the output.  Here's an
  example that uses C<smb> to fetch files from a remote server:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /src:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
  Notice that we carefully clear $out after the first command/response
  cycle? That's because IPC::Run does not delete $out when we continue,
  and we don't want to trip over the old output in the second
  command/response cycle.
  
  Say you want to accumulate all the output in $out and analyze it
  afterwards.  Perl offers incremental regular expression matching using
  the C<m//gc> and pattern matching idiom and the C<\G> assertion.
  IPC::Run is careful not to disturb the current C<pos()> value for
  scalars it appends data to, so we could modify the above so as not to
  destroy $out by adding a couple of C</gc> modifiers.  The C</g> keeps us
  from tripping over the previous prompt and the C</c> keeps us from
  resetting the prior match position if the expected prompt doesn't
  materialize immediately:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error cding to /src:\n$out" if $out =~ "ERR";
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
     analyze( $out );
  
  When using this technique, you may want to preallocate $out to have
  plenty of memory or you may find that the act of growing $out each time
  new input arrives causes an C<O(length($out)^2)> slowdown as $out grows.
  Say we expect no more than 10,000 characters of input at the most.  To
  preallocate memory to $out, do something like:
  
     my $out = "x" x 10_000;
     $out = "";
  
  C<perl> will allocate at least 10,000 characters' worth of space, then
  mark the $out as having 0 length without freeing all that yummy RAM.
  
  =head2 Timeouts and Timers
  
  More than likely, you don't want your subprocesses to run forever, and
  sometimes it's nice to know that they're going a little slowly.
  Timeouts throw exceptions after a some time has elapsed, timers merely
  cause pump() to return after some time has elapsed.  Neither is
  reset/restarted automatically.
  
  Timeout objects are created by calling timeout( $interval ) and passing
  the result to run(), start() or harness().  The timeout period starts
  ticking just after all the child processes have been fork()ed or
  spawn()ed, and are polled for expiration in run(), pump() and finish().
  If/when they expire, an exception is thrown.  This is typically useful
  to keep a subprocess from taking too long.
  
  If a timeout occurs in run(), all child processes will be terminated and
  all file/pipe/ptty descriptors opened by run() will be closed.  File
  descriptors opened by the parent process and passed in to run() are not
  closed in this event.
  
  If a timeout occurs in pump(), pump_nb(), or finish(), it's up to you to
  decide whether to kill_kill() all the children or to implement some more
  graceful fallback.  No I/O will be closed in pump(), pump_nb() or
  finish() by such an exception (though I/O is often closed down in those
  routines during the natural course of events).
  
  Often an exception is too harsh.  timer( $interval ) creates timer
  objects that merely prevent pump() from blocking forever.  This can be
  useful for detecting stalled I/O or printing a soothing message or "."
  to pacify an anxious user.
  
  Timeouts and timers can both be restarted at any time using the timer's
  start() method (this is not the start() that launches subprocesses).  To
  restart a timer, you need to keep a reference to the timer:
  
     ## Start with a nice long timeout to let smbclient connect.  If
     ## pump or finish take too long, an exception will be thrown.
  
   my $h;
   eval {
     $h = harness \@smbclient, \$in, \$out, \$err, ( my $t = timeout 30 );
     sleep 11;  # No effect: timer not running yet
  
     start $h;
     $in = "cd /src\n";
     pump $h until ! length $in;
  
     $in = "ls\n";
     ## Now use a short timeout, since this should be faster
     $t->start( 5 );
     pump $h until ! length $in;
  
     $t->start( 10 );  ## Give smbclient a little while to shut down.
     $h->finish;
   };
   if ( $@ ) {
     my $x = $@;    ## Preserve $@ in case another exception occurs
     $h->kill_kill; ## kill it gently, then brutally if need be, or just
                     ## brutally on Win32.
     die $x;
   }
  
  Timeouts and timers are I<not> checked once the subprocesses are shut
  down; they will not expire in the interval between the last valid
  process and when IPC::Run scoops up the processes' result codes, for
  instance.
  
  =head2 Spawning synchronization, child exception propagation
  
  start() pauses the parent until the child executes the command or CODE
  reference and propagates any exceptions thrown (including exec()
  failure) back to the parent.  This has several pleasant effects: any
  exceptions thrown in the child, including exec() failure, come flying
  out of start() or run() as though they had occurred in the parent.
  
  This includes exceptions your code thrown from init subs.  In this
  example:
  
     eval {
        run \@cmd, init => sub { die "blast it! foiled again!" };
     };
     print $@;
  
  the exception "blast it! foiled again" will be thrown from the child
  process (preventing the exec()) and printed by the parent.
  
  In situations like
  
     run \@cmd1, "|", \@cmd2, "|", \@cmd3;
  
  @cmd1 will be initted and exec()ed before @cmd2, and @cmd2 before @cmd3.
  This can save time and prevent oddball errors emitted by later commands
  when earlier commands fail to execute.  Note that IPC::Run doesn't start
  any commands unless it can find the executables referenced by all
  commands.  These executables must pass both the C<-f> and C<-x> tests
  described in L<perlfunc>.
  
  Another nice effect is that init() subs can take their time doing things
  and there will be no problems caused by a parent continuing to execute
  before a child's init() routine is complete.  Say the init() routine
  needs to open a socket or a temp file that the parent wants to connect
  to; without this synchronization, the parent will need to implement a
  retry loop to wait for the child to run, since often, the parent gets a
  lot of things done before the child's first timeslice is allocated.
  
  This is also quite necessary for pseudo-tty initialization, which needs
  to take place before the parent writes to the child via pty.  Writes
  that occur before the pty is set up can get lost.
  
  A final, minor, nicety is that debugging output from the child will be
  emitted before the parent continues on, making for much clearer debugging
  output in complex situations.
  
  The only drawback I can conceive of is that the parent can't continue to
  operate while the child is being initted.  If this ever becomes a
  problem in the field, we can implement an option to avoid this behavior,
  but I don't expect it to.
  
  B<Win32>: executing CODE references isn't supported on Win32, see
  L</Win32 LIMITATIONS> for details.
  
  =head2 Syntax
  
  run(), start(), and harness() can all take a harness specification
  as input.  A harness specification is either a single string to be passed
  to the systems' shell:
  
     run "echo 'hi there'";
  
  or a list of commands, io operations, and/or timers/timeouts to execute.
  Consecutive commands must be separated by a pipe operator '|' or an '&'.
  External commands are passed in as array references or L<IPC::Run::Win32Process>
  objects.  On systems supporting fork(), Perl code may be passed in as subs:
  
     run \@cmd;
     run \@cmd1, '|', \@cmd2;
     run \@cmd1, '&', \@cmd2;
     run \&sub1;
     run \&sub1, '|', \&sub2;
     run \&sub1, '&', \&sub2;
  
  '|' pipes the stdout of \@cmd1 the stdin of \@cmd2, just like a
  shell pipe.  '&' does not.  Child processes to the right of a '&'
  will have their stdin closed unless it's redirected-to.
  
  L<IPC::Run::IO> objects may be passed in as well, whether or not
  child processes are also specified:
  
     run io( "infile", ">", \$in ), io( "outfile", "<", \$in );
        
  as can L<IPC::Run::Timer> objects:
  
     run \@cmd, io( "outfile", "<", \$in ), timeout( 10 );
  
  Commands may be followed by scalar, sub, or i/o handle references for
  redirecting
  child process input & output:
  
     run \@cmd,  \undef,            \$out;
     run \@cmd,  \$in,              \$out;
     run \@cmd1, \&in, '|', \@cmd2, \*OUT;
     run \@cmd1, \*IN, '|', \@cmd2, \&out;
  
  This is known as succinct redirection syntax, since run(), start()
  and harness(), figure out which file descriptor to redirect and how.
  File descriptor 0 is presumed to be an input for
  the child process, all others are outputs.  The assumed file
  descriptor always starts at 0, unless the command is being piped to,
  in which case it starts at 1.
  
  To be explicit about your redirects, or if you need to do more complex
  things, there's also a redirection operator syntax:
  
     run \@cmd, '<', \undef, '>',  \$out;
     run \@cmd, '<', \undef, '>&', \$out_and_err;
     run(
        \@cmd1,
           '<', \$in,
        '|', \@cmd2,
           \$out
     );
  
  Operator syntax is required if you need to do something other than simple
  redirection to/from scalars or subs, like duping or closing file descriptors
  or redirecting to/from a named file.  The operators are covered in detail
  below.
  
  After each \@cmd (or \&foo), parsing begins in succinct mode and toggles to
  operator syntax mode when an operator (ie plain scalar, not a ref) is seen.
  Once in
  operator syntax mode, parsing only reverts to succinct mode when a '|' or
  '&' is seen.
  
  In succinct mode, each parameter after the \@cmd specifies what to
  do with the next highest file descriptor. These File descriptor start
  with 0 (stdin) unless stdin is being piped to (C<'|', \@cmd>), in which
  case they start with 1 (stdout).  Currently, being on the left of
  a pipe (C<\@cmd, \$out, \$err, '|'>) does I<not> cause stdout to be
  skipped, though this may change since it's not as DWIMerly as it
  could be.  Only stdin is assumed to be an
  input in succinct mode, all others are assumed to be outputs.
  
  If no piping or redirection is specified for a child, it will inherit
  the parent's open file handles as dictated by your system's
  close-on-exec behavior and the $^F flag, except that processes after a
  '&' will not inherit the parent's stdin. Also note that $^F does not
  affect file descriptors obtained via POSIX, since it only applies to
  full-fledged Perl file handles.  Such processes will have their stdin
  closed unless it has been redirected-to.
  
  If you want to close a child processes stdin, you may do any of:
  
     run \@cmd, \undef;
     run \@cmd, \"";
     run \@cmd, '<&-';
     run \@cmd, '0<&-';
  
  Redirection is done by placing redirection specifications immediately 
  after a command or child subroutine:
  
     run \@cmd1,      \$in, '|', \@cmd2,      \$out;
     run \@cmd1, '<', \$in, '|', \@cmd2, '>', \$out;
  
  If you omit the redirection operators, descriptors are counted
  starting at 0.  Descriptor 0 is assumed to be input, all others
  are outputs.  A leading '|' consumes descriptor 0, so this
  works as expected.
  
     run \@cmd1, \$in, '|', \@cmd2, \$out;
     
  The parameter following a redirection operator can be a scalar ref,
  a subroutine ref, a file name, an open filehandle, or a closed
  filehandle.
  
  If it's a scalar ref, the child reads input from or sends output to
  that variable:
  
     $in = "Hello World.\n";
     run \@cat, \$in, \$out;
     print $out;
  
  Scalars used in incremental (start()/pump()/finish()) applications are treated
  as queues: input is removed from input scalers, resulting in them dwindling
  to '', and output is appended to output scalars.  This is not true of 
  harnesses run() in batch mode.
  
  It's usually wise to append new input to be sent to the child to the input
  queue, and you'll often want to zap output queues to '' before pumping.
  
     $h = start \@cat, \$in;
     $in = "line 1\n";
     pump $h;
     $in .= "line 2\n";
     pump $h;
     $in .= "line 3\n";
     finish $h;
  
  The final call to finish() must be there: it allows the child process(es)
  to run to completion and waits for their exit values.
  
  =head1 OBSTINATE CHILDREN
  
  Interactive applications are usually optimized for human use.  This
  can help or hinder trying to interact with them through modules like
  IPC::Run.  Frequently, programs alter their behavior when they detect
  that stdin, stdout, or stderr are not connected to a tty, assuming that
  they are being run in batch mode.  Whether this helps or hurts depends
  on which optimizations change.  And there's often no way of telling
  what a program does in these areas other than trial and error and
  occasionally, reading the source.  This includes different versions
  and implementations of the same program.
  
  All hope is not lost, however.  Most programs behave in reasonably
  tractable manners, once you figure out what it's trying to do.
  
  Here are some of the issues you might need to be aware of.
  
  =over
  
  =item *
  
  fflush()ing stdout and stderr
  
  This lets the user see stdout and stderr immediately.  Many programs
  undo this optimization if stdout is not a tty, making them harder to
  manage by things like IPC::Run.
  
  Many programs decline to fflush stdout or stderr if they do not
  detect a tty there.  Some ftp commands do this, for instance.
  
  If this happens to you, look for a way to force interactive behavior,
  like a command line switch or command.  If you can't, you will
  need to use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  false prompts
  
  Interactive programs generally do not guarantee that output from user
  commands won't contain a prompt string.  For example, your shell prompt
  might be a '$', and a file named '$' might be the only file in a directory
  listing.
  
  This can make it hard to guarantee that your output parser won't be fooled
  into early termination of results.
  
  To help work around this, you can see if the program can alter it's 
  prompt, and use something you feel is never going to occur in actual
  practice.
  
  You should also look for your prompt to be the only thing on a line:
  
     pump $h until $out =~ /^<SILLYPROMPT>\s?\z/m;
  
  (use C<(?!\n)\Z> in place of C<\z> on older perls).
  
  You can also take the approach that IPC::ChildSafe takes and emit a
  command with known output after each 'real' command you issue, then
  look for this known output.  See new_appender() and new_chunker() for
  filters that can help with this task.
  
  If it's not convenient or possibly to alter a prompt or use a known
  command/response pair, you might need to autodetect the prompt in case
  the local version of the child program is different then the one
  you tested with, or if the user has control over the look & feel of
  the prompt.
  
  =item *
  
  Refusing to accept input unless stdin is a tty.
  
  Some programs, for security reasons, will only accept certain types
  of input from a tty.  su, notable, will not prompt for a password unless
  it's connected to a tty.
  
  If this is your situation, use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  Not prompting unless connected to a tty.
  
  Some programs don't prompt unless stdin or stdout is a tty.  See if you can
  turn prompting back on.  If not, see if you can come up with a command that
  you can issue after every real command and look for it's output, as
  IPC::ChildSafe does.   There are two filters included with IPC::Run that
  can help with doing this: appender and chunker (see new_appender() and
  new_chunker()).
  
  =item *
  
  Different output format when not connected to a tty.
  
  Some commands alter their formats to ease machine parsability when they
  aren't connected to a pipe.  This is actually good, but can be surprising.
  
  =back
  
  =head1 PSEUDO TERMINALS
  
  On systems providing pseudo terminals under /dev, IPC::Run can use IO::Pty
  (available on CPAN) to provide a terminal environment to subprocesses.
  This is necessary when the subprocess really wants to think it's connected
  to a real terminal.
  
  =head2 CAVEATS
  
  Pseudo-terminals are not pipes, though they are similar.  Here are some
  differences to watch out for.
  
  =over
  
  =item Echoing
  
  Sending to stdin will cause an echo on stdout, which occurs before each
  line is passed to the child program.  There is currently no way to
  disable this, although the child process can and should disable it for
  things like passwords.
  
  =item Shutdown
  
  IPC::Run cannot close a pty until all output has been collected.  This
  means that it is not possible to send an EOF to stdin by half-closing
  the pty, as we can when using a pipe to stdin.
  
  This means that you need to send the child process an exit command or
  signal, or run() / finish() will time out.  Be careful not to expect a
  prompt after sending the exit command.
  
  =item Command line editing
  
  Some subprocesses, notable shells that depend on the user's prompt
  settings, will reissue the prompt plus the command line input so far
  once for each character.
  
  =item '>pty>' means '&>pty>', not '1>pty>'
  
  The pseudo terminal redirects both stdout and stderr unless you specify
  a file descriptor.  If you want to grab stderr separately, do this:
  
     start \@cmd, '<pty<', \$in, '>pty>', \$out, '2>', \$err;
  
  =item stdin, stdout, and stderr not inherited
  
  Child processes harnessed to a pseudo terminal have their stdin, stdout,
  and stderr completely closed before any redirection operators take
  effect.  This casts of the bonds of the controlling terminal.  This is
  not done when using pipes.
  
  Right now, this affects all children in a harness that has a pty in use,
  even if that pty would not affect a particular child.  That's a bug and
  will be fixed.  Until it is, it's best not to mix-and-match children.
  
  =back
  
  =head2 Redirection Operators
  
     Operator       SHNP   Description
     ========       ====   ===========
     <, N<          SHN    Redirects input to a child's fd N (0 assumed)
  
     >, N>          SHN    Redirects output from a child's fd N (1 assumed)
     >>, N>>        SHN    Like '>', but appends to scalars or named files
     >&, &>         SHN    Redirects stdout & stderr from a child process
  
     <pty, N<pty    S      Like '<', but uses a pseudo-tty instead of a pipe
     >pty, N>pty    S      Like '>', but uses a pseudo-tty instead of a pipe
  
     N<&M                  Dups input fd N to input fd M
     M>&N                  Dups output fd N to input fd M
     N<&-                  Closes fd N
  
     <pipe, N<pipe     P   Pipe opens H for caller to read, write, close.
     >pipe, N>pipe     P   Pipe opens H for caller to read, write, close.
                        
  'N' and 'M' are placeholders for integer file descriptor numbers.  The
  terms 'input' and 'output' are from the child process's perspective.
  
  The SHNP field indicates what parameters an operator can take:
  
     S: \$scalar or \&function references.  Filters may be used with
        these operators (and only these).
     H: \*HANDLE or IO::Handle for caller to open, and close
     N: "file name".
     P: \*HANDLE or lexical filehandle opened by IPC::Run as the parent end of a pipe, but read
        and written to and closed by the caller (like IPC::Open3).
  
  =over
  
  =item Redirecting input: [n]<, [n]<pipe
  
  You can input the child reads on file descriptor number n to come from a
  scalar variable, subroutine, file handle, or a named file.  If stdin
  is not redirected, the parent's stdin is inherited.
  
     run \@cat, \undef          ## Closes child's stdin immediately
        or die "cat returned $?"; 
  
     run \@cat, \$in;
  
     run \@cat, \<<TOHERE;
     blah
     TOHERE
  
     run \@cat, \&input;       ## Calls &input, feeding data returned
                                ## to child's.  Closes child's stdin
                                ## when undef is returned.
  
  Redirecting from named files requires you to use the input
  redirection operator:
  
     run \@cat, '<.profile';
     run \@cat, '<', '.profile';
  
     open IN, "<foo";
     run \@cat, \*IN;
     run \@cat, *IN{IO};
  
  The form used second example here is the safest,
  since filenames like "0" and "&more\n" won't confuse &run:
  
  You can't do either of
  
     run \@a, *IN;      ## INVALID
     run \@a, '<', *IN; ## BUGGY: Reads file named like "*main::A"
     
  because perl passes a scalar containing a string that
  looks like "*main::A" to &run, and &run can't tell the difference
  between that and a redirection operator or a file name.  &run guarantees
  that any scalar you pass after a redirection operator is a file name.
  
  If your child process will take input from file descriptors other
  than 0 (stdin), you can use a redirection operator with any of the
  valid input forms (scalar ref, sub ref, etc.):
  
     run \@cat, '3<', \$in3;
  
  When redirecting input from a scalar ref, the scalar ref is
  used as a queue.  This allows you to use &harness and pump() to
  feed incremental bits of input to a coprocess.  See L</Coprocesses>
  below for more information.
  
  The <pipe operator opens the write half of a pipe on the filehandle
  glob reference it takes as an argument:
  
     $h = start \@cat, '<pipe', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  Unlike the other '<' operators, IPC::Run does nothing further with
  it: you are responsible for it.  The previous example is functionally
  equivalent to:
  
     pipe( \*R, \*IN ) or die $!;
     $h = start \@cat, '<', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  This is like the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Redirecting output: [n]>, [n]>>, [n]>&[m], [n]>pipe
  
  You can redirect any output the child emits
  to a scalar variable, subroutine, file handle, or file name.  You
  can have &run truncate or append to named files or scalars.  If
  you are redirecting stdin as well, or if the command is on the
  receiving end of a pipeline ('|'), you can omit the redirection
  operator:
  
     @ls = ( 'ls' );
     run \@ls, \undef, \$out
        or die "ls returned $?"; 
  
     run \@ls, \undef, \&out;  ## Calls &out each time some output
                                ## is received from the child's 
                                ## when undef is returned.
  
     run \@ls, \undef, '2>ls.err';
     run \@ls, '2>', 'ls.err';
  
  The two parameter form guarantees that the filename
  will not be interpreted as a redirection operator:
  
     run \@ls, '>', "&more";
     run \@ls, '2>', ">foo\n";
  
  You can pass file handles you've opened for writing:
  
     open( *OUT, ">out.txt" );
     open( *ERR, ">err.txt" );
     run \@cat, \*OUT, \*ERR;
  
  Passing a scalar reference and a code reference requires a little
  more work, but allows you to capture all of the output in a scalar
  or each piece of output by a callback:
  
  These two do the same things:
  
     run( [ 'ls' ], '2>', sub { $err_out .= $_[0] } );
  
  does the same basic thing as:
  
     run( [ 'ls' ], '2>', \$err_out );
  
  The subroutine will be called each time some data is read from the child.
  
  The >pipe operator is different in concept than the other '>' operators,
  although it's syntax is similar:
  
     $h = start \@cat, $in, '>pipe', \*OUT, '2>pipe', \*ERR;
     $in = "hello world\n";
     finish $h;
     print <OUT>;
     print <ERR>;
     close OUT;
     close ERR;
  
  causes two pipe to be created, with one end attached to cat's stdout
  and stderr, respectively, and the other left open on OUT and ERR, so
  that the script can manually
  read(), select(), etc. on them.  This is like
  the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Duplicating output descriptors: >&m, n>&m
  
  This duplicates output descriptor number n (default is 1 if n is omitted)
  from descriptor number m.
  
  =item Duplicating input descriptors: <&m, n<&m
  
  This duplicates input descriptor number n (default is 0 if n is omitted)
  from descriptor number m
  
  =item Closing descriptors: <&-, 3<&-
  
  This closes descriptor number n (default is 0 if n is omitted).  The
  following commands are equivalent:
  
     run \@cmd, \undef;
     run \@cmd, '<&-';
     run \@cmd, '<in.txt', '<&-';
  
  Doing
  
     run \@cmd, \$in, '<&-';    ## SIGPIPE recipe.
  
  is dangerous: the parent will get a SIGPIPE if $in is not empty.
  
  =item Redirecting both stdout and stderr: &>, >&, &>pipe, >pipe&
  
  The following pairs of commands are equivalent:
  
     run \@cmd, '>&', \$out;       run \@cmd, '>', \$out,     '2>&1';
     run \@cmd, '>&', 'out.txt';   run \@cmd, '>', 'out.txt', '2>&1';
  
  etc.
  
  File descriptor numbers are not permitted to the left or the right of
  these operators, and the '&' may occur on either end of the operator.
  
  The '&>pipe' and '>pipe&' variants behave like the '>pipe' operator, except
  that both stdout and stderr write to the created pipe.
  
  =item Redirection Filters
  
  Both input redirections and output redirections that use scalars or
  subs as endpoints may have an arbitrary number of filter subs placed
  between them and the child process.  This is useful if you want to
  receive output in chunks, or if you want to massage each chunk of
  data sent to the child.  To use this feature, you must use operator
  syntax:
  
     run(
        \@cmd
           '<', \&in_filter_2, \&in_filter_1, $in,
           '>', \&out_filter_1, \&in_filter_2, $out,
     );
  
  This capability is not provided for IO handles or named files.
  
  Two filters are provided by IPC::Run: appender and chunker.  Because
  these may take an argument, you need to use the constructor functions
  new_appender() and new_chunker() rather than using \& syntax:
  
     run(
        \@cmd
           '<', new_appender( "\n" ), $in,
           '>', new_chunker, $out,
     );
  
  =back
  
  =head2 Just doing I/O
  
  If you just want to do I/O to a handle or file you open yourself, you
  may specify a filehandle or filename instead of a command in the harness
  specification:
  
     run io( "filename", '>', \$recv );
  
     $h = start io( $io, '>', \$recv );
  
     $h = harness \@cmd, '&', io( "file", '<', \$send );
  
  =head2 Options
  
  Options are passed in as name/value pairs:
  
     run \@cat, \$in, debug => 1;
  
  If you pass the debug option, you may want to pass it in first, so you
  can see what parsing is going on:
  
     run debug => 1, \@cat, \$in;
  
  =over
  
  =item debug
  
  Enables debugging output in parent and child.  Debugging info is emitted
  to the STDERR that was present when IPC::Run was first C<use()>ed (it's
  C<dup()>ed out of the way so that it can be redirected in children without
  having debugging output emitted on it).
  
  =back
  
  =head1 RETURN VALUES
  
  harness() and start() return a reference to an IPC::Run harness.  This is
  blessed in to the IPC::Run package, so you may make later calls to
  functions as members if you like:
  
     $h = harness( ... );
     $h->start;
     $h->pump;
     $h->finish;
  
     $h = start( .... );
     $h->pump;
     ...
  
  Of course, using method call syntax lets you deal with any IPC::Run
  subclasses that might crop up, but don't hold your breath waiting for
  any.
  
  run() and finish() return TRUE when all subcommands exit with a 0 result
  code.  B<This is the opposite of perl's system() command>.
  
  All routines raise exceptions (via die()) when error conditions are
  recognized.  A non-zero command result is not treated as an error
  condition, since some commands are tests whose results are reported 
  in their exit codes.
  
  =head1 ROUTINES
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Exporter ();
  use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw{ Exporter };
  
      ## We use @EXPORT for the end user's convenience: there's only one function
      ## exported, it's homonymous with the module, it's an unusual name, and
      ## it can be suppressed by "use IPC::Run ();".
      @FILTER_IMP = qw( input_avail get_more_input );
      @FILTERS    = qw(
        new_appender
        new_chunker
        new_string_source
        new_string_sink
      );
      @API = qw(
        run
        harness start pump pumpable finish
        signal kill_kill reap_nb
        io timer timeout
        close_terminal
        binary
      );
      @EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
      %EXPORT_TAGS = (
          'filter_imp' => \@FILTER_IMP,
          'all'        => \@EXPORT_OK,
          'filters'    => \@FILTERS,
          'api'        => \@API,
      );
  
  }
  
  use strict;
  use warnings;
  use IPC::Run::Debug;
  use Exporter;
  use Fcntl;
  use POSIX ();
  
  BEGIN {
      if ( $] < 5.008 ) { require Symbol; }
  }
  use Carp;
  use File::Spec ();
  use IO::Handle;
  require IPC::Run::IO;
  require IPC::Run::Timer;
  
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  BEGIN {
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; 1;"
            or ( $@ && die )
            or die "$!";
      }
      else {
          eval "use File::Basename; 1;" or die $!;
      }
  }
  
  sub input_avail();
  sub get_more_input();
  
  ###############################################################################
  
  ##
  ## Error constants, not too locale-dependent
  use vars qw( $_EIO $_EAGAIN );
  use Errno qw(   EIO   EAGAIN );
  
  BEGIN {
      local $!;
      $!       = EIO;
      $_EIO    = qr/^$!/;
      $!       = EAGAIN;
      $_EAGAIN = qr/^$!/;
  }
  
  ##
  ## State machine states, set in $self->{STATE}
  ##
  ## These must be in ascending order numerically
  ##
  sub _newed()     { 0 }
  sub _harnessed() { 1 }
  sub _finished()  { 2 }    ## _finished behave almost exactly like _harnessed
  sub _started()   { 3 }
  
  ##
  ## Which fds have been opened in the parent.  This may have extra fds, since
  ## we aren't all that rigorous about closing these off, but that's ok.  This
  ## is used on Unixish OSs to close all fds in the child that aren't needed
  ## by that particular child.
  my %fds;
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  
  use vars qw( $cur_self );
  
  sub _debug_fd {
      return fileno STDERR unless defined $cur_self;
  
      if ( _debugging && !defined $cur_self->{DEBUG_FD} ) {
          my $fd = select STDERR;
          $| = 1;
          select $fd;
          $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
          _debug("debugging fd is $cur_self->{DEBUG_FD}\n")
            if _debugging_details;
      }
  
      return fileno STDERR unless defined $cur_self->{DEBUG_FD};
  
      return $cur_self->{DEBUG_FD};
  }
  
  sub DESTROY {
      ## We absolutely do not want to do anything else here.  We are likely
      ## to be in a child process and we don't want to do things like kill_kill
      ## ourself or cause other destruction.
      my IPC::Run $self = shift;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  
      for my $kid ( @{$self->{KIDS}} ) {
          for my $op ( @{$kid->{OPS}} ) {
              delete $op->{FILTERS};
          }
      }
  }
  
  ##
  ## Support routines (NOT METHODS)
  ##
  my %cmd_cache;
  
  sub _search_path {
      my ($cmd_name) = @_;
      if ( File::Spec->file_name_is_absolute($cmd_name) && -x $cmd_name ) {
          _debug "'", $cmd_name, "' is absolute"
            if _debugging_details;
          return $cmd_name;
      }
  
      my $dirsep = (
            Win32_MODE     ? '[/\\\\]'
          : $^O =~ /MacOS/ ? ':'
          : $^O =~ /VMS/   ? '[\[\]]'
          :                  '/'
      );
  
      if (   Win32_MODE
          && ( $cmd_name =~ /$dirsep/ )
          && ( $cmd_name !~ m!\.[^\\/\.]+$! ) ) {
  
          _debug "no extension(.exe), checking ENV{PATHEXT}" if _debugging;
          for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
              my $name = "$cmd_name$_";
              $cmd_name = $name, last if -f $name && -x _;
          }
          _debug "cmd_name is now '$cmd_name'" if _debugging;
      }
  
      if ( $cmd_name =~ /($dirsep)/ ) {
          _debug "'$cmd_name' contains '$1'" if _debugging;
          croak "file not found: $cmd_name"    unless -e $cmd_name;
          croak "not a file: $cmd_name"        unless -f $cmd_name;
          croak "permission denied: $cmd_name" unless -x $cmd_name;
          return $cmd_name;
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
            if _debugging;
          return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
          _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
            if _debugging;
          delete $cmd_cache{$cmd_name};
      }
  
      my @searched_in;
  
      ## This next bit is Unix/Win32 specific, unfortunately.
      ## There's been some conversation about extending File::Spec to provide
      ## a universal interface to PATH, but I haven't seen it yet.
      my $re = Win32_MODE ? qr/;/ : qr/:/;
  
    LOOP:
      for ( split( $re, $ENV{PATH} || '', -1 ) ) {
          $_ = "." unless length $_;
          push @searched_in, $_;
  
          my $prospect = File::Spec->catfile( $_, $cmd_name );
          my @prospects;
  
          @prospects =
            ( Win32_MODE && !( -f $prospect && -x _ ) )
            ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
            : ($prospect);
  
          for my $found (@prospects) {
              if ( -f $found && -x _ ) {
                  $cmd_cache{$cmd_name} = $found;
                  last LOOP;
              }
          }
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
            if _debugging_details;
          return $cmd_cache{$cmd_name};
      }
  
      croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
  }
  
  # Translate a command or CODE reference (a $kid->{VAL}) to a list of strings
  # suitable for passing to _debug().
  sub _debugstrings {
      my $operand = shift;
      if ( !defined $operand ) {
          return '<undef>';
      }
  
      my $ref = ref $operand;
      if ( !$ref ) {
          return length $operand < 50
            ? "'$operand'"
            : join( '', "'", substr( $operand, 0, 10 ), "...'" );
      }
      elsif ( $ref eq 'ARRAY' ) {
          return (
              '[ ',
              join( " ", map /[^\w.-]/ ? "'$_'" : $_, @$operand ),
              ' ]'
          );
      }
      elsif ( UNIVERSAL::isa( $operand, 'IPC::Run::Win32Process' ) ) {
          return "$operand";
      }
      return $ref;
  }
  
  sub _empty($) { !( defined $_[0] && length $_[0] ) }
  
  ## 'safe' versions of otherwise fun things to do. See also IPC::Run::Win32Helper.
  sub _close {
      confess 'undef' unless defined $_[0];
      my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
      if (Win32_MODE) {
  
          # Perl close() or POSIX::close() on the read end of a pipe hangs if
          # another process is in a read attempt on the same pipe
          # (https://github.com/Perl/perl5/issues/19963).  Since IPC::Run creates
          # pipes and shares them with user-defined kids, it's affected.  Work
          # around that by first using dup2() to replace the FD with a non-pipe.
          # Unfortunately, for socket FDs, dup2() closes the SOCKET with
          # CloseHandle().  CloseHandle() documentation leaves its behavior
          # undefined for sockets.  However, tests on Windows Server 2022 did not
          # leak memory, leak ports, or reveal any other obvious trouble.
          #
          # No failure here is fatal.  (_close() has worked that way, either due
          # to a principle or just due to a history of callers passing closed
          # FDs.)  croak() on EMFILE would be a bad user experience.  Better to
          # proceed and hope that $fd is not a being-read pipe.
          #
          # Since start() and other user-facing methods _close() many FDs, we
          # could optimize this by opening and closing the non-pipe FD just once
          # per method call.  The overhead of this simple approach was in the
          # noise, however.
          my $nul_fd = POSIX::open 'NUL';
          if ( !defined $nul_fd ) {
              _debug "open( NUL ) = ERROR $!" if _debugging_details;
          }
          else {
              my $r = POSIX::dup2( $nul_fd, $fd );
              _debug "dup2( $nul_fd, $fd ) = ERROR $!"
                if _debugging_details && !defined $r;
              $r = POSIX::close $nul_fd;
              _debug "close( $nul_fd (NUL) ) = ERROR $!"
                if _debugging_details && !defined $r;
          }
      }
      my $r = POSIX::close $fd;
      $r = $r ? '' : " ERROR $!";
      delete $fds{$fd};
      _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
  }
  
  sub _dup {
      confess 'undef' unless defined $_[0];
      my $r = POSIX::dup( $_[0] );
      croak "$!: dup( $_[0] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup( $_[0] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _dup2_rudely {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::dup2( $_[0], $_[1] );
      croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _exec {
      confess 'undef passed' if grep !defined, @_;
  
      #   exec @_ or croak "$!: exec( " . join( ', ', @_ ) . " )";
      _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
  
      #   {
  ## Commented out since we don't call this on Win32.
      #      # This works around the bug where 5.6.1 complains
      #      # "Can't exec ...: No error" after an exec on NT, where
      #      # exec() is simulated and actually returns in Perl's C
      #      # code, though Perl's &exec does not...
      #      no warnings "exec";
      #
      #      # Just in case the no warnings workaround
      #      # stops being a workaround, we don't want
      #      # old values of $! causing spurious strerr()
      #      # messages to appear in the "Can't exec" message
      #      undef $!;
      exec { $_[0] } @_;
  
      #   }
      #   croak "$!: exec( " . join( ', ', map "'$_'", @_ ) . " )";
      ## Fall through so $! can be reported to parent.
  }
  
  sub _sysopen {
      confess 'undef' unless defined $_[0] && defined $_[1];
      _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
        sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
        sprintf( "O_RDWR=0x%02x ",   O_RDWR ),
        sprintf( "O_TRUNC=0x%02x ",  O_TRUNC ),
        sprintf( "O_CREAT=0x%02x ",  O_CREAT ),
        sprintf( "O_APPEND=0x%02x ", O_APPEND ),
        if _debugging_details;
      my $r = POSIX::open( $_[0], $_[1], 0666 );
      croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
      _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
        if _debugging_data;
      $fds{$r} = {};
      return $r;
  }
  
  sub _pipe {
      ## Normal, blocking write for pipes that we read and the child writes,
      ## since most children expect writes to stdout to block rather than
      ## do a partial write.
      my ( $r, $w ) = POSIX::pipe;
      croak "$!: pipe()" unless defined $r;
      _debug "pipe() = ( $r, $w ) " if _debugging_details;
      @fds{$r, $w} = ( {}, {} );
      return ( $r, $w );
  }
  
  sub _pipe_nb {
      ## For pipes that we write, unblock the write side, so we can fill a buffer
      ## and continue to select().
      ## Contributed by Borislav Deianov <borislav@ensim.com>, with minor
      ## bugfix on fcntl result by me.
      local ( *R, *W );
      my $f = pipe( R, W );
      croak "$!: pipe()" unless defined $f;
      my ( $r, $w ) = ( fileno R, fileno W );
      _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
      unless (Win32_MODE) {
          ## POSIX::fcntl doesn't take fd numbers, so gotta use Perl's and
          ## then _dup the originals (which get closed on leaving this block)
          my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
          croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
          _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
      }
      ( $r, $w ) = ( _dup($r), _dup($w) );
      _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
      return ( $r, $w );
  }
  
  sub _pty {
      require IO::Pty;
      my $pty = IO::Pty->new();
      croak "$!: pty ()" unless $pty;
      $pty->autoflush();
      $pty->blocking(0) or croak "$!: pty->blocking ( 0 )";
      _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
        if _debugging_details;
      @fds{ $pty->fileno, $pty->slave->fileno } = ( {}, {} );
      return $pty;
  }
  
  sub _read {
      confess 'undef' unless defined $_[0];
      my $s = '';
      my $r = POSIX::read( $_[0], $s, 10_000 );
      croak "$!: read( $_[0] )" if not($r) and !$!{EINTR};
      $r ||= 0;
      _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
      return $s;
  }
  
  ## A METHOD, not a function.
  sub _spawn {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      croak "Can't spawn IPC::Run::Win32Process except on Win32"
        if UNIVERSAL::isa( $kid->{VAL}, 'IPC::Run::Win32Process' );
  
      _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
      my $sync_reader_fd;
      ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
      $kid->{PID} = fork();
      croak "$! during fork" unless defined $kid->{PID};
  
      unless ( $kid->{PID} ) {
          ## _do_kid_and_exit closes sync_reader_fd since it closes all unwanted and
          ## unloved fds.
          $self->_do_kid_and_exit($kid);
      }
      _debug "fork() = ", $kid->{PID} if _debugging_details;
  
      ## Wait for kid to get to it's exec() and see if it fails.
      _close $self->{SYNC_WRITER_FD};
      my $sync_pulse = _read $sync_reader_fd;
      _close $sync_reader_fd;
  
      if ( !defined $sync_pulse || length $sync_pulse ) {
          if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
              $kid->{RESULT} = $?;
          }
          else {
              $kid->{RESULT} = -1;
          }
          $sync_pulse = "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
            unless length $sync_pulse;
          croak $sync_pulse;
      }
      return $kid->{PID};
  
  ## Wait for pty to get set up.  This is a hack until we get synchronous
  ## selects.
      if ( keys %{ $self->{PTYS} } && $IO::Pty::VERSION < 0.9 ) {
          _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
          sleep 1;
      }
  }
  
  sub _write {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::write( $_[0], $_[1], length $_[1] );
      croak "$!: write( $_[0], '$_[1]' )" unless $r;
      _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
      return $r;
  }
  
  =pod
  
  =over
  
  =item run
  
  Run takes a harness or harness specification and runs it, pumping
  all input to the child(ren), closing the input pipes when no more
  input is available, collecting all output that arrives, until the
  pipes delivering output are closed, then waiting for the children to
  exit and reaping their result codes.
  
  You may think of C<run( ... )> as being like 
  
     start( ... )->finish();
  
  , though there is one subtle difference: run() does not
  set \$input_scalars to '' like finish() does.  If an exception is thrown
  from run(), all children will be killed off "gently", and then "annihilated"
  if they do not go gently (in to that dark night. sorry).
  
  If any exceptions are thrown, this does a L</kill_kill> before propagating
  them.
  
  =cut
  
  use vars qw( $in_run );    ## No, not Enron;)
  
  sub run {
      local $in_run = 1;     ## Allow run()-only optimizations.
      my IPC::Run $self = start(@_);
      my $r = eval {
          $self->{clear_ins} = 0;
          $self->finish;
      };
      if ($@) {
          my $x = $@;
          $self->kill_kill;
          die $x;
      }
      return $r;
  }
  
  =pod
  
  =item signal
  
     ## To send it a specific signal by name ("USR1"):
     signal $h, "USR1";
     $h->signal ( "USR1" );
  
  If $signal is provided and defined, sends a signal to all child processes.  Try
  not to send numeric signals, use C<"KILL"> instead of C<9>, for instance.
  Numeric signals aren't portable.
  
  Throws an exception if $signal is undef.
  
  This will I<not> clean up the harness, C<finish> it if you kill it.
  
  Normally TERM kills a process gracefully (this is what the command line utility
  C<kill> does by default), INT is sent by one of the keys C<^C>, C<Backspace> or
  C<E<lt>DelE<gt>>, and C<QUIT> is used to kill a process and make it coredump.
  
  The C<HUP> signal is often used to get a process to "restart", rereading 
  config files, and C<USR1> and C<USR2> for really application-specific things.
  
  Often, running C<kill -l> (that's a lower case "L") on the command line will
  list the signals present on your operating system.
  
  B<WARNING>: The signal subsystem is not at all portable.  We *may* offer
  to simulate C<TERM> and C<KILL> on some operating systems, submit code
  to me if you want this.
  
  B<WARNING 2>: Up to and including perl v5.6.1, doing almost anything in a
  signal handler could be dangerous.  The most safe code avoids all
  mallocs and system calls, usually by preallocating a flag before
  entering the signal handler, altering the flag's value in the
  handler, and responding to the changed value in the main system:
  
     my $got_usr1 = 0;
     sub usr1_handler { ++$got_signal }
  
     $SIG{USR1} = \&usr1_handler;
     while () { sleep 1; print "GOT IT" while $got_usr1--; }
  
  Even this approach is perilous if ++ and -- aren't atomic on your system
  (I've never heard of this on any modern CPU large enough to run perl).
  
  =cut
  
  sub signal {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      $self->_kill_kill_kill_pussycat_kill unless @_;
  
      Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
  
      my ($signal) = @_;
      croak "Undefined signal passed to signal" unless defined $signal;
      for ( grep $_->{PID} && !defined $_->{RESULT}, @{ $self->{KIDS} } ) {
          _debug "sending $signal to $_->{PID}"
            if _debugging;
          kill $signal, $_->{PID}
            or _debugging && _debug "$! sending $signal to $_->{PID}";
      }
  
      return;
  }
  
  =pod
  
  =item kill_kill
  
     ## To kill off a process:
     $h->kill_kill;
     kill_kill $h;
  
     ## To specify the grace period other than 30 seconds:
     kill_kill $h, grace => 5;
  
     ## To send QUIT instead of KILL if a process refuses to die:
     kill_kill $h, coup_d_grace => "QUIT";
  
  Sends a C<TERM>, waits for all children to exit for up to 30 seconds, then
  sends a C<KILL> to any that survived the C<TERM>.
  
  Will wait for up to 30 more seconds for the OS to successfully C<KILL> the
  processes.
  
  The 30 seconds may be overridden by setting the C<grace> option, this
  overrides both timers.
  
  The harness is then cleaned up.
  
  The doubled name indicates that this function may kill again and avoids
  colliding with the core Perl C<kill> function.
  
  Returns a 1 if the C<TERM> was sufficient, or a 0 if C<KILL> was 
  required.  Throws an exception if C<KILL> did not permit the children
  to be reaped.
  
  B<NOTE>: The grace period is actually up to 1 second longer than that
  given.  This is because the granularity of C<time> is 1 second.  Let me
  know if you need finer granularity, we can leverage Time::HiRes here.
  
  B<Win32>: Win32 does not know how to send real signals, so C<TERM> is
  a full-force kill on Win32.  Thus all talk of grace periods, etc. do
  not apply to Win32.
  
  =cut
  
  sub kill_kill {
      my IPC::Run $self = shift;
  
      my %options = @_;
      my $grace   = $options{grace};
      $grace = 30 unless defined $grace;
      ++$grace;    ## Make grace time a _minimum_
  
      my $coup_d_grace = $options{coup_d_grace};
      $coup_d_grace = "KILL" unless defined $coup_d_grace;
  
      delete $options{$_} for qw( grace coup_d_grace );
      Carp::cluck "Ignoring unknown options for kill_kill: ",
        join " ", keys %options
        if keys %options;
  
      if (Win32_MODE) {
  	# immediate brutal death for Win32
  	# TERM has unfortunate side-effects
  	$self->signal("KILL")
      }
      else {
  	$self->signal("TERM");
      }
  
      my $quitting_time = time + $grace;
      my $delay         = 0.01;
      my $accum_delay;
  
      my $have_killed_before;
  
      while () {
          ## delay first to yield to other processes
          select undef, undef, undef, $delay;
          $accum_delay += $delay;
  
          $self->reap_nb;
          last unless $self->_running_kids;
  
          if ( $accum_delay >= $grace * 0.8 ) {
              ## No point in checking until delay has grown some.
              if ( time >= $quitting_time ) {
                  if ( !$have_killed_before ) {
                      $self->signal($coup_d_grace);
                      $have_killed_before = 1;
                      $quitting_time += $grace;
                      $delay       = 0.01;
                      $accum_delay = 0;
                      next;
                  }
                  croak "Unable to reap all children, even after KILLing them";
              }
          }
  
          $delay *= 2;
          $delay = 0.5 if $delay >= 0.5;
      }
  
      $self->_cleanup;
      return $have_killed_before;
  }
  
  =pod
  
  =item harness
  
  Takes a harness specification and returns a harness.  This harness is
  blessed in to IPC::Run, allowing you to use method call syntax for
  run(), start(), et al if you like.
  
  harness() is provided so that you can pre-build harnesses if you
  would like to, but it's not required..
  
  You may proceed to run(), start() or pump() after calling harness() (pump()
  calls start() if need be).  Alternatively, you may pass your
  harness specification to run() or start() and let them harness() for
  you.  You can't pass harness specifications to pump(), though.
  
  =cut
  
  ##
  ## Notes: I've avoided handling a scalar that doesn't look like an
  ## opcode as a here document or as a filename, though I could DWIM
  ## those.  I'm not sure that the advantages outweigh the danger when
  ## the DWIMer guesses wrong.
  ##
  ## TODO: allow user to spec default shell. Hmm, globally, in the
  ## lexical scope hash, or per instance?  'Course they can do that
  ## now by using a [...] to hold the command.
  ##
  my $harness_id = 0;
  
  sub harness {
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      #   local $IPC::Run::debug = $options->{debug}
      #      if $options && defined $options->{debug};
  
      my @args;
      if ( @_ == 1 && !ref $_[0] ) {
          if (Win32_MODE) {
              my $command = $ENV{ComSpec} || 'cmd';
              @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
          }
          else {
              @args = ( [ qw( sh -c ), @_ ] );
          }
      }
      elsif ( @_ > 1 && !grep ref $_, @_ ) {
          @args = ( [@_] );
      }
      else {
          @args = map { !defined $_ ? bless(\$_, 'IPC::Run::Undef') : $_ } @_;
      }
  
      my @errs;    # Accum errors, emit them when done.
  
      my $succinct;    # set if no redir ops are required yet.  Cleared
                       # if an op is seen.
  
      my $cur_kid;     # references kid or handle being parsed
      my $next_kid_close_stdin = 0;
  
      my $assumed_fd = 0;    # fd to assume in succinct mode (no redir ops)
      my $handle_num = 0;    # 1... is which handle we're parsing
  
      my IPC::Run $self = bless {}, __PACKAGE__;
  
      local $cur_self = $self;
  
      $self->{ID}    = ++$harness_id;
      $self->{IOS}   = [];
      $self->{KIDS}  = [];
      $self->{PIPES} = [];
      $self->{PTYS}  = {};
      $self->{STATE} = _newed;
  
      if ($options) {
          $self->{$_} = $options->{$_} for keys %$options;
      }
  
      _debug "****** harnessing *****" if _debugging;
  
      my $first_parse;
      local $_;
      my $arg_count = @args;
      while (@args) {
          for ( shift @args ) {
              eval {
                  $first_parse = 1;
                  _debug( "parsing ", _debugstrings($_) ) if _debugging;
  
                REPARSE:
                  if (   ref eq 'ARRAY'
                      || UNIVERSAL::isa( $_, 'IPC::Run::Win32Process' )
                      || ( !$cur_kid && ref eq 'CODE' ) ) {
                      croak "Process control symbol ('|', '&') missing" if $cur_kid;
                      croak "Can't spawn a subroutine on Win32"
                        if Win32_MODE && ref eq "CODE";
                      $cur_kid = {
                          TYPE   => 'cmd',
                          VAL    => $_,
                          NUM    => @{ $self->{KIDS} } + 1,
                          OPS    => [],
                          PID    => '',
                          RESULT => undef,
                      };
  
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => 0,
                      } if $next_kid_close_stdin;
                      $next_kid_close_stdin = 0;
  
                      push @{ $self->{KIDS} }, $cur_kid;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
                      push @{ $self->{IOS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
                      push @{ $self->{TIMERS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif (/^(\d*)>&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 1,
                      };
                      _debug "redirect operators now required" if _debugging_details;
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&-$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*) (<pipe)()            ()  ()  $/x
                      || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
                      || /^(\d*) (<)    ()            ()  (.*)$/x ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = $2 . $4;
  
                      my $kfd = length $1 ? $1 : 0;
  
                      my $pty_id;
                      if ( $type eq '<pty<' ) {
                          $pty_id = length $3 ? $3 : '0';
                          ## do the require here to cause early error reporting
                          require IO::Pty;
                          ## Just flag the pyt's existence for now.  It'll be
                          ## converted to a real IO::Pty by _open_pipes.
                          $self->{PTYS}->{$pty_id} = undef;
                      }
  
                      my $source = $5;
  
                      my @filters;
                      my $binmode;
  
                      unless ( length $source ) {
                          if ( !$succinct ) {
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      push @filters, shift @args;
                                  }
                              }
                          }
                          $source = shift @args;
                          croak "'$_' missing a source" if _empty $source;
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s input fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
                      }
  
                      my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $source, $binmode, @filters );
  
                      if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
                          && $type !~ /^<p(ty<|ipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                          _dont_inherit($source) if Win32_MODE;
                      }
  
                      push @{ $cur_kid->{OPS} }, $pipe;
                  }
  
                  elsif (
                         /^()   (>>?)  (&)     ()      (.*)$/x
                      || /^()   (&)    (>pipe) ()      ()  $/x
                      || /^()   (>pipe)(&)     ()      ()  $/x
                      || /^(\d*)()     (>pipe) ()      ()  $/x
                      || /^()   (&)    (>pty)  ( \w*)> ()  $/x
  ## TODO:    ||   /^()   (>pty) (\d*)> (&) ()  $/x
                      || /^(\d*)()     (>pty)  ( \w*)> ()  $/x
                      || /^()   (&)    (>>?)   ()      (.*)$/x || /^(\d*)()     (>>?)   ()      (.*)$/x
                    ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = (
                            $2 eq '>pipe' || $3 eq '>pipe' ? '>pipe'
                          : $2 eq '>pty'  || $3 eq '>pty'  ? '>pty>'
                          :                                  '>'
                      );
                      my $kfd = length $1 ? $1 : 1;
                      my $trunc = !( $2 eq '>>' || $3 eq '>>' );
                      my $pty_id = (
                            $2 eq '>pty' || $3 eq '>pty'
                          ? length $4
                                ? $4
                                : 0
                          : undef
                      );
  
                      my $stderr_too =
                           $2 eq '&'
                        || $3 eq '&'
                        || ( !length $1 && substr( $type, 0, 4 ) eq '>pty' );
  
                      my $dest = $5;
                      my @filters;
                      my $binmode = 0;
                      unless ( length $dest ) {
                          if ( !$succinct ) {
                              ## unshift...shift: '>' filters source...sink left...right
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      unshift @filters, shift @args;
                                  }
                              }
                          }
  
  			if ( @args && ref $args[0] eq 'IPC::Run::Undef' ) {
  			    require Symbol;
  			    ${ $args[0] } = $dest = Symbol::gensym();
  			    shift @args;
  			}
  			else {
  			    $dest = shift @args;
  			}
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s output fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
  
                          if ( $type eq '>pty>' ) {
                              ## do the require here to cause early error reporting
                              require IO::Pty;
                              ## Just flag the pyt's existence for now.  _open_pipes()
                              ## will new an IO::Pty for each key.
                              $self->{PTYS}->{$pty_id} = undef;
                          }
                      }
  
                      croak "'$_' missing a destination" if _empty $dest;
                      my $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $dest, $binmode, @filters );
                      $pipe->{TRUNC} = $trunc;
  
                      if ( ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
                          && $type !~ /^>(pty>|pipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                      }
                      push @{ $cur_kid->{OPS} }, $pipe;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => 1,
                          KFD2 => 2,
                      } if $stderr_too;
                  }
  
                  elsif ( $_ eq "|" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => '|',
                          KFD  => 1,
                      };
                      $succinct   = 1;
                      $assumed_fd = 1;
                      $cur_kid    = undef;
                  }
  
                  elsif ( $_ eq "&" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      $next_kid_close_stdin = 1;
                      $succinct             = 1;
                      $assumed_fd           = 0;
                      $cur_kid              = undef;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( !ref $_ ) {
                      $self->{$_} = shift @args;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( $succinct && $first_parse ) {
                      ## It's not an opcode, and no explicit opcodes have been
                      ## seen yet, so assume it's a file name.
                      unshift @args, $_;
                      if ( !$assumed_fd ) {
                          $_ = "$assumed_fd<",
                      }
                      else {
                          $_ = "$assumed_fd>",
                      }
                      _debug "assuming '", $_, "'" if _debugging_details;
                      ++$assumed_fd;
                      $first_parse = 0;
                      goto REPARSE;
                  }
  
                  else {
                      croak join(
                          '',
                          'Unexpected ',
                          ( ref() ? $_ : 'scalar' ),
                          ' in harness() parameter ',
                          $arg_count - @args
                      );
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      die join( '', @errs ) if @errs;
  
      $self->{STATE} = _harnessed;
  
      #   $self->timeout( $options->{timeout} ) if exists $options->{timeout};
      return $self;
  }
  
  sub _open_pipes {
      my IPC::Run $self = shift;
  
      my @errs;
  
      my @close_on_fail;
  
      ## When a pipe character is seen, a pipe is created.  $pipe_read_fd holds
      ## the dangling read end of the pipe until we get to the next process.
      my $pipe_read_fd;
  
      ## Output descriptors for the last command are shared by all children.
      ## @output_fds_accum accumulates the current set of output fds.
      my @output_fds_accum;
  
      for ( sort keys %{ $self->{PTYS} } ) {
          _debug "opening pty '", $_, "'" if _debugging_details;
          my $pty = _pty;
          $self->{PTYS}->{$_} = $pty;
      }
  
      for ( @{ $self->{IOS} } ) {
          eval { $_->init; };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
          else {
              push @close_on_fail, $_;
          }
      }
  
      ## Loop through the kids and their OPS, interpreting any that require
      ## parent-side actions.
      for my $kid ( @{ $self->{KIDS} } ) {
          if ( ref $kid->{VAL} eq 'ARRAY' ) {
              $kid->{PATH} = _search_path $kid->{VAL}->[0];
          }
          if ( defined $pipe_read_fd ) {
              _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
                if _debugging_details;
              unshift @{ $kid->{OPS} }, {
                  TYPE => 'PIPE',          ## Prevent next loop from triggering on this
                  KFD  => 0,
                  TFD  => $pipe_read_fd,
              };
              $pipe_read_fd = undef;
          }
          @output_fds_accum = ();
          for my $op ( @{ $kid->{OPS} } ) {
  
              #         next if $op->{IS_DEBUG};
              my $ok = eval {
                  if ( $op->{TYPE} eq '<' ) {
                      my $source = $op->{SOURCE};
                      if ( !ref $source ) {
                          _debug(
                              "kid ",              $kid->{NUM}, " to read ", $op->{KFD},
                              " from '" . $source, "' (read only)"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen( $source, O_RDONLY );
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif (UNIVERSAL::isa( $source, 'GLOB' )
                          || UNIVERSAL::isa( $source, 'IO::Handle' ) ) {
                          croak "Unopened filehandle in input redirect for $op->{KFD}"
                            unless defined fileno $source;
                          $op->{TFD} = fileno $source;
                          _debug(
                              "kid ",      $kid->{NUM}, " to read ", $op->{KFD},
                              " from fd ", $op->{TFD}
                          ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                          _debug(
                              "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                              " from SCALAR"
                          ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                          _debug( 'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE' ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      else {
                          croak( "'" . ref($source) . "' not allowed as a source for input redirection" );
                      }
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pipe' ) {
                      _debug(
                          'kid to read ', $op->{KFD},
                          ' from a pipe IPC::Run opens and returns',
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
                      _debug "caller will write to ", fileno $op->{SOURCE}
                        if _debugging_details;
  
                      $op->{TFD} = $r;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pty<' ) {
                      _debug(
                          'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
                      ) if _debugging_details;
  
                      for my $source ( $op->{SOURCE} ) {
                          if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                              _debug(
                                  "kid ",                   $kid->{NUM},   " to read ", $op->{KFD},
                                  " from SCALAR via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
  
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                              _debug(
                                  "kid ",                 $kid->{NUM},   " to read ", $op->{KFD},
                                  " from CODE via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          else {
                              croak( "'" . ref($source) . "' not allowed as a source for '<pty<' redirection" );
                          }
                      }
                      $op->{FD}  = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD} = undef;                                      # The fd isn't known until after fork().
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '>' ) {
                      ## N> output redirection.
                      my $dest = $op->{DEST};
                      if ( !ref $dest ) {
                          _debug(
                              "kid ",  $kid->{NUM}, " to write ", $op->{KFD},
                              " to '", $dest,       "' (write only, create, ",
                              ( $op->{TRUNC} ? 'truncate' : 'append' ),
                              ")"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen(
                              $dest,
                              ( O_WRONLY | O_CREAT | ( $op->{TRUNC} ? O_TRUNC : O_APPEND ) )
                          );
                          if (Win32_MODE) {
                              ## I have no idea why this is needed to make the current
                              ## file position survive the gyrations TFD must go
                              ## through...
                              POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
                          }
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
                          croak("Unopened filehandle in output redirect, command $kid->{NUM}") unless defined fileno $dest;
                          ## Turn on autoflush, mostly just to flush out
                          ## existing output.
                          my $old_fh = select($dest);
                          $| = 1;
                          select($old_fh);
                          $op->{TFD} = fileno $dest;
                          _debug( 'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD} ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug( "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR" ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug("kid $kid->{NUM} to write $op->{KFD} to CODE") if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
  
                  elsif ( $op->{TYPE} eq '>pipe' ) {
                      ## N> output redirection to a pipe we open, but don't select()
                      ## on.
                      _debug(
                          "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                          ' to a pipe IPC::Run opens and returns'
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
                      _debug "caller will read from ", fileno $op->{DEST}
                        if _debugging_details;
  
                      $op->{TFD} = $w;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
  
                      $output_fds_accum[ $op->{KFD} ] = $op;
                  }
                  elsif ( $op->{TYPE} eq '>pty>' ) {
                      my $dest = $op->{DEST};
                      if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug(
                              "kid ",                 $kid->{NUM},   " to write ", $op->{KFD},
                              " to SCALAR via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
  
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug(
                              "kid ",               $kid->{NUM},   " to write ", $op->{KFD},
                              " to CODE via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
  
                      $op->{FD}                       = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD}                      = undef;                                      # The fd isn't known until after fork().
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '|' ) {
                      _debug( "pipelining $kid->{NUM} and " . ( $kid->{NUM} + 1 ) ) if _debugging_details;
                      ( $pipe_read_fd, $op->{TFD} ) = _pipe;
                      if (Win32_MODE) {
                          _dont_inherit($pipe_read_fd);
                          _dont_inherit( $op->{TFD} );
                      }
                      @output_fds_accum = ();
                  }
                  elsif ( $op->{TYPE} eq '&' ) {
                      @output_fds_accum = ();
                  }    # end if $op->{TYPE} tree
                  1;
              };    # end eval
              unless ($ok) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }    # end for ( OPS }
      }
  
      if (@errs) {
          for (@close_on_fail) {
              _close($_);
              $_ = undef;
          }
          for ( keys %{ $self->{PTYS} } ) {
              next unless $self->{PTYS}->{$_};
              close $self->{PTYS}->{$_};
              $self->{PTYS}->{$_} = undef;
          }
          die join( '', @errs );
      }
  
      ## give all but the last child all of the output file descriptors
      ## These will be reopened (and thus rendered useless) if the child
      ## dup2s on to these descriptors, since we unshift these.  This way
      ## each process emits output to the same file descriptors that the
      ## last child will write to.  This is probably not quite correct,
      ## since each child should write to the file descriptors inherited
      ## from the parent.
      ## TODO: fix the inheritance of output file descriptors.
      ## NOTE: This sharing of OPS among kids means that we can't easily put
      ## a kid number in each OPS structure to ping the kid when all ops
      ## have closed (when $self->{PIPES} has emptied).  This means that we
      ## need to scan the KIDS whenever @{$self->{PIPES}} is empty to see
      ## if there any of them are still alive.
      for ( my $num = 0; $num < $#{ $self->{KIDS} }; ++$num ) {
          for ( reverse @output_fds_accum ) {
              next unless defined $_;
              _debug(
                  'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
                  ' to ', ref $_->{DEST}
              ) if _debugging_details;
              unshift @{ $self->{KIDS}->[$num]->{OPS} }, $_;
          }
      }
  
      ## Open the debug pipe if we need it
      ## Create the list of PIPES we need to scan and the bit vectors needed by
      ## select().  Do this first so that _cleanup can _clobber() them if an
      ## exception occurs.
      @{ $self->{PIPES} } = ();
      $self->{RIN} = '';
      $self->{WIN} = '';
      $self->{EIN} = '';
      ## PIN is a vec()tor that indicates who's paused.
      $self->{PIN} = '';
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{FD} ) {
                  _debug(
                      'kid ',    $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
                      ' is my ', $_->{FD}
                  ) if _debugging_details;
                  vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $_->{FD}, 1 ) = 1;
                  push @{ $self->{PIPES} }, $_;
              }
          }
      }
  
      for my $io ( @{ $self->{IOS} } ) {
          my $fd = $io->fileno;
          vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
          vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
  
          #      vec( $self->{EIN}, $fd, 1 ) = 1;
          push @{ $self->{PIPES} }, $io;
      }
  
      ## Put filters on the end of the filter chains to read & write the pipes.
      ## Clear pipe states
      for my $pipe ( @{ $self->{PIPES} } ) {
          $pipe->{SOURCE_EMPTY} = 0;
          $pipe->{PAUSED}       = 0;
          if ( $pipe->{TYPE} =~ /^>/ ) {
              my $pipe_reader = sub {
                  my ( undef, $out_ref ) = @_;
  
                  return undef unless defined $pipe->{FD};
                  return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
  
                  vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
  
                  _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
                  my $in = eval { _read( $pipe->{FD} ) };
                  if ($@) {
                      $in = '';
                      ## IO::Pty throws the Input/output error if the kid dies.
                      ## read() throws the bad file descriptor message if the
                      ## kid dies on Win32.
                      die $@
                        unless $@ =~ $_EIO
                        || ( $@ =~ /input or output/ && $^O =~ /aix/ )
                        || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
                  }
  
                  unless ( length $in ) {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  ## Protect the position so /.../g matches may be used.
                  my $pos = pos $$out_ref;
                  $$out_ref .= $in;
                  pos($$out_ref) = $pos;
                  return 1;
              };
              ## Input filters are the last filters
              push @{ $pipe->{FILTERS} },      $pipe_reader;
              push @{ $self->{TEMP_FILTERS} }, $pipe_reader;
          }
          else {
              my $pipe_writer = sub {
                  my ( $in_ref, $out_ref ) = @_;
                  return undef unless defined $pipe->{FD};
                  return 0
                    unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
                    || $pipe->{PAUSED};
  
                  vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
  
                  if ( !length $$in_ref ) {
                      if ( !defined get_more_input ) {
                          $self->_clobber($pipe);
                          return undef;
                      }
                  }
  
                  unless ( length $$in_ref ) {
                      unless ( $pipe->{PAUSED} ) {
                          _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
                          vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
  
                          #		  vec( $self->{EIN}, $pipe->{FD}, 1 ) = 0;
                          vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
                          $pipe->{PAUSED} = 1;
                      }
                      return 0;
                  }
                  _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
  
                  if ( length $$in_ref && $$in_ref ) {
                      my $c = _write( $pipe->{FD}, $$in_ref );
                      substr( $$in_ref, 0, $c, '' );
                  }
                  else {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  return 1;
              };
              ## Output filters are the first filters
              unshift @{ $pipe->{FILTERS} }, $pipe_writer;
              push @{ $self->{TEMP_FILTERS} }, $pipe_writer;
          }
      }
  }
  
  sub _dup2_gently {
      ## A METHOD, NOT A FUNCTION, NEEDS $self!
      my IPC::Run $self = shift;
      my ( $files, $fd1, $fd2 ) = @_;
      ## Moves TFDs that are using the destination fd out of the
      ## way before calling _dup2
      for (@$files) {
          next unless defined $_->{TFD};
          $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
      }
      if ( defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2 ) {
          $self->{DEBUG_FD} = _dup $self->{DEBUG_FD};
          $fds{$self->{DEBUG_FD}}{needed} = 1;
      }
      _dup2_rudely( $fd1, $fd2 );
  }
  
  =pod
  
  =item close_terminal
  
  This is used as (or in) an init sub to cast off the bonds of a controlling
  terminal.  It must precede all other redirection ops that affect
  STDIN, STDOUT, or STDERR to be guaranteed effective.
  
  =cut
  
  sub close_terminal {
      ## Cast of the bonds of a controlling terminal
  
      # Just in case the parent (I'm talking to you FCGI) had these tied.
      untie *STDIN;
      untie *STDOUT;
      untie *STDERR;
  
      POSIX::setsid() || croak "POSIX::setsid() failed";
      _debug "closing stdin, out, err"
        if _debugging_details;
      close STDIN;
      close STDERR;
      close STDOUT;
  }
  
  sub _do_kid_and_exit {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      my ( $s1, $s2 );
      if ( $] < 5.008 ) {
          ## For unknown reasons, placing these two statements in the eval{}
          ## causes the eval {} to not catch errors after they are executed in
          ## perl 5.6.0, godforsaken version that it is...not sure about 5.6.1.
          ## Part of this could be that these symbols get destructed when
          ## exiting the eval, and that destruction might be what's (wrongly)
          ## confusing the eval{}, allowing the exception to propagate.
          $s1 = Symbol::gensym();
          $s2 = Symbol::gensym();
      }
  
      eval {
          local $cur_self = $self;
  
          if (_debugging) {
              _set_child_debug_name(
                  ref $kid->{VAL} eq "CODE"
                  ? "CODE"
                  : basename( $kid->{VAL}->[0] )
              );
          }
  
          ## close parent FD's first so they're out of the way.
          ## Don't close STDIN, STDOUT, STDERR: they should be inherited or
          ## overwritten below.
          do { $_->{needed} = 1 for @fds{0..2} }
             unless $self->{noinherit};
  
          $fds{$self->{SYNC_WRITER_FD}}{needed} = 1;
          $fds{$self->{DEBUG_FD}}{needed} = 1 if defined $self->{DEBUG_FD};
  
          $fds{$_->{TFD}}{needed} = 1
             foreach grep { defined $_->{TFD} } @{$kid->{OPS} };
  
  
          ## TODO: use the forthcoming IO::Pty to close the terminal and
          ## make the first pty for this child the controlling terminal.
          ## This will also make it so that pty-laden kids don't cause
          ## other kids to lose stdin/stdout/stderr.
  
          if ( %{ $self->{PTYS} } ) {
              ## Clean up the parent's fds.
              for ( keys %{ $self->{PTYS} } ) {
                  _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
                  $self->{PTYS}->{$_}->make_slave_controlling_terminal;
                  my $slave = $self->{PTYS}->{$_}->slave;
   	        delete $fds{$self->{PTYS}->{$_}->fileno};
                  close $self->{PTYS}->{$_};
                  $self->{PTYS}->{$_} = $slave;
              }
  
              close_terminal;
              delete @fds{0..2};
          }
  
          for my $sibling ( @{ $self->{KIDS} } ) {
              for ( @{ $sibling->{OPS} } ) {
                  if ( $_->{TYPE} =~ /^.pty.$/ ) {
                      $_->{TFD} = $self->{PTYS}->{ $_->{PTY_ID} }->fileno;
                      $fds{$_->{TFD}}{needed} = 1;
                  }
  
                  #	    for ( $_->{FD}, ( $sibling != $kid ? $_->{TFD} : () ) ) {
                  #	       if ( defined $_ && ! $closed[$_] && ! $needed[$_] ) {
                  #		  _close( $_ );
                  #		  $closed[$_] = 1;
                  #		  $_ = undef;
                  #	       }
                  #	    }
              }
          }
  
          ## This is crude: we have no way of keeping track of browsing all open
          ## fds, so we scan to a fairly high fd.
          _debug "open fds: ", join " ", keys %fds if _debugging_details;
  
          _close( $_ ) foreach grep { ! $fds{$_}{needed} } keys %fds;
  
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{TFD} ) {
  
                  # we're always creating KFD
                  $fds{$_->{KFD}}{needed} = 1;
  
                  unless ( $_->{TFD} == $_->{KFD} ) {
                      $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
                      $fds{$_->{TFD}}{lazy_close} = 1;
                  } else {
                      my $fd = _dup($_->{TFD});
                      $self->_dup2_gently( $kid->{OPS}, $fd, $_->{KFD} );
                      _close($fd);
                  }
              }
              elsif ( $_->{TYPE} eq 'dup' ) {
                  $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
                    unless $_->{KFD1} == $_->{KFD2};
                  $fds{$_->{KFD2}}{needed} = 1;
              }
              elsif ( $_->{TYPE} eq 'close' ) {
                  for ( $_->{KFD} ) {
                      if ( $fds{$_} ) {
                          _close($_);
                          $_ = undef;
                      }
                  }
              }
              elsif ( $_->{TYPE} eq 'init' ) {
                  $_->{SUB}->();
              }
          }
  
          _close( $_ ) foreach grep { $fds{$_}{lazy_close} } keys %fds;
  
          if ( ref $kid->{VAL} ne 'CODE' ) {
              open $s1, ">&=$self->{SYNC_WRITER_FD}"
                or croak "$! setting filehandle to fd SYNC_WRITER_FD";
              fcntl $s1, F_SETFD, 1;
  
              if ( defined $self->{DEBUG_FD} ) {
                  open $s2, ">&=$self->{DEBUG_FD}"
                    or croak "$! setting filehandle to fd DEBUG_FD";
                  fcntl $s2, F_SETFD, 1;
              }
  
              if (_debugging) {
                  my @cmd = ( $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] );
                  _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd;
              }
  
              die "exec failed: simulating exec() failure"
                if $self->{_simulate_exec_failure};
  
              _exec $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ];
  
              croak "exec failed: $!";
          }
      };
      if ($@) {
          _write $self->{SYNC_WRITER_FD}, $@;
          ## Avoid DESTROY.
          POSIX::_exit(1);
      }
  
      ## We must be executing code in the child, otherwise exec() would have
      ## prevented us from being here.
      _close $self->{SYNC_WRITER_FD};
      _debug 'calling fork()ed CODE ref' if _debugging;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      ## TODO: Overload CORE::GLOBAL::exit...
      $kid->{VAL}->();
  
      ## There are bugs in perl closures up to and including 5.6.1
      ## that may keep this next line from having any effect, and it
      ## won't have any effect if our caller has kept a copy of it, but
      ## this may cause the closure to be cleaned up.  Maybe.
      $kid->{VAL} = undef;
  
      ## Use POSIX::_exit to avoid global destruction, since this might
      ## cause DESTROY() to be called on objects created in the parent
      ## and thus cause double cleanup.  For instance, if DESTROY() unlinks
      ## a file in the child, we don't want the parent to suddenly miss
      ## it.
      POSIX::_exit(0);
  }
  
  =pod
  
  =item start
  
     $h = start(
        \@cmd, \$in, \$out, ...,
        timeout( 30, name => "process timeout" ),
        $stall_timeout = timeout( 10, name => "stall timeout"   ),
     );
  
     $h = start \@cmd, '<', \$in, '|', \@cmd2, ...;
  
  start() accepts a harness or harness specification and returns a harness
  after building all of the pipes and launching (via fork()/exec(), or, maybe
  someday, spawn()) all the child processes.  It does not send or receive any
  data on the pipes, see pump() and finish() for that.
  
  You may call harness() and then pass it's result to start() if you like,
  but you only need to if it helps you structure or tune your application.
  If you do call harness(), you may skip start() and proceed directly to
  pump.
  
  start() also starts all timers in the harness.  See L<IPC::Run::Timer>
  for more information.
  
  start() flushes STDOUT and STDERR to help you avoid duplicate output.
  It has no way of asking Perl to flush all your open filehandles, so
  you are going to need to flush any others you have open.  Sorry.
  
  Here's how if you don't want to alter the state of $| for your
  filehandle:
  
     $ofh = select HANDLE; $of = $|; $| = 1; $| = $of; select $ofh;
  
  If you don't mind leaving output unbuffered on HANDLE, you can do
  the slightly shorter
  
     $ofh = select HANDLE; $| = 1; select $ofh;
  
  Or, you can use IO::Handle's flush() method:
  
     use IO::Handle;
     flush HANDLE;
  
  Perl needs the equivalent of C's fflush( (FILE *)NULL ).
  
  =cut
  
  sub start {
  
      # $SIG{__DIE__} = sub { my $s = shift; Carp::cluck $s; die $s };
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      my IPC::Run $self;
      if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
          $self = shift;
          $self->{$_} = $options->{$_} for keys %$options;
      }
      else {
          $self = harness( @_, $options ? $options : () );
      }
  
      local $cur_self = $self;
  
      $self->kill_kill if $self->{STATE} == _started;
  
      _debug "** starting" if _debugging;
  
      $_->{RESULT} = undef for @{ $self->{KIDS} };
  
      ## Assume we're not being called from &run.  It will correct our
      ## assumption if need be.  This affects whether &_select_loop clears
      ## input queues to '' when they're empty.
      $self->{clear_ins} = 1;
  
      IPC::Run::Win32Helper::optimize $self
        if Win32_MODE && $in_run;
  
      my @errs;
  
      for ( @{ $self->{TIMERS} } ) {
          eval { $_->start };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
      }
  
      eval { $self->_open_pipes };
      if ($@) {
          push @errs, $@;
          _debug 'caught ', $@ if _debugging;
      }
  
      if ( !@errs ) {
          ## This is a bit of a hack, we should do it for all open filehandles.
          ## Since there's no way I know of to enumerate open filehandles, we
          ## autoflush STDOUT and STDERR.  This is done so that the children don't
          ## inherit output buffers chock full o' redundant data.  It's really
          ## confusing to track that down.
          { my $ofh = select STDOUT; my $of = $|; $| = 1; $| = $of; select $ofh; }
          { my $ofh = select STDERR; my $of = $|; $| = 1; $| = $of; select $ofh; }
          for my $kid ( @{ $self->{KIDS} } ) {
              $kid->{RESULT} = undef;
              _debug "child: ", _debugstrings( $kid->{VAL} )
                if _debugging_details;
              eval {
                  croak "simulated failure of fork"
                    if $self->{_simulate_fork_failure};
                  unless (Win32_MODE) {
                      $self->_spawn($kid);
                  }
                  else {
  ## TODO: Test and debug spawning code.  Someday.
                      _debug(
                          'spawning ',
                          _debugstrings(
                              [
                                  $kid->{PATH},
                                  @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ]
                              ]
                          )
                      ) if $kid->{PATH} && _debugging;
                      ## The external kid wouldn't know what to do with it anyway.
                      ## This is only used by the "helper" pump processes on Win32.
                      _dont_inherit( $self->{DEBUG_FD} );
                      ( $kid->{PID}, $kid->{PROCESS} ) = IPC::Run::Win32Helper::win32_spawn(
                          ref( $kid->{VAL} ) eq "ARRAY"
                          ? [ $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] ]
                          : $kid->{VAL},
                          $kid->{OPS},
                      );
                      _debug "spawn() = ", $kid->{PID} if _debugging;
                      if ($self->{_sleep_after_win32_spawn}) {
                        sleep $self->{_sleep_after_win32_spawn};
                        _debug "after sleep $self->{_sleep_after_win32_spawn}"
                            if _debugging;
                      }
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      ## Close all those temporary filehandles that the kids needed.
      for my $pty ( values %{ $self->{PTYS} } ) {
          close $pty->slave;
      }
  
      my @closed;
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              my $close_it = eval {
                       defined $_->{TFD}
                    && !$_->{DONT_CLOSE}
                    && !$closed[ $_->{TFD} ]
                    && ( !Win32_MODE || !$_->{RECV_THROUGH_TEMP_FILE} )    ## Win32 hack
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
              if ( $close_it || $@ ) {
                  eval {
                      _close( $_->{TFD} );
                      $closed[ $_->{TFD} ] = 1;
                      $_->{TFD} = undef;
                  };
                  if ($@) {
                      push @errs, $@;
                      _debug 'caught ', $@ if _debugging;
                  }
              }
          }
      }
      confess "gak!" unless defined $self->{PIPES};
  
      if (@errs) {
          eval { $self->_cleanup };
          warn $@ if $@;
          die join( '', @errs );
      }
  
      $self->{STATE} = _started;
      return $self;
  }
  
  =item adopt
  
  Experimental feature. NOT FUNCTIONAL YET, NEED TO CLOSE FDS BETTER IN CHILDREN.  SEE t/adopt.t for a test suite.
  
  =cut
  
  sub adopt {
      my IPC::Run $self = shift;
  
      for my $adoptee (@_) {
          push @{ $self->{IOS} }, @{ $adoptee->{IOS} };
          ## NEED TO RENUMBER THE KIDS!!
          push @{ $self->{KIDS} },  @{ $adoptee->{KIDS} };
          push @{ $self->{PIPES} }, @{ $adoptee->{PIPES} };
          $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_} for keys %{ $adoptee->{PYTS} };
          push @{ $self->{TIMERS} }, @{ $adoptee->{TIMERS} };
          $adoptee->{STATE} = _finished;
      }
  }
  
  sub _clobber {
      my IPC::Run $self = shift;
      my ($file) = @_;
      _debug_desc_fd( "closing", $file ) if _debugging_details;
      my $doomed = $file->{FD};
      my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
      vec( $self->{$dir}, $doomed, 1 ) = 0;
  
      #   vec( $self->{EIN},  $doomed, 1 ) = 0;
      vec( $self->{PIN}, $doomed, 1 ) = 0;
      if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
          if ( $1 eq '>' ) {
              ## Only close output ptys.  This is so that ptys as inputs are
              ## never autoclosed, which would risk losing data that was
              ## in the slave->parent queue.
              _debug_desc_fd "closing pty", $file if _debugging_details;
              close $self->{PTYS}->{ $file->{PTY_ID} }
                if defined $self->{PTYS}->{ $file->{PTY_ID} };
              $self->{PTYS}->{ $file->{PTY_ID} } = undef;
          }
      }
      elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
          $file->close unless $file->{DONT_CLOSE};
      }
      else {
          _close($doomed);
      }
  
      @{ $self->{PIPES} } = grep
        defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed ),
        @{ $self->{PIPES} };
  
      $file->{FD} = undef;
  }
  
  sub _select_loop {
      my IPC::Run $self = shift;
  
      my $io_occurred;
  
      my $not_forever = 0.01;
  
    SELECT:
      while ( $self->pumpable ) {
          if ( $io_occurred && $self->{break_on_io} ) {
              _debug "exiting _select(): io occurred and break_on_io set"
                if _debugging_details;
              last;
          }
  
          my $timeout = $self->{non_blocking} ? 0 : undef;
  
          if ( @{ $self->{TIMERS} } ) {
              my $now = time;
              my $time_left;
              for ( @{ $self->{TIMERS} } ) {
                  next unless $_->is_running;
                  $time_left = $_->check($now);
                  ## Return when a timer expires
                  return if defined $time_left && !$time_left;
                  $timeout = $time_left
                    if !defined $timeout || $time_left < $timeout;
              }
          }
  
          ##
          ## See if we can unpause any input channels
          ##
          my $paused = 0;
  
          for my $file ( @{ $self->{PIPES} } ) {
              next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
  
              _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
              my $did;
              1 while $did = $file->_do_filters($self);
              if ( defined $file->{FD} && !defined($did) || $did ) {
                  _debug_desc_fd( "unpausing", $file ) if _debugging_details;
                  $file->{PAUSED} = 0;
                  vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $file->{FD}, 1 ) = 1;
                  vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
              }
              else {
                  ## This gets incremented occasionally when the IO channel
                  ## was actually closed.  That's a bug, but it seems mostly
                  ## harmless: it causes us to exit if break_on_io, or to set
                  ## the timeout to not be forever.  I need to fix it, though.
                  ++$paused;
              }
          }
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{RIN}, $_, 1 );
                      $out = $out ? 'b' : 'w' if vec( $self->{WIN}, $_, 1 );
                      $out = 'p' if !$out && vec( $self->{PIN}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EIN}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 1024 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug 'fds for select: ', $map if _debugging_details;
          }
  
          ## _do_filters may have closed our last fd, and we need to see if
          ## we have I/O, or are just waiting for children to exit.
          my $p = $self->pumpable;
          last unless $p;
          if ( $p != 0 && ( !defined $timeout || $timeout > 0.1 ) ) {
              ## No I/O will wake the select loop up, but we have children
              ## lingering, so we need to poll them with a short timeout.
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          ## Make sure we don't block forever in select() because inputs are
          ## paused.
          if ( !defined $timeout && !( @{ $self->{PIPES} } - $paused ) ) {
              ## Need to return if we're in pump and all input is paused, or
              ## we'll loop until all inputs are unpaused, which is darn near
              ## forever.  And a day.
              if ( $self->{break_on_io} ) {
                  _debug "exiting _select(): no I/O to do and timeout=forever"
                    if _debugging;
                  last;
              }
  
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          _debug 'timeout=', defined $timeout ? $timeout : 'forever'
            if _debugging_details;
  
          my $nfound;
          unless (Win32_MODE) {
              $nfound = select(
                  $self->{ROUT} = $self->{RIN},
                  $self->{WOUT} = $self->{WIN},
                  $self->{EOUT} = $self->{EIN},
                  $timeout
              );
          }
          else {
              my @in = map $self->{$_}, qw( RIN WIN EIN );
              ## Win32's select() on Win32 seems to die if passed vectors of
              ## all 0's.  Need to report this when I get back online.
              for (@in) {
                  $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
              }
  
              $nfound = select(
                  $self->{ROUT} = $in[0],
                  $self->{WOUT} = $in[1],
                  $self->{EOUT} = $in[2],
                  $timeout
              );
  
              for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
                  $_ = "" unless defined $_;
              }
          }
          last if !$nfound && $self->{non_blocking};
  
          if ( $nfound < 0 ) {
              if ( $!{EINTR} ) {
  
                  # Caught a signal before any FD went ready.  Ensure that
                  # the bit fields reflect "no FDs ready".
                  $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
                  $nfound = 0;
              }
              else {
                  croak "$! in select";
              }
          }
          ## TODO: Analyze the EINTR failure mode and see if this patch
          ## is adequate and optimal.
          ## TODO: Add an EINTR test to the test suite.
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{ROUT}, $_, 1 );
                      $out = $out ? 'b'      : 'w' if vec( $self->{WOUT}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EOUT}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 128 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug "selected  ", $map;
          }
  
          ## Need to copy since _clobber alters @{$self->{PIPES}}.
          ## TODO: Rethink _clobber().  Rethink $file->{PAUSED}, too.
          my @pipes = @{ $self->{PIPES} };
          $io_occurred = $_->poll($self) ? 1 : $io_occurred for @pipes;
  
          #   FILE:
          #      for my $pipe ( @pipes ) {
          #         ## Pipes can be shared among kids.  If another kid closes the
          #         ## pipe, then it's {FD} will be undef.  Also, on Win32, pipes can
          #	 ## be optimized to be files, in which case the FD is left undef
          #	 ## so we don't try to select() on it.
          #         if ( $pipe->{TYPE} =~ /^>/
          #            && defined $pipe->{FD}
          #            && vec( $self->{ROUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data from", $pipe ) if _debugging_details;
          #confess "phooey" unless UNIVERSAL::isa( $pipe, "IPC::Run::IO" );
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #	 ## On Win32, pipes to the child can be optimized to be files
          #	 ## and FD left undefined so we won't select on it.
          #         if ( $pipe->{TYPE} =~ /^</
          #            && defined $pipe->{FD}
          #            && vec( $self->{WOUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data to", $pipe ) if _debugging_details;
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #         if ( defined $pipe->{FD} && vec( $self->{EOUT}, $pipe->{FD}, 1 ) ) {
          #            ## BSD seems to sometimes raise the exceptional condition flag
          #            ## when a pipe is closed before we read it's last data.  This
          #            ## causes spurious warnings and generally renders the exception
          #            ## mechanism useless for our purposes.  The exception
          #            ## flag semantics are too variable (they're device driver
          #            ## specific) for me to easily map to any automatic action like
          #            ## warning or croaking (try running v0.42 if you don't believe me
          #            ## :-).
          #            warn "Exception on descriptor $pipe->{FD}";
          #         }
          #      }
      }
  
      return;
  }
  
  sub _cleanup {
      my IPC::Run $self = shift;
      _debug "cleaning up" if _debugging_details;
  
      for ( values %{ $self->{PTYS} } ) {
          next unless ref $_;
          eval {
              _debug "closing slave fd ", fileno $_->slave if _debugging_data;
              close $_->slave;
          };
          carp $@ . " while closing ptys" if $@;
          eval {
              _debug "closing master fd ", fileno $_ if _debugging_data;
              close $_;
          };
          carp $@ . " closing ptys" if $@;
      }
  
      _debug "cleaning up pipes" if _debugging_details;
      ## _clobber modifies PIPES
      $self->_clobber( $self->{PIPES}->[0] ) while @{ $self->{PIPES} };
  
      for my $kid ( @{ $self->{KIDS} } ) {
          _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
          if ( !length $kid->{PID} ) {
              _debug 'never ran child ', $kid->{NUM}, ", can't reap"
                if _debugging;
              for my $op ( @{ $kid->{OPS} } ) {
                  _close( $op->{TFD} )
                    if defined $op->{TFD} && !defined $op->{TEMP_FILE_HANDLE};
              }
          }
          elsif ( !defined $kid->{RESULT} ) {
              _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
                if _debugging;
              my $pid = waitpid $kid->{PID}, 0;
              $kid->{RESULT} = $?;
              _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
                if _debugging;
          }
  
          #      if ( defined $kid->{DEBUG_FD} ) {
          #	 die;
          #         @{$kid->{OPS}} = grep
          #            ! defined $_->{KFD} || $_->{KFD} != $kid->{DEBUG_FD},
          #            @{$kid->{OPS}};
          #         $kid->{DEBUG_FD} = undef;
          #      }
  
          _debug "cleaning up filters" if _debugging_details;
          for my $op ( @{ $kid->{OPS} } ) {
              @{ $op->{FILTERS} } = grep {
                  my $filter = $_;
                  !grep $filter == $_, @{ $self->{TEMP_FILTERS} };
              } @{ $op->{FILTERS} };
          }
  
          for my $op ( @{ $kid->{OPS} } ) {
              $op->_cleanup($self) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
          }
      }
      $self->{STATE} = _finished;
      @{ $self->{TEMP_FILTERS} } = ();
      _debug "done cleaning up" if _debugging_details;
  
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  }
  
  =pod
  
  =item pump
  
     pump $h;
     $h->pump;
  
  Pump accepts a single parameter harness.  It blocks until it delivers some
  input or receives some output.  It returns TRUE if there is still input or
  output to be done, FALSE otherwise.
  
  pump() will automatically call start() if need be, so you may call harness()
  then proceed to pump() if that helps you structure your application.
  
  If pump() is called after all harnessed activities have completed, a "process
  ended prematurely" exception to be thrown.  This allows for simple scripting
  of external applications without having to add lots of error handling code at
  each step of the script:
  
     $h = harness \@smbclient, \$in, \$out, $err;
  
     $in = "cd /foo\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /foo:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $h->finish;
  
     warn $err if $err;
  
  =cut
  
  sub pump {
      die "pump() takes only a single harness as a parameter"
        unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
  
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      _debug "** pumping"
        if _debugging;
  
      #   my $r = eval {
      $self->start if $self->{STATE} < _started;
      croak "process ended prematurely" unless $self->pumpable;
  
      $self->{auto_close_ins} = 0;
      $self->{break_on_io}    = 1;
      $self->_select_loop;
      return $self->pumpable;
  
      #   };
      #   if ( $@ ) {
      #      my $x = $@;
      #      _debug $x if _debugging && $x;
      #      eval { $self->_cleanup };
      #      warn $@ if $@;
      #      die $x;
      #   }
      #   return $r;
  }
  
  =pod
  
  =item pump_nb
  
     pump_nb $h;
     $h->pump_nb;
  
  "pump() non-blocking", pumps if anything's ready to be pumped, returns
  immediately otherwise.  This is useful if you're doing some long-running
  task in the foreground, but don't want to starve any child processes.
  
  =cut
  
  sub pump_nb {
      my IPC::Run $self = shift;
  
      $self->{non_blocking} = 1;
      my $r = eval { $self->pump };
      $self->{non_blocking} = 0;
      die $@ if $@;
      return $r;
  }
  
  =pod
  
  =item pumpable
  
  Returns TRUE if calling pump() won't throw an immediate "process ended
  prematurely" exception.  This means that there are open I/O channels or
  active processes. May yield the parent processes' time slice for 0.01
  second if all pipes are to the child and all are paused.  In this case
  we can't tell if the child is dead, so we yield the processor and
  then attempt to reap the child in a nonblocking way.
  
  =cut
  
  ## Undocumented feature (don't depend on it outside this module):
  ## returns -1 if we have I/O channels open, or >0 if no I/O channels
  ## open, but we have kids running.  This allows the select loop
  ## to poll for child exit.
  sub pumpable {
      my IPC::Run $self = shift;
  
      ## There's a catch-22 we can get in to if there is only one pipe left
      ## open to the child and it's paused (ie the SCALAR it's tied to
      ## is '').  It's paused, so we're not select()ing on it, so we don't
      ## check it to see if the child attached to it is alive and it stays
      ## in @{$self->{PIPES}} forever.  So, if all pipes are paused, see if
      ## we can reap the child.
      return -1 if grep !$_->{PAUSED}, @{ $self->{PIPES} };
  
      ## See if the child is dead.
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      ## If we reap_nb and it's not dead yet, yield to it to see if it
      ## exits.
      ##
      ## A better solution would be to unpause all the pipes, but I tried that
      ## and it never errored on linux.  Sigh.
      select undef, undef, undef, 0.0001;
  
      ## try again
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      return -1;    ## There are pipes waiting
  }
  
  sub _running_kids {
      my IPC::Run $self = shift;
      return grep
        defined $_->{PID} && !defined $_->{RESULT},
        @{ $self->{KIDS} };
  }
  
  =pod
  
  =item reap_nb
  
  Attempts to reap child processes, but does not block.
  
  Does not currently take any parameters, one day it will allow specific
  children to be reaped.
  
  Only call this from a signal handler if your C<perl> is recent enough
  to have safe signal handling (5.6.1 did not, IIRC, but it was being discussed
  on perl5-porters).  Calling this (or doing any significant work) in a signal
  handler on older C<perl>s is asking for seg faults.
  
  =cut
  
  my $still_runnings;
  
  sub reap_nb {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      ## No more pipes, look to see if all the kids yet live, reaping those
      ## that haven't.  I'd use $SIG{CHLD}/$SIG{CLD}, but that's broken
      ## on older (SYSV) platforms and perhaps less portable than waitpid().
      ## This could be slow with a lot of kids, but that's rare and, well,
      ## a lot of kids is slow in the first place.
      ## Oh, and this keeps us from reaping other children the process
      ## may have spawned.
      for my $kid ( @{ $self->{KIDS} } ) {
          if (Win32_MODE) {
              next if !defined $kid->{PROCESS} || defined $kid->{RESULT};
              unless ( $kid->{PROCESS}->Wait(0) ) {
                  _debug "kid $kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                if _debugging;
  
              $kid->{PROCESS}->GetExitCode( $kid->{RESULT} )
                or croak "$! while GetExitCode()ing for Win32 process";
  
              unless ( defined $kid->{RESULT} ) {
                  $kid->{RESULT} = "0 but true";
                  $? = $kid->{RESULT} = 0x0F;
              }
              else {
                  $? = $kid->{RESULT} << 8;
              }
          }
          else {
              next if !defined $kid->{PID} || defined $kid->{RESULT};
              my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
              unless ($pid) {
                  _debug "$kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              if ( $pid < 0 ) {
                  _debug "No such process: $kid->{PID}\n" if _debugging;
                  $kid->{RESULT} = "unknown result, unknown PID";
              }
              else {
                  _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                    if _debugging;
  
                  confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
                    unless $pid == $kid->{PID};
                  _debug "$kid->{PID} returned $?\n" if _debugging;
                  $kid->{RESULT} = $?;
              }
          }
      }
  }
  
  =pod
  
  =item finish
  
  This must be called after the last start() or pump() call for a harness,
  or your system will accumulate defunct processes and you may "leak"
  file descriptors.
  
  finish() returns TRUE if all children returned 0 (and were not signaled and did
  not coredump, ie ! $?), and FALSE otherwise (this is like run(), and the
  opposite of system()).
  
  Once a harness has been finished, it may be run() or start()ed again,
  including by pump()s auto-start.
  
  If this throws an exception rather than a normal exit, the harness may
  be left in an unstable state, it's best to kill the harness to get rid
  of all the child processes, etc.
  
  Specifically, if a timeout expires in finish(), finish() will not
  kill all the children.  Call C<<$h->kill_kill>> in this case if you care.
  This differs from the behavior of L</run>.
  
  =cut
  
  sub finish {
      my IPC::Run $self = shift;
      my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
  
      local $cur_self = $self;
  
      _debug "** finishing" if _debugging;
  
      $self->{non_blocking}   = 0;
      $self->{auto_close_ins} = 1;
      $self->{break_on_io}    = 0;
  
      # We don't alter $self->{clear_ins}, start() and run() control it.
  
      while ( $self->pumpable ) {
          $self->_select_loop($options);
      }
      $self->_cleanup;
  
      return !$self->full_result;
  }
  
  =pod
  
  =item result
  
     $h->result;
  
  Returns the first non-zero result code (ie $? >> 8).  See L</full_result> to 
  get the $? value for a child process.
  
  To get the result of a particular child, do:
  
     $h->result( 0 );  # first child's $? >> 8
     $h->result( 1 );  # second child
  
  or
  
     ($h->results)[0]
     ($h->results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub _assert_finished {
      my IPC::Run $self = $_[0];
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  }
  
  sub _child_result {
      my IPC::Run $self = shift;
  
      my ($which) = @_;
      croak(
          "Only ",
          scalar( @{ $self->{KIDS} } ),
          " child processes, no process $which"
      ) unless $which >= 0 && $which <= $#{ $self->{KIDS} };
      return $self->{KIDS}->[$which]->{RESULT};
  }
  
  sub result {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which) >> 8;
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
          }
      }
  }
  
  =pod
  
  =item results
  
  Returns a list of child exit values.  See L</full_results> if you want to
  know if a signal killed the child.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      # we add 0 here to stop warnings associated with "unknown result, unknown PID"
      return map { ( 0 + $_->{RESULT} ) >> 8 } @{ $self->{KIDS} };
  }
  
  =pod
  
  =item full_result
  
     $h->full_result;
  
  Returns the first non-zero $?.  See L</result> to get the first $? >> 8 
  value for a child process.
  
  To get the result of a particular child, do:
  
     $h->full_result( 0 );  # first child's $?
     $h->full_result( 1 );  # second child
  
  or
  
     ($h->full_results)[0]
     ($h->full_results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub full_result {
      &_assert_finished;
  
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which);
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} if $_->{RESULT};
          }
      }
  }
  
  =pod
  
  =item full_results
  
  Returns a list of child exit values as returned by C<wait>.  See L</results>
  if you don't care about coredumps or signals.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub full_results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  
      return map $_->{RESULT}, @{ $self->{KIDS} };
  }
  
  ##
  ## Filter Scaffolding
  ##
  use vars (
      '$filter_op',     ## The op running a filter chain right now
      '$filter_num',    ## Which filter is being run right now.
  );
  
  ##
  ## A few filters and filter constructors
  ##
  
  =pod
  
  =back
  
  =back
  
  =head1 FILTERS
  
  These filters are used to modify input our output between a child
  process and a scalar or subroutine endpoint.
  
  =over
  
  =item binary
  
     run \@cmd, ">", binary, \$out;
     run \@cmd, ">", binary, \$out;  ## Any TRUE value to enable
     run \@cmd, ">", binary 0, \$out;  ## Any FALSE value to disable
  
  This is a constructor for a "binmode" "filter" that tells IPC::Run to keep
  the carriage returns that would ordinarily be edited out for you (binmode
  is usually off).  This is not a real filter, but an option masquerading as
  a filter.
  
  It's not named "binmode" because you're likely to want to call Perl's binmode
  in programs that are piping binary data around.
  
  =cut
  
  sub binary(;$) {
      my $enable = @_ ? shift : 1;
      return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
  }
  
  =pod
  
  =item new_chunker
  
  This breaks a stream of data in to chunks, based on an optional
  scalar or regular expression parameter.  The default is the Perl
  input record separator in $/, which is a newline be default.
  
     run \@cmd, '>', new_chunker, \&lines_handler;
     run \@cmd, '>', new_chunker( "\r\n" ), \&lines_handler;
  
  Because this uses $/ by default, you should always pass in a parameter
  if you are worried about other code (modules, etc) modifying $/.
  
  If this filter is last in a filter chain that dumps in to a scalar,
  the scalar must be set to '' before a new chunk will be written to it.
  
  As an example of how a filter like this can be written, here's a
  chunker that splits on newlines:
  
     sub line_splitter {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/\A(.*?\n)// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  
  =cut
  
  sub new_chunker(;$) {
      my ($re) = @_;
      $re = $/ if _empty $re;
      $re = quotemeta($re) unless ref $re eq 'Regexp';
      $re = qr/\A(.*?$re)/s;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return 0 if length $$out_ref;
  
          return input_avail && do {
              while (1) {
                  if ( $$in_ref =~ s/$re// ) {
                      $$out_ref .= $1;
                      return 1;
                  }
                  my $hmm = get_more_input;
                  unless ( defined $hmm ) {
                      $$out_ref = $$in_ref;
                      $$in_ref  = '';
                      return length $$out_ref ? 1 : 0;
                  }
                  return 0 if $hmm eq 0;
              }
            }
      };
  }
  
  =pod
  
  =item new_appender
  
  This appends a fixed string to each chunk of data read from the source
  scalar or sub.  This might be useful if you're writing commands to a
  child process that always must end in a fixed string, like "\n":
  
     run( \@cmd,
        '<', new_appender( "\n" ), \&commands,
     );
  
  Here's a typical filter sub that might be created by new_appender():
  
     sub newline_appender {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, "\n" );
           $$in_ref = '';
           1;
        }
     };
  
  =cut
  
  sub new_appender($) {
      my ($suffix) = @_;
      croak "\$suffix undefined" unless defined $suffix;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
              $$in_ref = '';
              1;
            }
      };
  }
  
  =item new_string_source
  
  TODO: Needs confirmation. Was previously undocumented. in this module.
  
  This is a filter which is exportable. Returns a sub which appends the data passed in to the output buffer and returns 1 if data was appended. 0 if it was an empty string and undef if no data was passed. 
  
  NOTE: Any additional variables passed to new_string_source will be passed to the sub every time it's called and appended to the output. 
  
  =cut
  
  sub new_string_source {
      my $ref;
      if ( @_ > 1 ) {
          $ref = [@_],
      }
      else {
          $ref = shift;
      }
  
      return ref $ref eq 'SCALAR'
        ? sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return defined $$ref
            ? do {
              $$out_ref .= $$ref;
              my $r = length $$ref ? 1 : 0;
              $$ref = undef;
              $r;
            }
            : undef;
        }
        : sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return @$ref
            ? do {
              my $s = shift @$ref;
              $$out_ref .= $s;
              length $s ? 1 : 0;
            }
            : undef;
        }
  }
  
  =item new_string_sink
  
  TODO: Needs confirmation. Was previously undocumented.
  
  This is a filter which is exportable. Returns a sub which pops the data out of the input stream and pushes it onto the string.
  
  =cut
  
  sub new_string_sink {
      my ($string_ref) = @_;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$string_ref .= $$in_ref;
              $$in_ref = '';
              1;
            }
      };
  }
  
  #=item timeout
  #
  #This function defines a time interval, starting from when start() is
  #called, or when timeout() is called.  If all processes have not finished
  #by the end of the timeout period, then a "process timed out" exception
  #is thrown.
  #
  #The time interval may be passed in seconds, or as an end time in
  #"HH:MM:SS" format (any non-digit other than '.' may be used as
  #spacing and punctuation).  This is probably best shown by example:
  #
  #   $h->timeout( $val );
  #
  #   $val                     Effect
  #   ======================== =====================================
  #   undef                    Timeout timer disabled
  #   ''                       Almost immediate timeout
  #   0                        Almost immediate timeout
  #   0.000001                 timeout > 0.0000001 seconds
  #   30                       timeout > 30 seconds
  #   30.0000001               timeout > 30 seconds
  #   10:30                    timeout > 10 minutes, 30 seconds
  #
  #Timeouts are currently evaluated with a 1 second resolution, though
  #this may change in the future.  This means that setting
  #timeout($h,1) will cause a pokey child to be aborted sometime after
  #one second has elapsed and typically before two seconds have elapsed.
  #
  #This sub does not check whether or not the timeout has expired already.
  #
  #Returns the number of seconds set as the timeout (this does not change
  #as time passes, unless you call timeout( val ) again).
  #
  #The timeout does not include the time needed to fork() or spawn()
  #the child processes, though some setup time for the child processes can
  #included.  It also does not include the length of time it takes for
  #the children to exit after they've closed all their pipes to the
  #parent process.
  #
  #=cut
  #
  #sub timeout {
  #   my IPC::Run $self = shift;
  #
  #   if ( @_ ) {
  #      ( $self->{TIMEOUT} ) = @_;
  #      $self->{TIMEOUT_END} = undef;
  #      if ( defined $self->{TIMEOUT} ) {
  #	 if ( $self->{TIMEOUT} =~ /[^\d.]/ ) {
  #	    my @f = split( /[^\d\.]+/i, $self->{TIMEOUT} );
  #	    unshift @f, 0 while @f < 3;
  #	    $self->{TIMEOUT} = (($f[0]*60)+$f[1])*60+$f[2];
  #	 }
  #	 elsif ( $self->{TIMEOUT} =~ /^(\d*)(?:\.(\d*))/ ) {
  #	    $self->{TIMEOUT} = $1 + 1;
  #	 }
  #	 $self->_calc_timeout_end if $self->{STATE} >= _started;
  #      }
  #   }
  #   return $self->{TIMEOUT};
  #}
  #
  #
  #sub _calc_timeout_end {
  #   my IPC::Run $self = shift;
  #
  #   $self->{TIMEOUT_END} = defined $self->{TIMEOUT}
  #      ? time + $self->{TIMEOUT}
  #      : undef;
  #
  #   ## We add a second because we might be at the very end of the current
  #   ## second, and we want to guarantee that we don't have a timeout even
  #   ## one second less then the timeout period.
  #   ++$self->{TIMEOUT_END} if $self->{TIMEOUT};
  #}
  
  =pod
  
  =item io
  
  Takes a filename or filehandle, a redirection operator, optional filters,
  and a source or destination (depends on the redirection operator).  Returns
  an IPC::Run::IO object suitable for harness()ing (including via start()
  or run()).
  
  This is shorthand for 
  
  
     require IPC::Run::IO;
  
        ... IPC::Run::IO->new(...) ...
  
  =cut
  
  sub io {
      require IPC::Run::IO;
      IPC::Run::IO->new(@_);
  }
  
  =pod
  
  =item timer
  
     $h = start( \@cmd, \$in, \$out, $t = timer( 5 ) );
  
     pump $h until $out =~ /expected stuff/ || $t->is_expired;
  
  Instantiates a non-fatal timer.  pump() returns once each time a timer
  expires.  Has no direct effect on run(), but you can pass a subroutine
  to fire when the timer expires. 
  
  See L</timeout> for building timers that throw exceptions on
  expiration.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timer;
  *timer = \&IPC::Run::Timer::timer;
  
  =pod
  
  =item timeout
  
     $h = start( \@cmd, \$in, \$out, $t = timeout( 5 ) );
  
     pump $h until $out =~ /expected stuff/;
  
  Instantiates a timer that throws an exception when it expires.
  If you don't provide an exception, a default exception that matches
  /^IPC::Run: .*timed out/ is thrown by default.  You can pass in your own
  exception scalar or reference:
  
     $h = start(
        \@cmd, \$in, \$out,
        $t = timeout( 5, exception => 'slowpoke' ),
     );
  
  or set the name used in debugging message and in the default exception
  string:
  
     $h = start(
        \@cmd, \$in, \$out,
        timeout( 50, name => 'process timer' ),
        $stall_timer = timeout( 5, name => 'stall timer' ),
     );
  
     pump $h until $out =~ /started/;
  
     $in = 'command 1';
     $stall_timer->start;
     pump $h until $out =~ /command 1 finished/;
  
     $in = 'command 2';
     $stall_timer->start;
     pump $h until $out =~ /command 2 finished/;
  
     $in = 'very slow command 3';
     $stall_timer->start( 10 );
     pump $h until $out =~ /command 3 finished/;
  
     $stall_timer->start( 5 );
     $in = 'command 4';
     pump $h until $out =~ /command 4 finished/;
  
     $stall_timer->reset; # Prevent restarting or expirng
     finish $h;
  
  See L</timer> for building non-fatal timers.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timeout;
  *timeout = \&IPC::Run::Timer::timeout;
  
  =pod
  
  =back
  
  =head1 FILTER IMPLEMENTATION FUNCTIONS
  
  These functions are for use from within filters.
  
  =over
  
  =item input_avail
  
  Returns TRUE if input is available.  If none is available, then 
  &get_more_input is called and its result is returned.
  
  This is usually used in preference to &get_more_input so that the
  calling filter removes all data from the $in_ref before more data
  gets read in to $in_ref.
  
  C<input_avail> is usually used as part of a return expression:
  
     return input_avail && do {
        ## process the input just gotten
        1;
     };
  
  This technique allows input_avail to return the undef or 0 that a
  filter normally returns when there's no input to process.  If a filter
  stores intermediate values, however, it will need to react to an
  undef:
  
     my $got = input_avail;
     if ( ! defined $got ) {
        ## No more input ever, flush internal buffers to $out_ref
     }
     return $got unless $got;
     ## Got some input, move as much as need be
     return 1 if $added_to_out_ref;
  
  =cut
  
  sub input_avail() {
      confess "Undefined FBUF ref for $filter_num+1"
        unless defined $filter_op->{FBUFS}->[ $filter_num + 1 ];
      length ${ $filter_op->{FBUFS}->[ $filter_num + 1 ] } || get_more_input;
  }
  
  =pod
  
  =item get_more_input
  
  This is used to fetch more input in to the input variable.  It returns
  undef if there will never be any more input, 0 if there is none now,
  but there might be in the future, and TRUE if more input was gotten.
  
  C<get_more_input> is usually used as part of a return expression,
  see L</input_avail> for more information.
  
  =cut
  
  ##
  ## Filter implementation interface
  ##
  sub get_more_input() {
      ++$filter_num;
      my $r = eval {
          confess "get_more_input() called and no more filters in chain"
            unless defined $filter_op->{FILTERS}->[$filter_num];
          $filter_op->{FILTERS}->[$filter_num]->(
              $filter_op->{FBUFS}->[ $filter_num + 1 ],
              $filter_op->{FBUFS}->[$filter_num],
          );    # if defined ${$filter_op->{FBUFS}->[$filter_num+1]};
      };
      --$filter_num;
      die $@ if $@;
      return $r;
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 TODO
  
  These will be addressed as needed and as time allows.
  
  Stall timeout.
  
  Expose a list of child process objects.  When I do this,
  each child process is likely to be blessed into IPC::Run::Proc.
  
  $kid->abort(), $kid->kill(), $kid->signal( $num_or_name ).
  
  Write tests for /(full_)?results?/ subs.
  
  Currently, pump() and run() only work on systems where select() works on the
  filehandles returned by pipe().  This does *not* include ActiveState on Win32,
  although it does work on cygwin under Win32 (thought the tests whine a bit).
  I'd like to rectify that, suggestions and patches welcome.
  
  Likewise start() only fully works on fork()/exec() machines (well, just
  fork() if you only ever pass perl subs as subprocesses).  There's
  some scaffolding for calling Open3::spawn_with_handles(), but that's
  untested, and not that useful with limited select().
  
  Support for C<\@sub_cmd> as an argument to a command which
  gets replaced with /dev/fd or the name of a temporary file containing foo's
  output.  This is like <(sub_cmd ...) found in bash and csh (IIRC).
  
  Allow multiple harnesses to be combined as independent sets of processes
  in to one 'meta-harness'.
  
  Allow a harness to be passed in place of an \@cmd.  This would allow
  multiple harnesses to be aggregated.
  
  Ability to add external file descriptors w/ filter chains and endpoints.
  
  Ability to add timeouts and timing generators (i.e. repeating timeouts).
  
  High resolution timeouts.
  
  =head1 Win32 LIMITATIONS
  
  =over
  
  =item argument-passing rules are program-specific
  
  Win32 programs receive all arguments in a single "command line" string.
  IPC::Run assembles this string so programs using L<standard command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>
  will see an C<argv> that matches the array reference specifying the command.
  Some programs use different rules to parse their command line.  Notable examples
  include F<cmd.exe>, F<cscript.exe>, and Cygwin programs called from non-Cygwin
  programs.  Use L<IPC::Run::Win32Process> to call these and other nonstandard
  programs.
  
  =item batch files
  
  Properly escaping a batch file argument depends on how the script will use that
  argument, because some uses experience multiple levels of caret (escape
  character) removal.  Avoid calling batch files with arguments, particularly when
  the argument values originate outside your program or contain non-alphanumeric
  characters.  Perl scripts and PowerShell scripts are sound alternatives.  If you
  do use batch file arguments, IPC::Run escapes them so the batch file can pass
  them, unquoted, to a program having standard command line parsing rules.  If the
  batch file enables delayed environment variable expansion, it must disable that
  feature before expanding its arguments.  For example, if F<foo.cmd> contains
  C<perl %*>, C<run ['foo.cmd', @list]> will create a Perl process in which
  C<@ARGV> matches C<@list>.  Prepending a C<setlocal enabledelayedexpansion> line
  would make the batch file malfunction, silently.  Another silent-malfunction
  example is C<run ['outer.bat', @list]> for F<outer.bat> containing C<foo.cmd
  %*>.
  
  =item Fails on Win9X
  
  If you want Win9X support, you'll have to debug it or fund me because I
  don't use that system any more.  The Win32 subsysem has been extended to
  use temporary files in simple run() invocations and these may actually
  work on Win9X too, but I don't have time to work on it.
  
  =item May deadlock on Win2K (but not WinNT4 or WinXPPro)
  
  Spawning more than one subprocess on Win2K causes a deadlock I haven't
  figured out yet, but simple uses of run() often work.  Passes all tests
  on WinXPPro and WinNT.
  
  =item no support yet for <pty< and >pty>
  
  These are likely to be implemented as "<" and ">" with binmode on, not
  sure.
  
  =item no support for file descriptors higher than 2 (stderr)
  
  Win32 only allows passing explicit fds 0, 1, and 2.  If you really, really need to pass file handles, us Win32API:: GetOsFHandle() or ::FdGetOsFHandle() to
  get the integer handle and pass it to the child process using the command
  line, environment, stdin, intermediary file, or other IPC mechanism.  Then
  use that handle in the child (Win32API.pm provides ways to reconstitute
  Perl file handles from Win32 file handles).
  
  =item no support for subroutine subprocesses (CODE refs)
  
  Can't fork(), so the subroutines would have no context, and closures certainly
  have no meaning
  
  Perhaps with Win32 fork() emulation, this can be supported in a limited
  fashion, but there are other very serious problems with that: all parent
  fds get dup()ed in to the thread emulating the forked process, and that
  keeps the parent from being able to close all of the appropriate fds.
  
  =item no support for init => sub {} routines.
  
  Win32 processes are created from scratch, there is no way to do an init
  routine that will affect the running child.  Some limited support might
  be implemented one day, do chdir() and %ENV changes can be made.
  
  =item signals
  
  Win32 does not fully support signals.  signal() is likely to cause errors
  unless sending a signal that Perl emulates, and C<kill_kill()> is immediately
  fatal (there is no grace period).
  
  =item helper processes
  
  IPC::Run uses helper processes, one per redirected file, to adapt between the
  anonymous pipe connected to the child and the TCP socket connected to the
  parent.  This is a waste of resources and will change in the future to either
  use threads (instead of helper processes) or a WaitForMultipleObjects call
  (instead of select).  Please contact me if you can help with the
  WaitForMultipleObjects() approach; I haven't figured out how to get at it
  without C code.
  
  =item shutdown pause
  
  There seems to be a pause of up to 1 second between when a child program exits
  and the corresponding sockets indicate that they are closed in the parent.
  Not sure why.
  
  =item binmode
  
  binmode is not supported yet.  The underpinnings are implemented, just ask
  if you need it.
  
  =item IPC::Run::IO
  
  IPC::Run::IO objects can be used on Unix to read or write arbitrary files.  On
  Win32, they will need to use the same helper processes to adapt from
  non-select()able filehandles to select()able ones (or perhaps
  WaitForMultipleObjects() will work with them, not sure).
  
  =item startup race conditions
  
  There seems to be an occasional race condition between child process startup
  and pipe closings.  It seems like if the child is not fully created by the time
  CreateProcess returns and we close the TCP socket being handed to it, the
  parent socket can also get closed.  This is seen with the Win32 pumper
  applications, not the "real" child process being spawned.
  
  I assume this is because the kernel hasn't gotten around to incrementing the
  reference count on the child's end (since the child was slow in starting), so
  the parent's closing of the child end causes the socket to be closed, thus
  closing the parent socket.
  
  Being a race condition, it's hard to reproduce, but I encountered it while
  testing this code on a drive share to a samba box.  In this case, it takes
  t/run.t a long time to spawn it's child processes (the parent hangs in the
  first select for several seconds until the child emits any debugging output).
  
  I have not seen it on local drives, and can't reproduce it at will,
  unfortunately.  The symptom is a "bad file descriptor in select()" error, and,
  by turning on debugging, it's possible to see that select() is being called on
  a no longer open file descriptor that was returned from the _socket() routine
  in Win32Helper.  There's a new confess() that checks for this ("PARENT_HANDLE
  no longer open"), but I haven't been able to reproduce it (typically).
  
  =back
  
  =head1 LIMITATIONS
  
  On Unix, requires a system that supports C<waitpid( $pid, WNOHANG )> so
  it can tell if a child process is still running.
  
  PTYs don't seem to be non-blocking on some versions of Solaris. Here's a
  test script contributed by Borislav Deianov <borislav@ensim.com> to see
  if you have the problem.  If it dies, you have the problem.
  
     #!/usr/bin/perl
  
     use IPC::Run qw(run);
     use Fcntl;
     use IO::Pty;
  
     sub makecmd {
         return ['perl', '-e', 
                 '<STDIN>, print "\n" x '.$_[0].'; while(<STDIN>){last if /end/}'];
     }
  
     #pipe R, W;
     #fcntl(W, F_SETFL, O_NONBLOCK);
     #while (syswrite(W, "\n", 1)) { $pipebuf++ };
     #print "pipe buffer size is $pipebuf\n";
     my $pipebuf=4096;
     my $in = "\n" x ($pipebuf * 2) . "end\n";
     my $out;
  
     $SIG{ALRM} = sub { die "Never completed!\n" };
  
     print "reading from scalar via pipe...";
     alarm( 2 );
     run(makecmd($pipebuf * 2), '<', \$in, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     print "reading from code via pipe... ";
     alarm( 2 );
     run(makecmd($pipebuf * 3), '<', sub { $t = $in; undef $in; $t}, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     $pty = IO::Pty->new();
     $pty->blocking(0);
     $slave = $pty->slave();
     while ($pty->syswrite("\n", 1)) { $ptybuf++ };
     print "pty buffer size is $ptybuf\n";
     $in = "\n" x ($ptybuf * 3) . "end\n";
  
     print "reading via pty... ";
     alarm( 2 );
     run(makecmd($ptybuf * 3), '<pty<', \$in, '>', \$out);
     alarm(0);
     print "done\n";
  
  No support for ';', '&&', '||', '{ ... }', etc: use perl's, since run()
  returns TRUE when the command exits with a 0 result code.
  
  Does not provide shell-like string interpolation.
  
  No support for C<cd>, C<setenv>, or C<export>: do these in an init() sub
  
     run(
        \cmd,
           ...
           init => sub {
              chdir $dir or die $!;
              $ENV{FOO}='BAR'
           }
     );
  
  Timeout calculation does not allow absolute times, or specification of
  days, months, etc.
  
  B<WARNING:> Function coprocesses (C<run \&foo, ...>) suffer from two
  limitations.  The first is that it is difficult to close all filehandles the
  child inherits from the parent, since there is no way to scan all open
  FILEHANDLEs in Perl and it both painful and a bit dangerous to close all open
  file descriptors with C<POSIX::close()>. Painful because we can't tell which
  fds are open at the POSIX level, either, so we'd have to scan all possible fds
  and close any that we don't want open (normally C<exec()> closes any
  non-inheritable but we don't C<exec()> for &sub processes.
  
  The second problem is that Perl's DESTROY subs and other on-exit cleanup gets
  run in the child process.  If objects are instantiated in the parent before the
  child is forked, the DESTROY will get run once in the parent and once in
  the child.  When coprocess subs exit, POSIX::_exit is called to work around this,
  but it means that objects that are still referred to at that time are not
  cleaned up.  So setting package vars or closure vars to point to objects that
  rely on DESTROY to affect things outside the process (files, etc), will
  lead to bugs.
  
  I goofed on the syntax: "<pipe" vs. "<pty<" and ">filename" are both
  oddities.
  
  =head1 TODO
  
  =over
  
  =item Allow one harness to "adopt" another:
  
     $new_h = harness \@cmd2;
     $h->adopt( $new_h );
  
  =item Close all filehandles not explicitly marked to stay open.
  
  The problem with this one is that there's no good way to scan all open
  FILEHANDLEs in Perl, yet you don't want child processes inheriting handles
  willy-nilly.
  
  =back
  
  =head1 INSPIRATION
  
  Well, select() and waitpid() badly needed wrapping, and open3() isn't
  open-minded enough for me.
  
  The shell-like API inspired by a message Russ Allbery sent to perl5-porters,
  which included:
  
     I've thought for some time that it would be
     nice to have a module that could handle full Bourne shell pipe syntax
     internally, with fork and exec, without ever invoking a shell.  Something
     that you could give things like:
  
     pipeopen (PIPE, [ qw/cat file/ ], '|', [ 'analyze', @args ], '>&3');
  
  Message ylln51p2b6.fsf@windlord.stanford.edu, on 2000/02/04.
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the GitHub bug tracker
  
  L<https://github.com/toddr/IPC-Run/issues>
  
  =head1 AUTHORS
  
  Adam Kennedy <adamk@cpan.org>
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2008 - 2009 Adam Kennedy.
  
  Copyright 1999 Barrie Slaymaker.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the README file.
  
  =cut
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Debug - debugging routines for IPC::Run
  
  =head1 SYNOPSIS
  
     ##
     ## Environment variable usage
     ##
     ## To force debugging off and shave a bit of CPU and memory
     ## by compile-time optimizing away all debugging code in IPC::Run
     ## (debug => ...) options to IPC::Run will be ignored.
     export IPCRUNDEBUG=none
  
     ## To force debugging on (levels are from 0..10)
     export IPCRUNDEBUG=basic
  
     ## Leave unset or set to "" to compile in debugging support and
     ## allow runtime control of it using the debug option.
  
  =head1 DESCRIPTION
  
  Controls IPC::Run debugging.  Debugging levels are now set by using words,
  but the numbers shown are still supported for backwards compatibility:
  
     0  none         disabled (special, see below)
     1  basic        what's running
     2  data         what's being sent/received
     3  details      what's going on in more detail
     4  gory         way too much detail for most uses
     10 all          use this when submitting bug reports
        noopts       optimizations forbidden due to inherited STDIN
  
  The C<none> level is special when the environment variable IPCRUNDEBUG
  is set to this the first time IPC::Run::Debug is loaded: it prevents
  the debugging code from being compiled in to the remaining IPC::Run modules,
  saving a bit of cpu.
  
  To do this in a script, here's a way that allows it to be overridden:
  
     BEGIN {
        unless ( defined $ENV{IPCRUNDEBUG} ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	    or die $@;
        }
     }
  
  This should force IPC::Run to not be debuggable unless somebody sets
  the IPCRUNDEBUG flag; modify this formula to grep @ARGV if need be:
  
     BEGIN {
        unless ( grep /^--debug/, @ARGV ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	 or die $@;
     }
  
  Both of those are untested.
  
  =cut
  
  ## We use @EXPORT for the end user's convenience: there's only one function
  ## exported, it's homonymous with the module, it's an unusual name, and
  ## it can be suppressed by "use IPC::Run ();".
  
  use strict;
  use warnings;
  use Exporter;
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        _debug
        _debug_desc_fd
        _debugging
        _debugging_data
        _debugging_details
        _debugging_gory_details
        _debugging_not_optimized
        _set_child_debug_name
      );
  
      @EXPORT_OK = qw(
        _debug_init
        _debugging_level
        _map_fds
      );
      %EXPORT_TAGS = (
          default => \@EXPORT,
          all => [ @EXPORT, @EXPORT_OK ],
      );
  }
  
  my $disable_debugging = defined $ENV{IPCRUNDEBUG}
    && ( !$ENV{IPCRUNDEBUG}
      || lc $ENV{IPCRUNDEBUG} eq "none" );
  
  eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX ();
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $in_use;
     my $dummy;
     for my $fd (0..63) {
        ## I'd like a quicker way (less user, cpu & especially sys and kernel
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        ## but that segfaults on Win32
        my $test_fd = POSIX::dup( $fd );
        $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        $map .= $in_use ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to its own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self && defined $IPC::Run::cur_self->{ID}
           ? "#$IPC::Run::cur_self->{ID}"
           : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
  
  =pod
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>, with numerous suggestions by p5p.
  
  =cut
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_IO';
  package IPC::Run::IO;
  
  =head1 NAME
  
  IPC::Run::IO -- I/O channels for IPC::Run.
  
  =head1 SYNOPSIS
  
  B<NOT IMPLEMENTED YET ON Win32! Win32 does not allow select() on
  normal file descriptors; IPC::RUN::IO needs to use IPC::Run::Win32Helper
  to do this.>
  
     use IPC::Run qw( io );
  
     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv );
     $io = io( "filename", 'r',  \$recv );
  
     ## Append to $recv:
     $io = io( "filename", '>>', \$recv );
     $io = io( "filename", 'ra', \$recv );
  
     $io = io( "filename", '<',  \$send );
     $io = io( "filename", 'w',  \$send );
  
     $io = io( "filename", '<<', \$send );
     $io = io( "filename", 'wa', \$send );
  
     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send );
  
     $f = IO::Handle->new( ... ); # Any subclass of IO::Handle
     $io = io( $f, '<', \$send );
  
     require IPC::Run::IO;
     $io = IPC::Run::IO->new( ... );
  
     ## Then run(), harness(), or start():
     run $io, ...;
  
     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... );
  
  =head1 DESCRIPTION
  
  This class and module allows filehandles and filenames to be harnessed for
  I/O when used IPC::Run, independent of anything else IPC::Run is doing
  (except that errors & exceptions can affect all things that IPC::Run is
  doing).
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: due to the awkwardness introduced in ripping pseudohashes
  out of Perl, this class I<no longer> uses the fields pragma.
  
  =cut
  
  ## This class is also used internally by IPC::Run in a very intimate way,
  ## since this is a partial factoring of code from IPC::Run plus some code
  ## needed to do standalone channels.  This factoring process will continue
  ## at some point.  Don't know how far how fast.
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  
  use IPC::Run::Debug;
  use IPC::Run qw( Win32_MODE );
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
            or ( $@ && die )
            or die "$!";
      }
  }
  
  sub _empty($);
  *_empty = \&IPC::Run::_empty;
  
  =head1 SUBROUTINES
  
  =over 4
  
  =item new
  
  I think it takes >> or << along with some other data.
  
  TODO: Needs more thorough documentation. Patches welcome.
  
  =cut
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my ( $external, $type, $internal ) = ( shift, shift, pop );
  
      croak "$class: '$_' is not a valid I/O operator"
        unless $type =~ /^(?:<<?|>>?)$/;
  
      my IPC::Run::IO $self = $class->_new_internal( $type, undef, undef, $internal, undef, @_ );
  
      if ( !ref $external ) {
          $self->{FILENAME} = $external;
      }
      elsif ( ref $external eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
          $self->{HANDLE}     = $external;
          $self->{DONT_CLOSE} = 1;
      }
      else {
          croak "$class: cannot accept " . ref($external) . " to do I/O with";
      }
  
      return $self;
  }
  
  ## IPC::Run uses this ctor, since it preparses things and needs more
  ## smarts.
  sub _new_internal {
      my $class = shift;
      $class = ref $class || $class;
  
      $class = "IPC::Run::Win32IO"
        if Win32_MODE && $class eq "IPC::Run::IO";
  
      my IPC::Run::IO $self;
      $self = bless {}, $class;
  
      my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
  
      # Older perls (<=5.00503, at least) don't do list assign to
      # psuedo-hashes well.
      $self->{TYPE}   = $type;
      $self->{KFD}    = $kfd;
      $self->{PTY_ID} = $pty_id;
      $self->binmode($binmode);
      $self->{FILTERS} = [@filters];
  
      ## Add an adapter to the end of the filter chain (which is usually just the
      ## read/writer sub pushed by IPC::Run) to the DEST or SOURCE, if need be.
      if ( $self->op =~ />/ ) {
          croak "'$_' missing a destination" if _empty $internal;
          $self->{DEST} = $internal;
          if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
              ## Put a filter on the end of the filter chain to pass the
              ## output on to the CODE ref.  For SCALAR refs, the last
              ## filter in the chain writes directly to the scalar itself.  See
              ## _init_filters().  For CODE refs, however, we need to adapt from
              ## the SCALAR to calling the CODE.
              unshift(
                  @{ $self->{FILTERS} },
                  sub {
                      my ($in_ref) = @_;
  
                      return IPC::Run::input_avail() && do {
                          $self->{DEST}->($$in_ref);
                          $$in_ref = '';
                          1;
                        }
                  }
              );
          }
      }
      else {
          croak "'$_' missing a source" if _empty $internal;
          $self->{SOURCE} = $internal;
          if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      return undef
                        if $self->{SOURCE_EMPTY};
  
                      my $in = $internal->();
                      unless ( defined $in ) {
                          $self->{SOURCE_EMPTY} = 1;
                          return undef;
                      }
                      return 0 unless length $in;
                      $$out_ref = $in;
  
                      return 1;
                  }
              );
          }
          elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      ## pump() clears auto_close_ins, finish() sets it.
                      return $self->{HARNESS}->{auto_close_ins} ? undef : 0
                        if IPC::Run::_empty ${ $self->{SOURCE} }
                        || $self->{SOURCE_EMPTY};
  
                      $$out_ref = $$internal;
                      eval { $$internal = '' }
                        if $self->{HARNESS}->{clear_ins};
  
                      $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
  
                      return 1;
                  }
              );
          }
      }
  
      return $self;
  }
  
  =item filename
  
  Gets/sets the filename.  Returns the value after the name change, if
  any.
  
  =cut
  
  sub filename {
      my IPC::Run::IO $self = shift;
      $self->{FILENAME} = shift if @_;
      return $self->{FILENAME};
  }
  
  =item init
  
  Does initialization required before this can be run.  This includes open()ing
  the file, if necessary, and clearing the destination scalar if necessary.
  
  =cut
  
  sub init {
      my IPC::Run::IO $self = shift;
  
      $self->{SOURCE_EMPTY} = 0;
      ${ $self->{DEST} } = ''
        if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
  
      $self->open if defined $self->filename;
      $self->{FD} = $self->fileno;
  
      if ( !$self->{FILTERS} ) {
          $self->{FBUFS} = undef;
      }
      else {
          @{ $self->{FBUFS} } = map {
              my $s = "";
              \$s;
          } ( @{ $self->{FILTERS} }, '' );
  
          $self->{FBUFS}->[0] = $self->{DEST}
            if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
          push @{ $self->{FBUFS} }, $self->{SOURCE};
      }
  
      return undef;
  }
  
  =item open
  
  If a filename was passed in, opens it.  Determines if the handle is open
  via fileno().  Throws an exception on error.
  
  =cut
  
  my %open_flags = (
      '>'  => O_RDONLY,
      '>>' => O_RDONLY,
      '<'  => O_WRONLY | O_CREAT | O_TRUNC,
      '<<' => O_WRONLY | O_CREAT | O_APPEND,
  );
  
  sub open {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: Can't open() a file with no name"
        unless defined $self->{FILENAME};
      $self->{HANDLE} = gensym unless $self->{HANDLE};
  
      _debug "opening '", $self->filename, "' mode '", $self->mode, "'"
        if _debugging_data;
      sysopen(
          $self->{HANDLE},
          $self->filename,
          $open_flags{ $self->op },
      ) or croak "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
  
      return undef;
  }
  
  =item open_pipe
  
  If this is a redirection IO object, this opens the pipe in a platform
  independent manner.
  
  =cut
  
  sub _do_open {
      my $self = shift;
      my ( $child_debug_fd, $parent_handle ) = @_;
  
      if ( $self->dir eq "<" ) {
          ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
          if ($parent_handle) {
              CORE::open $parent_handle, ">&=$self->{FD}"
                or croak "$! duping write end of pipe for caller";
          }
      }
      else {
          ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
          if ($parent_handle) {
              CORE::open $parent_handle, "<&=$self->{FD}"
                or croak "$! duping read end of pipe for caller";
          }
      }
  }
  
  sub open_pipe {
      my IPC::Run::IO $self = shift;
  
      ## Hmmm, Maybe allow named pipes one day.  But until then...
      croak "IPC::Run::IO: Can't pipe() when a file name has been set"
        if defined $self->{FILENAME};
  
      $self->_do_open(@_);
  
      ## return ( child_fd, parent_fd )
      return $self->dir eq "<"
        ? ( $self->{TFD}, $self->{FD} )
        : ( $self->{FD}, $self->{TFD} );
  }
  
  sub _cleanup {    ## Called from Run.pm's _cleanup
      my $self = shift;
      undef $self->{FAKE_PIPE};
  }
  
  =item close
  
  Closes the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub close {
      my IPC::Run::IO $self = shift;
  
      if ( defined $self->{HANDLE} ) {
          close $self->{HANDLE}
            or croak(
              "IPC::Run::IO: $! closing "
                . (
                  defined $self->{FILENAME}
                  ? "'$self->{FILENAME}'"
                  : "handle"
                )
            );
      }
      else {
          IPC::Run::_close( $self->{FD} );
      }
  
      $self->{FD} = undef;
  
      return undef;
  }
  
  =item fileno
  
  Returns the fileno of the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub fileno {
      my IPC::Run::IO $self = shift;
  
      my $fd = fileno $self->{HANDLE};
      croak(
          "IPC::Run::IO: $! "
            . (
              defined $self->{FILENAME}
              ? "'$self->{FILENAME}'"
              : "handle"
            )
      ) unless defined $fd;
  
      return $fd;
  }
  
  =item mode
  
  Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
  'ra', unlike Perl's open(), which indicates that data read from the
  handle or file will be appended to the output if the output is a scalar.
  This is only meaningful if the output is a scalar, it has no effect if
  the output is a subroutine.
  
  The redirection operators can be a little confusing, so here's a reference
  table:
  
     >      r      Read from handle in to process
     <      w      Write from process out to handle
     >>     ra     Read from handle in to process, appending it to existing
                   data if the destination is a scalar.
     <<     wa     Write from process out to handle, appending to existing
                   data if IPC::Run::IO opened a named file.
  
  =cut
  
  sub mode {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
  
      ## TODO: Optimize this
      return ( $self->{TYPE} =~ /</ ? 'w' : 'r' ) . ( $self->{TYPE} =~ /<<|>>/ ? 'a' : '' );
  }
  
  =item op
  
  Returns the operation: '<', '>', '<<', '>>'.  See L</mode> if you want
  to spell these 'r', 'w', etc.
  
  =cut
  
  sub op {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
  
      return $self->{TYPE};
  }
  
  =item binmode
  
  Sets/gets whether this pipe is in binmode or not.  No effect off of Win32
  OSs, of course, and on Win32, no effect after the harness is start()ed.
  
  =cut
  
  sub binmode {
      my IPC::Run::IO $self = shift;
  
      $self->{BINMODE} = shift if @_;
  
      return $self->{BINMODE};
  }
  
  =item dir
  
  Returns the first character of $self->op.  This is either "<" or ">".
  
  =cut
  
  sub dir {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
  
      return substr $self->{TYPE}, 0, 1;
  }
  
  ##
  ## Filter Scaffolding
  ##
  #my $filter_op ;        ## The op running a filter chain right now
  #my $filter_num;        ## Which filter is being run right now.
  
  use vars (
      '$filter_op',    ## The op running a filter chain right now
      '$filter_num'    ## Which filter is being run right now.
  );
  
  sub _init_filters {
      my IPC::Run::IO $self = shift;
  
      confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
      $self->{FBUFS} = [];
  
      $self->{FBUFS}->[0] = $self->{DEST}
        if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
  
      return unless $self->{FILTERS} && @{ $self->{FILTERS} };
  
      push @{ $self->{FBUFS} }, map {
          my $s = "";
          \$s;
      } ( @{ $self->{FILTERS} }, '' );
  
      push @{ $self->{FBUFS} }, $self->{SOURCE};
  }
  
  =item poll
  
  TODO: Needs confirmation that this is correct. Was previously undocumented.
  
  I believe this is polling the IO for new input and then returns undef if there will never be any more input, 0 if there is none now, but there might be in the future, and TRUE if more input was gotten.
  
  =cut
  
  sub poll {
      my IPC::Run::IO $self = shift;
      my ($harness) = @_;
  
      if ( defined $self->{FD} ) {
          my $d = $self->dir;
          if ( $d eq "<" ) {
              if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data to", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
          elsif ( $d eq ">" ) {
              if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data from", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
      }
      return 0;
  }
  
  sub _do_filters {
      my IPC::Run::IO $self = shift;
  
      ( $self->{HARNESS} ) = @_;
  
      my ( $saved_op, $saved_num ) = ( $IPC::Run::filter_op, $IPC::Run::filter_num );
      $IPC::Run::filter_op  = $self;
      $IPC::Run::filter_num = -1;
      my $redos = 0;
      my $r;
      {
          $@ = '';
          $r = eval { IPC::Run::get_more_input(); };
  
          # Detect Resource temporarily unavailable and re-try 200 times (2 seconds),  assuming select behaves (which it doesn't always? need ref)
          if ( ( $@ || '' ) =~ $IPC::Run::_EAGAIN && $redos++ < 200 ) {
              select( undef, undef, undef, 0.01 );
              redo;
          }
      }
      ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
      $self->{HARNESS} = undef;
      die "ack ", $@ if $@;
      return $r;
  }
  
  =back
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 TODO
  
  Implement bidirectionality.
  
  =cut
  
  1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_TIMER';
  package IPC::Run::Timer;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Timer -- Timer channels for IPC::Run.
  
  =head1 SYNOPSIS
  
     use IPC::Run qw( run  timer timeout );
     ## or IPC::Run::Timer ( timer timeout );
     ## or IPC::Run::Timer ( :all );
  
     ## A non-fatal timer:
     $t = timer( 5 ); # or...
     $t = IO::Run::Timer->new( 5 );
     run $t, ...;
  
     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ); # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" );
  
  =head1 DESCRIPTION
  
  This class and module allows timers and timeouts to be created for use
  by IPC::Run.  A timer simply expires when it's time is up.  A timeout
  is a timer that throws an exception when it expires.
  
  Timeouts are usually a bit simpler to use  than timers: they throw an
  exception on expiration so you don't need to check them:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/;
  
  You do need to check timers:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $t->is_expired || $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired;
  
  Timers and timeouts that are reset get started by start() and
  pump().  Timers change state only in pump().  Since run() and
  finish() both call pump(), they act like pump() with respect to
  timers.
  
  Timers and timeouts have three states: reset, running, and expired.
  Setting the timeout value resets the timer, as does calling
  the reset() method.  The start() method starts (or restarts) a
  timer with the most recently set time value, no matter what state
  it's in.
  
  =head2 Time values
  
  All time values are in seconds.  Times may be any kind of perl number,
  e.g. as integer or floating point seconds, optionally preceded by
  punctuation-separated days, hours, and minutes.
  
  Examples:
  
     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds
     'inf'       the infinity perl special number (the timer never finishes)
  
  Absolute date/time strings are *not* accepted: year, month and
  day-of-month parsing is not available (patches welcome :-).
  
  =head2 Interval fudging
  
  When calculating an end time from a start time and an interval, IPC::Run::Timer
  instances add a little fudge factor.  This is to ensure that no time will
  expire before the interval is up.
  
  First a little background.  Time is sampled in discrete increments.  We'll
  call the
  exact moment that the reported time increments from one interval to the
  next a tick, and the interval between ticks as the time period.  Here's
  a diagram of three ticks and the periods between them:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                   ^                   ^
      |<--- period 0 ---->|<--- period 1 ---->|
      |                   |                   |
    tick 0              tick 1              tick 2
  
  To see why the fudge factor is necessary, consider what would happen
  when a timer with an interval of 1 second is started right at the end of
  period 0:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^                   ^
      |                |  |                   |
      |                |  |                   |
    tick 0             |tick 1              tick 2
                       |
                   start $t
  
  Assuming that check() is called many times per period, then the timer
  is likely to expire just after tick 1, since the time reported will have
  lept from the value '0' to the value '1':
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^   ^               ^
      |                |  |   |               |
      |                |  |   |               |
    tick 0             |tick 1|             tick 2
                       |      |
                   start $t   |
  		            |
  			check $t
  
  Adding a fudge of '1' in this example means that the timer is guaranteed
  not to expire before tick 2.
  
  The fudge is not added to an interval of '0'.
  
  This means that intervals guarantee a minimum interval.  Given that
  the process running perl may be suspended for some period of time, or that
  it gets busy doing something time-consuming, there are no other guarantees on
  how long it will take a timer to expire.
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: Due to the awkwardness introduced by ripping
  pseudohashes out of Perl, this class I<no longer> uses the fields
  pragma.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  use Exporter;
  use Scalar::Util ();
  use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
  
  BEGIN {
      $VERSION   = '20220807.0';
      @ISA       = qw( Exporter );
      @EXPORT_OK = qw(
        check
        end_time
        exception
        expire
        interval
        is_expired
        is_reset
        is_running
        name
        reset
        start
        timeout
        timer
      );
  
      %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  }
  
  require IPC::Run;
  use IPC::Run::Debug;
  
  ##
  ## Some helpers
  ##
  my $resolution = 1;
  
  sub _parse_time {
      for ( $_[0] ) {
          my $val;
          if ( not defined $_ ) {
              $val = $_;
          }
          else {
              my @f = split( /:/, $_, -1 );
              if ( scalar @f > 4 ) {
                  croak "IPC::Run: expected <= 4 elements in time string '$_'";
              }
              for (@f) {
                  if ( not Scalar::Util::looks_like_number($_) ) {
                      croak "IPC::Run: non-numeric element '$_' in time string '$_'";
                  }
              }
              my ( $s, $m, $h, $d ) = reverse @f;
              $val = ( ( ( $d || 0 ) * 24 + ( $h || 0 ) ) * 60 + ( $m || 0 ) ) * 60 + ( $s || 0 );
          }
          return $val;
      }
  }
  
  sub _calc_end_time {
      my IPC::Run::Timer $self = shift;
      my $interval = $self->interval;
      $interval += $resolution if $interval;
      $self->end_time( $self->start_time + $interval );
  }
  
  =item timer
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timer( 5 );
     $t = timer( 5, name => 'stall timer', debug => 1 );
  
     $t = timer;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timer( 5 );
  
  This convenience function is a shortened spelling of
  
     IPC::Run::Timer->new( ... );
     
  .  It returns a timer in the reset state with a given interval.
  
  If an exception is provided, it will be thrown when the timer notices that
  it has expired (in check()).  The name is for debugging usage, if you plan on
  having multiple timers around.  If no name is provided, a name like "timer #1"
  will be provided.
  
  =cut
  
  sub timer {
      return IPC::Run::Timer->new(@_);
  }
  
  =item timeout
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timeout( 5 );
     $t = timeout( 5, exception => "kablooey" );
     $t = timeout( 5, name => "stall", exception => "kablooey" );
  
     $t = timeout;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timeout( 5 );
  
  A This convenience function is a shortened spelling of 
  
     IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... );
     
  .  It returns a timer in the reset state that will throw an
  exception when it expires.
  
  Takes the same parameters as L</timer>, any exception passed in overrides
  the default exception.
  
  =cut
  
  sub timeout {
      my $t = IPC::Run::Timer->new(@_);
      $t->exception( "IPC::Run: timeout on " . $t->name )
        unless defined $t->exception;
      return $t;
  }
  
  =item new
  
     IPC::Run::Timer->new()  ;
     IPC::Run::Timer->new( 5 )  ;
     IPC::Run::Timer->new( 5, exception => 'kablooey' )  ;
  
  Constructor.  See L</timer> for details.
  
  =cut
  
  my $timer_counter;
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my IPC::Run::Timer $self = bless {}, $class;
  
      $self->{STATE} = 0;
      $self->{DEBUG} = 0;
      $self->{NAME}  = "timer #" . ++$timer_counter;
  
      while (@_) {
          my $arg = shift;
          if ( $arg eq 'exception' ) {
              $self->exception(shift);
          }
          elsif ( $arg eq 'name' ) {
              $self->name(shift);
          }
          elsif ( $arg eq 'debug' ) {
              $self->debug(shift);
          }
          else {
              $self->interval($arg);
          }
      }
  
      _debug $self->name . ' constructed'
        if $self->{DEBUG} || _debugging_details;
  
      return $self;
  }
  
  =item check
  
     check $t;
     check $t, $now;
     $t->check;
  
  Checks to see if a timer has expired since the last check.  Has no effect
  on non-running timers.  This will throw an exception if one is defined.
  
  IPC::Run::pump() calls this routine for any timers in the harness.
  
  You may pass in a version of now, which is useful in case you have
  it lying around or you want to check several timers with a consistent
  concept of the current time.
  
  Returns the time left before end_time or 0 if end_time is no longer
  in the future or the timer is not running
  (unless, of course, check() expire()s the timer and this
  results in an exception being thrown).
  
  Returns undef if the timer is not running on entry, 0 if check() expires it,
  and the time left if it's left running.
  
  =cut
  
  sub check {
      my IPC::Run::Timer $self = shift;
      return undef if !$self->is_running;
      return 0     if $self->is_expired;
  
      my ($now) = @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      _debug( "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now ) if $self->{DEBUG} || _debugging_details;
  
      my $left = $self->end_time - $now;
      return $left if $left > 0;
  
      $self->expire;
      return 0;
  }
  
  =item debug
  
  Sets/gets the current setting of the debugging flag for this timer.  This
  has no effect if debugging is not enabled for the current harness.
  
  =cut
  
  sub debug {
      my IPC::Run::Timer $self = shift;
      $self->{DEBUG} = shift if @_;
      return $self->{DEBUG};
  }
  
  =item end_time
  
     $et = $t->end_time;
     $et = end_time $t;
  
     $t->end_time( time + 10 );
  
  Returns the time when this timer will or did expire.  Even if this time is
  in the past, the timer may not be expired, since check() may not have been
  called yet.
  
  Note that this end_time is not start_time($t) + interval($t), since some
  small extra amount of time is added to make sure that the timer does not
  expire before interval() elapses.  If this were not so, then 
  
  Changing end_time() while a timer is running will set the expiration time.
  Changing it while it is expired has no affect, since reset()ing a timer always
  clears the end_time().
  
  =cut
  
  sub end_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{END_TIME} = shift;
          _debug $self->name, ' end_time set to ', $self->{END_TIME}
            if $self->{DEBUG} > 2 || _debugging_details;
      }
      return $self->{END_TIME};
  }
  
  =item exception
  
     $x = $t->exception;
     $t->exception( $x );
     $t->exception( undef );
  
  Sets/gets the exception to throw, if any.  'undef' means that no
  exception will be thrown.  Exception does not need to be a scalar: you 
  may ask that references be thrown.
  
  =cut
  
  sub exception {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{EXCEPTION} = shift;
          _debug $self->name, ' exception set to ', $self->{EXCEPTION}
            if $self->{DEBUG} || _debugging_details;
      }
      return $self->{EXCEPTION};
  }
  
  =item interval
  
     $i = interval $t;
     $i = $t->interval;
     $t->interval( $i );
  
  Sets the interval.  Sets the end time based on the start_time() and the
  interval (and a little fudge) if the timer is running.
  
  =cut
  
  sub interval {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{INTERVAL} = _parse_time(shift);
          _debug $self->name, ' interval set to ', $self->{INTERVAL}
            if $self->{DEBUG} > 2 || _debugging_details;
  
          $self->_calc_end_time if $self->state;
      }
      return $self->{INTERVAL};
  }
  
  =item expire
  
     expire $t;
     $t->expire;
  
  Sets the state to expired (undef).
  Will throw an exception if one
  is defined and the timer was not already expired.  You can expire a
  reset timer without starting it.
  
  =cut
  
  sub expire {
      my IPC::Run::Timer $self = shift;
      if ( defined $self->state ) {
          _debug $self->name . ' expired'
            if $self->{DEBUG} || _debugging;
  
          $self->state(undef);
          croak $self->exception if $self->exception;
      }
      return undef;
  }
  
  =item is_running
  
  =cut
  
  sub is_running {
      my IPC::Run::Timer $self = shift;
      return $self->state ? 1 : 0;
  }
  
  =item is_reset
  
  =cut
  
  sub is_reset {
      my IPC::Run::Timer $self = shift;
      return defined $self->state && $self->state == 0;
  }
  
  =item is_expired
  
  =cut
  
  sub is_expired {
      my IPC::Run::Timer $self = shift;
      return !defined $self->state;
  }
  
  =item name
  
  Sets/gets this timer's name.  The name is only used for debugging
  purposes so you can tell which freakin' timer is doing what.
  
  =cut
  
  sub name {
      my IPC::Run::Timer $self = shift;
  
      $self->{NAME} = shift if @_;
      return
          defined $self->{NAME}      ? $self->{NAME}
        : defined $self->{EXCEPTION} ? 'timeout'
        :                              'timer';
  }
  
  =item reset
  
     reset $t;
     $t->reset;
  
  Resets the timer to the non-running, non-expired state and clears
  the end_time().
  
  =cut
  
  sub reset {
      my IPC::Run::Timer $self = shift;
      $self->state(0);
      $self->end_time(undef);
      _debug $self->name . ' reset'
        if $self->{DEBUG} || _debugging;
  
      return undef;
  }
  
  =item start
  
     start $t;
     $t->start;
     start $t, $interval;
     start $t, $interval, $now;
  
  Starts or restarts a timer.  This always sets the start_time.  It sets the
  end_time based on the interval if the timer is running or if no end time
  has been set.
  
  You may pass an optional interval or current time value.
  
  Not passing a defined interval causes the previous interval setting to be
  re-used unless the timer is reset and an end_time has been set
  (an exception is thrown if no interval has been set).  
  
  Not passing a defined current time value causes the current time to be used.
  
  Passing a current time value is useful if you happen to have a time value
  lying around or if you want to make sure that several timers are started
  with the same concept of start time.  You might even need to lie to an
  IPC::Run::Timer, occasionally.
  
  =cut
  
  sub start {
      my IPC::Run::Timer $self = shift;
  
      my ( $interval, $now ) = map { _parse_time($_) } @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      $self->interval($interval) if defined $interval;
  
      ## start()ing a running or expired timer clears the end_time, so that the
      ## interval is used.  So does specifying an interval.
      $self->end_time(undef) if !$self->is_reset || $interval;
  
      croak "IPC::Run: no timer interval or end_time defined for " . $self->name
        unless defined $self->interval || defined $self->end_time;
  
      $self->state(1);
      $self->start_time($now);
      ## The "+ 1" is in case the START_TIME was sampled at the end of a
      ## tick (which are one second long in this module).
      $self->_calc_end_time
        unless defined $self->end_time;
  
      _debug(
          $self->name, " started at ", $self->start_time,
          ", with interval ", $self->interval, ", end_time ", $self->end_time
      ) if $self->{DEBUG} || _debugging;
      return undef;
  }
  
  =item start_time
  
  Sets/gets the start time, in seconds since the epoch.  Setting this manually
  is a bad idea, it's better to call L</start>() at the correct time.
  
  =cut
  
  sub start_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{START_TIME} = _parse_time(shift);
          _debug $self->name, ' start_time set to ', $self->{START_TIME}
            if $self->{DEBUG} > 2 || _debugging;
      }
  
      return $self->{START_TIME};
  }
  
  =item state
  
     $s = state $t;
     $t->state( $s );
  
  Get/Set the current state.  Only use this if you really need to transfer the
  state to/from some variable.
  Use L</expire>, L</start>, L</reset>, L</is_expired>, L</is_running>,
  L</is_reset>.
  
  Note:  Setting the state to 'undef' to expire a timer will not throw an
  exception.
  
  =back
  
  =cut
  
  sub state {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{STATE} = shift;
          _debug $self->name, ' state set to ', $self->{STATE}
            if $self->{DEBUG} > 2 || _debugging;
      }
      return $self->{STATE};
  }
  
  1;
  
  =pod
  
  =head1 TODO
  
  use Time::HiRes; if it's present.
  
  Add detection and parsing of [[[HH:]MM:]SS formatted times and intervals.
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =cut
IPC_RUN_TIMER

$fatpacked{"IPC/Run/Win32Helper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32HELPER';
  package IPC::Run::Win32Helper;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Helper - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32Helper;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select() loop
  will work on Win32. This seems to only work on WinNT and Win2K at this time, not
  sure if it will ever work on Win95 or Win98. If you have experience in this area, please
  contact me at barries@slaysys.com, thanks!.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use vars qw{ $VERSION @ISA @EXPORT };
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        win32_spawn
        win32_parse_cmd_line
        _dont_inherit
        _inherit
      );
  }
  
  require POSIX;
  
  use File::Spec ();
  use Text::ParseWords;
  use Win32 ();
  use Win32::Process;
  use Win32::ShellQuote ();
  use IPC::Run::Debug;
  use Win32API::File qw(
    FdGetOsFHandle
    SetHandleInformation
    HANDLE_FLAG_INHERIT
    INVALID_HANDLE_VALUE
  );
  
  ## Takes an fd or a GLOB ref, never never never a Win32 handle.
  sub _dont_inherit {
      for (@_) {
          next unless defined $_;
          my $fd = $_;
          $fd = fileno $fd if ref $fd;
          _debug "disabling inheritance of ", $fd if _debugging_details;
          my $osfh = FdGetOsFHandle $fd;
          croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
      }
  }
  
  sub _inherit {    #### REMOVE
      for (@_) {    #### REMOVE
          next unless defined $_;    #### REMOVE
          my $fd = $_;               #### REMOVE
          $fd = fileno $fd if ref $fd;    #### REMOVE
          _debug "enabling inheritance of ", $fd if _debugging_details;    #### REMOVE
          my $osfh = FdGetOsFHandle $fd;                                   #### REMOVE
          croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;    #### REMOVE
          #### REMOVE
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );           #### REMOVE
      }    #### REMOVE
  }    #### REMOVE
  #### REMOVE
  #sub _inherit {
  #   for ( @_ ) {
  #      next unless defined $_;
  #      my $osfh = GetOsFHandle $_;
  #      croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  #      SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT );
  #   }
  #}
  
  =pod
  
  =head1 FUNCTIONS
  
  =over
  
  =item optimize()
  
  Most common incantations of C<run()> (I<not> C<harness()>, C<start()>,
  or C<finish()>) now use temporary files to redirect input and output
  instead of pumper processes.
  
  Temporary files are used when sending to child processes if input is
  taken from a scalar with no filter subroutines.  This is the only time
  we can assume that the parent is not interacting with the child's
  redirected input as it runs.
  
  Temporary files are used when receiving from children when output is
  to a scalar or subroutine with or without filters, but only if
  the child in question closes its inputs or takes input from 
  unfiltered SCALARs or named files.  Normally, a child inherits its STDIN
  from its parent; to close it, use "0<&-" or the C<< noinherit => 1 >> option.
  If data is sent to the child from CODE refs, filehandles or from
  scalars through filters than the child's outputs will not be optimized
  because C<optimize()> assumes the parent is interacting with the child.
  It is ok if the output is filtered or handled by a subroutine, however.
  
  This assumes that all named files are real files (as opposed to named
  pipes) and won't change; and that a process is not communicating with
  the child indirectly (through means not visible to IPC::Run).
  These can be an invalid assumptions, but are the 99% case.
  Write me if you need an option to enable or disable optimizations; I
  suspect it will work like the C<binary()> modifier.
  
  To detect cases that you might want to optimize by closing inputs, try
  setting the C<IPCRUNDEBUG> environment variable to the special C<notopt>
  value:
  
     C:> set IPCRUNDEBUG=notopt
     C:> my_app_that_uses_IPC_Run.pl
  
  =item optimizer() rationalizations
  
  Only for that limited case can we be sure that it's ok to batch all the
  input in to a temporary file.  If STDIN is from a SCALAR or from a named
  file or filehandle (again, only in C<run()>), then outputs to CODE refs
  are also assumed to be safe enough to batch through a temp file,
  otherwise only outputs to SCALAR refs are batched.  This can cause a bit
  of grief if the parent process benefits from or relies on a bit of
  "early returns" coming in before the child program exits.  As long as
  the output is redirected to a SCALAR ref, this will not be visible.
  When output is redirected to a subroutine or (deprecated) filters, the
  subroutine will not get any data until after the child process exits,
  and it is likely to get bigger chunks of data at once.
  
  The reason for the optimization is that, without it, "pumper" processes
  are used to overcome the inconsistencies of the Win32 API.  We need to
  use anonymous pipes to connect to the child processes' stdin, stdout,
  and stderr, yet select() does not work on these.  select() only works on
  sockets on Win32.  So for each redirected child handle, there is
  normally a "pumper" process that connects to the parent using a
  socket--so the parent can select() on that fd--and to the child on an
  anonymous pipe--so the child can read/write a pipe.
  
  Using a socket to connect directly to the child (as at least one MSDN
  article suggests) seems to cause the trailing output from most children
  to be lost.  I think this is because child processes rarely close their
  stdout and stderr explicitly, and the winsock dll does not seem to flush
  output when a process that uses it exits without explicitly closing
  them.
  
  Because of these pumpers and the inherent slowness of Win32
  CreateProcess(), child processes with redirects are quite slow to
  launch; so this routine looks for the very common case of
  reading/writing to/from scalar references in a run() routine and
  converts such reads and writes in to temporary file reads and writes.
  
  Such files are marked as FILE_ATTRIBUTE_TEMPORARY to increase speed and
  as FILE_FLAG_DELETE_ON_CLOSE so it will be cleaned up when the child
  process exits (for input files).  The user's default permissions are
  used for both the temporary files and the directory that contains them,
  hope your Win32 permissions are secure enough for you.  Files are
  created with the Win32API::File defaults of
  FILE_SHARE_READ|FILE_SHARE_WRITE.
  
  Setting the debug level to "details" or "gory" will give detailed
  information about the optimization process; setting it to "basic" or
  higher will tell whether or not a given call is optimized.  Setting
  it to "notopt" will highlight those calls that aren't optimized.
  
  =cut
  
  sub optimize {
      my ($h) = @_;
  
      my @kids = @{ $h->{KIDS} };
  
      my $saw_pipe;
  
      my ( $ok_to_optimize_outputs, $veto_output_optimization );
  
      for my $kid (@kids) {
          ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
            unless $saw_pipe;
  
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
            if _debugging_details && $ok_to_optimize_outputs;
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
            if _debugging_details && $veto_output_optimization;
  
          if ( $h->{noinherit} && !$ok_to_optimize_outputs ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
                if _debugging_details && $ok_to_optimize_outputs;
              $ok_to_optimize_outputs = 1;
          }
  
          for ( @{ $kid->{OPS} } ) {
              if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
                  if ( $_->{TYPE} eq "<" ) {
                      if ( @{ $_->{FILTERS} } > 1 ) {
                          ## Can't assume that the filters are idempotent.
                      }
                      elsif (ref $_->{SOURCE} eq "SCALAR"
                          || ref $_->{SOURCE} eq "GLOB"
                          || UNIVERSAL::isa( $_, "IO::Handle" ) ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
                                ref $_->{SOURCE},
                                ", ok to optimize outputs"
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          $_->{SEND_THROUGH_TEMP_FILE} = 1;
                          next;
                      }
                      elsif ( !ref $_->{SOURCE} && defined $_->{SOURCE} ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          next;
                      }
                  }
                  _debug
                    "Win32 optimizer: (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{SOURCE}
                    ? ref $_->{SOURCE}
                        ? ref $_->{SOURCE}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } > 1 ? " with filters" : (),
                    ", VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
                  $veto_output_optimization = 1;
              }
              elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
                  $ok_to_optimize_outputs = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
                    if _debugging_details;
              }
              elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
                  $veto_output_optimization = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
              }
              elsif ( $_->{TYPE} eq "|" ) {
                  $saw_pipe = 1;
              }
          }
  
          if ( !$ok_to_optimize_outputs && !$veto_output_optimization ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
                if _debugging_details || _debugging_not_optimized;
              $veto_output_optimization = 1;
          }
  
          if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
              $ok_to_optimize_outputs = 0;
              _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
                if _debugging_details || _debugging_not_optimized;
          }
  
          ## SOURCE/DEST ARRAY means it's a filter.
          ## TODO: think about checking to see if the final input/output of
          ## a filter chain (an ARRAY SOURCE or DEST) is a scalar...but
          ## we may be deprecating filters.
  
          for ( @{ $kid->{OPS} } ) {
              if ( $_->{TYPE} eq ">" ) {
                  if (
                      ref $_->{DEST} eq "SCALAR"
                      || (
                          (
                                 @{ $_->{FILTERS} } > 1
                              || ref $_->{DEST} eq "CODE"
                              || ref $_->{DEST} eq "ARRAY"    ## Filters?
                          )
                          && ( $ok_to_optimize_outputs && !$veto_output_optimization )
                      )
                    ) {
                      $_->{RECV_THROUGH_TEMP_FILE} = 1;
                      next;
                  }
                  _debug
                    "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{DEST}
                    ? ref $_->{DEST}
                        ? ref $_->{DEST}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } ? " with filters" : (),
                    if _debugging_details;
              }
          }
      }
  
  }
  
  =pod
  
  =item win32_parse_cmd_line
  
     @words = win32_parse_cmd_line( q{foo bar 'baz baz' "bat bat"} );
  
  returns 4 words. This parses like the bourne shell (see
  the bit about shellwords() in L<Text::ParseWords>), assuming we're
  trying to be a little cross-platform here.  The only difference is
  that "\" is *not* treated as an escape except when it precedes 
  punctuation, since it's used all over the place in DOS path specs.
  
  TODO: strip caret escapes?
  
  TODO: use
  https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments
  
  TODO: globbing? probably not (it's unDOSish).
  
  TODO: shebang emulation? Probably, but perhaps that should be part
  of Run.pm so all spawned processes get the benefit.
  
  LIMITATIONS: shellwords dies silently on malformed input like 
  
     a\"
  
  =cut
  
  sub win32_parse_cmd_line {
      my $line = shift;
      $line =~ s{(\\[\w\s])}{\\$1}g;
      return shellwords $line;
  }
  
  =pod
  
  =item win32_spawn
  
  Spawns a child process, possibly with STDIN, STDOUT, and STDERR (file descriptors 0, 1, and 2, respectively) redirected.
  
  B<LIMITATIONS>.
  
  Cannot redirect higher file descriptors due to lack of support for this in the
  Win32 environment.
  
  This can be worked around by marking a handle as inheritable in the
  parent (or leaving it marked; this is the default in perl), obtaining it's
  Win32 handle with C<Win32API::GetOSFHandle(FH)> or
  C<Win32API::FdGetOsFHandle($fd)> and passing it to the child using the command
  line, the environment, or any other IPC mechanism (it's a plain old integer).
  The child can then use C<OsFHandleOpen()> or C<OsFHandleOpenFd()> and possibly
  C<<open FOO ">&BAR">> or C<<open FOO ">&$fd>> as need be.  Ach, the pain!
  
  Remember to check the Win32 handle against INVALID_HANDLE_VALUE.
  
  =cut
  
  sub _save {
      my ( $saved, $saved_as, $fd ) = @_;
  
      ## We can only save aside the original fds once.
      return if exists $saved->{$fd};
  
      my $saved_fd = IPC::Run::_dup($fd);
      _dont_inherit $saved_fd;
  
      $saved->{$fd}          = $saved_fd;
      $saved_as->{$saved_fd} = $fd;
  
      _dont_inherit $saved->{$fd};
  }
  
  sub _dup2_gently {
      my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
      _save $saved, $saved_as, $fd2;
  
      if ( exists $saved_as->{$fd2} ) {
          ## The target fd is colliding with a saved-as fd, gotta bump
          ## the saved-as fd to another fd.
          my $orig_fd  = delete $saved_as->{$fd2};
          my $saved_fd = IPC::Run::_dup($fd2);
          _dont_inherit $saved_fd;
  
          $saved->{$orig_fd}     = $saved_fd;
          $saved_as->{$saved_fd} = $orig_fd;
      }
      _debug "moving $fd1 to kid's $fd2" if _debugging_details;
      IPC::Run::_dup2_rudely( $fd1, $fd2 );
  }
  
  sub win32_spawn {
      my ( $cmd, $ops ) = @_;
  
      my ( $app, $cmd_line );
      my $need_pct = 0;
      if ( UNIVERSAL::isa( $cmd, 'IPC::Run::Win32Process' ) ) {
          $app      = $cmd->{lpApplicationName};
          $cmd_line = $cmd->{lpCommandLine};
      }
      elsif ( $cmd->[0] !~ /\.(bat|cmd) *$/i ) {
          $app      = $cmd->[0];
          $cmd_line = Win32::ShellQuote::quote_native(@$cmd);
      }
      else {
          # Batch file, so follow the batch-specific guidance of
          # https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
          # There's no one true way to locate cmd.exe.  In the unlikely event that
          # %COMSPEC% is missing, fall back on a Windows API.  We could search
          # %PATH% like _wsystem() does.  That would be prone to security bugs,
          # and one fallback is enough.
          $app = (
              $ENV{COMSPEC}
                || File::Spec->catfile(
                  Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                  'cmd.exe'
                )
          );
  
          # Win32 rejects attempts to create files with names containing certain
          # characters.  Ignore most, but reject the subset that might otherwise
          # cause us to execute the wrong file instead of failing cleanly.
          if ( $cmd->[0] =~ /["\r\n\0]/ ) {
              croak "invalid batch file name";
          }
  
          # Make cmd.exe see the batch file name as quoted.  Suppose we instead
          # used caret escapes, as we do for arguments.  cmd.exe could then "break
          # the command token at the first occurrence of <space> , ; or ="
          # (https://stackoverflow.com/a/4095133).
          my @parts = qq{"$cmd->[0]"};
  
          # cmd.exe will strip escapes once when parsing our $cmd_line and again
          # where the batch file injects the argument via %*, %1, etc.  Compensate
          # by adding one extra cmd_escape layer.
          if ( @$cmd > 1 ) {
              my @q = Win32::ShellQuote::quote_cmd( @{$cmd}[ 1 .. $#{$cmd} ] );
              push @parts, map { Win32::ShellQuote::cmd_escape($_) } @q;
          }
  
          # One can't stop cmd.exe from expanding %var%, so inject each literal %
          # via an environment variable.  Delete that variable before the real
          # child can see it.  See
          # https://www.dostips.com/forum/viewtopic.php?f=3&t=10131 for more on
          # this technique and the limitations of alternatives.
          $cmd_line = join ' ', @parts;
          if ( $cmd_line =~ s/%/%ipcrunpct%/g ) {
              $cmd_line = qq{/c "set "ipcrunpct=" & $cmd_line"};
              $need_pct = 1;
          }
          else {
              $cmd_line = qq{/c "$cmd_line"};
          }
      }
      _debug "app: ", $app
        if _debugging;
      _debug "cmd line: ", $cmd_line
        if _debugging;
  
      ## NOTE: The debug pipe write handle is passed to pump processes as STDOUT.
      ## and is not to the "real" child process, since they would not know
      ## what to do with it...unlike Unix, we have no code executing in the
      ## child before the "real" child is exec()ed.
  
      my %saved;       ## Map of parent's orig fd -> saved fd
      my %saved_as;    ## Map of parent's saved fd -> orig fd, used to
      ## detect collisions between a KFD and the fd a
      ## parent's fd happened to be saved to.
  
      for my $op (@$ops) {
          _dont_inherit $op->{FD} if defined $op->{FD};
  
          if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
              ## TODO: Detect this in harness()
              ## TODO: enable temporary redirections if ever necessary, not
              ## sure why they would be...
              ## 4>&1 1>/dev/null 1>&4 4>&-
              croak "Can't redirect fd #", $op->{KFD}, " on Win32";
          }
  
          ## This is very similar logic to IPC::Run::_do_kid_and_exit().
          if ( defined $op->{TFD} ) {
              unless ( $op->{TFD} == $op->{KFD} ) {
                  _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
                  _dont_inherit $op->{TFD};
              }
          }
          elsif ( $op->{TYPE} eq "dup" ) {
              _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
                unless $op->{KFD1} == $op->{KFD2};
          }
          elsif ( $op->{TYPE} eq "close" ) {
              _save \%saved, \%saved_as, $op->{KFD};
              IPC::Run::_close( $op->{KFD} );
          }
          elsif ( $op->{TYPE} eq "init" ) {
              ## TODO: detect this in harness()
              croak "init subs not allowed on Win32";
          }
      }
  
      local $ENV{ipcrunpct} = '%' if $need_pct;
      my $process;
      Win32::Process::Create(
          $process,
          $app,
          $cmd_line,
          1,    ## Inherit handles
          0,    ## Inherit parent priortiy class. Was NORMAL_PRIORITY_CLASS
          ".",
        )
        or do {
          my $err = Win32::FormatMessage( Win32::GetLastError() );
          $err =~ s/\r?\n$//s;
          croak "$err: Win32::Process::Create()";
        };
  
      for my $orig_fd ( keys %saved ) {
          IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
          IPC::Run::_close( $saved{$orig_fd} );
      }
  
      return ( $process->GetProcessID(), $process );
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32HELPER

$fatpacked{"IPC/Run/Win32IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32IO';
  package IPC::Run::Win32IO;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32IO - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32IO;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select()
  loop will work on Win32. This seems to only work on WinNT and Win2K at this
  time, not sure if it will ever work on Win95 or Win98. If you have experience
  in this area, please contact me at barries@slaysys.com, thanks!.
  
  =head1 DESCRIPTION
  
  A specialized IO class used on Win32.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use Socket;
  require POSIX;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  use Socket qw( IPPROTO_TCP TCP_NODELAY );
  use Symbol;
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug qw( :default _debugging_level );
  use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
  use Fcntl qw( O_TEXT O_RDONLY );
  
  use base qw( IPC::Run::IO );
  my @cleanup_fields;
  
  BEGIN {
      ## These fields will be set to undef in _cleanup to close
      ## the handles.
      @cleanup_fields = (
          'SEND_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'RECV_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'TEMP_FILE_NAME',            ## The name of the temp file, needed for
          ## error reporting / debugging only.
  
          'PARENT_HANDLE',             ## The handle of the socket for the parent
          'PUMP_SOCKET_HANDLE',        ## The socket handle for the pump
          'PUMP_PIPE_HANDLE',          ## The anon pipe handle for the pump
          'CHILD_HANDLE',              ## The anon pipe handle for the child
  
          'TEMP_FILE_HANDLE',          ## The Win32 filehandle for the temp file
      );
  }
  
  ## REMOVE OSFHandleOpen
  use Win32API::File qw(
    GetOsFHandle
    OsFHandleOpenFd
    OsFHandleOpen
    FdGetOsFHandle
    SetHandleInformation
    SetFilePointer
    HANDLE_FLAG_INHERIT
    INVALID_HANDLE_VALUE
  
    createFile
    WriteFile
    ReadFile
    CloseHandle
  
    FILE_ATTRIBUTE_TEMPORARY
    FILE_FLAG_DELETE_ON_CLOSE
    FILE_FLAG_WRITE_THROUGH
  
    FILE_BEGIN
  );
  
  #   FILE_ATTRIBUTE_HIDDEN
  #   FILE_ATTRIBUTE_SYSTEM
  
  BEGIN {
      ## Force AUTOLOADED constants to be, well, constant by getting them
      ## to AUTOLOAD before compilation continues.  Sigh.
      () = (
          SOL_SOCKET,
          SO_REUSEADDR,
          IPPROTO_TCP,
          TCP_NODELAY,
          HANDLE_FLAG_INHERIT,
          INVALID_HANDLE_VALUE,
      );
  }
  
  use constant temp_file_flags => ( FILE_ATTRIBUTE_TEMPORARY() | FILE_FLAG_DELETE_ON_CLOSE() | FILE_FLAG_WRITE_THROUGH() );
  
  #   FILE_ATTRIBUTE_HIDDEN()    |
  #   FILE_ATTRIBUTE_SYSTEM()    |
  my $tmp_file_counter;
  my $tmp_dir;
  
  sub _cleanup {
      my IPC::Run::Win32IO $self = shift;
      my ($harness) = @_;
  
      $self->_recv_through_temp_file($harness)
        if $self->{RECV_THROUGH_TEMP_FILE};
  
      CloseHandle( $self->{TEMP_FILE_HANDLE} )
        if defined $self->{TEMP_FILE_HANDLE};
  
      close( $self->{CHILD_HANDLE} )
        if defined $self->{CHILD_HANDLE};
  
      $self->{$_} = undef for @cleanup_fields;
  }
  
  sub _create_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## Create a hidden temp file that Win32 will delete when we close
      ## it.
      unless ( defined $tmp_dir ) {
          $tmp_dir = File::Spec->catdir( File::Spec->tmpdir, "IPC-Run.tmp" );
  
          ## Trust in the user's umask.
          ## This could possibly be a security hole, perhaps
          ## we should offer an option.  Hmmmm, really, people coding
          ## security conscious apps should audit this code and
          ## tell me how to make it better.  Nice cop-out :).
          unless ( -d $tmp_dir ) {
              mkdir $tmp_dir or croak "$!: $tmp_dir";
          }
      }
  
      $self->{TEMP_FILE_NAME} = File::Spec->catfile(
          ## File name is designed for easy sorting and not conflicting
          ## with other processes.  This should allow us to use "t"runcate
          ## access in CreateFile in case something left some droppings
          ## around (which should never happen because we specify
          ## FLAG_DELETE_ON_CLOSE.
          ## heh, belt and suspenders are better than bug reports; God forbid
          ## that NT should ever crash before a temp file gets deleted!
          $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
      );
  
      $self->{TEMP_FILE_HANDLE} = createFile(
          $self->{TEMP_FILE_NAME},
          "trw",    ## new, truncate, read, write
          {
              Flags => temp_file_flags,
          },
      ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
  
      $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
      $self->{FD} = undef;
  
      _debug
        "Win32 Optimizer: temp file (",
        $self->{KFD},
        $self->{TYPE},
        $self->{TFD},
        ", fh ",
        $self->{TEMP_FILE_HANDLE},
        "): ",
        $self->{TEMP_FILE_NAME}
        if _debugging_details;
  }
  
  sub _reset_temp_file_pointer {
      my $self = shift;
      SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
        or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
  }
  
  sub _send_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      _debug "Win32 optimizer: optimizing " . " $self->{KFD} $self->{TYPE} temp file instead of ",
        ref $self->{SOURCE} || $self->{SOURCE}
        if _debugging_details;
  
      $self->_create_temp_file;
  
      if ( defined ${ $self->{SOURCE} } ) {
          my $bytes_written = 0;
          my $data_ref;
          if ( $self->binmode ) {
              $data_ref = $self->{SOURCE};
          }
          else {
              my $data = ${ $self->{SOURCE} };    # Ugh, a copy.
              $data =~ s/(?<!\r)\n/\r\n/g;
              $data_ref = \$data;
          }
  
          WriteFile(
              $self->{TEMP_FILE_HANDLE},
              $$data_ref,
              0,                                  ## Write entire buffer
              $bytes_written,
              [],                                 ## Not overlapped.
          ) or croak "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
          _debug "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
            if _debugging_data;
  
          $self->_reset_temp_file_pointer;
  
      }
  
      _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
        if _debugging_details;
  }
  
  sub _init_recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      $self->_create_temp_file;
  }
  
  ## TODO: Use the Win32 API in the select loop to see if the file has grown
  ## and read it incrementally if it has.
  sub _recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## This next line kicks in if the run() never got to initting things
      ## and needs to clean up.
      return undef unless defined $self->{TEMP_FILE_HANDLE};
  
      push @{ $self->{FILTERS} }, sub {
          my ( undef, $out_ref ) = @_;
  
          return undef unless defined $self->{TEMP_FILE_HANDLE};
  
          my $r;
          my $s;
          ReadFile(
              $self->{TEMP_FILE_HANDLE},
              $s,
              999_999,    ## Hmmm, should read the size.
              $r,
              []
          ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
  
          _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
  
          return undef unless $r;
  
          $s =~ s/\r\n/\n/g unless $self->binmode;
  
          my $pos = pos $$out_ref;
          $$out_ref .= $s;
          pos($out_ref) = $pos;
          return 1;
      };
  
      my ($harness) = @_;
  
      $self->_reset_temp_file_pointer;
  
      1 while $self->_do_filters($harness);
  
      pop @{ $self->{FILTERS} };
  
      IPC::Run::_close( $self->{TFD} );
  }
  
  =head1 SUBROUTINES
  
  =over
  
  =item poll
  
  Windows version of IPC::Run::IP::poll.
  
  =back
  
  =cut
  
  sub poll {
      my IPC::Run::Win32IO $self = shift;
  
      return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
  
      return $self->SUPER::poll(@_);
  }
  
  ## When threaded Perls get good enough, we should use threads here.
  ## The problem with threaded perls is that they dup() all sorts of
  ## filehandles and fds and don't allow sufficient control over
  ## closing off the ones we don't want.
  
  sub _spawn_pumper {
      my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
      my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
  
      _debug "pumper stdin = ",  $stdin_fd  if _debugging_details;
      _debug "pumper stdout = ", $stdout_fd if _debugging_details;
      _inherit $stdin_fd, $stdout_fd, $debug_fd;
      my @I_options = map qq{"-I$_"}, @INC;
  
      my $cmd_line = join(
          " ",
          qq{"$^X"},
          @I_options,
          qw(-MIPC::Run::Win32Pump -e 1 ),
  ## I'm using this clunky way of passing filehandles to the child process
  ## in order to avoid some kind of premature closure of filehandles
  ## problem I was having with VCP's test suite when passing them
  ## via CreateProcess.  All of the ## REMOVE code is stuff I'd like
  ## to be rid of and the ## ADD code is what I'd like to use.
          FdGetOsFHandle($stdin_fd),     ## REMOVE
          FdGetOsFHandle($stdout_fd),    ## REMOVE
          FdGetOsFHandle($debug_fd),     ## REMOVE
          $binmode ? 1 : 0,
          $$, $^T, _debugging_level, qq{"$child_label"},
          @opts
      );
  
      #   open SAVEIN,  "<&STDIN"  or croak "$! saving STDIN";       #### ADD
      #   open SAVEOUT, ">&STDOUT" or croak "$! saving STDOUT";       #### ADD
      #   open SAVEERR, ">&STDERR" or croak "$! saving STDERR";       #### ADD
      #   _dont_inherit \*SAVEIN;       #### ADD
      #   _dont_inherit \*SAVEOUT;       #### ADD
      #   _dont_inherit \*SAVEERR;       #### ADD
      #   open STDIN,  "<&$stdin_fd"  or croak "$! dup2()ing $stdin_fd (pumper's STDIN)";       #### ADD
      #   open STDOUT, ">&$stdout_fd" or croak "$! dup2()ing $stdout_fd (pumper's STDOUT)";       #### ADD
      #   open STDERR, ">&$debug_fd" or croak "$! dup2()ing $debug_fd (pumper's STDERR/debug_fd)";       #### ADD
  
      _debug "pump cmd line: ", $cmd_line if _debugging_details;
  
      my $process;
      Win32::Process::Create(
          $process,
          $^X,
          $cmd_line,
          1,    ## Inherit handles
          NORMAL_PRIORITY_CLASS,
          ".",
      ) or croak "$!: Win32::Process::Create()";
  
      #   open STDIN,  "<&SAVEIN"  or croak "$! restoring STDIN";       #### ADD
      #   open STDOUT, ">&SAVEOUT" or croak "$! restoring STDOUT";       #### ADD
      #   open STDERR, ">&SAVEERR" or croak "$! restoring STDERR";       #### ADD
      #   close SAVEIN             or croak "$! closing SAVEIN";       #### ADD
      #   close SAVEOUT            or croak "$! closing SAVEOUT";       #### ADD
      #   close SAVEERR            or croak "$! closing SAVEERR";       #### ADD
  
      # In case of a sleep right here, need the IPC::Run::_close() treatment.
      IPC::Run::_close fileno($stdin);
      close $stdin;
      IPC::Run::_close fileno($stdout);
      close $stdout;
  
      # Don't close $debug_fd, we need it, as do other pumpers.
  
      # Pause a moment to allow the child to get up and running and emit
      # debug messages.  This does not always work.
      #   select undef, undef, undef, 1 if _debugging_details;
  
      _debug "_spawn_pumper pid = ", $process->GetProcessID
        if _debugging_data;
  }
  
  my $loopback  = inet_aton "127.0.0.1";
  my $tcp_proto = getprotobyname('tcp');
  croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
  
  sub _socket {
      my ($server) = @_;
      $server ||= gensym;
      my $client = gensym;
  
      my $listener = gensym;
      socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
        or croak "$!: socket()";
      setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack( "l", 0 )
        or croak "$!: setsockopt()";
  
      unless ( bind $listener, sockaddr_in( 0, $loopback ) ) {
          croak "Error binding: $!";
      }
  
      my ($port) = sockaddr_in( getsockname($listener) );
  
      _debug "win32 port = $port" if _debugging_details;
  
      listen $listener, my $queue_size = 1
        or croak "$!: listen()";
  
      {
          socket $client, PF_INET, SOCK_STREAM, $tcp_proto
            or croak "$!: socket()";
  
          my $paddr = sockaddr_in( $port, $loopback );
  
          connect $client, $paddr
            or croak "$!: connect()";
  
          croak "$!: accept" unless defined $paddr;
  
          ## The windows "default" is SO_DONTLINGER, which should make
          ## sure all socket data goes through.  I have my doubts based
          ## on experimentation, but nothing prompts me to set SO_LINGER
          ## at this time...
          setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack( "l", 0 )
            or croak "$!: setsockopt()";
      }
  
      {
          _debug "accept()ing on port $port" if _debugging_details;
          my $paddr = accept( $server, $listener );
          croak "$!: accept()" unless defined $paddr;
      }
  
      _debug "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port"
        if _debugging_details;
      return ( $server, $client );
  }
  
  sub _open_socket_pipe {
      my IPC::Run::Win32IO $self = shift;
      my ( $debug_fd, $parent_handle ) = @_;
  
      my $is_send_to_child = $self->dir eq "<";
  
      $self->{CHILD_HANDLE}     = gensym;
      $self->{PUMP_PIPE_HANDLE} = gensym;
  
      (
          $self->{PARENT_HANDLE},
          $self->{PUMP_SOCKET_HANDLE}
      ) = _socket $parent_handle;
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{PARENT_HANDLE}      or die $!;
      binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
  
      _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
        if _debugging_details;
  ##my $buf;
  ##$buf = "write on child end of " . fileno( $self->{WRITE_HANDLE} ) . "\n\n\n\n\n";
  ##POSIX::write(fileno $self->{WRITE_HANDLE}, $buf, length $buf) or warn "$! in syswrite";
  ##$buf = "write on parent end of " . fileno( $self->{CHILD_HANDLE} ) . "\r\n";
  ##POSIX::write(fileno $self->{CHILD_HANDLE},$buf, length $buf) or warn "$! in syswrite";
  ##   $self->{CHILD_HANDLE}->autoflush( 1 );
  ##   $self->{WRITE_HANDLE}->autoflush( 1 );
  
      ## Now fork off a data pump and arrange to return the correct fds.
      if ($is_send_to_child) {
          pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
      else {
          pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{CHILD_HANDLE};
      binmode $self->{PUMP_PIPE_HANDLE};
  
      ## No child should ever see this.
      _dont_inherit $self->{PARENT_HANDLE};
  
      ## We clear the inherit flag so these file descriptors are not inherited.
      ## It'll be dup()ed on to STDIN/STDOUT/STDERR before CreateProcess is
      ## called and *that* fd will be inheritable.
      _dont_inherit $self->{PUMP_SOCKET_HANDLE};
      _dont_inherit $self->{PUMP_PIPE_HANDLE};
      _dont_inherit $self->{CHILD_HANDLE};
  
      ## Need to return $self so the HANDLEs don't get freed.
      ## Return $self, $parent_fd, $child_fd
      my ( $parent_fd, $child_fd ) = (
          fileno $self->{PARENT_HANDLE},
          fileno $self->{CHILD_HANDLE}
      );
  
      ## Both PUMP_..._HANDLEs will be closed, no need to worry about
      ## inheritance.
      _debug "binmode on" if _debugging_data && $self->binmode;
      _spawn_pumper(
          $is_send_to_child
          ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
          : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
          $debug_fd,
          $self->binmode,
          $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
      );
  
      {
          my $foo;
          confess "PARENT_HANDLE no longer open"
            unless POSIX::read( $parent_fd, $foo, 0 );
      }
  
      _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
        if _debugging_details;
  
      $self->{FD}  = $parent_fd;
      $self->{TFD} = $child_fd;
  }
  
  sub _do_open {
      my IPC::Run::Win32IO $self = shift;
  
      if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
          return $self->_send_through_temp_file(@_);
      }
      elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
          return $self->_init_recv_through_temp_file(@_);
      }
      else {
          return $self->_open_socket_pipe(@_);
      }
  }
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32IO

$fatpacked{"IPC/Run/Win32Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PROCESS';
  package IPC::Run::Win32Process;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Process -- deliver nonstandard command lines via IPC::Run.
  
  =head1 SYNOPSIS
  
     use File::Spec ();
     use IPC::Run qw(run);
     use IPC::Run::Win32Process ();
     use Win32 ();
  
     $find_exe = File::Spec->catfile(Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                                     'find.exe');
     run(IPC::Run::Win32Process->new($ENV{COMSPEC}, q{cmd.exe /c echo ""}),
         '|', IPC::Run::Win32Process->new($find_exe, q{find_exe """"""}),
         '>', \$out);
  
  =head1 DESCRIPTION
  
  This class facilitates executing Windows programs that don't use L<standard
  command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>.
  Notable programs having nonstandard rules include F<cmd.exe>, F<cscript.exe>,
  and Cygwin programs called from non-Cygwin programs.  IPC::Run will use the two
  strings, verbatim, as the lpApplicationName and lpCommandLine arguments of
  CreateProcessA().  This furnishes unfiltered control over the child process
  command line.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  
  use overload '""' => sub {
      my ($self) = @_;
      return join(
          '',
          'IPC::Run::Win32Process(',
          $self->{lpApplicationName},
          ', ',
          $self->{lpCommandLine},
          ')'
      );
  };
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  =item new
  
     IPC::Run::Win32Process->new( $lpApplicationName, $lpCommandLine );
     IPC::Run::Win32Process->new( $ENV{COMSPEC}, q{cmd.exe /c echo ""} );
  
  Constructor.
  
  =back
  
  =cut
  
  sub new {
      my ( $class, $lpApplicationName, $lpCommandLine ) = @_;
      $class = ref $class || $class;
  
      croak "missing lpApplicationName" if !defined $lpApplicationName;
      croak "missing lpCommandLine"     if !defined $lpCommandLine;
  
      my IPC::Run::Win32Process $self = bless {}, $class;
      $self->{lpApplicationName} = $lpApplicationName;
      $self->{lpCommandLine}     = $lpCommandLine;
  
      return $self;
  }
  
  1;
IPC_RUN_WIN32PROCESS

$fatpacked{"IPC/Run/Win32Pump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PUMP';
  package IPC::Run::Win32Pump;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Pump - helper processes to shovel data to/from parent, child
  
  =head1 SYNOPSIS
  
  Internal use only; see IPC::Run::Win32IO and best of luck to you.
  
  =head1 DESCRIPTION
  
  See L<IPC::Run::Win32Helper|IPC::Run::Win32Helper> for details.  This
  module is used in subprocesses that are spawned to shovel data to/from
  parent processes from/to their child processes.  Where possible, pumps
  are optimized away.
  
  NOTE: This is not a real module: it's a script in module form, designed
  to be run like
  
     $^X -MIPC::Run::Win32Pumper -e 1 ...
  
  It parses a bunch of command line parameters from IPC::Run::Win32IO.
  
  =cut
  
  use strict;
  use warnings;
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  use Win32API::File qw(
    OsFHandleOpen
  );
  
  my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
  
  BEGIN {
      ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
      ## Rather than letting IPC::Run::Debug export all-0 constants
      ## when not debugging, we do it manually in order to not even
      ## load IPC::Run::Debug.
      if ($debug) {
          eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
            or die $@;
      }
      else {
          eval <<STUBS_END or die $@;
  	 sub _debug {}
  	 sub _debug_init {}
  	 sub _debugging() { 0 }
  	 sub _debugging_data() { 0 }
  	 sub _debugging_details() { 0 }
  	 sub _debugging_gory_details() { 0 }
  	 1;
  STUBS_END
      }
  }
  
  ## For some reason these get created with binmode on.  AAargh, gotta       #### REMOVE
  ## do it by hand below.       #### REMOVE
  if ($debug) {    #### REMOVE
      close STDERR;    #### REMOVE
      OsFHandleOpen( \*STDERR, $debug_fh, "w" )    #### REMOVE
        or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";    #### REMOVE
  }               #### REMOVE
  close STDIN;    #### REMOVE
  OsFHandleOpen( \*STDIN, $stdin_fh, "r" )    #### REMOVE
    or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";    #### REMOVE
  close STDOUT;                                                          #### REMOVE
  OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )                             #### REMOVE
    or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";  #### REMOVE
  
  binmode STDIN;
  binmode STDOUT;
  $| = 1;
  select STDERR;
  $| = 1;
  select STDOUT;
  
  $child_label ||= "pump";
  _debug_init(
      $parent_pid,
      $parent_start_time,
      $debug,
      fileno STDERR,
      $child_label,
  );
  
  _debug "Entered" if _debugging_details;
  
  # No need to close all fds; win32 doesn't seem to pass any on to us.
  $| = 1;
  my $buf;
  my $total_count = 0;
  while (1) {
      my $count = sysread STDIN, $buf, 10_000;
      last unless $count;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars revc: ", $count ), $msg;
      }
      $total_count += $count;
      $buf =~ s/\r//g unless $binmode;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars sent: ", $count ), $msg;
      }
      print $buf;
  }
  
  _debug "Exiting, transferred $total_count chars" if _debugging_details;
  
  ## Perform a graceful socket shutdown.  Windows defaults to SO_DONTLINGER,
  ## which should cause a "graceful shutdown in the background" on sockets.
  ## but that's only true if the process closes the socket manually, it
  ## seems; if the process exits and lets the OS clean up, the OS is not
  ## so kind.  STDOUT is not always a socket, of course, but it won't hurt
  ## to close a pipe and may even help.  With a closed source OS, who
  ## can tell?
  ##
  ## In any case, this close() is one of the main reasons we have helper
  ## processes; if the OS closed socket fds gracefully when an app exits,
  ## we'd just redirect the client directly to what is now the pump end
  ## of the socket.  As it is, however, we need to let the client play with
  ## pipes, which don't have the abort-on-app-exit behavior, and then
  ## adapt to the sockets in the helper processes to allow the parent to
  ## select.
  ##
  ## Possible alternatives / improvements:
  ##
  ## 1) use helper threads instead of processes.  I don't trust perl's threads
  ## as of 5.005 or 5.6 enough (which may be myopic of me).
  ##
  ## 2) figure out if/how to get at WaitForMultipleObjects() with pipe
  ## handles.  May be able to take the Win32 handle and pass it to
  ## Win32::Event::wait_any, dunno.
  ##
  ## 3) Use Inline::C or a hand-tooled XS module to do helper threads.
  ## This would be faster than #1, but would require a ppm distro.
  ##
  close STDOUT;
  close STDERR;
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32PUMP

$fatpacked{"match/simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MATCH_SIMPLE';
  package match::simple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny;
  use List::Util 1.33 qw( any );
  use Scalar::Util qw( blessed );
  
  BEGIN {
  	$match::simple::AUTHORITY = 'cpan:TOBYINK';
  	$match::simple::VERSION   = '0.012';
  }
  
  our @ISA       = qw( Exporter::Tiny );
  our @EXPORT    = qw( M );
  our @EXPORT_OK = qw( match );
  
  my $xs;
  unless (($ENV{MATCH_SIMPLE_IMPLEMENTATION}||'') =~ /pp/i) {
  	eval {
  		require match::simple::XS;
  		match::simple::XS->VERSION( 0.002 );  # minimum
  		
  		# Unless we're a development version...
  		# Avoid using an unstable version of ::XS
  		unless (match::simple->VERSION =~ /_/) {
  			die if match::simple::XS->VERSION =~ /_/;
  		}
  		
  		$xs = match::simple::XS->can('match');
  	};
  }
  
  eval($xs ? <<'XS' : <<'PP');
  
  sub IMPLEMENTATION () { "XS" }
  
  *match = *match::simple::XS::match;
  
  XS
  
  sub IMPLEMENTATION () { "PP" }
  
  sub match {
  	no warnings qw( uninitialized numeric );
  	
  	my ( $a, $b ) = @_;
  	my $method;
  	
  	return !defined $a                      if !defined($b);
  	return $a eq $b                         if !ref($b);
  	return $a =~ $b                         if ref($b) eq q(Regexp);
  	return do { local $_ = $a; !!$b->($a) } if ref($b) eq q(CODE);
  	return any { match( $a, $_ ) } @$b      if ref($b) eq q(ARRAY);
  	return !!$b->$method( $a, 1 )           if blessed($b) && ( $method = _overloaded_smartmatch( $b ) );
  	
  	require Carp;
  	Carp::croak( "match::simple cannot match anything against: $b" );
  }
  
  unless ( eval 'require re; 1' and exists &re::is_regexp ) {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object( $_[0] )->MAGIC->TYPE eq 'r' };
  	};
  }
  
  sub _overloaded_smartmatch {
  	my ( $obj ) = @_;
  	return if re::is_regexp( $obj );
  	
  	if ( $obj->isa( 'Type::Tiny' ) ) {
  		return $obj->can( 'check' );
  	}
  	
  	if ( my $match = $obj->can( 'MATCH' ) ) {
  		return $match;
  	}
  	
  	if ( $] lt '5.010' ) { require MRO::Compat; }
  	else                 { require mro;         }
  	
  	my @mro = @{ mro::get_linear_isa( ref $obj ) };
  	for my $class ( @mro ) {
  		my $name = "$class\::(~~";
  		my $overload = do {
  			no strict 'refs';
  			exists( &$name ) ? \&$name : undef;
  		};
  		return $overload if $overload;
  	}
  	
  	return;
  }
  
  PP
  
  sub _generate_M {
  	require Sub::Infix;
  	&Sub::Infix::infix( \&match );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smartmatch recurses
  
  =head1 NAME
  
  match::simple - simplified clone of smartmatch operator
  
  =head1 SYNOPSIS
  
     use v5.10;
     use match::simple;
     
     if ( $this |M| $that ) {
        say "$this matches $that";
     }
  
  =head1 DESCRIPTION
  
  match::simple provides a simple match operator C<< |M| >> that acts like
  a sane subset of the (as of Perl 5.18) deprecated smart match operator.
  Unlike smart match, the behaviour of the match is determined entirely by
  the operand on the right hand side.
  
  =over
  
  =item *
  
  If the right hand side is C<undef>, then there is only a match if the left
  hand side is also C<undef>.
  
  =item *
  
  If the right hand side is a non-reference, then the match is a simple string
  match.
  
  =item *
  
  If the right hand side is a reference to a regexp, then the left hand is
  evaluated .
  
  =item *
  
  If the right hand side is a code reference, then it is called in a boolean
  context with the left hand side being passed as an argument.
  
  =item *
  
  If the right hand side is an object which provides a C<MATCH> method, then
  it this is called as a method, with the left hand side being passed as an
  argument.
  
  =item *
  
  If the right hand side is an object which overloads C<< ~~ >>, then this
  will be used.
  
  =item *
  
  If the right hand side is an arrayref, then the operator recurses into the
  array, with the match succeeding if the left hand side matches any array
  element.
  
  =item *
  
  If any other value appears on the right hand side, the operator will croak.
  
  =back
  
  If you don't like the crazy L<Sub::Infix> operator, you can alternatively
  export a more normal function:
  
     use v5.10;
     use match::simple qw(match);
     
     if ( match($this, $that) ) {
        say "$this matches $that";
     }
  
  If you're making heavy use of this module, then this is probably your best
  option, as it runs significantly faster.
  
  =head2 XS Backend
  
  If you install match::simple::XS, a faster XS-based implementation will be
  used instead of the pure Perl functions. Depending on what sort of match you
  are doing, this is likely to be several times faster. In extreme cases, such
  as matching a string in an arrayref, it can be twenty-five times faster, or
  more. However, where C<< $that >> is a single regexp, it's around 30% slower.
  Overall though, I think the performance improvement is worthwhile.
  
  If you want to take advantage of this speed up, use the C<match> function
  rather than the C<< |M| >> operator. Otherwise all your gains will be lost to
  the slow implementation of operator overloading.
  
  The constant C<< match::simple::IMPLEMENTATION >> tells you which backend
  is currently in use.
  
  =head2 Environment
  
  Setting the C<MATCH_SIMPLE_IMPLEMENTATION> environment variable to "PP"
  encourages match::simple to use the pure Perl backend.
  
  =begin trustme
  
  =item M
  
  =item match
  
  =item IMPLEMENTATION
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-match-simple/issues>.
  
  =head1 SEE ALSO
  
  L<match::smart>, L<match::simple::sugar>.
  
  This module uses L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017, 2022-2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MATCH_SIMPLE

$fatpacked{"match/simple/sugar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MATCH_SIMPLE_SUGAR';
  package match::simple::sugar;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny;
  use Carp qw( croak );
  use Scalar::Util qw( blessed );
  use match::simple qw( match );
  
  BEGIN {
  	$match::simple::sugar::AUTHORITY = 'cpan:TOBYINK';
  	$match::simple::sugar::VERSION   = '0.012';
  	my $strict = 0;
  	$ENV{$_} && $strict++ for qw(
  		EXTENDED_TESTING
  		AUTHOR_TESTING
  		RELEASE_TESTING
  		PERL_STRICT
  	);
  	eval qq{
  		sub STRICT () { !! $strict }
  		sub LAX    () {  ! $strict }
  	};
  }
  
  our @ISA       = qw( Exporter::Tiny );
  our @EXPORT    = qw( when then numeric match );
  
  my $then_class    = __PACKAGE__ . '::then';
  my $numeric_class = __PACKAGE__ . '::numeric';
  
  sub when {
  	my @things = @_;
  	my $then = pop @things;
  	if ( blessed $then and $then->isa( $then_class ) ) {
  		if ( match $_, \@things ) {
  			no warnings 'exiting';
  			$then->();
  			next;
  		}
  	}
  	else {
  		croak "when: expects then";
  	}
  	return;
  }
  
  sub _check_coderef {
  	my $coderef = shift;
  	require B;
  	local *B::OP::__match_simple_sugar_callback = sub {
  		my $name = $_[0]->name;
  		croak "Block appears to contain a `$name` statement; not suitable for use with when/then"
  			if match $name, [ qw/ wantarray return redo last next / ];
  		return;
  	};
  	B::svref_2object( $coderef )->ROOT->B::walkoptree( '__match_simple_sugar_callback' );
  }
  
  sub then (&) {
  	my $coderef = shift;
  	_check_coderef $coderef if STRICT;
  	bless $coderef, $then_class;
  }
  
  sub numeric ($) {
  	my $n = shift;
  	bless \$n, $numeric_class;
  }
  
  {
  	my $check = sub {
  		my ( $x, $y ) = map {
  			( blessed $_ and $_->isa( $numeric_class ) )
  				? $$_
  				: $_;
  		} @_[0, 1];
  		no warnings qw( numeric );
  		defined $x and defined $y and !ref $x and !ref $y and $x == $y;
  	};
  	no strict 'refs';
  	*{"$numeric_class\::MATCH"} = $check;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smartmatch recurses
  
  =head1 NAME
  
  match::simple::sugar - a few extras for match::simple
  
  =head1 SYNOPSIS
  
  This module provides a C<given>/C<when> substitute for L<match::simple>.
  
     use match::simple::sugar;
     
     for ( $var ) {
        when 'foo',        then { ... };
        when 'bar', 'baz', then { ... };
        ...;  # otherwise
     }
  
  It also provides a function for numeric matching (because L<match::simple>
  always assumes you want stringy matching if the right-hand-side is a defined
  non-reference value).
  
     use match::simple::sugar;
     
     for ( $var ) {
        when numeric 0, then { ... };
        when numeric 1, then { ... };
        ...;  # otherwise
     }
  
  
  =head1 DESCRIPTION
  
  This module exports three functions C<when>, C<then>, and C<numeric>,
  and also re-exports C<match> from L<match::simple>.
  
  =head2 C<when> and C<then>
  
  The C<when> and C<then> functions are intended to be used together,
  inside a C<< for ( SCALAR ) { ... } >> block. The block acts as a
  topicalizer (it sets C<< $_ >>) and also a control-flow mechanism
  (C<when> can use C<next> to jump out of it). Any other use of C<when>
  and C<then> is unsupported.
  
  =head3 C<< when( @values, $then ) >>
  
  The C<when> function accepts a list of values, followed by a special
  C<< $then >> argument.
  
  If C<< $_ >> matches (according to the definition in L<match::simple>)
  any of the values, then the C<< $then >> argument will be executed, and
  C<when> will use the Perl built-in C<next> keyword to jump out of the
  surrounding C<for> block.
  
  =head3 C<< then { ... } >>
  
  The C<then> function takes a block of code and returns an object suitable
  for use as C<when>'s C<< $then >> argument.
  
  In the current implementation, the block of code should not inspect
  C<< @_ >> or C<wantarray>, and should not use the C<return>, C<next>,
  C<last>, or C<redo> keywords. (If you set any of the C<PERL_STRICT>,
  C<EXTENDED_TESTING>, C<AUTHOR_TESTING>, or C<RELEASE_TESTING> environment
  variables to true, then match::simple::sugar will I<try> to enforce this!
  This is intended to catch faulty C<then> blocks when running your test
  suite.)
  
  =head2 C<numeric>
  
  The C<numeric> function accepts a number and returns a blessed object
  which has a C<MATCH> method. The C<MATCH> method returns true if it is
  called with a single defined non-referece scalar that is numerically
  equal to the original number passed to C<numeric>. Example:
  
     numeric( '5.0' )->MATCH( '5.000' );    # true
  
  This is intended for use in cases like:
  
     if ( match $var, numeric 1 ) {
        ...;
     }
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-match-simple/issues>.
  
  =head1 SEE ALSO
  
  L<match::simple>.
  
  This module uses L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  This module is inspired by a talk I gave to
  L<Boston.PM|https://boston-pm.github.io/>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MATCH_SIMPLE_SUGAR

$fatpacked{"match/smart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MATCH_SMART';
  package match::smart;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use B qw();
  use Exporter::Tiny;
  use List::Util 1.33 qw( any all );
  use Scalar::Util qw( blessed looks_like_number refaddr );
  
  BEGIN {
  	$match::smart::AUTHORITY = 'cpan:TOBYINK';
  	$match::smart::VERSION   = '0.012';
  }
  
  our @ISA       = qw( Exporter::Tiny );
  our @EXPORT    = qw( M );
  our @EXPORT_OK = qw( match );
  
  sub match {
  	no warnings qw( uninitialized numeric );
  	
  	my ( $a, $b, $seen ) = @_;
  	my $method;
  	
  	return !defined $a                     if !defined( $b );
  	return !!$b->$method( $a, 1 )          if blessed( $b ) && ( $method = _overloaded_smartmatch( $b ) );
  	
  	if ( blessed($b) and not $b->isa("Regexp") ) {
  		require Carp;
  		Carp::croak( "Smart matching a non-overloaded object breaks encapsulation" );
  	}
  	
  	$seen ||= {};
  	my $refb = refaddr($b);
  	return refaddr( $a ) == $refb if $refb && $seen->{$refb}++;
  	
  	if ( ref($b) eq q(ARRAY) ) {
  		if ( ref($a) eq q(ARRAY) ) {
  			return !!0 unless @$a == @$b;
  			for my $i ( 0 .. $#$a ) {
  				return !!0 unless match( $a->[$i], $b->[$i], $seen );
  			}
  			return !!1;
  		}
  		
  		return any { exists $a->{$_} } @$b  if ref( $a ) eq q(HASH);
  		return any { $_ =~ $a } @$b         if ref( $a ) eq q(Regexp);
  		return any { !defined( $_ ) } @$b   if !defined( $a );
  		return any { match( $a, $_ ) } @$b;
  	}
  	
  	if ( ref($b) eq q(HASH) ) {
  		return match( [ sort map "$_", keys %$a ], [ sort map "$_", keys %$b ] )
  			if ref($a) eq q(HASH);
  		
  		return any { exists $b->{$_} } @$a  if ref( $a ) eq q(ARRAY);
  		return any { $_ =~ $a } keys %$b    if ref( $a ) eq q(Regexp);
  		return !!0                          if !defined( $a );
  		return exists $b->{$a};
  	}
  	
  	if ( ref($b) eq q(CODE) ) {
  		return all { !!$b->($_) } @$a       if ref( $a ) eq q(ARRAY);
  		return all { !!$b->($_) } keys %$a  if ref( $a ) eq q(HASH);
  		return $b->( $a );
  	}
  	
  	if ( ref($b) eq q(Regexp) ) {
  		return any { $_ =~ $b } @$a       if ref( $a ) eq q(ARRAY);
  		return any { $_ =~ $b } keys %$a  if ref( $a ) eq q(HASH);
  		return $a =~ $b;
  	}
  	
  	return !!$a->$method( $b, 0 )           if blessed( $a ) && ( $method = _overloaded_smartmatch( $a ) );
  	return !defined( $b )                   if !defined( $a );
  	return $a == $b                         if _is_number( $b );
  	return $a == $b                         if _is_number( $a ) && looks_like_number( $b );
  	
  	return $a eq $b;
  }
  
  sub _is_number {
  	my $value = shift;
  	return if ref $value;
  	my $flags = B::svref_2object( \$value )->FLAGS;
  	$flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK );
  }
  
  sub _generate_M {
  	require Sub::Infix;
  	&Sub::Infix::infix( \&match );
  }
  
  unless ( eval 'require re; 1' and exists &re::is_regexp ) {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object( $_[0] )->MAGIC->TYPE eq 'r' };
  	};
  }
  
  sub _overloaded_smartmatch {
  	my ( $obj ) = @_;
  	return if re::is_regexp( $obj );
  	
  	if ( $obj->isa( 'Type::Tiny' ) ) {
  		return $obj->can( 'check' );
  	}
  	
  	if ( my $match = $obj->can( 'MATCH' ) ) {
  		return $match;
  	}
  	
  	if ( $] lt '5.010' ) { require MRO::Compat; }
  	else                 { require mro;         }
  	
  	my @mro = @{ mro::get_linear_isa( ref $obj ) };
  	for my $class ( @mro ) {
  		my $name = "$class\::(~~";
  		my $overload = do {
  			no strict 'refs';
  			exists( &$name ) ? \&$name : undef;
  		};
  		return $overload if defined $overload;
  	}
  	
  	return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smartmatch recurses
  
  =head1 NAME
  
  match::smart - clone of smartmatch operator
  
  =head1 SYNOPSIS
  
     use v5.10;
     use match::smart;
     
     if ($this |M| $that)
     {
        say "$this matches $that";
     }
  
  =head1 DESCRIPTION
  
  match::smart provides a match operator C<< |M| >> that acts like more or
  less identically to the (as of Perl 5.18) deprecated smart match operator.
  
  If you don't like the crazy L<Sub::Infix> operator, you can alternatively
  export a more normal function:
  
     use v5.10;
     use match::smart qw(match);
     
     if (match($this, $that))
     {
        say "$this matches $that";
     }
  
  =head2 Differences with ~~
  
  There were major changes to smart match between 5.10.0 and 5.10.1. This
  module attempts to emulate the behaviour of the operator in more recent
  versions of Perl. In particular, 5.18.0 (minus the warnings). Divergences
  not noted below should be considered bugs.
  
  While the real smart match operator implicitly takes references to operands
  that are hashes or arrays, match::smart's operator does not.
  
     @foo ~~ %bar       # means: \@foo ~~ \%bar
     @foo |M| %bar      # means: scalar(@foo) |M| scalar(%bar)
  
  If you want the C<< \@foo ~~ \%bar >> behaviour, you need to add the
  backslashes yourself:
  
     \@foo |M| \%bar
  
  Similarly:
  
     "foo" ~~  /foo/    # works
     "foo" |M| /foo/    # no worky!
     "foo" |M| qr/foo/  # do this instead
  
  match::smart treats the C<MATCH> method on blessed objects (if it exists)
  like an overloaded C<< ~~ >>. This is for compatibility with L<match::simple>,
  and for compatibility with versions of Perl that don't have documented support
  for overloading C<< ~~ >>.
  
  =begin trustme
  
  =item M
  
  =item match
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<https://github.com/tobyink/p5-match-simple/issues>.
  
  =head1 SEE ALSO
  
  L<match::simple>.
  
  This module uses L<Exporter::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017, 2022-2023 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
MATCH_SMART

$fatpacked{"x86_64-linux-gnu-thread-multi/Want.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_WANT';
  package Want;
  
  require 5.006;
  use Carp 'croak';
  use strict;
  use warnings;
  
  require Exporter;
  require DynaLoader;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw(want rreturn lnoreturn);
  our @EXPORT_OK = qw(howmany wantref);
  our $VERSION = '0.29';
  
  bootstrap Want $VERSION;
  
  my %reftype = (
      ARRAY  => 1,
      HASH   => 1,
      CODE   => 1,
      GLOB   => 1,
      OBJECT => 1,
  );
  
  sub _wantone {
      my ($uplevel, $arg) = @_;
      
      my $wantref = wantref($uplevel + 1);
      if	  ($arg =~ /^\d+$/) {
  	my $want_count = want_count($uplevel);
  	return ($want_count == -1 || $want_count >= $arg);
      }
      elsif (lc($arg) eq 'infinity') {
  	return (want_count($uplevel) == -1);
      }
      elsif ($arg eq 'REF') {
  	return $wantref;
      }
      elsif ($reftype{$arg}) {
  	return ($wantref eq $arg);
      }
      elsif ($arg eq 'REFSCALAR') {
  	return ($wantref eq 'SCALAR');
      }
      elsif ($arg eq 'LVALUE') {
  	return want_lvalue($uplevel);
      }
      elsif ($arg eq 'RVALUE') {
  	return !want_lvalue($uplevel);
      }
      elsif ($arg eq 'VOID') {
  	return !defined(wantarray_up($uplevel));
      }
      elsif ($arg eq 'SCALAR') {
  	my $gimme = wantarray_up($uplevel);
  	return (defined($gimme) && 0 == $gimme);
      }
      elsif ($arg eq 'BOOL' || $arg eq 'BOOLEAN') {
  	return want_boolean(bump_level($uplevel));
      }
      elsif ($arg eq 'LIST') {
  	return wantarray_up($uplevel);
      }
      elsif ($arg eq 'COUNT') {
  	croak("want: COUNT must be the *only* parameter");
      }
      elsif ($arg eq 'ASSIGN') {
  	return !!wantassign($uplevel + 1);
      }
      else {
  	croak ("want: Unrecognised specifier $arg");
      }    
  }
  
  sub want {
      if (@_ == 1 && $_[0] eq 'ASSIGN') {
  	@_ = (1);
  	goto &wantassign;
      }
      want_uplevel(1, @_);
  }
  
  # Simulate the propagation of context through a return value.
  sub bump_level {
      my ($level) = @_;
      for(;;) {
  	my ($p, $r) = parent_op_name($level+1);
  	if ($p eq "return"
          or  $p eq "(none)" && $r =~ /^leavesub(lv)?$/)
  	{
  	    ++$level
  	}
  	else {
  	    return $level
  	}
      }
  }
  
  sub want_uplevel {
      my ($level, @args) = @_;
  
      # Deal with special cases (for RFC21-consistency):
      if (1 == @args) {
  	@_ = (1 + $level);
  	goto &wantref    if $args[0] eq 'REF';
  	goto &howmany    if $args[0] eq 'COUNT';
  	goto &wantassign if $args[0] eq 'ASSIGN';
      }
  
      for my $arg (map split, @args) {
  	if ($arg =~ /^!(.*)/) {
  	    return 0 unless !_wantone(2 + $level, $1);
  	}
  	else {
  	    return 0 unless _wantone(2 + $level, $arg);
  	}
      }
      
      return 1;
  }
  
  sub howmany () {
      my $level = bump_level(@_, 1);
      my $count = want_count($level);
      return ($count < 0 ? undef : $count);
  }
  
  sub wantref {
      my $level = bump_level(@_, 1);
      my $n = parent_op_name($level);
      if    ($n eq 'rv2av') {
  	return "ARRAY";
      }
      elsif ($n eq 'rv2hv') {
  	return "HASH";
      }
      elsif ($n eq 'rv2cv' || $n eq 'entersub') {
  	return "CODE";
      }
      elsif ($n eq 'rv2gv' || $n eq 'gelem') {
  	return "GLOB";
      }
      elsif ($n eq 'rv2sv') {
  	return "SCALAR";
      }
      elsif ($n eq 'method_call') {
  	return 'OBJECT';
      }
      elsif ($n eq 'multideref') {
  	return first_multideref_type($level);
      }
      else {
  	return "";
      }
  }
  
  sub wantassign {
      my $uplevel = shift();
      return unless want_lvalue($uplevel);
      my $r = want_assign(bump_level($uplevel));
      if (want('BOOL')) {
  	return (defined($r) && 0 != $r);
      }
      else {
  	return $r ? (want('SCALAR') ? $r->[$#$r] : @$r) : ();
      }
  }
  
  sub double_return :lvalue;
  
  sub rreturn (@) {
      if (want_lvalue(1)) {
          croak "Can't rreturn in lvalue context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      {
          return double_return(@_);
      }
  }
  
  sub lnoreturn () : lvalue {
      if (!want_lvalue(1) || !want_assign(1)) {
          croak "Can't lnoreturn except in ASSIGN context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      #
      # But in older versions of perl, adding the extra scope
      # causes the error:
      #   Can't modify loop exit in lvalue subroutine return
      # so we have to check the version.
      if ($] >= 5.019) {
          return double_return(disarm_temp(my $undef));
      }
      return double_return(disarm_temp(my $undef));
  }
  
  # Some naughty people were relying on these internal methods.
  *_wantref = \&wantref;
  *_wantassign = \&wantassign;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Want - A generalisation of C<wantarray>
  
  =head1 SYNOPSIS
  
    use Want;
    sub foo :lvalue {
        if    (want(qw'LVALUE ASSIGN')) {
          print "We have been assigned ", want('ASSIGN');
          lnoreturn;
        }
        elsif (want('LIST')) {
          rreturn (1, 2, 3);
        }
        elsif (want('BOOL')) {
          rreturn 0;
        }
        elsif (want(qw'SCALAR !REF')) {
          rreturn 23;
        }
        elsif (want('HASH')) {
          rreturn { foo => 17, bar => 23 };
        }
        return;  # You have to put this at the end to keep the compiler happy
    }
  
  =head1 DESCRIPTION
  
  This module generalises the mechanism of the B<wantarray> function,
  allowing a function to determine in some detail how its return value
  is going to be immediately used.
  
  =head2 Top-level contexts:
  
  The three kinds of top-level context are well known:
  
  =over 4
  
  =item B<VOID>
  
  The return value is not being used in any way. It could be an entire statement
  like C<foo();>, or the last component of a compound statement which is itself in
  void context, such as C<$test || foo();>n. Be warned that the last statement
  of a subroutine will be in whatever context the subroutine was called in, because
  the result is implicitly returned.
  
  =item B<SCALAR>
  
  The return value is being treated as a scalar value of some sort:
  
    my $x = foo();
    $y += foo();
    print "123" x foo();
    print scalar foo();
    warn foo()->{23};
    ...etc...
  
  =item B<LIST>
  
  The return value is treated as a list of values:
  
    my @x = foo();
    my ($x) = foo();
    () = foo();		# even though the results are discarded
    print foo();
    bar(foo());		# unless the bar subroutine has a prototype
    print @hash{foo()};	# (hash slice)
    ...etc...
  
  =back
  
  =head2 Lvalue subroutines:
  
  The introduction of B<lvalue subroutines> in Perl 5.6 has created a new type
  of contextual information, which is independent of those listed above. When
  an lvalue subroutine is called, it can either be called in the ordinary way
  (so that its result is treated as an ordinary value, an B<rvalue>); or else
  it can be called so that its result is considered updatable, an B<lvalue>.
  
  These rather arcane terms (lvalue and rvalue) are easier to remember if you
  know why they are so called. If you consider a simple assignment statement
  C<left = right>, then the B<l>eft-hand side is an B<l>value and the B<r>ight-hand
  side is an B<r>value.
  
  So (for lvalue subroutines only) there are two new types of context:
  
  =over 4
  
  =item B<RVALUE>
  
  The caller is definitely not trying to assign to the result:
  
    foo();
    my $x = foo();
    ...etc...
  
  If the sub is declared without the C<:lvalue> attribute, then it will
  I<always> be in RVALUE context.
  
  If you need to return values from an lvalue subroutine in RVALUE context,
  you should use the C<rreturn> function rather than an ordinary C<return>.
  Otherwise you'll probably get a compile-time error in perl 5.6.1 and later.
  
  =item B<LVALUE>
  
  Either the caller is directly assigning to the result of the sub call:
  
    foo() = $x;
    foo() = (1, 1, 2, 3, 5, 8);
  
  or the caller is making a reference to the result, which might be assigned to
  later:
  
    my $ref = \(foo());	# Could now have: $$ref = 99;
    
    # Note that this example imposes LIST context on the sub call.
    # So we're taking a reference to the first element to be
    # returned _in list context_.
    # If we want to call the function in scalar context, we can
    # do it like this:
    my $ref = \(scalar foo());
  
  or else the result of the function call is being used as part of the argument list
  for I<another> function call:
  
    bar(foo());	# Will *always* call foo in lvalue context,
    		# (provided that foo is an C<:lvalue> sub)
    		# regardless of what bar actually does.
  
  The reason for this last case is that bar might be a sub which modifies its
  arguments. They're rare in contemporary Perl code, but perfectly possible:
  
    sub bar {
      $_[0] = 23;
    }
  
  (This is really a throwback to Perl 4, which didn't support explicit references.)
  
  =back
  
  =head2 Assignment context:
  
  The commonest use of lvalue subroutines is with the assignment statement:
  
    size() = 12;
    (list()) = (1..10);
  
  A useful motto to remember when thinking about assignment statements is
  I<context comes from the left>. Consider code like this:
  
    my ($x, $y, $z);
    sub list () :lvalue { ($x, $y, $z) }
    list = (1, 2, 3);
    print "\$x = $x; \$y = $y; \$z = $z\n";
  
  This prints C<$x = ; $y = ; $z = 3>, which may not be what you were expecting.
  The reason is that the assignment is in scalar context, so the comma operator
  is in scalar context too, and discards all values but the last. You can fix
  it by writing C<(list) = (1,2,3);> instead.
  
  If your lvalue subroutine is used on the left of an assignment statement,
  it's in B<ASSIGN> context.  If ASSIGN is the only argument to C<want()>, then
  it returns a reference to an array of the value(s) of the right-hand side.
  
  In this case, you should return with the C<lnoreturn> function, rather than
  an ordinary C<return>. 
  
  This makes it very easy to write lvalue subroutines which do clever things:
  
    use Want;
    use strict;
    sub backstr :lvalue {
      if (want(qw'LVALUE ASSIGN')) {
        my ($a) = want('ASSIGN');
        $_[0] = reverse $a;
        lnoreturn;
      }
      elsif (want('RVALUE')) {
        rreturn scalar reverse $_[0];
      }
      else {
        carp("Not in ASSIGN context");
      }
      return
    }
   
    print "foo -> ", backstr("foo"), "\n";	# foo -> oof
    backstr(my $robin) = "nibor";
    print "\$robin is now $robin\n";		# $robin is now robin
  
  Notice that you need to put a (meaningless) return
  statement at the end of the function, otherwise you will get the
  error
  I<Can't modify non-lvalue subroutine call in lvalue subroutine return>.
  
  The only way to write that C<backstr> function without using Want is to return
  a tied variable which is tied to a custom class.
  
  =head2 Reference context:
  
  Sometimes in scalar context the caller is expecting a reference of some sort
  to be returned:
  
      print foo()->();     # CODE reference expected
      print foo()->{bar};  # HASH reference expected
      print foo()->[23];   # ARRAY reference expected
      print ${foo()};	 # SCALAR reference expected
      print foo()->bar();	 # OBJECT reference expected
      
      my $format = *{foo()}{FORMAT} # GLOB reference expected
  
  You can check this using conditionals like C<if (want('CODE'))>.
  There is also a function C<wantref()> which returns one of the strings
  "CODE", "HASH", "ARRAY", "GLOB", "SCALAR" or "OBJECT"; or the empty string
  if a reference is not expected.
  
  Because C<want('SCALAR')> is already used to select ordinary scalar context,
  you have to use C<want('REFSCALAR')> to find out if a SCALAR reference is
  expected. Or you could use C<want('REF') eq 'SCALAR'> of course.
  
  Be warned that C<want('ARRAY')> is a B<very> different thing from C<wantarray()>.
  
  =head2 Item count
  
  Sometimes in list context the caller is expecting a particular number of items
  to be returned:
  
      my ($x, $y) = foo();   # foo is expected to return two items
  
  If you pass a number to the C<want> function, then it will return true or false
  according to whether at least that many items are wanted. So if we are in the
  definition of a sub which is being called as above, then:
  
      want(1) returns true
      want(2) returns true
      want(3) returns false
  
  Sometimes there is no limit to the number of items that might be used:
  
      my @x = foo();
      do_something_with( foo() );
  
  In this case, C<want(2)>, C<want(100)>, C<want(1E9)> and so on will all return
  true; and so will C<want('Infinity')>.
  
  The C<howmany> function can be used to find out how many items are wanted.
  If the context is scalar, then C<want(1)> returns true and C<howmany()> returns
  1. If you want to check whether your result is being assigned to a singleton
  list, you can say C<if (want('LIST', 1)) { ... }>.
  
  
  =head2 Boolean context
  
  Sometimes the caller is only interested in the truth or falsity of a function's
  return value:
  
      if (everything_is_okay()) {
  	# Carry on
      }
      
      print (foo() ? "ok\n" : "not ok\n");
      
  In the following example, all subroutine calls are in BOOL context:
  
      my $x = ( (foo() && !bar()) xor (baz() || quux()) );
  
  Boolean context, like the reference contexts above, is considered to be a subcontext
  of SCALAR.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item want(SPECIFIERS)
  
  This is the primary interface to this module, and should suffice for most
  purposes. You pass it a list of context specifiers, and the return value
  is true whenever all of the specifiers hold.
  
      want('LVALUE', 'SCALAR');   # Are we in scalar lvalue context?
      want('RVALUE', 3);		# Are at least three rvalues wanted?
      want('ARRAY');	# Is the return value used as an array ref?
  
  You can also prefix a specifier with an exclamation mark to indicate that you
  B<don't> want it to be true
  
      want(2, '!3');		# Caller wants exactly two items.
      want(qw'REF !CODE !GLOB');  # Expecting a reference that
      				#   isn't a CODE or GLOB ref.
      want(100, '!Infinity');	# Expecting at least 100 items,
      				#   but there is a limit.
  
  If the I<REF> keyword is the only parameter passed, then the type of reference will be
  returned.  This is just a synonym for the C<wantref> function: it's included because
  you might find it useful if you don't want to pollute your namespace by importing
  several functions, and to conform to Damian Conway's suggestion in RFC 21.
  
  Finally, the keyword I<COUNT> can be used, provided that it's the only keyword
  you pass. Mixing COUNT with other keywords is an error. This is a synonym for the
  C<howmany> function.
  
  A full list of the permitted keyword is in the B<ARGUMENTS> section below.
  
  =item rreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you know that you're in RVALUE context. If you try to use a normal C<return>,
  you'll get a compile-time error in Perl 5.6.1 and above unless you return an
  lvalue. (Note: this is no longer true in Perl 5.16, where an ordinary return
  will once again work.)
  
  =item lnoreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you're in ASSIGN context and you've used C<want('ASSIGN')> to carry out the
  appropriate action.
  
  If you use C<rreturn> or C<lnoreturn>, then you have to put a bare C<return;>
  at the very end of your lvalue subroutine, in order to stop the Perl compiler
  from complaining. Think of it as akin to the C<1;> that you have to put at the
  end of a module. (Note: this is no longer true in Perl 5.16.)
  
  =item howmany()
  
  Returns the I<expectation count>, i.e. the number of items expected. If the 
  expectation count is undefined, that
  indicates that an unlimited number of items might be used (e.g. the return
  value is being assigned to an array). In void context the expectation count
  is zero, and in scalar context it is one.
  
  The same as C<want('COUNT')>.
  
  =item wantref()
  
  Returns the type of reference which the caller is expecting, or the empty string
  if the caller isn't expecting a reference immediately.
  
  The same as C<want('REF')>.
  
  =back
  
  =head1 EXAMPLES
  
      use Carp 'croak';
      use Want 'howmany';
      sub numbers {
  	my $count = howmany();
  	croak("Can't make an infinite list") if !defined($count);
  	return (1..$count);
      }
      my ($one, $two, $three) = numbers();
      
      
      use Want 'want';
      sub pi () {
  	if    (want('ARRAY')) {
  	    return [3, 1, 4, 1, 5, 9];
  	}
  	elsif (want('LIST')) {
  	    return (3, 1, 4, 1, 5, 9);
  	}
  	else {
  	    return 3;
  	}
      }
      print pi->[2];	# prints 4
      print ((pi)[3]);	# prints 1
  
  =head1 ARGUMENTS
  
  The permitted arguments to the C<want> function are listed below.
  The list is structured so that sub-contexts appear below the context that they
  are part of.
  
  =over 4
  
  =item *
  
  VOID
  
  =item *
  
  SCALAR
  
  =over 4
  
  =item *
  
  REF
  
  =over 4
  
  =item *
  
  REFSCALAR
  
  =item *
  
  CODE
  
  =item *
  
  HASH
  
  =item *
  
  ARRAY
  
  =item *
  
  GLOB
  
  =item *
  
  OBJECT
  
  =back
  
  =item *
  
  BOOL
  
  =back
  
  =item *
  
  LIST
  
  =over 4
  
  =item *
  
  COUNT
  
  =item *
  
  E<lt>numberE<gt>
  
  =item *
  
  Infinity
  
  =back
  
  =item *
  
  LVALUE
  
  =over 4
  
  =item *
  
  ASSIGN
  
  =back
  
  =item *
  
  RVALUE
  
  =back
  
  =head1 EXPORT
  
  The C<want> and C<rreturn> functions are exported by default.
  The C<wantref> and/or C<howmany> functions can also be imported:
  
    use Want qw'want howmany';
  
  If you don't import these functions, you must qualify their names as (e.g.)
  C<Want::wantref>.
  
  =head1 INTERFACE
  
  This module is still under development, and the public interface may change in
  future versions. The C<want> function can now be regarded as stable.
  
  I'd be interested to know how you're using this module.
  
  =head1 SUBTLETIES
  
  There are two different levels of B<BOOL> context. I<Pure> boolean context
  occurs in conditional expressions, and the operands of the C<xor> and C<!>/C<not>
  operators.
  Pure boolean context also propagates down through the C<&&> and C<||> operators.
  
  However, consider an expression like C<my $x = foo() && "yes">. The subroutine
  is called in I<pseudo>-boolean context - its return value isn't B<entirely>
  ignored, because the undefined value, the empty string and the integer 0 are
  all false.
  
  At the moment C<want('BOOL')> is true in either pure or pseudo boolean
  context. Let me know if this is a problem.
  
  =head1 BUGS
  
   * Doesn't work from inside a tie-handler.
  
  =head1 AUTHOR
  
  Robin Houston, E<lt>robin@cpan.orgE<gt>
  
  Thanks to Damian Conway for encouragement and good suggestions,
  and Father Chrysostomos for a patch.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<perlfunc/wantarray>
  
  =item *
  
  Perl6 RFC 21, by Damian Conway.
  http://dev.perl.org/rfc/21.html
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2012, Robin Houston. All Rights Reserved.
  This module is free software. It may be used, redistributed
  and/or modified under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_WANT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.36;
use utf8;
use strictures 2; # nice `use strict`, `use warnings` defaults
use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
use diagnostics -verbose;

# Carp
    use Carp;
    use Carp::Assert;
# filepath functions
    use Cwd qw(abs_path);
    use File::Basename qw(basename dirname);
    use File::Spec;
# misc file utilities
    use File::Temp;
    use File::Slurp;
# misc scripting IO utilities
    use IO::Prompter;
    # `capture_stdout` for backticks w/o shell (escaping issues)
    use Capture::Tiny qw(:all);
    # for more complicated stuff
    # eg timeout, redirection
    use IPC::Run qw(run);
    use IPC::Cmd qw(can_run);
# option/arg handling
    use Getopt::Long qw(:config gnu_getopt auto_version); # auto_help not the greatest
    use Pod::Usage;
# use local modules
    use lib (
        dirname(abs_path($0)),
        ); # https://stackoverflow.com/a/46550384
 
# turn on features
    use builtin qw(true false is_bool reftype);
    no warnings 'experimental::builtin';
    use feature 'try';
    no warnings 'experimental::try';

    our $VERSION = version->declare('v2023.05.01');
# end prelude

my @builds = glob 'Gradescope-Utils-*';
@builds = grep {m/^Gradescope-Utils-([\d\.]+)(\.tar\.gz)?$/} @builds;
say '[debug] found versions:';
say for @builds;
my @versions = map {m/^Gradescope-Utils-([\d\.]+)(\.tar\.gz)?$/; version->parse($1)} @builds;
@versions = sort @versions;
my $latest_version = pop @versions;
should($latest_version->stringify, "$latest_version"); # I'm a bit nervous about how version objects are handled
say "[debug] using version: $latest_version";
# NOTE: we could use the perl equivalents for portability, but I'm assuming so much *nix anyways, there's no point
# (ie sorry windows users)
my $local_share = File::Spec->catdir($ENV{HOME}, '.local', 'share', 'gradescope-utils');
my $confirm_overwrite_install = sub{
    if(-e $local_share){
        my $confirm = IO::Prompter::prompt(
            "Confirm: update existing install at '$local_share'? (y/N)? ",
            -in => *STDIN
        );
        croak '[error] user cancelled' if $confirm ne 'y';
    }
    else{
        run ['mkdir', '-p', $local_share] or croak '[error] `mkdir` failed';
    }
};
@builds = grep {m/^Gradescope-Utils-$latest_version(\.tar\.gz)?$/} @builds;
# prefer the regular build dir over the tar 'd one, if it exists
if(grep {m/^Gradescope-Utils-$latest_version$/} @builds){
    say "[debug] using build at 'Gradescope-Utils-$latest_version/'";
    &$confirm_overwrite_install;
    run ['cp', '-rT', "Gradescope-Utils-$latest_version", $local_share] or croak '[error] `cp` failed';
}
elsif(grep {m/\.tar\.gz$/} @builds){
    say "[debug] using build at 'Gradescope-Utils-$latest_version.tar.gz'";
    &$confirm_overwrite_install;
    my $tmpdir = File::Temp->newdir();
    run ['tar', '-xf', "Gradescope-Utils-$latest_version.tar.gz", '-C', $tmpdir] or croak '[error] `tar` failed';
    run ['cp', '-rT', File::Spec->catdir($tmpdir, "Gradescope-Utils-$latest_version"), $local_share] or croak '[error] `cp` failed';
}
else{
    croak '[error] no suitable builds found';
}

my $local_bin = File::Spec->catdir($ENV{HOME}, '.local', 'bin');
if(!-e $local_bin){
    run ['mkdir', '-p', File::Spec->catdir($ENV{HOME}, '.local', 'bin')] or croak '[error] `mkdir` failed';
}
run ['ln', '-fs', File::Spec->catfile($local_share, 'bin', 'gradescope-utils.pl'), File::Spec->catfile($ENV{HOME}, '.local', 'bin', 'gu')] or croak '[error] `ln` failed';

# PODNAME:
# ABSTRACT: Gradescope Utils installer
=pod

=encoding utf8

=head1 SYNOPSIS

=head1 DESCRIPTION

see README.md

=cut
